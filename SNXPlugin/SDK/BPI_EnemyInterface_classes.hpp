#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_EnemyInterface

#include "Basic.hpp"

#include "BattlePrototype_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Enum_EnemyAiType_structs.hpp"
#include "Enum_EnemySound_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BPI_EnemyInterface.BPI_EnemyInterface_C
// 0x0000 (0x0028 - 0x0028)
class IBPI_EnemyInterface_C final : public IInterface
{
public:
	void GetEnemyInterfaceSound(Enum_EnemySound* Enum);
	void BeginEnemyAttack(EnemyAttackAnimKind Attack, bool* Bool);
	void IsEnemyAttack(EnemyAttackAnimKind Attack, bool* Bool);
	void BeginEnemyMove(EnemyMoveAnimKind Move, bool* Bool);
	void IsEnemyMove(EnemyMoveAnimKind Move, bool* Bool);
	void IsEnemyDamageWince(bool* Bool);
	void IsEnemyDamageDown(bool* Bool);
	void BeginEnemyAction(EnemyActionAnimKind Action, bool* Bool);
	void IsEnemyAction(EnemyActionAnimKind Action, bool* Bool);
	void IsEnemyDamageLaunch(bool* Bool);
	void IsEnemyDamageknockBack(bool* Bool);
	void IsEnemyDamageBlow(bool* Bool);
	void IsEnemyStateAttack(bool* Return);
	void IsEnemyStateDamage(bool* Return);
	void IsEnemyStateDamageDown(bool* Return);
	void IsEnemyStateMove(bool* Return);
	void IsEnemyStateAction(bool* Return);
	void IsEnemyBossActive(bool* Return);
	void SetEnemyBrainCrashPerformance(bool* Return);
	void SetEnemyTarget(bool* NewParam);
	void ResetEnemyTarget(bool* NewParam);
	void SetEnemyDamageReaction(bool* NewParam);
	void SetEnemyBrainFieldMoveInner(bool MoveBrainField, bool* Dummy);
	void SetEnemyBrainFieldMoveNormal(bool MoveBrainField, bool* Dummy);
	void SetEnemyBrainFieldStart(bool MoveBrainField, bool* NewParam);
	void SetEnemyBrainFieldEnd(bool MoveBrainField, bool* NewParam);
	void GetEnemyGroundTransform(const struct FTransform& Transform, struct FTransform* Return);
	void SetEnemyWait(bool* NewParam);
	void ResetEnemyWait(bool* NewParam);
	void OnSwitchVisibleBrainFieldLevel(bool Visible, bool* Unused);
	void SetEnemyStealthSeeEnable(bool On, bool ShadowChange, bool* Return);
	void SetEnemyBrainCrashParam(float BrainCrashTimer, float BrainCrashMissScale, bool* Return);
	void IsEnableEnemyMoveRange(bool* bReturn);
	void PlayerActionForEnemyReaction(BattlePrototype::EPsychicObjectAttackType PsychicObjectType, const struct FVector& PsychicObjLocation, bool* Dummy);
	void EnemyDataDrop(const struct FVector& SpawnLocation, const struct FVector& SpawnDir, bool* IsDrop);
	void SetEnemySpawn(bool Spawn, bool* Return);
	void SpawnStart(bool* Return);
	void IsHideWeak(bool* Param_IsHideWeak);
	void ReturnStart(bool* Return);
	void IsAttacking(bool* IsAttack);
	void GetTargetKind(ERSPartyPlayerKind* TargetKind);
	void GetBrainCore(class ABP_co2000Base_C** CoreObject);
	void IsEnemyStateFloating(bool* IsFloating);
	void CalcCameraShake(class UClass* InputShakeClass, float InputScale, const struct FVector& ShakeLocation, class UClass** OutputShakeClass, float* OutputScale);
	void SetEnemyPressDownEnd(bool* Dammy);
	void EndUniqueObjState(bool* Dummy);
	void StartUniqueObjState(class ABP_PsychicObjectBasic_C* AttackObject, bool* Dummy);
	void CheckUniqueObjState(const struct FHCHitResult& HitResult, bool* Dummy);
	void IsUniqueObjState(bool* ReturnState);
	void SwitchDispCore(bool DisplayOn, bool* Dummy);
	void OnStartCrashChance(bool* bStart);
	void OnEndCrashChance(bool* bEnd);
	void IsPossibleTargetAttack(class AActor* Attacker, bool* bPossible);
	void IsDisableLostAction(bool* bDisable);
	void GetCoreCollision(class UDamagePartCollisionComponent** CoreCollision);
	void OnSpawnMoveStart(bool* Dummy);
	void OnEnemyBrainFieldResetAction(bool bMoveBrainField, bool* bReset);
	void OnEnemyBrainFieldFinishWeapon(bool bMoveBrainField, bool* Dummy);
	void OnEnemyBrainFieldResetStatus(bool bMoveBrainField, bool* Dummy);
	void OnEnemyBrainFieldCutChange(bool* Dummy);
	void ChangeAiType(Enum_EnemyAiType Param_ChangeAiType, bool* bFailed);
	void CheckChangeAiTypeForHpRate(bool* Failed);
	void IsChangeAiTypeAction(Enum_EnemyAiType InAiType, bool* bPossible);
	void Em1200_ChangePhaseParamSetting(bool* Dummy);
	void Em1210_AddPSychicFlyObj(class ABP_PsychicObjectBasic_C* FlyObj, bool* Dummy);
	void StartReactionDilation(uint8 ReactionKind, bool AddDamage, bool* Return);
	void IsEnemyDiscoveredOnceInterface(bool* bDiscoverd);
	void Em0700_EnableInvalidDamage(bool* bEnable);
	void Em1400_StartDither(float TotalDuration, bool* Return);
	void Em1400_EndDither(bool* Return);
	void Em1400_UpdateDither(EEasingFunc EasingFunc, float DeltaSec, bool* Return);
	void Em1400_SetSpawnTransform(const struct FTransform& SpawnTransform, bool* Return);
	void Em1400_GetSpawnTransform(struct FTransform* SpawTransform);
	void IsBrainFieldEnemyAlive(bool* bEnemyAlive);
	void IsSwitchAttackCollisionInfo(bool* IsSwitch);
	void SetEnemyUpDownWait(bool DownWait, bool* Dummy);
	void IsEnemyUpDownWait(bool* bUpDownWait);
	void StartCriticalHitSlow(const struct FHCHitResult& InHitResult, bool* Return);
	void Em1130_EnableWeak(bool bEnable, bool* Return);
	void GetEnemySpawnConditionCheck(bool* IsSpawnOK);
	void StartEnemyCrashVisionHitEffect(bool* NewParam);
	void StartEnemyCrashVisionHitUniqueEffect(bool* NewParam);
	void BindingCrashVisionEnemy(bool* NewParam);
	void Em8300_DeadBattleSimulator(bool* Dummy);
	void IsEnemyRepop(bool* Repop);

	void IsEnemyActive(bool* Return) const;
	void IsBossEnemy(bool* bBoss) const;
	void GetDistanceToPlayer(float* Distance) const;
	void GetTargetDistance(float* Distance) const;
	void GetEnemySpawn(bool* Return) const;
	void GetHeightCheckFlag(bool* NewParam) const;
	void IsFlyEnemyCheck(bool* NewParam) const;
	void GetBrainCrashSequence(bool IsUnique, class ULevelSequence** Sequence) const;
	void GetMoveToTargetAnim(EnemyMoveAnimKind* MoveAnim) const;
	void GetMainPlayerDistance(float* Distance) const;
	void IsRealThings(bool* bReal) const;
	void IsEnemySpawnNow(bool* SpawnNow) const;
	void IsNotFindPlayer(bool* bNotFind) const;
	void IsEnemyTickDisableCondition(bool* bDisableCondition) const;
	void Em8310_IsMaskMan(bool* bMaskMan) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BPI_EnemyInterface_C">();
	}
	static class IBPI_EnemyInterface_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_EnemyInterface_C>();
	}
};
static_assert(alignof(IBPI_EnemyInterface_C) == 0x000008, "Wrong alignment on IBPI_EnemyInterface_C");
static_assert(sizeof(IBPI_EnemyInterface_C) == 0x000028, "Wrong size on IBPI_EnemyInterface_C");

}

