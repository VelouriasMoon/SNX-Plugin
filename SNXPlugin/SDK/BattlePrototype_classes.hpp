#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BattlePrototype

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "BattlePrototype_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "ActionSystem_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "SlateCore_structs.hpp"
#include "HorizonUI_classes.hpp"
#include "AssetRegistry_structs.hpp"
#include "CriWareRuntime_structs.hpp"
#include "CriWareRuntime_classes.hpp"
#include "REDAnimationNode_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "InputCore_structs.hpp"
#include "LevelSequence_classes.hpp"


namespace SDK
{

// Class BattlePrototype.BattleCharacterInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleCharacterInterface final : public IInterface
{
public:
	bool AddScarFromHitDamageInfoInterface(class AActor* Actor, const struct FHitDamageInfo& HitDamageInfo);
	float CalcUniqueDamage(const struct FHCHitResult& HitResult, float BaseDamage);
	bool CheckEmphasisCrashGauge(const struct FHCHitResult& HitResult);
	void DisEnableNoDeadTutorial();
	void EndNoDeadNoCrashChanceEvent();
	bool EventStartForceEndBadStatus();
	struct FVector GetAutoAimTargetLocation();
	void GetCameraStabilizeParameter(float* DistLockHz, float* DistRestoreHz, float* DistLockVt, float* DistRestoreVt);
	ECharacterHitPriority GetCharacterHitPriorityInterface();
	struct FVector GetDamageReactionDirInterface(const struct FHCHitResult& HitResult);
	struct FVector GetLookAtTargetLocation();
	bool IsBadStatusConfusionCPP();
	bool IsBadStatusElectricCPP();
	bool IsBadStatusFlameCPP();
	bool IsBadStatusFloodedCPP();
	bool IsBadStatusOilCPP();
	bool IsCounterWaitInterface();
	bool IsDisableAtomCuePlayInterface();
	bool IsEnableSlashEffectInterface(const struct FHCHitResult& HitResult);
	bool IsHitWeakChangeDefaultEffectInterface();
	bool IsSuperArmorInterface();
	bool RestartBehaviorTree(bool bTickEnable);
	bool SetActorAllTickEnabled(bool bEnabled);
	bool SetBehaviorTreeTickEnable(bool bEnable);
	bool SetCounterInterface();
	bool SetHiddenCharacterAttachment(bool NewHidden);
	void SetInfinityCrashChance(bool bEnable);
	void SetInvalidDamageInterface(bool bInvalidDamage, class FName ClaimantName, int32 Param);
	void SetNoCrashChanceByUseGuts(bool bEnable);
	void SetNoCrashChanceEvent(bool NoCrashChanceEvent);
	void SetNoDeadEvent(bool NoDeadEvent);
	bool SetRareSpawnEnemyHpRateCPP(float HpRate, class AActor* RareSpawnEnemy);
	void SetUseGuts(bool bUse);
	bool ShakeCameraInDamageInterface(const struct FHCHitResult& HitResult);
	bool StopBehaviorTree(bool bTickDisable);
	bool SufferDamageAfterInterface(const struct FHCHitResult& HitResult, int32 Damage, int32 TakedDamage);
	bool SufferDamageBeforeInterface(const struct FHCHitResult& HitResult, int32 Damage);
	bool VibrationControllerInDamageInterface(const struct FHCHitResult& HitResult);

	bool CheckRareSpawnHpRateCPP() const;
	EAssassinAttackHit GetAssasinAttackHitType() const;
	int32 GetCharaKind() const;
	struct FVector GetWeakTargetPointInterface(const struct FVector& AttackerPos) const;
	bool IsAbsoluteVisibilityTrace() const;
	bool IsAttackerTargetSelf(const struct FHCHitResult& HitResult) const;
	bool IsAttractSelfInterface() const;
	bool IsCrashMaxWithGuts() const;
	bool IsDeadBrainCrashOnly() const;
	bool IsDeadChaseAttackOnly() const;
	bool IsDeadLaunchAttackOnly() const;
	bool IsDeadPhysicsAttackOnly() const;
	bool IsDeadPsychicObjComboOnly() const;
	bool IsDeadPsychicObjOnly() const;
	bool IsEnableReactionCoefficientInterface(float* OutReactionSRate, float* OutReactionLRate, float* OutDownRate, float* OutCrashRate, bool* OutAcceptAll) const;
	bool IsEventCondition() const;
	bool IsInfinityCrashChance() const;
	bool IsNoCrashChanceByUseGuts() const;
	bool IsNoCrashChanceEvent() const;
	bool IsNoDeadEvent() const;
	bool IsNoDeadTutorial() const;
	bool IsNotAbleBrainCrashTarget() const;
	bool IsRareSpawnEnemy() const;
	bool IsUniqueNoDead() const;
	bool IsUseGuts() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCharacterInterface">();
	}
	static class IBattleCharacterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleCharacterInterface>();
	}
};
static_assert(alignof(IBattleCharacterInterface) == 0x000008, "Wrong alignment on IBattleCharacterInterface");
static_assert(sizeof(IBattleCharacterInterface) == 0x000028, "Wrong size on IBattleCharacterInterface");

// Class BattlePrototype.REDUserTextWidget
// 0x0018 (0x0248 - 0x0230)
class UREDUserTextWidget : public UUserWidget
{
public:
	uint8                                         Pad_1C0C[0x18];                                    // 0x0230(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTextFormatFromBase(int32 StringIndex);
	void ChangeFont(int32 StringIndex, class UObject* Font);
	void ChangeRubyProperty(int32 StringIndex, float RubySizeRate, float RubyAdjustY);
	void ClearString(int32 StringIndex);
	void Destroy(int32 StringIndex);
	float GetGeometryScale();
	void GetTextRect(int32 StringIndex, struct FVector4* Rect);
	void GetTextRectLight(int32 StringIndex, struct FVector4* Rect);
	void InitializeString(int32 StringIndex, class UTextBlock* baseTextBlock, int32 TextBlockNum, class UImage* baseIconFont, int32 IconFontNum, bool IsUseRuby);
	void InitializeStringForKeyGuide(int32 StringIndex, int32 GuideNum, class UTextBlock* baseTextBlock, class UImage* baseIconFont);
	void MoveAll(int32 StringIndex, float FMoveX, float FMoveY);
	void ResetString();
	void SetApplyGeometryScale(bool IsApply);
	void SetString(int32 StringIndex, const class FString& String, bool bIsAnalyzeTag);
	void SetStringSlotVersion(int32 StringIndex, const class FString& String);

	class UTextBlock* GetBaseTextBlock(int32 StringIndex) const;
	struct FVector2D GetDefaultViewportSize() const;
	class UWidget* GetRootWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDUserTextWidget">();
	}
	static class UREDUserTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDUserTextWidget>();
	}
};
static_assert(alignof(UREDUserTextWidget) == 0x000008, "Wrong alignment on UREDUserTextWidget");
static_assert(sizeof(UREDUserTextWidget) == 0x000248, "Wrong size on UREDUserTextWidget");

// Class BattlePrototype.UIBase
// 0x0140 (0x0388 - 0x0248)
class UUIBase : public UREDUserTextWidget
{
public:
	bool                                          FlagPlay;                                          // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FlagMouse;                                         // 0x0249(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C17[0x2];                                     // 0x024A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRedMouseArgument                      MouseCallArgument;                                 // 0x024C(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              MouseHitOffsetPos;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MouseHitOffsetSize;                                // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIMouseHitType                               MouseHitType;                                      // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugMouseHitDisp;                                 // 0x0269(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C18[0x6];                                     // 0x026A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_BaseFocusMouse;                                  // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             M_BaseUnFocusMouse;                                // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             M_BaseDownMouse;                                   // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C19[0x1];                                     // 0x02A0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FlagRemove;                                        // 0x02A1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagNotRemoveHud;                                  // 0x02A2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1A[0x1];                                     // 0x02A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentState;                                      // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextState;                                         // 0x02A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentSubState;                                   // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NextSubState;                                      // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1B[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidgetAnimation*>               AnimationList;                                     // 0x02B8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayIndex;                                         // 0x02C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIViewPrio                                   ViewPortPrio;                                      // 0x02CC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1C[0x3];                                     // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIChromaticAberration*                 ChromaticAberration;                               // 0x02D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        CA_WorkObject;                                     // 0x02D8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIChromaticAberration*>         ListChromaticAberration;                           // 0x02E8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UREDRetainerBox*>                ListControlRetainerBox;                            // 0x02F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StateControlRetainerBox;                           // 0x0308(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1D[0x4];                                     // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            ControlWidget;                                     // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              LocalVisibility;                                   // 0x0318(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1E[0x3];                                     // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InputLevel;                                        // 0x031C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseScrollSpeed;                                   // 0x0320(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1F[0x1C];                                    // 0x0324(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UREDebugLines*                          M_DebugDraw;                                       // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGeometry                              M_MyGeometry;                                      // 0x0348(0x0038)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C20[0x8];                                     // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToSetViewPortPrio(EUIViewPrio Viewprio);
	void AddViewPortPrio();
	void ChangeState(int32 NewState);
	void ChangeStateAllDirect(int32 NewState, int32 NewSubState);
	void ChangeStateDirect(int32 NewState);
	void ChangeSubState(int32 NewSubState);
	bool CheckAnyInput();
	bool CheckCircle();
	bool CheckCircleCore(const struct FVector2D& Position);
	bool CheckEqualName(const class FString& BaseString, const class FString& CheckString);
	void CheckInput(EUIInputButton KeyType, EUIInputType InputType, bool* IsInput);
	bool CheckRectangle();
	bool CheckRectangleCore(const struct FVector2D& Position);
	void Close();
	void CloseDirect();
	void DebugDrawLastAnimation(float DeltaSecond);
	void DebugDrawPlayingAnimation(float DeltaSecond);
	struct FVector2D GetAbsolutePosition();
	void GetAbsoluteScreenOfffset(const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	struct FVector2D GetAbsoluteSize();
	void GetIconLimitLU(struct FVector2D* LimitPosition);
	void GetIconLimitRD(struct FVector2D* LimitPosition);
	class FText GetMenuCommonMessage(class UDatabaseManager* PDatabaseManager, class FName Param_Name);
	void GetScreenOffset(const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	void GetScreenOffsetReverse(const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	void GetViewportOffset(const struct FVector2D& AbsolutePosition, struct FVector2D* CalcOffset);
	void InitChromaticAberration();
	void InitControlRetainerBox();
	bool IsLoopSE(class FName LoopSeName);
	void Open();
	void OpenDirect();
	void PlayLoopSe(EUI_SE SeType, class FName LoopSeName);
	class URSAtomComponentBase* PlaySE(EUI_SE SeType);
	class URSAtomComponentBase* PlaySEAtLocation(EUI_SE SeType, const struct FVector& Location);
	void PlayUIAnimation(int32 Param_Index, float Speed, bool IsLoop);
	void ProjectWorldToScreen2(const struct FVector& WorldPosition, struct FVector2D* ScreenPosition);
	void RedWidgetDown__DelegateSignature(const struct FRedMouseArgument& Argument, class UUserWidget* PWidget);
	void RedWidgetFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UUserWidget* PWidget);
	void RedWidgetUnFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UUserWidget* PWidget);
	void RemoveFromParentRED();
	void SearchControlRetainerBox(class UWidget* Widget);
	void SetAnimation(int32 Param_Index, class UWidgetAnimation* Animation);
	void SetAnimationNum(int32 Num);
	void SetControlWidget(class UUserWidget* Widget);
	void SetDebugInvisible(bool IsInvisible);
	void SetFlagUpdateAlways(bool Flag);
	void SetImageFromSprite(class UImage* Image, class UPaperSprite* Sprite);
	void SetInputLevel(int32 Param_InputLevel);
	void SetMouseDisable(bool Flag);
	void SetMouseMode(bool Mousemode, int32 Param_InputLevel);
	void SetUIAnimationFrame(int32 Param_Index, float Time);
	void SetupChromaticAberrationImage(class UPanelWidget* Base);
	void SetupChromaticAberrationRetainerBox(class UPanelWidget* Base);
	void SetViewPortPrio(EUIViewPrio Viewprio);
	void SetVisible(ESlateVisibility Visiblity);
	void StopLoopSe(class FName LoopSeName);
	void StopUIAllAnimation();
	void StopUIAnimation(int32 Param_Index);
	void StopUICurrentAnimation();
	void Update(float InDeltaTime);
	void UpdateChromaticAberration();
	void UpdateControlRetainerBox();
	void UpdateState(int32 State, int32 SubState, float DeltaSeconds);
	void UpdateVisible();

	void GetAnimation(int32 Param_Index, class UWidgetAnimation** Animation) const;
	void GetCurrentState(int32* State) const;
	void GetFlagUpdateAlways(bool* Flag) const;
	void GetInputLevel(int32* Param_InputLevel) const;
	bool GetMouseDisable() const;
	void GetUICurrentAnimationIndex(int32* Param_Index) const;
	class FString IntToString(int32 Value, int32 MinLength, int32 MaxLength) const;
	void IsPlaying(bool* Param_IsPlaying) const;
	void IsPlayUIAnimation(int32 Param_Index, bool* IsPlay) const;
	void IsPlayUIAnyAnimation(bool* IsPlay) const;
	void IsPlayUICurrentAnimation(bool* IsPlay) const;
	void IsStatePlay(bool* IsPlay) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBase">();
	}
	static class UUIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBase>();
	}
};
static_assert(alignof(UUIBase) == 0x000008, "Wrong alignment on UUIBase");
static_assert(sizeof(UUIBase) == 0x000388, "Wrong size on UUIBase");
static_assert(offsetof(UUIBase, FlagPlay) == 0x000248, "Member 'UUIBase::FlagPlay' has a wrong offset!");
static_assert(offsetof(UUIBase, FlagMouse) == 0x000249, "Member 'UUIBase::FlagMouse' has a wrong offset!");
static_assert(offsetof(UUIBase, MouseCallArgument) == 0x00024C, "Member 'UUIBase::MouseCallArgument' has a wrong offset!");
static_assert(offsetof(UUIBase, MouseHitOffsetPos) == 0x000258, "Member 'UUIBase::MouseHitOffsetPos' has a wrong offset!");
static_assert(offsetof(UUIBase, MouseHitOffsetSize) == 0x000260, "Member 'UUIBase::MouseHitOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIBase, MouseHitType) == 0x000268, "Member 'UUIBase::MouseHitType' has a wrong offset!");
static_assert(offsetof(UUIBase, DebugMouseHitDisp) == 0x000269, "Member 'UUIBase::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UUIBase, M_BaseFocusMouse) == 0x000270, "Member 'UUIBase::M_BaseFocusMouse' has a wrong offset!");
static_assert(offsetof(UUIBase, M_BaseUnFocusMouse) == 0x000280, "Member 'UUIBase::M_BaseUnFocusMouse' has a wrong offset!");
static_assert(offsetof(UUIBase, M_BaseDownMouse) == 0x000290, "Member 'UUIBase::M_BaseDownMouse' has a wrong offset!");
static_assert(offsetof(UUIBase, FlagRemove) == 0x0002A1, "Member 'UUIBase::FlagRemove' has a wrong offset!");
static_assert(offsetof(UUIBase, FlagNotRemoveHud) == 0x0002A2, "Member 'UUIBase::FlagNotRemoveHud' has a wrong offset!");
static_assert(offsetof(UUIBase, CurrentState) == 0x0002A4, "Member 'UUIBase::CurrentState' has a wrong offset!");
static_assert(offsetof(UUIBase, NextState) == 0x0002A8, "Member 'UUIBase::NextState' has a wrong offset!");
static_assert(offsetof(UUIBase, CurrentSubState) == 0x0002AC, "Member 'UUIBase::CurrentSubState' has a wrong offset!");
static_assert(offsetof(UUIBase, NextSubState) == 0x0002B0, "Member 'UUIBase::NextSubState' has a wrong offset!");
static_assert(offsetof(UUIBase, AnimationList) == 0x0002B8, "Member 'UUIBase::AnimationList' has a wrong offset!");
static_assert(offsetof(UUIBase, PlayIndex) == 0x0002C8, "Member 'UUIBase::PlayIndex' has a wrong offset!");
static_assert(offsetof(UUIBase, ViewPortPrio) == 0x0002CC, "Member 'UUIBase::ViewPortPrio' has a wrong offset!");
static_assert(offsetof(UUIBase, ChromaticAberration) == 0x0002D0, "Member 'UUIBase::ChromaticAberration' has a wrong offset!");
static_assert(offsetof(UUIBase, CA_WorkObject) == 0x0002D8, "Member 'UUIBase::CA_WorkObject' has a wrong offset!");
static_assert(offsetof(UUIBase, ListChromaticAberration) == 0x0002E8, "Member 'UUIBase::ListChromaticAberration' has a wrong offset!");
static_assert(offsetof(UUIBase, ListControlRetainerBox) == 0x0002F8, "Member 'UUIBase::ListControlRetainerBox' has a wrong offset!");
static_assert(offsetof(UUIBase, StateControlRetainerBox) == 0x000308, "Member 'UUIBase::StateControlRetainerBox' has a wrong offset!");
static_assert(offsetof(UUIBase, ControlWidget) == 0x000310, "Member 'UUIBase::ControlWidget' has a wrong offset!");
static_assert(offsetof(UUIBase, LocalVisibility) == 0x000318, "Member 'UUIBase::LocalVisibility' has a wrong offset!");
static_assert(offsetof(UUIBase, InputLevel) == 0x00031C, "Member 'UUIBase::InputLevel' has a wrong offset!");
static_assert(offsetof(UUIBase, BaseScrollSpeed) == 0x000320, "Member 'UUIBase::BaseScrollSpeed' has a wrong offset!");
static_assert(offsetof(UUIBase, M_DebugDraw) == 0x000340, "Member 'UUIBase::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UUIBase, M_MyGeometry) == 0x000348, "Member 'UUIBase::M_MyGeometry' has a wrong offset!");

// Class BattlePrototype.UITargetBrain
// 0x0088 (0x0410 - 0x0388)
class UUITargetBrain : public UUIBase
{
public:
	uint8                                         Pad_1C31[0x88];                                    // 0x0388(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseThis();
	void Decide();
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimOut2, class UWidgetAnimation* AnimChange1_2, class UWidgetAnimation* AnimChange2_1, class UBorder* borderButtonSet);
	void SetEnable(bool IsEnable);
	bool UpdateButton();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsEnableDecide() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITargetBrain">();
	}
	static class UUITargetBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITargetBrain>();
	}
};
static_assert(alignof(UUITargetBrain) == 0x000008, "Wrong alignment on UUITargetBrain");
static_assert(sizeof(UUITargetBrain) == 0x000410, "Wrong size on UUITargetBrain");

// Class BattlePrototype.BP_SM_MapModel_Base
// 0x00A8 (0x02E8 - 0x0240)
class ABP_SM_MapModel_Base : public AStaticMeshActor
{
public:
	bool                                          IsDetaileMap;                                      // 0x0240(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsScale;                                           // 0x0241(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C32[0x2];                                     // 0x0242(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Playerrate;                                        // 0x0244(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapGradationValue;                             // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapIconScaleRate;                                  // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapIconDetail_ZOffset;                             // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimapOnlyIconGradationValue;                     // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MinimapOnlyIconGradationValueFlag;                 // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C33[0x7];                                     // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               M_MaterialDynamicMinimap;                          // 0x0260(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               M_MaterialDynamicDetail;                           // 0x0268(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_SubMapData;                                      // 0x0270(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C34[0x8];                                     // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIMapFloorAdjustData>          PGAdjuster;                                        // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_pgAdjusterFlag;                                  // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C35[0x7];                                     // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PgHeightData;                                      // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_pgIconHeightFlag;                                // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isCenterOffsetProc;                              // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C36[0x6];                                     // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIDetaileMapSubAreaCenterPosition> M_AreaCenterPos;                                   // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FloorWidthDataCheck;                             // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C37[0x3];                                     // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_FloorWidthIndex;                                 // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 M_FloorWidthData;                                  // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C38[0x8];                                     // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcMaterialUpDateParam(float RateHeight, float Width);
	struct FVector GetAreaCenterPos();
	TArray<struct FUIDetaileMapSubAreaCenterPosition> GetAreaCenterPosArray();
	class UCapsuleComponent* GetCollisitonData();
	float GetDirectionRotate();
	TArray<struct FUIDetaileMapFloorData> GetFloorData();
	int32 GetFloorIndextoGameWidth();
	float GetFloorIndextoGameWidthData(int32 Floorindex);
	bool GetFloorIndextoGameWidthFlag();
	int32 GetFloorIndextoGameWidthNum();
	TArray<struct FUIMapFloorAdjustData> GetFloorPGAdjuster();
	float GetMapIconDetail_ZOffset();
	float GetMapIconScaleRate();
	float GetMinimapGradationValue();
	float GetMinimapOnlyIconGradationValue();
	TArray<float> GetPgIconHeightFlag();
	float GetZoomMax();
	float GetZoomMin();
	bool IsAdjusterFlag();
	bool IsBrainField();
	bool IsCenterOffsetProc();
	bool IsMinimapOnlyIconGradationValue();
	bool IsPgIconHeightFlag();
	bool IsVisionSimulator();
	bool MaterialUpdate();
	void SetBrainField(bool Flag);
	void SetDetaileMap(bool DetaileMap);
	bool SetFloorIndex(int32 Floorindex);
	void SetFloorIndextoGame(int32 Floorindex);
	void SetFloorPGAdjuster(const TArray<struct FUIMapFloorAdjustData>& Update);
	void SetGradationValue(float Gradation);
	void SetPersSwitch(bool Pers);
	void SetPlayerRate(float Param_Playerrate);
	void SetScale(bool Scale);
	void SetSubModelVisible(class FName SubName, bool Flag);
	void SetVisionSimulator(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BP_SM_MapModel_Base">();
	}
	static class ABP_SM_MapModel_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_SM_MapModel_Base>();
	}
};
static_assert(alignof(ABP_SM_MapModel_Base) == 0x000008, "Wrong alignment on ABP_SM_MapModel_Base");
static_assert(sizeof(ABP_SM_MapModel_Base) == 0x0002E8, "Wrong size on ABP_SM_MapModel_Base");
static_assert(offsetof(ABP_SM_MapModel_Base, IsDetaileMap) == 0x000240, "Member 'ABP_SM_MapModel_Base::IsDetaileMap' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, IsScale) == 0x000241, "Member 'ABP_SM_MapModel_Base::IsScale' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, Playerrate) == 0x000244, "Member 'ABP_SM_MapModel_Base::Playerrate' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MinimapGradationValue) == 0x000248, "Member 'ABP_SM_MapModel_Base::MinimapGradationValue' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MapIconScaleRate) == 0x00024C, "Member 'ABP_SM_MapModel_Base::MapIconScaleRate' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MapIconDetail_ZOffset) == 0x000250, "Member 'ABP_SM_MapModel_Base::MapIconDetail_ZOffset' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MinimapOnlyIconGradationValue) == 0x000254, "Member 'ABP_SM_MapModel_Base::MinimapOnlyIconGradationValue' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, MinimapOnlyIconGradationValueFlag) == 0x000258, "Member 'ABP_SM_MapModel_Base::MinimapOnlyIconGradationValueFlag' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_MaterialDynamicMinimap) == 0x000260, "Member 'ABP_SM_MapModel_Base::M_MaterialDynamicMinimap' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_MaterialDynamicDetail) == 0x000268, "Member 'ABP_SM_MapModel_Base::M_MaterialDynamicDetail' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_SubMapData) == 0x000270, "Member 'ABP_SM_MapModel_Base::M_SubMapData' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, PGAdjuster) == 0x000288, "Member 'ABP_SM_MapModel_Base::PGAdjuster' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_pgAdjusterFlag) == 0x000298, "Member 'ABP_SM_MapModel_Base::M_pgAdjusterFlag' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, PgHeightData) == 0x0002A0, "Member 'ABP_SM_MapModel_Base::PgHeightData' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_pgIconHeightFlag) == 0x0002B0, "Member 'ABP_SM_MapModel_Base::M_pgIconHeightFlag' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_isCenterOffsetProc) == 0x0002B1, "Member 'ABP_SM_MapModel_Base::M_isCenterOffsetProc' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_AreaCenterPos) == 0x0002B8, "Member 'ABP_SM_MapModel_Base::M_AreaCenterPos' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_FloorWidthDataCheck) == 0x0002C8, "Member 'ABP_SM_MapModel_Base::M_FloorWidthDataCheck' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_FloorWidthIndex) == 0x0002CC, "Member 'ABP_SM_MapModel_Base::M_FloorWidthIndex' has a wrong offset!");
static_assert(offsetof(ABP_SM_MapModel_Base, M_FloorWidthData) == 0x0002D0, "Member 'ABP_SM_MapModel_Base::M_FloorWidthData' has a wrong offset!");

// Class BattlePrototype.BattleEnemyInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleEnemyInterface final : public IInterface
{
public:
	bool BrainCrashLock_Native();
	bool CallDead_Native();
	bool CallFuncDamageDownEnd_Native();
	bool CallFuncDamageDownLoop_Native();
	bool CallFuncDamageDownStart_Native();
	bool CameraAttentionEnd_Native(class UCurveFloat* FovCurveOut);
	bool CheckNpcDrive_Native(ENpcDriveCheckType CheckType, class AActor* EnemyActor);
	bool CheckSASHologramAttack_Native(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	bool DamageFloatEnd_Native();
	bool DamageMotionEnd_Native(float DeltaTime);
	bool DeadStart_Native();
	bool DisableFitGroundTmp_Native();
	bool DropFlyingEnemy_Native(class AActor* Enemy);
	bool EnableAllWeak_Native(bool bEnable);
	bool EnableFitGroundTmp_Native();
	bool EndDamageFloating_Native();
	bool EnemyEndEvDitherNative(bool bDisp);
	bool EnemyStartEvDitherNative(bool bDisp, float DitherTime);
	bool EnemyUpdateEvDitherNative(float DeltaSec);
	bool EntryBrainCrashAccess_Native(class ARSCharacterBase* Character);
	void FlyDown_Native(bool* IsEnd);
	void GetCurrentActionTime_Native(float* ActionTime);
	EEnemyTribe GetEnemyTribe();
	bool GetFailedFall_Native();
	bool GetFall_Native();
	void GetHitObjectType_Native(TArray<EObjectTypeQuery>* ObjectType);
	void GetLostData_Native(float* LostMoveTimeMin, float* LostMoveTimeMax, float* LostMoveRotationRate, float* SpeedScale, bool* IsNoMoveAnim);
	class USearchingComponent* GetSearchingComponent_Native();
	void IsBrainCrashMiss_Native(bool* IsMiss);
	bool IsCheckLookScrollTick(const struct FVector& Start, const struct FVector& End);
	bool IsCheckSameCompareGroundLoaction();
	bool IsEnemyDamageDown_CallFromCPP();
	void IsEnemyLandingCheck_Native(bool* bHit);
	bool IsEnemyStateAttack_CallFromCPP();
	bool IsFlyEnemyCheck_Native();
	void IsIgnoreLandingCheck_Native(bool* bIgnoreLandingCheck);
	void IsMotionEnd_Native(bool* ReturnValue);
	bool IsPossibleTargetAttack_CallFromCPP(class AActor* Actor);
	bool KickCrashChanceLoopEffect_Native();
	void LaunchDown_Native(bool* IsEnd);
	bool LeaveBrainCrashAccess_Native(class ARSCharacterBase* Character);
	bool OnCrashVisionDead();
	void OnEndAnimDieIF(bool* bDummy);
	bool OnEndCrashChance_Native();
	void OnHitCrashVisionAttack();
	bool OnNotifyPlayerDead();
	bool OutputLogCrashChanceEnd_Native();
	void ReceivedNotifyAnimEnd_Native(bool* Received);
	bool ResetAction_Native();
	bool ResetCore_Native(class AActor* Enemy, bool RemoveCore);
	bool ResetStateReceivedExecuteAi_Native();
	bool RestoreWeakEmissive_Native(const class FString& WeakSlotName);
	bool RestoreWeakState_Native();
	bool SafeDestroy_Native(class AActor* Actor);
	bool SetDamageCollisionDisable_Native(const class FName& ClaimantName);
	bool SetDownTimer_Native(float NewTime);
	bool SetEnemyConsiderDownDead(bool bEnable);
	bool SetHp_Native(int32 HP);
	bool SetIdleMove_Native(bool IsIdle);
	bool SetIsBrainAccess_Native(bool NewIsBrainAccess);
	bool SetIsLandCheck_Native(bool NewIsLandCheck);
	bool SetIsLaunchDown_Native(bool NewIsLaunchDown);
	bool SetIsMoveAnim_Native(bool NewIsMoveAnim);
	bool SetLanding_Native(bool bLanding);
	bool SetReserveAction_Native(uint8 Action, float Param00, float Param01);
	bool SetTickEnableMeshOnly(bool bMeshOnly);
	bool SetUseWaitNoInterpolation_Native(bool Use);
	bool SetWeakEmissiveOff_Native(const class FString& WeakSlotName);
	bool StartDamageFloating_Native();
	void StartFallIfFlyingIF(bool* bDummy);
	bool StartReactionDilation_CallFromCPP(uint8 ReactionKind, bool bAddDamage);
	bool StartVanish_Native(float VanishSec, float StartVanish, float EndVanish);
	bool StopCrashChanceLoopEffect_Native();
	bool StoreWeakState_Native();
	bool SwitchDispCore_Native(bool DisplayOn);
	void UpdateDamageAnim_Native(bool* DamageEnd, bool* DamageDownEnd);
	bool UpdateFall_Native();
	bool UpdateMoveMaxSpeed();
	void UpdateOutRangeFade_Native(float ToTargetLenge, bool ForceDisp);

	class UCapsuleComponent* GetCapsuleComponent_Native() const;
	class AActor* GetCurrentTarget() const;
	struct FVector GetDamageHitDirectionIF() const;
	bool GetDebugEnemyDownInfinity_Native() const;
	float GetDownTimer_Native() const;
	EnemyMoveAnimKind GetDownUpMoveAnimKind_Native() const;
	class UEnemyAiComponentBase* GetEnemyAiComponent() const;
	class UEnemyAnimControllerComponent* GetEnemyAnimControllerComponent() const;
	class UEnemyScriptComponent* GetEnemyScriptComponent() const;
	class UHateTargetComponent* GetHateTarget_Native() const;
	bool GetIsJumpEnd() const;
	bool GetIsLandCheck() const;
	void GetLostActionInfoList_Native(TArray<struct FEmLostActionInfo>* LostActionInfo) const;
	bool GetNewDamageFloating_Native() const;
	bool GetPressDownLoop_Native() const;
	class AActor* GetTargetCharacter_Native() const;
	struct FVector GetTopHeightLocation() const;
	float GetUniqueTickEnableRange() const;
	bool IsBossEnemy_CallFromCPP() const;
	bool IsBrainSuccess_Native() const;
	bool IsCheckHeightChangeTick() const;
	bool IsCheckLookTargetTick(const struct FVector& Start, const struct FVector& End) const;
	bool IsDamageMotionEnd_Native() const;
	bool IsDisableDownMotionInterface() const;
	bool IsDisableUroAction_Interface() const;
	bool IsEnemyConsiderDownDead() const;
	bool IsEnemyFalling_Interface() const;
	bool IsEnemySpawn_Interface() const;
	bool IsExecLowProcess() const;
	bool IsInvincible_Native() const;
	bool IsLaunchDown_Native() const;
	bool IsNotFindPlayer_CallFromCPP() const;
	bool IsPressDown_Native() const;
	bool IsReflectContainer() const;
	bool IsSpawned() const;
	bool IsSuspendFollowAttackInterface() const;
	bool IsTickDisableCondition() const;
	bool IsUniqueAroundEffectPause() const;
	bool IsUpdateEnemySpawn() const;
	bool IsUpdateEnemyTickEnable() const;
	bool IsWeakUiDamageHit_CallFromCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleEnemyInterface">();
	}
	static class IBattleEnemyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleEnemyInterface>();
	}
};
static_assert(alignof(IBattleEnemyInterface) == 0x000008, "Wrong alignment on IBattleEnemyInterface");
static_assert(sizeof(IBattleEnemyInterface) == 0x000028, "Wrong size on IBattleEnemyInterface");

// Class BattlePrototype.PhantomAnimInstance
// 0x0020 (0x0640 - 0x0620)
class UPhantomAnimInstance final : public UASAnimInstance
{
public:
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x0620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageEnded;                              // 0x0630(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void RecvOnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void RecvOnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomAnimInstance">();
	}
	static class UPhantomAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhantomAnimInstance>();
	}
};
static_assert(alignof(UPhantomAnimInstance) == 0x000010, "Wrong alignment on UPhantomAnimInstance");
static_assert(sizeof(UPhantomAnimInstance) == 0x000640, "Wrong size on UPhantomAnimInstance");
static_assert(offsetof(UPhantomAnimInstance, DispatchMontageBlendingOut) == 0x000620, "Member 'UPhantomAnimInstance::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UPhantomAnimInstance, DispatchMontageEnded) == 0x000630, "Member 'UPhantomAnimInstance::DispatchMontageEnded' has a wrong offset!");

// Class BattlePrototype.BP_UI_SceneMap
// 0x0300 (0x0530 - 0x0230)
class alignas(0x10) ABP_UI_SceneMap : public AActor
{
public:
	struct FVector                                ObjectIconScale;                                   // 0x0230(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugCameraPers;                                   // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C58[0x3];                                     // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewModeCameraLocation;                            // 0x0240(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ViewModeViewLocation;                              // 0x024C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewModeZoom;                                      // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapGradationValue;                                 // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapHeightValue;                                    // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_FootPrintSpanNormal;                             // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_FootPrintSpanExtent;                             // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_FootPrintSpanMax;                                // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FootPrintStop;                                   // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C59[0x3];                                     // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_CameraHeight;                                    // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_CameraOrthoWidth;                                // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_CameraRotatePitch;                               // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_RotateCamera;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_CameraRoll;                                      // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_CameraRollBase;                                  // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsScaleFlag;                                       // 0x028C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCameraRotateFlag;                                // 0x028D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDetailMap;                                       // 0x028E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_IsPerspective;                                   // 0x028F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_AreaMax;                                         // 0x0290(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_FloorMax;                                        // 0x0294(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_CurrentFloor;                                    // 0x0298(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_CurrentArea;                                     // 0x029C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_CurrentLevel;                                    // 0x02A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFloorPlayer;                                // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAreaPlayer;                                 // 0x02A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFloorMain;                                  // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFloorSub;                                   // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentFloorBonds;                                 // 0x02B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_CurrentIndex;                                    // 0x02B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_ChapterNo;                                       // 0x02BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_ProgressNo;                                      // 0x02C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C5A[0x4];                                     // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIDetaileMapFloorData>         M_FloorData;                                       // 0x02C8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(int32 Floor)>                  M_OnMinimapChangeFloor;                            // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             M_MaterialIconArray;                               // 0x02E8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       M_MaterialDynamicIconArray;                        // 0x02F8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_minimapDistanceSquareEnemy;                      // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C5B[0x4];                                     // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_SM_MapModel_Base*                   M_SM_MapModel_Base;                                // 0x0310(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_MeshList;                                        // 0x0318(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUIDetaileMapCheckData                 M_DetailMapData;                                   // 0x0328(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C5C[0x30];                                    // 0x0350(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_AsyncLineActor;                                  // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C5D[0xC8];                                    // 0x0388(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        Instance;                                          // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEnemyManager*                          EnemyManager;                                      // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerCameraManager*                   CameraManager;                                     // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEventManager*                          EventManager;                                      // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneCaptureComponent2D*               CaptureCamera;                                     // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  M_player;                                          // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          ObjectInstancedMesh;                               // 0x0480(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          NpcPlInstancedMesh;                                // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          EnemyInstancedMeshNormal;                          // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          EnemyInstancedMesh0630;                            // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          FootInstancedMesh;                                 // 0x04A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          MainQuestInstancedMesh;                            // 0x04A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          SubQuestActiveInstancedMesh;                       // 0x04B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          SubQuestCompActiveInstancedMesh;                   // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          BoudsQuestInstancedMesh;                           // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APsychicObjectManager*                  PsychicObjectManager;                              // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerManager*                         PlayerManager;                                     // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ARSCharacterBase>> PlayerCharacterList;                               // 0x04D8(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               M_EnemyList;                                       // 0x04E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTransform>                     M_PlPosDataListNormal;                             // 0x04F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FTransform>                     M_PlPosDataListExtent;                             // 0x0508(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSHUDBase*                             M_pHudBase;                                        // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C5E[0x10];                                    // 0x0520(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BgModelLoadNextAreaNative(int32* Area, int32* Lc);
	void BgModelLoadPreviousAreaNative(int32* Area, int32* Lc);
	struct FVector CalcMapIconLocation(EUIMapIconNative Type, const struct FVector& InputLocation, float AddZ);
	bool Camera_UpdateDetailMap();
	bool CameraSetPerspectiveNative(bool Isperspective);
	void CameraUpdateMinimapPerspective();
	bool DebugUpdateIcon();
	bool End();
	void EndMinimapBrainField();
	void EnemyIconInit(class UInstancedStaticMeshComponent* InstancedMeshNormal, class UInstancedStaticMeshComponent* InstancedMesh0630, float Square);
	void EnemyIconUpdate();
	int32 GetAreaMax(class FName AssetClass, class FName AssetDataPath);
	float GetCameraRoll();
	float GetCameraRollBase();
	int32 GetCurrentAreaPlayer();
	int32 GetCurrentFloorBonds();
	int32 GetCurrentFloorMain();
	int32 GetCurrentFloorPlayer();
	int32 GetCurrentFloorSub();
	class AEventManager* GetEventManager();
	int32 GetFloorIndexCore(float Floorrate);
	int32 GetFloorIndexCore2(float Floorrate, bool Detail);
	class FName GetGimmickActorName(class AActor* Actor);
	class AActor* GetIconAdjustVector(TSubclassOf<class AActor> ActorClass, class FName FindName);
	class UInstancedStaticMeshComponent* GetInstanceMeshBondsQuest();
	class UInstancedStaticMeshComponent* GetInstanceMeshMainQuest();
	class UInstancedStaticMeshComponent* GetInstanceMeshSubQuestActive();
	class UInstancedStaticMeshComponent* GetInstanceMeshSubQuestCompActive();
	struct FVector GetLineTraceActorLocation();
	class UMaterialInstanceDynamic* GetMaterialInstanceNative(EUIMapIconNative IconTypeNatice);
	TSubclassOf<class AStaticMeshActor> GetMeshClassRefalence(const class FString& Path);
	TArray<class ANpcTownPeople*> GetMinimapNpcList();
	EQuestProgressState GetQuestInfoState(const class FName& QuestId);
	float GetRateData(const struct FVector& Inputpos);
	float GetRotateCamera();
	class ASceneManager* GetSceneManager();
	void InitializeMaterialNative();
	void InitializePlayerFootIconArray();
	void InstanceObjInit(class UInstancedStaticMeshComponent* Mainquest, class UInstancedStaticMeshComponent* SubquestActive, class UInstancedStaticMeshComponent* SubquestCompActive, class UInstancedStaticMeshComponent* boudsquest);
	bool IsActorTick();
	bool IsAysncLocation();
	bool IsBrainField();
	bool IsCheckFlag(const struct FUIDetaileMapCheckCoreData& Data);
	bool IsCheckProg(const struct FUIDetaileMapCheckCoreData& Data);
	bool IsVisionSimulator();
	void NpcPlayerInit(class UInstancedStaticMeshComponent* InstancedMesh);
	void NpcPlayerUpdate();
	void OnEnemyListUpdate();
	void PlayerFootIconInit(class UInstancedStaticMeshComponent* InstancedMesh);
	void PlayerFootIconUpdate();
	void PsychicObjInit(class UInstancedStaticMeshComponent* InstancedMesh, float Square);
	void PsychicObjUpdate();
	bool QuestIconInit_Native();
	void SceneCaptureCameraInit(class USceneCaptureComponent2D* PCamera);
	void SetBrainField(bool Flag);
	void SetChapterNoIndex(int32 No);
	void SetCurrentIndex(int32 Param_Index);
	void SetDetailMapData(const struct FUIDetaileMapCheckData& Data, int32 Initareano);
	void SetIconUpdateFlag(bool Flag);
	void SetMapGradation(float Gradation);
	void SetMapHeight(float Height);
	void SetProgressNo(int32 Progress);
	void SetSubModel();
	void SetVisionSimulator(bool Flag);
	void SetWantsTraceRequest(class AActor* Actor, bool Flag);
	bool Start();
	void StartMinimapBrainField();
	void UpdateDetailmapCalc();
	void UpdateMaterialCalc(float Rate, bool Update);
	void UpdateMinimapCalc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BP_UI_SceneMap">();
	}
	static class ABP_UI_SceneMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_UI_SceneMap>();
	}
};
static_assert(alignof(ABP_UI_SceneMap) == 0x000010, "Wrong alignment on ABP_UI_SceneMap");
static_assert(sizeof(ABP_UI_SceneMap) == 0x000530, "Wrong size on ABP_UI_SceneMap");
static_assert(offsetof(ABP_UI_SceneMap, ObjectIconScale) == 0x000230, "Member 'ABP_UI_SceneMap::ObjectIconScale' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, DebugCameraPers) == 0x00023C, "Member 'ABP_UI_SceneMap::DebugCameraPers' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, ViewModeCameraLocation) == 0x000240, "Member 'ABP_UI_SceneMap::ViewModeCameraLocation' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, ViewModeViewLocation) == 0x00024C, "Member 'ABP_UI_SceneMap::ViewModeViewLocation' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, ViewModeZoom) == 0x000258, "Member 'ABP_UI_SceneMap::ViewModeZoom' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, MapGradationValue) == 0x00025C, "Member 'ABP_UI_SceneMap::MapGradationValue' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, MapHeightValue) == 0x000260, "Member 'ABP_UI_SceneMap::MapHeightValue' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FootPrintSpanNormal) == 0x000264, "Member 'ABP_UI_SceneMap::M_FootPrintSpanNormal' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FootPrintSpanExtent) == 0x000268, "Member 'ABP_UI_SceneMap::M_FootPrintSpanExtent' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FootPrintSpanMax) == 0x00026C, "Member 'ABP_UI_SceneMap::M_FootPrintSpanMax' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FootPrintStop) == 0x000270, "Member 'ABP_UI_SceneMap::M_FootPrintStop' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraHeight) == 0x000274, "Member 'ABP_UI_SceneMap::M_CameraHeight' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraOrthoWidth) == 0x000278, "Member 'ABP_UI_SceneMap::M_CameraOrthoWidth' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraRotatePitch) == 0x00027C, "Member 'ABP_UI_SceneMap::M_CameraRotatePitch' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_RotateCamera) == 0x000280, "Member 'ABP_UI_SceneMap::M_RotateCamera' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraRoll) == 0x000284, "Member 'ABP_UI_SceneMap::M_CameraRoll' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CameraRollBase) == 0x000288, "Member 'ABP_UI_SceneMap::M_CameraRollBase' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, IsScaleFlag) == 0x00028C, "Member 'ABP_UI_SceneMap::IsScaleFlag' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, IsCameraRotateFlag) == 0x00028D, "Member 'ABP_UI_SceneMap::IsCameraRotateFlag' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, IsDetailMap) == 0x00028E, "Member 'ABP_UI_SceneMap::IsDetailMap' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_IsPerspective) == 0x00028F, "Member 'ABP_UI_SceneMap::M_IsPerspective' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_AreaMax) == 0x000290, "Member 'ABP_UI_SceneMap::M_AreaMax' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FloorMax) == 0x000294, "Member 'ABP_UI_SceneMap::M_FloorMax' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CurrentFloor) == 0x000298, "Member 'ABP_UI_SceneMap::M_CurrentFloor' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CurrentArea) == 0x00029C, "Member 'ABP_UI_SceneMap::M_CurrentArea' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CurrentLevel) == 0x0002A0, "Member 'ABP_UI_SceneMap::M_CurrentLevel' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentFloorPlayer) == 0x0002A4, "Member 'ABP_UI_SceneMap::CurrentFloorPlayer' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentAreaPlayer) == 0x0002A8, "Member 'ABP_UI_SceneMap::CurrentAreaPlayer' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentFloorMain) == 0x0002AC, "Member 'ABP_UI_SceneMap::CurrentFloorMain' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentFloorSub) == 0x0002B0, "Member 'ABP_UI_SceneMap::CurrentFloorSub' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CurrentFloorBonds) == 0x0002B4, "Member 'ABP_UI_SceneMap::CurrentFloorBonds' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_CurrentIndex) == 0x0002B8, "Member 'ABP_UI_SceneMap::M_CurrentIndex' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_ChapterNo) == 0x0002BC, "Member 'ABP_UI_SceneMap::M_ChapterNo' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_ProgressNo) == 0x0002C0, "Member 'ABP_UI_SceneMap::M_ProgressNo' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_FloorData) == 0x0002C8, "Member 'ABP_UI_SceneMap::M_FloorData' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_OnMinimapChangeFloor) == 0x0002D8, "Member 'ABP_UI_SceneMap::M_OnMinimapChangeFloor' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_MaterialIconArray) == 0x0002E8, "Member 'ABP_UI_SceneMap::M_MaterialIconArray' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_MaterialDynamicIconArray) == 0x0002F8, "Member 'ABP_UI_SceneMap::M_MaterialDynamicIconArray' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_minimapDistanceSquareEnemy) == 0x000308, "Member 'ABP_UI_SceneMap::M_minimapDistanceSquareEnemy' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_SM_MapModel_Base) == 0x000310, "Member 'ABP_UI_SceneMap::M_SM_MapModel_Base' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_MeshList) == 0x000318, "Member 'ABP_UI_SceneMap::M_MeshList' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_DetailMapData) == 0x000328, "Member 'ABP_UI_SceneMap::M_DetailMapData' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_AsyncLineActor) == 0x000380, "Member 'ABP_UI_SceneMap::M_AsyncLineActor' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, Instance) == 0x000450, "Member 'ABP_UI_SceneMap::Instance' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, EnemyManager) == 0x000458, "Member 'ABP_UI_SceneMap::EnemyManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CameraManager) == 0x000460, "Member 'ABP_UI_SceneMap::CameraManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, EventManager) == 0x000468, "Member 'ABP_UI_SceneMap::EventManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, CaptureCamera) == 0x000470, "Member 'ABP_UI_SceneMap::CaptureCamera' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_player) == 0x000478, "Member 'ABP_UI_SceneMap::M_player' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, ObjectInstancedMesh) == 0x000480, "Member 'ABP_UI_SceneMap::ObjectInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, NpcPlInstancedMesh) == 0x000488, "Member 'ABP_UI_SceneMap::NpcPlInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, EnemyInstancedMeshNormal) == 0x000490, "Member 'ABP_UI_SceneMap::EnemyInstancedMeshNormal' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, EnemyInstancedMesh0630) == 0x000498, "Member 'ABP_UI_SceneMap::EnemyInstancedMesh0630' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, FootInstancedMesh) == 0x0004A0, "Member 'ABP_UI_SceneMap::FootInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, MainQuestInstancedMesh) == 0x0004A8, "Member 'ABP_UI_SceneMap::MainQuestInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, SubQuestActiveInstancedMesh) == 0x0004B0, "Member 'ABP_UI_SceneMap::SubQuestActiveInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, SubQuestCompActiveInstancedMesh) == 0x0004B8, "Member 'ABP_UI_SceneMap::SubQuestCompActiveInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, BoudsQuestInstancedMesh) == 0x0004C0, "Member 'ABP_UI_SceneMap::BoudsQuestInstancedMesh' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, PsychicObjectManager) == 0x0004C8, "Member 'ABP_UI_SceneMap::PsychicObjectManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, PlayerManager) == 0x0004D0, "Member 'ABP_UI_SceneMap::PlayerManager' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, PlayerCharacterList) == 0x0004D8, "Member 'ABP_UI_SceneMap::PlayerCharacterList' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_EnemyList) == 0x0004E8, "Member 'ABP_UI_SceneMap::M_EnemyList' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_PlPosDataListNormal) == 0x0004F8, "Member 'ABP_UI_SceneMap::M_PlPosDataListNormal' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_PlPosDataListExtent) == 0x000508, "Member 'ABP_UI_SceneMap::M_PlPosDataListExtent' has a wrong offset!");
static_assert(offsetof(ABP_UI_SceneMap, M_pHudBase) == 0x000518, "Member 'ABP_UI_SceneMap::M_pHudBase' has a wrong offset!");

// Class BattlePrototype.LibraryCharaDBAsset
// 0x0050 (0x0078 - 0x0028)
class ULibraryCharaDBAsset final : public UObject
{
public:
	TMap<class FName, struct FLibraryCharaDBCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryCharaDBAsset">();
	}
	static class ULibraryCharaDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryCharaDBAsset>();
	}
};
static_assert(alignof(ULibraryCharaDBAsset) == 0x000008, "Wrong alignment on ULibraryCharaDBAsset");
static_assert(sizeof(ULibraryCharaDBAsset) == 0x000078, "Wrong size on ULibraryCharaDBAsset");
static_assert(offsetof(ULibraryCharaDBAsset, DBMap) == 0x000028, "Member 'ULibraryCharaDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.BattlefieldFenceInterface
// 0x0000 (0x0028 - 0x0028)
class IBattlefieldFenceInterface final : public IInterface
{
public:
	bool GetBattlefieldEnable();
	class USplineComponent* GetBattlefieldSpline();
	void SetBattlefieldEnable(bool Enable);
	void SetBattlefieldVisibleForce(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlefieldFenceInterface">();
	}
	static class IBattlefieldFenceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattlefieldFenceInterface>();
	}
};
static_assert(alignof(IBattlefieldFenceInterface) == 0x000008, "Wrong alignment on IBattlefieldFenceInterface");
static_assert(sizeof(IBattlefieldFenceInterface) == 0x000028, "Wrong size on IBattlefieldFenceInterface");

// Class BattlePrototype.UITitleMenuParts
// 0x0090 (0x0418 - 0x0388)
class UUITitleMenuParts final : public UUIBase
{
public:
	uint8                                         Pad_1C6A[0x90];                                    // 0x0388(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeNormalAnime(class UWidgetAnimation* _cursor_menu_out, class UWidgetAnimation* _cursor_menu_in, class UWidgetAnimation* _cursor_menu_default_none, class UWidgetAnimation* _cursor_menu_default_, class UWidgetAnimation* _cursor_menu_select, class UWidgetAnimation* _cursor_menu_decision);
	void InitializeText(class UTextBlock* Partsdatatext);
	void InitializeUnSelectAnime(class UWidgetAnimation* _cursor_menu_out, class UWidgetAnimation* _cursor_menu_in, class UWidgetAnimation* _cursor_menu_default_none, class UWidgetAnimation* _cursor_menu_default_, class UWidgetAnimation* _cursor_menu_select, class UWidgetAnimation* _cursor_menu_decision);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleMenuParts">();
	}
	static class UUITitleMenuParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleMenuParts>();
	}
};
static_assert(alignof(UUITitleMenuParts) == 0x000008, "Wrong alignment on UUITitleMenuParts");
static_assert(sizeof(UUITitleMenuParts) == 0x000418, "Wrong size on UUITitleMenuParts");

// Class BattlePrototype.UISceneMapFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUISceneMapFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void MinimapIconGetArrangeElementList(class UObject* WorldContextObject, class UDataTable* ArrangePointTable, int32 LocationNo, int32 AreaNo, EMapIconType Map_Icon_Type, TArray<struct FMapArrangeItemNode>& ResultList);
	static EMapIconType MinimapIconGetArrangeIconType(class UObject* WorldContextObject, const TArray<class UDataTable*>& IconTables, class FName PointName);
	static void MinimapIconGetElementList(class UObject* WorldContextObject, const TArray<class UDataTable*>& IconTables, EUiSceneMapIconType Type, TArray<struct FUiSceneMapIconNode>& ResultList);
	static void MinimapIconGetElementList_OtherArea(class UObject* WorldContextObject, const TArray<class UDataTable*>& IconTables, EUiSceneMapIconType Type, TArray<struct FUiSceneMapIconNode>& ResultList, class FName AreaName);
	static void MinimapIconGetElementListUse(class UObject* WorldContextObject, int32 Location, int32 Area, int32 Valiation, const TArray<class UDataTable*>& IconTables, EUiSceneMapIconType Type, TArray<struct FUiSceneMapIconNode>& ResultList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISceneMapFunctionLibrary">();
	}
	static class UUISceneMapFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISceneMapFunctionLibrary>();
	}
};
static_assert(alignof(UUISceneMapFunctionLibrary) == 0x000008, "Wrong alignment on UUISceneMapFunctionLibrary");
static_assert(sizeof(UUISceneMapFunctionLibrary) == 0x000028, "Wrong size on UUISceneMapFunctionLibrary");

// Class BattlePrototype.EnemyManager
// 0x02A8 (0x04D8 - 0x0230)
class AEnemyManager : public AActor
{
public:
	uint8                                         Pad_1C71[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MTickEnableTargetDroneActor;                       // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshComponent>          MTickEnableTargetDroneMesh;                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsStealthSeeFlag;                                // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C72[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SelectParamDistList;                               // 0x0250(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SelectParamDistPointList;                          // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 SelectParamAngleList;                              // 0x0270(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 SelectParamAnglePointList;                         // 0x0280(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C73[0x58];                                    // 0x0290(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEnemyListNative;                                 // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class ARSCharacterBase*>               EnemyList;                                         // 0x02F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FEnemyListInfo>      EnemyListByLevel;                                  // 0x0308(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         EnemyBossList;                                     // 0x0358(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FEnemyListInfo>      EnemyBossListByLevel;                              // 0x0368(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               BrainCrashCandidateList;                           // 0x03B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        _enemyIgnoreDamageFlag;                            // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C74[0x5];                                     // 0x03CC(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RestrictSelfDead;                                  // 0x03D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C75[0x2];                                     // 0x03D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RestrictSelfDeadTimer;                             // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FEnemyRepopLevelInfo> EnemyRepopLevelInfoList;                           // 0x03D8(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, bool>                       MUniqueBrainCrashPlayedList;                       // 0x0428(0x0050)(Edit, NativeAccessSpecifierPrivate)
	uint32                                        MUpdateEnemyCount;                                 // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        MEnemyCountMax;                                    // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               MMovingList;                                       // 0x0480(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EnemyMovingCount;                                  // 0x0490(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C76[0x4];                                     // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharacterBase*>               BrainCrashTargetList;                              // 0x0498(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ARSCharacterBase*>               CurrentTargetList;                                 // 0x04A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExecBrainCrash;                                   // 0x04B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastEnableBc;                                     // 0x04B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDisplayCursor;                                  // 0x04BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C77[0x5];                                     // 0x04BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharacterBase*>               MNeedCheckCutList;                                 // 0x04C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MCanPlayCutScene;                                  // 0x04D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C78[0x7];                                     // 0x04D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBrainCrashCandidate(class ARSCharacterBase* AddChara);
	void AddEnemyBossList(class AActor* AddEnemy);
	void AddEnemyList(class ARSCharacterBase* AddEnemy);
	void AddEnemyRepopLevelInfoList(class FName Param_Name, const struct FEnemyRepopLevelInfo& EnemyRepopLevelInfo);
	void AddMovingList(class ARSCharacterBase* AddCharacter);
	void AllEnemyTickStop();
	bool CanUpdateEnemyNative();
	bool CheckRepopCharaInListNative(class FName CharaUniqueId, int32 GroupID);
	void ClearEnemyRepopLevelInfoList();
	void DebugLog(const class FString& LogString);
	void DisableEnemyIgnoreDamage(ECharacterIgnoreDamage SetFlag);
	void DisableEnemyIgnoreDamageAll();
	void EnableEnemyIgnoreDamage(ECharacterIgnoreDamage SetFlag);
	void EnableEnemyIgnoreDamageAll();
	bool EnableUniqueBrainCrashPlayedList(class FName Param_Name);
	void EntryRepopNative(float RepopTimeBase, float Range, float Probability, const class FString& ClassBpPath, const struct FVector& InitPos, float MoveArea, class FName LevelName, int32 Group, int32 SubGroup, class FName UniqueId, class FName Level, int32 DropId, class ARSCharacterBase* RepopTarget);
	bool FindEnemyRepopLevelInfoList(class FName Param_Name, struct FEnemyRepopLevelInfo* EnemyRepopLevelInfo);
	void GetActorLevelAreaID(const class AActor* Actor, int32* LocationId, int32* AreaId);
	class FName GetActorLevelName(const class AActor* Actor);
	TArray<class ARSCharacterBase*> GetBrainCrashCandidateList();
	bool GetCanPlayCutSceneFromNative();
	TArray<class AActor*> GetEnemyBossList();
	TArray<class AActor*> GetEnemyBossListByLevelName(const class FName LevelName);
	int32 GetEnemyBossNumByLevelName(const class FName LevelName);
	class UClass* GetEnemyClass(const class FString& Path);
	TArray<class ARSCharacterBase*> GetEnemyList();
	TArray<class AActor*> GetEnemyListByLevelName(const class FName LevelName);
	TArray<class ARSCharacterBase*> GetEnemyListRef();
	int32 GetEnemyNumByLevelName(const class FName LevelName);
	TMap<class FName, struct FEnemyRepopLevelInfo> GetEnemyRepopLevelInfoList();
	class AActor* GetTickEnableTargetActor();
	struct FVector GetTickEnableTargetLocation();
	TMap<class FName, bool> GetUniqueBrainCrashPlayedList();
	void IncrementUpdateEnemyNative();
	bool IsBattleCourtMortNative();
	int32 IsEntryBrainCrashCandidate(class ARSCharacterBase* FindChara);
	bool IsStealthSeeFlagNative();
	bool IsUniqueBrainCrashPlayed(class FName Param_Name);
	bool MakeEnemyRepopLevelInfoList(const TMap<class FName, struct FEnemyRepopLevelInfo>& _srcList);
	bool MakeUniqueBrainCrashPlayedList(const TMap<class FName, bool>& SrcList);
	void NotifyPlayerDead();
	bool PreUpdateEnemyTickEnable(class AActor* Enemy, class AActor* Player, float OutRange);
	void RegisterNeedCheckCutActor(class ARSCharacterBase* _registerActor);
	void RemoveEnemyRepopLevelInfoList(class FName Param_Name);
	bool RepopCheckInsideCameraNative(const struct FVector& MyPos);
	bool RepopSpawn_FromNative(const struct FEnemyRepopInfo& EnemyRepopInfo, int32 Group, int32 SubGroup);
	bool RepopUpdateNative(class FName NowLocationName, bool IsInScene, float DeltaSeconds);
	void ResetUniqueBrainCrashPlayedList();
	void ResetUpdateEnemyNative();
	class ARSCharacterBase* SelectBrainCrashCharacter_Native();
	bool SetBrainCrashHUDTarget_Window(class ARSCharacterBase* TargetChara, bool EnablePlayer);
	void SetEnemyIgnoreDamageFlag(int32 Param_Flags);
	void SetMaxMovingCount(int32 Count);
	void SetRepopExtendInfoToActor(const struct FEnemyRepopExtendInfo& EnemyRepopExtendInfo, bool& IsIgnoreRestrictAttackOther, bool& IsIgnoreAllowance, bool& IsNoCheckCaptureArea, bool& IsChangeSearchAngle, float& ChangeSearchAngle, bool& IsAlwayChangeSearchAngle, bool& IsChangeSearchRange, float& ChangeSearchRange, bool& IsAlwayChangeSearchRange, bool& IsChangeSensingAngle, float& ChangeSensingAngle, bool& IsAlwaySensingAngle, bool& IsChangeCaptureArea, float& ChangeCaptureArea, bool& IsAlwayCaptureArea);
	void SetRepopExtendInfoToList(struct FEnemyRepopExtendInfo& EnemyRepopExtendInfo, bool IsIgnoreRestrictAttackOther, bool IsIgnoreAllowance, bool IsNoCheckCaptureArea, bool IsChangeSearchAngle, float ChangeSearchAngle, bool IsAlwayChangeSearchAngle, bool IsChangeSearchRange, float ChangeSearchRange, bool IsAlwayChangeSearchRange, bool IsChangeSensingAngle, float ChangeSensingAngle, bool IsAlwaySensingAngle, bool IsChangeCaptureArea, float ChangeCaptureArea, bool IsAlwayCaptureArea);
	bool SetRepopExtendInList_FromNative(struct FEnemyRepopExtendInfo& EnemyRepopExtendInfo, class ARSCharacterBase* RepopTarget);
	void SetRestrictSelfDead(bool _RestrictSelfDead, float _RestrictTime);
	void SetSelectParameter(const TArray<float>& DistList, const TArray<int32>& DistPointList, const TArray<float>& AngleList, const TArray<int32>& AnglePointList);
	void SetSpawnWaitDelay(class ARSCharacterBase* Chara, float DelayTime);
	void SetTickEnableTargetDroneActor(class AActor* DroneActor);
	void SetTickEnableTargetDroneMesh(class UMeshComponent* DroneMesh);
	bool SimulatorCancelMission();
	void StopEnemyAll_FromNative();
	void SubBrainCrashCandidate(class ARSCharacterBase* SubChara);
	void SubEnemyBossList(class AActor* SubEnemy);
	void SubEnemyList(class ARSCharacterBase* SubEnemy);
	void SubMovingList(class ARSCharacterBase* SubCharacter);
	void UnregisterNeedCheckCutActor(class ARSCharacterBase* _unregisterActor);
	void UpdateBrainCrashTarget_Native();
	void UpdateCheckCut();
	void UpdateEnemyTickEnable(class AActor* Enemy, class AActor* Player, float Range, float Height, float OutRange);
	void UpdateOutRangeFade(float OutRange);
	void UpdateRestrictSelfDead(float _DeltaSec);
	class ARSCharacterBase* UsableBrainCrashLockTarget_Native(class ARSCharacterBase* Player);

	int32 CalcBrainCrashScore(float* OutDist, float* OutAngle, const class ARSCharacterBase* ChkChara, const struct FVector& ChkPos, const struct FVector& ChkDir, float LongestDist) const;
	int32 CalcRelationScore(const struct FVector& CameraPos, const struct FVector& CameraDir, const struct FVector& CheckPos, float PossibleBrainCrashRange) const;
	bool CanAddMovingList(const class ARSCharacterBase* NewCharacter) const;
	bool CanPlayCutSceneEnemy() const;
	int32 GetBrainCrashCandidateNum() const;
	int32 GetEnemyIgnoreDamageFlag() const;
	int32 GetEnemyNum() const;
	bool IsEnemyIgnoreDamage(ECharacterIgnoreDamage CheckFlag) const;
	bool IsRestrictSelfDead() const;
	TArray<class ARSCharacterBase*> SelectBrainCrashMultiTarget(const struct FVector& ChkPos, const struct FVector& ChkDir) const;
	class ARSCharacterBase* SelectBrainCrashTarget(const struct FVector& ChkPos, const struct FVector& ChkDir) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyManager">();
	}
	static class AEnemyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyManager>();
	}
};
static_assert(alignof(AEnemyManager) == 0x000008, "Wrong alignment on AEnemyManager");
static_assert(sizeof(AEnemyManager) == 0x0004D8, "Wrong size on AEnemyManager");
static_assert(offsetof(AEnemyManager, MTickEnableTargetDroneActor) == 0x000238, "Member 'AEnemyManager::MTickEnableTargetDroneActor' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MTickEnableTargetDroneMesh) == 0x000240, "Member 'AEnemyManager::MTickEnableTargetDroneMesh' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MbIsStealthSeeFlag) == 0x000248, "Member 'AEnemyManager::MbIsStealthSeeFlag' has a wrong offset!");
static_assert(offsetof(AEnemyManager, SelectParamDistList) == 0x000250, "Member 'AEnemyManager::SelectParamDistList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, SelectParamDistPointList) == 0x000260, "Member 'AEnemyManager::SelectParamDistPointList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, SelectParamAngleList) == 0x000270, "Member 'AEnemyManager::SelectParamAngleList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, SelectParamAnglePointList) == 0x000280, "Member 'AEnemyManager::SelectParamAnglePointList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, OnEnemyListNative) == 0x0002E8, "Member 'AEnemyManager::OnEnemyListNative' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyList) == 0x0002F8, "Member 'AEnemyManager::EnemyList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyListByLevel) == 0x000308, "Member 'AEnemyManager::EnemyListByLevel' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyBossList) == 0x000358, "Member 'AEnemyManager::EnemyBossList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyBossListByLevel) == 0x000368, "Member 'AEnemyManager::EnemyBossListByLevel' has a wrong offset!");
static_assert(offsetof(AEnemyManager, BrainCrashCandidateList) == 0x0003B8, "Member 'AEnemyManager::BrainCrashCandidateList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, _enemyIgnoreDamageFlag) == 0x0003C8, "Member 'AEnemyManager::_enemyIgnoreDamageFlag' has a wrong offset!");
static_assert(offsetof(AEnemyManager, RestrictSelfDead) == 0x0003D1, "Member 'AEnemyManager::RestrictSelfDead' has a wrong offset!");
static_assert(offsetof(AEnemyManager, RestrictSelfDeadTimer) == 0x0003D4, "Member 'AEnemyManager::RestrictSelfDeadTimer' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyRepopLevelInfoList) == 0x0003D8, "Member 'AEnemyManager::EnemyRepopLevelInfoList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MUniqueBrainCrashPlayedList) == 0x000428, "Member 'AEnemyManager::MUniqueBrainCrashPlayedList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MUpdateEnemyCount) == 0x000478, "Member 'AEnemyManager::MUpdateEnemyCount' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MEnemyCountMax) == 0x00047C, "Member 'AEnemyManager::MEnemyCountMax' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MMovingList) == 0x000480, "Member 'AEnemyManager::MMovingList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, EnemyMovingCount) == 0x000490, "Member 'AEnemyManager::EnemyMovingCount' has a wrong offset!");
static_assert(offsetof(AEnemyManager, BrainCrashTargetList) == 0x000498, "Member 'AEnemyManager::BrainCrashTargetList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, CurrentTargetList) == 0x0004A8, "Member 'AEnemyManager::CurrentTargetList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, bExecBrainCrash) == 0x0004B8, "Member 'AEnemyManager::bExecBrainCrash' has a wrong offset!");
static_assert(offsetof(AEnemyManager, bLastEnableBc) == 0x0004B9, "Member 'AEnemyManager::bLastEnableBc' has a wrong offset!");
static_assert(offsetof(AEnemyManager, bIsDisplayCursor) == 0x0004BA, "Member 'AEnemyManager::bIsDisplayCursor' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MNeedCheckCutList) == 0x0004C0, "Member 'AEnemyManager::MNeedCheckCutList' has a wrong offset!");
static_assert(offsetof(AEnemyManager, MCanPlayCutScene) == 0x0004D0, "Member 'AEnemyManager::MCanPlayCutScene' has a wrong offset!");

// Class BattlePrototype.SequencerFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class USequencerFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetGhostTrailInfo(class ARSLevelSequenceActor* Sequencer, class UObject* GhostTrailObject, TArray<struct FGhostTrailInfo>* GhostTrailInfo);
	static bool IsSequencerSpawner(class ARSLevelSequenceActor* Sequencer, class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerFunctionLibrary">();
	}
	static class USequencerFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequencerFunctionLibrary>();
	}
};
static_assert(alignof(USequencerFunctionLibrary) == 0x000008, "Wrong alignment on USequencerFunctionLibrary");
static_assert(sizeof(USequencerFunctionLibrary) == 0x000028, "Wrong size on USequencerFunctionLibrary");

// Class BattlePrototype.DebuggingItemBase
// 0x0098 (0x02C8 - 0x0230)
class ADebuggingItemBase : public AActor
{
public:
	int32                                         Priority;                                          // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C98[0x4];                                     // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   HashName;                                          // 0x0238(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	class FText                                   DispName;                                          // 0x0250(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInFocus;                                         // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLostFocus;                                       // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeyLeft;                                         // 0x0288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeyRight;                                        // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKeySelect;                                       // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C99[0x10];                                    // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* CreateWidgetBP();
	void DestroyItem(bool DestroyChild);
	void Dump(int32 InIndent);
	class ADebuggingItemBase* SearchItem(const class FText& InHashName, bool InRecursive, bool InIgnoreCase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemBase">();
	}
	static class ADebuggingItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemBase>();
	}
};
static_assert(alignof(ADebuggingItemBase) == 0x000008, "Wrong alignment on ADebuggingItemBase");
static_assert(sizeof(ADebuggingItemBase) == 0x0002C8, "Wrong size on ADebuggingItemBase");
static_assert(offsetof(ADebuggingItemBase, Priority) == 0x000230, "Member 'ADebuggingItemBase::Priority' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, HashName) == 0x000238, "Member 'ADebuggingItemBase::HashName' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, DispName) == 0x000250, "Member 'ADebuggingItemBase::DispName' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnInFocus) == 0x000268, "Member 'ADebuggingItemBase::OnInFocus' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnLostFocus) == 0x000278, "Member 'ADebuggingItemBase::OnLostFocus' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnKeyLeft) == 0x000288, "Member 'ADebuggingItemBase::OnKeyLeft' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnKeyRight) == 0x000298, "Member 'ADebuggingItemBase::OnKeyRight' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBase, OnKeySelect) == 0x0002A8, "Member 'ADebuggingItemBase::OnKeySelect' has a wrong offset!");

// Class BattlePrototype.UITitleFirstConfirmChildBase
// 0x0018 (0x03A0 - 0x0388)
class UUITitleFirstConfirmChildBase : public UUIBase
{
public:
	uint8                                         Pad_1C9B[0x10];                                    // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSTitleManager*                        TitleManager;                                      // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirmChildBase">();
	}
	static class UUITitleFirstConfirmChildBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirmChildBase>();
	}
};
static_assert(alignof(UUITitleFirstConfirmChildBase) == 0x000008, "Wrong alignment on UUITitleFirstConfirmChildBase");
static_assert(sizeof(UUITitleFirstConfirmChildBase) == 0x0003A0, "Wrong size on UUITitleFirstConfirmChildBase");
static_assert(offsetof(UUITitleFirstConfirmChildBase, TitleManager) == 0x000398, "Member 'UUITitleFirstConfirmChildBase::TitleManager' has a wrong offset!");

// Class BattlePrototype.UITitleFirstConfirmChildText
// 0x0040 (0x03E0 - 0x03A0)
class UUITitleFirstConfirmChildText final : public UUITitleFirstConfirmChildBase
{
public:
	uint8                                         Pad_1C9C[0x40];                                    // 0x03A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextMain, class UREDTextBlock* TextTitle, class UREDTextBlock* TextHelp, class UREDScrollBoxSimple* ScrollBox, class UUITitleFirstConfirmSelect2* UiSelect2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirmChildText">();
	}
	static class UUITitleFirstConfirmChildText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirmChildText>();
	}
};
static_assert(alignof(UUITitleFirstConfirmChildText) == 0x000008, "Wrong alignment on UUITitleFirstConfirmChildText");
static_assert(sizeof(UUITitleFirstConfirmChildText) == 0x0003E0, "Wrong size on UUITitleFirstConfirmChildText");

// Class BattlePrototype.SavePointBase
// 0x00B0 (0x02E0 - 0x0230)
class ASavePointBase final : public AActor
{
public:
	uint8                                         Pad_1C9D[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CollisionCapsuleComponent;                         // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionIconType                               ActionIconType;                                    // 0x0284(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9E[0x3];                                     // 0x0285(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIMapIconAdjust                       MapIconAdjust;                                     // 0x0288(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9F[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANpcShopBase*                           PairActor;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFitGround;                                       // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA0[0x27];                                    // 0x02B9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UChildActorComponent* GetChildActionIcon();
	void RegisterPairActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SavePointBase">();
	}
	static class ASavePointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASavePointBase>();
	}
};
static_assert(alignof(ASavePointBase) == 0x000008, "Wrong alignment on ASavePointBase");
static_assert(sizeof(ASavePointBase) == 0x0002E0, "Wrong size on ASavePointBase");
static_assert(offsetof(ASavePointBase, SkeletalMeshComponent) == 0x000240, "Member 'ASavePointBase::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ASavePointBase, ShowBoxComponent) == 0x000248, "Member 'ASavePointBase::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(ASavePointBase, CollisionCapsuleComponent) == 0x000250, "Member 'ASavePointBase::CollisionCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ASavePointBase, EventBoxComponent) == 0x000258, "Member 'ASavePointBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(ASavePointBase, MakeEventActorClass) == 0x000260, "Member 'ASavePointBase::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ASavePointBase, MakeEventActor) == 0x000268, "Member 'ASavePointBase::MakeEventActor' has a wrong offset!");
static_assert(offsetof(ASavePointBase, ChildActionIcon) == 0x000270, "Member 'ASavePointBase::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(ASavePointBase, ActionIconWorldPositionOffset) == 0x000278, "Member 'ASavePointBase::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(ASavePointBase, ActionIconType) == 0x000284, "Member 'ASavePointBase::ActionIconType' has a wrong offset!");
static_assert(offsetof(ASavePointBase, MapIconAdjust) == 0x000288, "Member 'ASavePointBase::MapIconAdjust' has a wrong offset!");
static_assert(offsetof(ASavePointBase, PairActor) == 0x0002B0, "Member 'ASavePointBase::PairActor' has a wrong offset!");
static_assert(offsetof(ASavePointBase, IsFitGround) == 0x0002B8, "Member 'ASavePointBase::IsFitGround' has a wrong offset!");

// Class BattlePrototype.DebuggingItemGroup
// 0x0008 (0x02D0 - 0x02C8)
class ADebuggingItemGroup : public ADebuggingItemBase
{
public:
	uint8                                         Pad_1CA1[0x8];                                     // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterChild(class ADebuggingItemBase* InItem);
	void UnregisterChildFromHashName(const class FText& InHashName);
	void UnregisterChildFromItem(class ADebuggingItemBase* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemGroup">();
	}
	static class ADebuggingItemGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemGroup>();
	}
};
static_assert(alignof(ADebuggingItemGroup) == 0x000008, "Wrong alignment on ADebuggingItemGroup");
static_assert(sizeof(ADebuggingItemGroup) == 0x0002D0, "Wrong size on ADebuggingItemGroup");

// Class BattlePrototype.DebuggingItemAchievementGroup
// 0x0038 (0x0308 - 0x02D0)
class ADebuggingItemAchievementGroup final : public ADebuggingItemGroup
{
public:
	uint8                                         Pad_1CA2[0x4];                                     // 0x02D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADebuggingItemStringArray> StringList;                                        // 0x02D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemLabel>     Label;                                             // 0x02DC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     Unlock;                                            // 0x02E4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     Lock;                                              // 0x02EC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CA3[0x4];                                     // 0x02F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int64>                                 EnumValueList;                                     // 0x02F8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangeSelected(const class ADebuggingItemStringArray* Item);
	void OnExexLock(const class ADebuggingItemEvent* Item);
	void OnExexUnlock(const class ADebuggingItemEvent* Item);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemAchievementGroup">();
	}
	static class ADebuggingItemAchievementGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemAchievementGroup>();
	}
};
static_assert(alignof(ADebuggingItemAchievementGroup) == 0x000008, "Wrong alignment on ADebuggingItemAchievementGroup");
static_assert(sizeof(ADebuggingItemAchievementGroup) == 0x000308, "Wrong size on ADebuggingItemAchievementGroup");
static_assert(offsetof(ADebuggingItemAchievementGroup, StringList) == 0x0002D4, "Member 'ADebuggingItemAchievementGroup::StringList' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAchievementGroup, Label) == 0x0002DC, "Member 'ADebuggingItemAchievementGroup::Label' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAchievementGroup, Unlock) == 0x0002E4, "Member 'ADebuggingItemAchievementGroup::Unlock' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAchievementGroup, Lock) == 0x0002EC, "Member 'ADebuggingItemAchievementGroup::Lock' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAchievementGroup, EnumValueList) == 0x0002F8, "Member 'ADebuggingItemAchievementGroup::EnumValueList' has a wrong offset!");

// Class BattlePrototype.HPEventComponent
// 0x0010 (0x00D0 - 0x00C0)
class UHPEventComponent : public UActorComponent
{
public:
	TArray<struct FCharacterHPEventInfo>          HpEventInfos;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CheckHpEvent(class AActor* Actor, float PreHpRate, float PostHpRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HPEventComponent">();
	}
	static class UHPEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHPEventComponent>();
	}
};
static_assert(alignof(UHPEventComponent) == 0x000008, "Wrong alignment on UHPEventComponent");
static_assert(sizeof(UHPEventComponent) == 0x0000D0, "Wrong size on UHPEventComponent");
static_assert(offsetof(UHPEventComponent, HpEventInfos) == 0x0000C0, "Member 'UHPEventComponent::HpEventInfos' has a wrong offset!");

// Class BattlePrototype.UIShopTransfer
// 0x0030 (0x03B8 - 0x0388)
class UUIShopTransfer : public UUIBase
{
public:
	uint8                                         Pad_1CA4[0x30];                                    // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimBuy, class UWidgetAnimation* AnimSell, class UWidgetAnimation* AnimTrade, class UTextBlock* TextTransfer1, class UTextBlock* TextTransfer2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopTransfer">();
	}
	static class UUIShopTransfer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopTransfer>();
	}
};
static_assert(alignof(UUIShopTransfer) == 0x000008, "Wrong alignment on UUIShopTransfer");
static_assert(sizeof(UUIShopTransfer) == 0x0003B8, "Wrong size on UUIShopTransfer");

// Class BattlePrototype.DebuggingItemInt
// 0x0038 (0x0300 - 0x02C8)
class ADebuggingItemInt : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSliderSettingChanged;                            // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Max;                                               // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Step;                                              // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Value;                                             // 0x02F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CA5[0x8];                                     // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeyLeftFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void OnKeyRightFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void SetSliderSettings(int32 InMin, int32 InMax, int32 InStep);
	void SetValue(int32 InValue);

	int32 GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemInt">();
	}
	static class ADebuggingItemInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemInt>();
	}
};
static_assert(alignof(ADebuggingItemInt) == 0x000008, "Wrong alignment on ADebuggingItemInt");
static_assert(sizeof(ADebuggingItemInt) == 0x000300, "Wrong size on ADebuggingItemInt");
static_assert(offsetof(ADebuggingItemInt, OnChanged) == 0x0002C8, "Member 'ADebuggingItemInt::OnChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, OnSliderSettingChanged) == 0x0002D8, "Member 'ADebuggingItemInt::OnSliderSettingChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, Min) == 0x0002E8, "Member 'ADebuggingItemInt::Min' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, Max) == 0x0002EC, "Member 'ADebuggingItemInt::Max' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, Step) == 0x0002F0, "Member 'ADebuggingItemInt::Step' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInt, Value) == 0x0002F4, "Member 'ADebuggingItemInt::Value' has a wrong offset!");

// Class BattlePrototype.HelpTutorialData
// 0x0018 (0x0040 - 0x0028)
class UHelpTutorialData final : public UObject
{
public:
	class UHelpTutorialDBAsset*                   HelptutorialDataAsset_;                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FHelpListSortParam>             HelpSortList_;                                     // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetHelpDataAsset(TMap<EHelpTutorial, struct FHelpDBDataCell>* ReturnHelpMap);
	bool GetHelpDataCellFromAsset(EHelpTutorial HelpID, struct FHelpDBDataCell* ReturnCell);
	bool GetHelpDataIndexFromAsset(EHelpTutorial HelpID, int32* DataIndex);
	class UHelpTutorialDBAsset* GetHelpTutorialDataAsset();
	void GetMiniHelpDataAsset(TMap<EHelpTutorial, struct FMiniHelpRowDataCell>* ReturnMiniHelpMap);
	bool GetMiniHelpDataCellFromAsset(EHelpTutorial HelpID, struct FMiniHelpRowDataCell* ReturnCell);
	bool GetMiniHelpDataIndexFromAsset(EHelpTutorial HelpID, int32* DataIndex);
	void GetTutorialDataAsset(TMap<class FName, struct FTutorialDBDataCell>* ReturnTutorialMap);
	bool GetTutorialDataCellFromAsset(class FName TutorialID, struct FTutorialDBDataCell* ReturnCell);
	bool GetTutorialDataIndexFromAsset(class FName TutorialID, int32* DataIndex);
	bool LoadDataAsset(const class FString& DtPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpTutorialData">();
	}
	static class UHelpTutorialData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpTutorialData>();
	}
};
static_assert(alignof(UHelpTutorialData) == 0x000008, "Wrong alignment on UHelpTutorialData");
static_assert(sizeof(UHelpTutorialData) == 0x000040, "Wrong size on UHelpTutorialData");
static_assert(offsetof(UHelpTutorialData, HelptutorialDataAsset_) == 0x000028, "Member 'UHelpTutorialData::HelptutorialDataAsset_' has a wrong offset!");
static_assert(offsetof(UHelpTutorialData, HelpSortList_) == 0x000030, "Member 'UHelpTutorialData::HelpSortList_' has a wrong offset!");

// Class BattlePrototype.DebuggingItemInt2
// 0x0008 (0x0308 - 0x0300)
class ADebuggingItemInt2 final : public ADebuggingItemInt
{
public:
	int32                                         Index_DebuggingItemInt2;                           // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CB3[0x4];                                     // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemInt2">();
	}
	static class ADebuggingItemInt2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemInt2>();
	}
};
static_assert(alignof(ADebuggingItemInt2) == 0x000008, "Wrong alignment on ADebuggingItemInt2");
static_assert(sizeof(ADebuggingItemInt2) == 0x000308, "Wrong size on ADebuggingItemInt2");
static_assert(offsetof(ADebuggingItemInt2, Index_DebuggingItemInt2) == 0x000300, "Member 'ADebuggingItemInt2::Index_DebuggingItemInt2' has a wrong offset!");

// Class BattlePrototype.UITitleFirstConfigVoiceLanguage
// 0x00F8 (0x0480 - 0x0388)
class UUITitleFirstConfigVoiceLanguage final : public UUIBase
{
public:
	uint8                                         Pad_1CB4[0xF8];                                    // 0x0388(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextDescription, class UTextBlock* TextVoiceLanguage, class USpacer* GuideSpacer);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsBack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfigVoiceLanguage">();
	}
	static class UUITitleFirstConfigVoiceLanguage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfigVoiceLanguage>();
	}
};
static_assert(alignof(UUITitleFirstConfigVoiceLanguage) == 0x000008, "Wrong alignment on UUITitleFirstConfigVoiceLanguage");
static_assert(sizeof(UUITitleFirstConfigVoiceLanguage) == 0x000480, "Wrong size on UUITitleFirstConfigVoiceLanguage");

// Class BattlePrototype.DebuggingItemBool
// 0x0020 (0x02E8 - 0x02C8)
class ADebuggingItemBool : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x02D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CB6[0xF];                                     // 0x02D9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeySelectFunc(const class ADebuggingItemBase* InItem, bool IsRepeat);
	void SetValue(bool InValue);

	bool GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemBool">();
	}
	static class ADebuggingItemBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemBool>();
	}
};
static_assert(alignof(ADebuggingItemBool) == 0x000008, "Wrong alignment on ADebuggingItemBool");
static_assert(sizeof(ADebuggingItemBool) == 0x0002E8, "Wrong size on ADebuggingItemBool");
static_assert(offsetof(ADebuggingItemBool, OnChanged) == 0x0002C8, "Member 'ADebuggingItemBool::OnChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemBool, Value) == 0x0002D8, "Member 'ADebuggingItemBool::Value' has a wrong offset!");

// Class BattlePrototype.DebuggingItemBool2
// 0x0008 (0x02F0 - 0x02E8)
class ADebuggingItemBool2 final : public ADebuggingItemBool
{
public:
	int32                                         Index_DebuggingItemBool2;                          // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CB8[0x4];                                     // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemBool2">();
	}
	static class ADebuggingItemBool2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemBool2>();
	}
};
static_assert(alignof(ADebuggingItemBool2) == 0x000008, "Wrong alignment on ADebuggingItemBool2");
static_assert(sizeof(ADebuggingItemBool2) == 0x0002F0, "Wrong size on ADebuggingItemBool2");
static_assert(offsetof(ADebuggingItemBool2, Index_DebuggingItemBool2) == 0x0002E8, "Member 'ADebuggingItemBool2::Index_DebuggingItemBool2' has a wrong offset!");

// Class BattlePrototype.LoadingInterludeLatentActor
// 0x0000 (0x0230 - 0x0230)
class ALoadingInterludeLatentActor final : public AActor
{
public:
	void FinishWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingInterludeLatentActor">();
	}
	static class ALoadingInterludeLatentActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoadingInterludeLatentActor>();
	}
};
static_assert(alignof(ALoadingInterludeLatentActor) == 0x000008, "Wrong alignment on ALoadingInterludeLatentActor");
static_assert(sizeof(ALoadingInterludeLatentActor) == 0x000230, "Wrong size on ALoadingInterludeLatentActor");

// Class BattlePrototype.UIVisionSimulatorStartEnd
// 0x00B8 (0x0440 - 0x0388)
class UUIVisionSimulatorStartEnd : public UUIBase
{
public:
	uint8                                         Pad_1CB9[0x48];                                    // 0x0388(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTextBlock*>                     TextProgressHyphenList;                            // 0x03D0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomSwithRateLittle;                             // 0x03E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomSwithRateBig;                                // 0x03E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FixedSwithLongSecond;                              // 0x03E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CBA[0x4];                                     // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDatabaseManager*                       M_pDatabaseManager;                                // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CBB[0x48];                                    // 0x03F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimBar, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimStartDefault, class UWidgetAnimation* AnimStartOut, class UWidgetAnimation* AnimEndDefault, class UWidgetAnimation* AnimEndOut, class UTextBlock* TextStartEnd, class UTextBlock* TextFileName);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVisionSimulatorStartEnd">();
	}
	static class UUIVisionSimulatorStartEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVisionSimulatorStartEnd>();
	}
};
static_assert(alignof(UUIVisionSimulatorStartEnd) == 0x000008, "Wrong alignment on UUIVisionSimulatorStartEnd");
static_assert(sizeof(UUIVisionSimulatorStartEnd) == 0x000440, "Wrong size on UUIVisionSimulatorStartEnd");
static_assert(offsetof(UUIVisionSimulatorStartEnd, TextProgressHyphenList) == 0x0003D0, "Member 'UUIVisionSimulatorStartEnd::TextProgressHyphenList' has a wrong offset!");
static_assert(offsetof(UUIVisionSimulatorStartEnd, RandomSwithRateLittle) == 0x0003E0, "Member 'UUIVisionSimulatorStartEnd::RandomSwithRateLittle' has a wrong offset!");
static_assert(offsetof(UUIVisionSimulatorStartEnd, RandomSwithRateBig) == 0x0003E4, "Member 'UUIVisionSimulatorStartEnd::RandomSwithRateBig' has a wrong offset!");
static_assert(offsetof(UUIVisionSimulatorStartEnd, FixedSwithLongSecond) == 0x0003E8, "Member 'UUIVisionSimulatorStartEnd::FixedSwithLongSecond' has a wrong offset!");
static_assert(offsetof(UUIVisionSimulatorStartEnd, M_pDatabaseManager) == 0x0003F0, "Member 'UUIVisionSimulatorStartEnd::M_pDatabaseManager' has a wrong offset!");

// Class BattlePrototype.DebuggingItemInGameAchievementGroup
// 0x0090 (0x0360 - 0x02D0)
class ADebuggingItemInGameAchievementGroup final : public ADebuggingItemGroup
{
public:
	TArray<TWeakObjectPtr<class ADebuggingItemInt2>> IntList;                                           // 0x02D0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       IntReport;                                         // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> TradeBool;                                         // 0x02E8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> QuestBool;                                         // 0x02F8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> AttachmentBool;                                    // 0x0308(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> EnemyBool;                                         // 0x0318(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt2>      IntMoney;                                          // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecMoney;                                         // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> PresentBool;                                       // 0x0338(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAchievementManager*                    Manager;                                           // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAchievementParamDBAsset*               DBAsset;                                           // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CBC[0x8];                                     // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeBoolAttachment(const class ADebuggingItemBool* Item);
	void OnChangeBoolEnemy(const class ADebuggingItemBool* Item);
	void OnChangeBoolPresent(const class ADebuggingItemBool* Item);
	void OnChangeBoolQuest(const class ADebuggingItemBool* Item);
	void OnChangeBoolTrade(const class ADebuggingItemBool* Item);
	void OnChangeIntParam(const class ADebuggingItemInt* Item);
	void OnChangeReportCount(const class ADebuggingItemInt* Item);
	void OnEventChangeKins(const class ADebuggingItemEvent* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemInGameAchievementGroup">();
	}
	static class ADebuggingItemInGameAchievementGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemInGameAchievementGroup>();
	}
};
static_assert(alignof(ADebuggingItemInGameAchievementGroup) == 0x000008, "Wrong alignment on ADebuggingItemInGameAchievementGroup");
static_assert(sizeof(ADebuggingItemInGameAchievementGroup) == 0x000360, "Wrong size on ADebuggingItemInGameAchievementGroup");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, IntList) == 0x0002D0, "Member 'ADebuggingItemInGameAchievementGroup::IntList' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, IntReport) == 0x0002E0, "Member 'ADebuggingItemInGameAchievementGroup::IntReport' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, TradeBool) == 0x0002E8, "Member 'ADebuggingItemInGameAchievementGroup::TradeBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, QuestBool) == 0x0002F8, "Member 'ADebuggingItemInGameAchievementGroup::QuestBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, AttachmentBool) == 0x000308, "Member 'ADebuggingItemInGameAchievementGroup::AttachmentBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, EnemyBool) == 0x000318, "Member 'ADebuggingItemInGameAchievementGroup::EnemyBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, IntMoney) == 0x000328, "Member 'ADebuggingItemInGameAchievementGroup::IntMoney' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, ExecMoney) == 0x000330, "Member 'ADebuggingItemInGameAchievementGroup::ExecMoney' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, PresentBool) == 0x000338, "Member 'ADebuggingItemInGameAchievementGroup::PresentBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, Manager) == 0x000348, "Member 'ADebuggingItemInGameAchievementGroup::Manager' has a wrong offset!");
static_assert(offsetof(ADebuggingItemInGameAchievementGroup, DBAsset) == 0x000350, "Member 'ADebuggingItemInGameAchievementGroup::DBAsset' has a wrong offset!");

// Class BattlePrototype.EventAssetPoolComponent
// 0x0018 (0x00D8 - 0x00C0)
class UEventAssetPoolComponent : public UActorComponent
{
public:
	TArray<class UEventAsset*>                    Assets;                                            // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CBD[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UEventAsset* GetHandle(int32 HandleId);
	class UEventAsset* LoadAsset(const class FString& Path, bool Async);
	void UnloadAll();
	bool UnloadAsset(int32 HandleId);

	bool IsLoaded(int32 HandleId) const;
	bool IsLoadedAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAssetPoolComponent">();
	}
	static class UEventAssetPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAssetPoolComponent>();
	}
};
static_assert(alignof(UEventAssetPoolComponent) == 0x000008, "Wrong alignment on UEventAssetPoolComponent");
static_assert(sizeof(UEventAssetPoolComponent) == 0x0000D8, "Wrong size on UEventAssetPoolComponent");
static_assert(offsetof(UEventAssetPoolComponent, Assets) == 0x0000C0, "Member 'UEventAssetPoolComponent::Assets' has a wrong offset!");

// Class BattlePrototype.ShowDestinationDBAsset
// 0x0050 (0x0078 - 0x0028)
class UShowDestinationDBAsset final : public UObject
{
public:
	TMap<class FName, struct FShowDestinationDBDataCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationDBAsset">();
	}
	static class UShowDestinationDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowDestinationDBAsset>();
	}
};
static_assert(alignof(UShowDestinationDBAsset) == 0x000008, "Wrong alignment on UShowDestinationDBAsset");
static_assert(sizeof(UShowDestinationDBAsset) == 0x000078, "Wrong size on UShowDestinationDBAsset");
static_assert(offsetof(UShowDestinationDBAsset, DBMap) == 0x000028, "Member 'UShowDestinationDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.RSTickableManagerBase
// 0x0010 (0x0038 - 0x0028)
class URSTickableManagerBase : public UObject
{
public:
	uint8                                         Pad_1CC2[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSTickableManagerBase">();
	}
	static class URSTickableManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSTickableManagerBase>();
	}
};
static_assert(alignof(URSTickableManagerBase) == 0x000008, "Wrong alignment on URSTickableManagerBase");
static_assert(sizeof(URSTickableManagerBase) == 0x000038, "Wrong size on URSTickableManagerBase");

// Class BattlePrototype.UITutoOperation
// 0x0120 (0x04A8 - 0x0388)
class UUITutoOperation : public UUIBase
{
public:
	struct FVector2D                              baseOffset;                                        // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUITutoOperationParts>      M_pClassSelect;                                    // 0x0390(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           M_pPartsParent;                                    // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 OwnerActor;                                        // 0x03A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WorldOffset;                                       // 0x03A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC3[0xEC];                                    // 0x03B4(0x00EC)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pHudBase;                                        // 0x04A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeTutoOperation(class UREDRetainerBox* REDRetainerBox, class UImage* boximage);
	void InitializeTutoOperationList(int32 ListIndex, class UOverlay* OverlayData, class UUITutoOperationParts* Textleft);
	void OperationEnd();
	void Start(class FName HelpID);
	void UpdateStateTutoOperation(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutoOperation">();
	}
	static class UUITutoOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutoOperation>();
	}
};
static_assert(alignof(UUITutoOperation) == 0x000008, "Wrong alignment on UUITutoOperation");
static_assert(sizeof(UUITutoOperation) == 0x0004A8, "Wrong size on UUITutoOperation");
static_assert(offsetof(UUITutoOperation, baseOffset) == 0x000388, "Member 'UUITutoOperation::baseOffset' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, M_pClassSelect) == 0x000390, "Member 'UUITutoOperation::M_pClassSelect' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, M_pPartsParent) == 0x000398, "Member 'UUITutoOperation::M_pPartsParent' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, OwnerActor) == 0x0003A0, "Member 'UUITutoOperation::OwnerActor' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, WorldOffset) == 0x0003A8, "Member 'UUITutoOperation::WorldOffset' has a wrong offset!");
static_assert(offsetof(UUITutoOperation, M_pHudBase) == 0x0004A0, "Member 'UUITutoOperation::M_pHudBase' has a wrong offset!");

// Class BattlePrototype.SequencerMovieManagerController
// 0x0010 (0x0240 - 0x0230)
class ASequencerMovieManagerController : public AActor
{
public:
	TArray<class UManaTexture*>                   ManaTextureArray;                                  // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerMovieManagerController">();
	}
	static class ASequencerMovieManagerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerMovieManagerController>();
	}
};
static_assert(alignof(ASequencerMovieManagerController) == 0x000008, "Wrong alignment on ASequencerMovieManagerController");
static_assert(sizeof(ASequencerMovieManagerController) == 0x000240, "Wrong size on ASequencerMovieManagerController");
static_assert(offsetof(ASequencerMovieManagerController, ManaTextureArray) == 0x000230, "Member 'ASequencerMovieManagerController::ManaTextureArray' has a wrong offset!");

// Class BattlePrototype.AchievementManager
// 0x01E8 (0x0220 - 0x0038)
class UAchievementManager final : public URSTickableManagerBase
{
public:
	uint8                                         Pad_1CC5[0x10];                                    // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC6[0x10];                                    // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAchievementParam                      Parameter;                                         // 0x0060(0x0130)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC7[0x28];                                    // 0x0190(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AchievementQueue;                                  // 0x01B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           AchievementFailedQueue;                            // 0x01C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           AchievementUnclearableQueue;                       // 0x01D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CC8[0x8];                                     // 0x01E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OpenCompleted;                                     // 0x01F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CC9[0x20];                                    // 0x0200(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcquireSkill(EPlayerID PlayerId, EPlayerSkill Skill);
	void AddMoney(int32 Num);
	void BondsLvOver6(EPlayerID PlayerId, EPlayerID TargetID);
	void BrainCrashKillsSameTime(int32 Num);
	void ChaseAttack();
	void CheckAlreadyAchieved();
	void CheckAlreadyAchievedAtTrial2(const bool IsTrial2SaveData);
	void CheckAlreadyAchievedAtTrial2ConvSaveData();
	void CheckCompleteSkill(EPlayerID PlayerId);
	void ClearBondsEp(EPlayerID PlayerId, EPlayerID TargetID, int32 EpisodeNo);
	void ClearQuest(class FName QuestId);
	void CompleteEnemyLibrary();
	void DriveMaxBonus();
	void EndPsychicObjectBus();
	void EndStory(EPlayerID PlayerId);
	void EquipItems(EPlayerID PlayerId, class FName ItemId);
	void FinishLastBattle();
	void GatherAllMember();
	const class FString GetDebugString(int32 Idx);
	void GetItem(class FName ItemId);
	bool IsOpenAchievement(const EAchievementsType Type);
	void JustDodge();
	void Kill_UseBus(int32 Num);
	void KillEnemyDataForAchievement(class FName EnemyName, const struct FHCHitResult& HcResult, EPsychicObjectUniqueType PoType, bool bBrainCrashMulti);
	void KillEnemys(int32 Num);
	void KillsInBrainField(int32 Num);
	void MaMoRu();
	bool OpenAchievement(const EAchievementsType Type);
	bool OpenAchievementCheckProgress_EnemyKill();
	void PlayVoice(const class FString& CueName);
	void Present(EPlayerID PlayerId, EPlayerID TargetID, class FName ItemId);
	void Protected();
	void QueryAchievements();
	void RegisterOpenAchievement(const EAchievementsType Type);
	void Resuscitated();
	void ResuscitateFollow();
	void SasHologram();
	void StartPsychicObjectBus();
	void StartStory(EPlayerID PlayerId);
	void SuohIncident(EPlayerID PlayerId);
	void SupportedInBrainField();
	void TimeoverInBF();
	void TradeItem(class FName ItemId);
	void Use4CVinCombo();
	void UseBrainCrash();
	void UseCombinationVision(EPlayerID PlayerId, EPlayerID VisionCharID);
	void UseDrive();
	void UsePKObject();
	void UseSas();
	void WatchOpeningMovie();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementManager">();
	}
	static class UAchievementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementManager>();
	}
};
static_assert(alignof(UAchievementManager) == 0x000008, "Wrong alignment on UAchievementManager");
static_assert(sizeof(UAchievementManager) == 0x000220, "Wrong size on UAchievementManager");
static_assert(offsetof(UAchievementManager, _gameInstance) == 0x000048, "Member 'UAchievementManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(UAchievementManager, Parameter) == 0x000060, "Member 'UAchievementManager::Parameter' has a wrong offset!");
static_assert(offsetof(UAchievementManager, AchievementQueue) == 0x0001B8, "Member 'UAchievementManager::AchievementQueue' has a wrong offset!");
static_assert(offsetof(UAchievementManager, AchievementFailedQueue) == 0x0001C8, "Member 'UAchievementManager::AchievementFailedQueue' has a wrong offset!");
static_assert(offsetof(UAchievementManager, AchievementUnclearableQueue) == 0x0001D8, "Member 'UAchievementManager::AchievementUnclearableQueue' has a wrong offset!");
static_assert(offsetof(UAchievementManager, OpenCompleted) == 0x0001F0, "Member 'UAchievementManager::OpenCompleted' has a wrong offset!");

// Class BattlePrototype.AchievementUtility
// 0x0000 (0x0028 - 0x0028)
class UAchievementUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AcquireSkill(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerSkill Skill);
	static void AddMoney(const class UObject* WorldContextObject, int32 Num);
	static void BondsLvOver6(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID TargetID);
	static void BrainCrashKillsSameTime(const class UObject* WorldContextObject, int32 Num);
	static void ChaseAttack(const class UObject* WorldContextObject);
	static void CheckCompleteSkill(const class UObject* WorldContextObject, EPlayerID PlayerId);
	static void Clear(const class UObject* WorldContextObject);
	static void ClearBondsEp(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID TargetID, int32 EpisodeNo);
	static void ClearQuest(const class UObject* WorldContextObject, class FName QuestId);
	static void CompleteEnemyLibrary(const class UObject* WorldContextObject);
	static void DriveMaxBonus(const class UObject* WorldContextObject);
	static void EndPsychicObjectBus(const class UObject* WorldContextObject);
	static void EndStory(const class UObject* WorldContextObject, EPlayerID PlayerId);
	static void EquipItems(const class UObject* WorldContextObject, EPlayerID PlayerId, class FName ItemId);
	static void FinishLastBattle(const class UObject* WorldContextObject);
	static void GatherAllMember(const class UObject* WorldContextObject);
	static void GetItem(const class UObject* WorldContextObject, class FName ItemId);
	static void JustDodge(const class UObject* WorldContextObject);
	static void Kill_UseBus(const class UObject* WorldContextObject, int32 Num);
	static void KillEnemyDataForAchievement(const class UObject* WorldContextObject, class FName EnemyName, const struct FHCHitResult& HcResult, EPsychicObjectUniqueType PoType, bool bBrainCrashMulti);
	static void KillEnemys(const class UObject* WorldContextObject, int32 Num);
	static void KillsInBrainField(const class UObject* WorldContextObject, int32 Num);
	static void MaMoRu(const class UObject* WorldContextObject);
	static void PlayVoice(const class UObject* WorldContextObject, const class FString& CueName);
	static void Present(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID TargetID, class FName ItemId);
	static void Protected(const class UObject* WorldContextObject);
	static void Resuscitated(const class UObject* WorldContextObject);
	static void ResuscitateFollow(const class UObject* WorldContextObject);
	static void SasHologram(const class UObject* WorldContextObject);
	static void StartPsychicObjectBus(const class UObject* WorldContextObject);
	static void StartStory(const class UObject* WorldContextObject, EPlayerID PlayerId);
	static void SuohIncident(const class UObject* WorldContextObject, EPlayerID PlayerId);
	static void SupportedInBrainField(const class UObject* WorldContextObject);
	static void TimeoverInBF(const class UObject* WorldContextObject);
	static void TradeItem(const class UObject* WorldContextObject, class FName ItemId);
	static void Use4CVinCombo(const class UObject* WorldContextObject);
	static void UseBrainCrash(const class UObject* WorldContextObject);
	static void UseCombinationVision(const class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID VisionCharID);
	static void UseDrive(const class UObject* WorldContextObject);
	static void UsePKObject(const class UObject* WorldContextObject);
	static void UseSas(const class UObject* WorldContextObject);
	static void WatchOpeningMovie(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementUtility">();
	}
	static class UAchievementUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementUtility>();
	}
};
static_assert(alignof(UAchievementUtility) == 0x000008, "Wrong alignment on UAchievementUtility");
static_assert(sizeof(UAchievementUtility) == 0x000028, "Wrong size on UAchievementUtility");

// Class BattlePrototype.ArrangeItemStageManager
// 0x0020 (0x0048 - 0x0028)
class UArrangeItemStageManager final : public UObject
{
public:
	TArray<TWeakObjectPtr<class AArrangeItemBase>> ArrangeItems;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AArrangeItemBase>> UnvisivleArrangeItemsInEvent;                      // 0x0038(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChangeVisibleActorInEvent(const bool IsVisible);
	class AArrangeItemBase* GetArrangeItem(const class FString& ID);
	void Initialize(const class UObject* WorldContextObject);
	void RegisterArrangeItem(class AArrangeItemBase* ArrangeItem);
	void SetVisible(const bool IsVisible, const int32 LevelID, const int32 GroupID);
	void UnregisterArrangeItem(class AArrangeItemBase* ArrangeItem);
	void UnregisterArrangeItemAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemStageManager">();
	}
	static class UArrangeItemStageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrangeItemStageManager>();
	}
};
static_assert(alignof(UArrangeItemStageManager) == 0x000008, "Wrong alignment on UArrangeItemStageManager");
static_assert(sizeof(UArrangeItemStageManager) == 0x000048, "Wrong size on UArrangeItemStageManager");
static_assert(offsetof(UArrangeItemStageManager, ArrangeItems) == 0x000028, "Member 'UArrangeItemStageManager::ArrangeItems' has a wrong offset!");
static_assert(offsetof(UArrangeItemStageManager, UnvisivleArrangeItemsInEvent) == 0x000038, "Member 'UArrangeItemStageManager::UnvisivleArrangeItemsInEvent' has a wrong offset!");

// Class BattlePrototype.DriveRendererParameter
// 0x0050 (0x0080 - 0x0030)
class UDriveRendererParameter final : public UDataAsset
{
public:
	struct FLinearColor                           BgEdgeColorInner;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BgEdgeColorOuter;                                  // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeColorShift;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeLength;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeLengthMin;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeSmooth;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeEdgeThresholdNormal;                         // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BgEdgeEdgeThresholdLuminance;                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VignetteIntensity;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VignetteRange;                                     // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTime;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleOnPPStartDelay;                              // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleOffPPStartDelay;                             // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE2[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DriveRendererParameter">();
	}
	static class UDriveRendererParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDriveRendererParameter>();
	}
};
static_assert(alignof(UDriveRendererParameter) == 0x000008, "Wrong alignment on UDriveRendererParameter");
static_assert(sizeof(UDriveRendererParameter) == 0x000080, "Wrong size on UDriveRendererParameter");
static_assert(offsetof(UDriveRendererParameter, BgEdgeColorInner) == 0x000030, "Member 'UDriveRendererParameter::BgEdgeColorInner' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeColorOuter) == 0x000040, "Member 'UDriveRendererParameter::BgEdgeColorOuter' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeColorShift) == 0x000050, "Member 'UDriveRendererParameter::BgEdgeColorShift' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeLength) == 0x000054, "Member 'UDriveRendererParameter::BgEdgeLength' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeLengthMin) == 0x000058, "Member 'UDriveRendererParameter::BgEdgeLengthMin' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeSmooth) == 0x00005C, "Member 'UDriveRendererParameter::BgEdgeSmooth' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeEdgeThresholdNormal) == 0x000060, "Member 'UDriveRendererParameter::BgEdgeEdgeThresholdNormal' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BgEdgeEdgeThresholdLuminance) == 0x000064, "Member 'UDriveRendererParameter::BgEdgeEdgeThresholdLuminance' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, VignetteIntensity) == 0x000068, "Member 'UDriveRendererParameter::VignetteIntensity' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, VignetteRange) == 0x00006C, "Member 'UDriveRendererParameter::VignetteRange' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, TransitionTime) == 0x000070, "Member 'UDriveRendererParameter::TransitionTime' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BattleOnPPStartDelay) == 0x000074, "Member 'UDriveRendererParameter::BattleOnPPStartDelay' has a wrong offset!");
static_assert(offsetof(UDriveRendererParameter, BattleOffPPStartDelay) == 0x000078, "Member 'UDriveRendererParameter::BattleOffPPStartDelay' has a wrong offset!");

// Class BattlePrototype.AchievementParamDBAsset
// 0x0258 (0x0280 - 0x0028)
class UAchievementParamDBAsset final : public UObject
{
public:
	TMap<EPlayerID, struct FAchievementPresentItem> PresentItemListM;                                  // 0x0028(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EPlayerID, struct FAchievementPresentItem> PresentItemListF;                                  // 0x0078(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	int32                                         PresentItemTotal;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CE3[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AttachmentItemList;                                // 0x00D0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           TradeItemList;                                     // 0x00E0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           CostumeEquipItemList;                              // 0x00F0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           BakiHeadItemList;                                  // 0x0100(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         BoredomVoiceList;                                  // 0x0110(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           QuestList;                                         // 0x0120(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPlayerID, int32>                        bondsProgressM;                                    // 0x0130(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EPlayerID, int32>                        bondsProgressF;                                    // 0x0180(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           EnemyLibraryList;                                  // 0x01D0(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPlayerSkillCategory, struct FAchievementSkillItem> SkillListM;                                        // 0x01E0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EPlayerSkillCategory, struct FAchievementSkillItem> SkillListF;                                        // 0x0230(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementParamDBAsset">();
	}
	static class UAchievementParamDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementParamDBAsset>();
	}
};
static_assert(alignof(UAchievementParamDBAsset) == 0x000008, "Wrong alignment on UAchievementParamDBAsset");
static_assert(sizeof(UAchievementParamDBAsset) == 0x000280, "Wrong size on UAchievementParamDBAsset");
static_assert(offsetof(UAchievementParamDBAsset, PresentItemListM) == 0x000028, "Member 'UAchievementParamDBAsset::PresentItemListM' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, PresentItemListF) == 0x000078, "Member 'UAchievementParamDBAsset::PresentItemListF' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, PresentItemTotal) == 0x0000C8, "Member 'UAchievementParamDBAsset::PresentItemTotal' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, AttachmentItemList) == 0x0000D0, "Member 'UAchievementParamDBAsset::AttachmentItemList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, TradeItemList) == 0x0000E0, "Member 'UAchievementParamDBAsset::TradeItemList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, CostumeEquipItemList) == 0x0000F0, "Member 'UAchievementParamDBAsset::CostumeEquipItemList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, BakiHeadItemList) == 0x000100, "Member 'UAchievementParamDBAsset::BakiHeadItemList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, BoredomVoiceList) == 0x000110, "Member 'UAchievementParamDBAsset::BoredomVoiceList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, QuestList) == 0x000120, "Member 'UAchievementParamDBAsset::QuestList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, bondsProgressM) == 0x000130, "Member 'UAchievementParamDBAsset::bondsProgressM' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, bondsProgressF) == 0x000180, "Member 'UAchievementParamDBAsset::bondsProgressF' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, EnemyLibraryList) == 0x0001D0, "Member 'UAchievementParamDBAsset::EnemyLibraryList' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, SkillListM) == 0x0001E0, "Member 'UAchievementParamDBAsset::SkillListM' has a wrong offset!");
static_assert(offsetof(UAchievementParamDBAsset, SkillListF) == 0x000230, "Member 'UAchievementParamDBAsset::SkillListF' has a wrong offset!");

// Class BattlePrototype.NpcShopBase
// 0x0098 (0x02C8 - 0x0230)
class ANpcShopBase : public AActor
{
public:
	uint8                                         Pad_1CE4[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CollisionCapsuleComponent;                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0270(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionIconType                               ActionIconType;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE5[0x3];                                     // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIMapIconAdjust                       MapIconAdjust;                                     // 0x0280(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE6[0x4];                                     // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASavePointBase*                         PairActor;                                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShopParam;                                         // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TradeParam;                                        // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFitGround;                                       // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE7[0xF];                                     // 0x02B9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UChildActorComponent* GetChildActionIcon();
	void RegisterPairActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcShopBase">();
	}
	static class ANpcShopBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcShopBase>();
	}
};
static_assert(alignof(ANpcShopBase) == 0x000008, "Wrong alignment on ANpcShopBase");
static_assert(sizeof(ANpcShopBase) == 0x0002C8, "Wrong size on ANpcShopBase");
static_assert(offsetof(ANpcShopBase, StaticMeshComponent) == 0x000238, "Member 'ANpcShopBase::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ShowBoxComponent) == 0x000240, "Member 'ANpcShopBase::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, CollisionCapsuleComponent) == 0x000248, "Member 'ANpcShopBase::CollisionCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, EventBoxComponent) == 0x000250, "Member 'ANpcShopBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, MakeEventActorClass) == 0x000258, "Member 'ANpcShopBase::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, MakeEventActor) == 0x000260, "Member 'ANpcShopBase::MakeEventActor' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ChildActionIcon) == 0x000268, "Member 'ANpcShopBase::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ActionIconWorldPositionOffset) == 0x000270, "Member 'ANpcShopBase::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ActionIconType) == 0x00027C, "Member 'ANpcShopBase::ActionIconType' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, MapIconAdjust) == 0x000280, "Member 'ANpcShopBase::MapIconAdjust' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, PairActor) == 0x0002A8, "Member 'ANpcShopBase::PairActor' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, ShopParam) == 0x0002B0, "Member 'ANpcShopBase::ShopParam' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, TradeParam) == 0x0002B4, "Member 'ANpcShopBase::TradeParam' has a wrong offset!");
static_assert(offsetof(ANpcShopBase, IsFitGround) == 0x0002B8, "Member 'ANpcShopBase::IsFitGround' has a wrong offset!");

// Class BattlePrototype.ActionIcon
// 0x0068 (0x0298 - 0x0230)
class AActionIcon final : public AActor
{
public:
	class AActionIcon*                            PairActionIconActor;                               // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CE8[0x8];                                     // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CE9[0x20];                                    // 0x0250(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldPositionOffset;                               // 0x0270(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               ActionIconType;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconSubQuestState                      ActionIconSubQuestState;                           // 0x027D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ActionIconSubQuestActive;                          // 0x027E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CEA[0x1];                                     // 0x027F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIActionIcon*                          UIActionIcon;                                      // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActionIcon*                            PairActionIcon;                                    // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CEB[0x4];                                     // 0x0290(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          OverlapEventInvalidFlag;                           // 0x0294(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CEC[0x3];                                     // 0x0295(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckVisibleIcon(class AActor* Actor);
	bool GetOverlapEventInvalidFlag();
	void OnDecide();
	void OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnReActivate();
	void RestoreVisible();
	void SafeSetIconMode(EActionIconMode Mode);
	void SetActionCollisionEnable(bool Enable);
	void SetActionIconSupportParam(const struct FActionIconSupportParam& ActionIconSupportParam);
	void SetBattleFlag(bool bBattle);
	void SetIconType(EActionIconType Param_ActionIconType, bool IsActive);
	void SetLockIconMode(bool IsLock);
	void SetOverlapEventInvalidFlag(bool Enable);
	void SetSubQuestState(EActionIconSubQuestState State, bool SubquestActive);
	void SetVisible(const bool Flag, const bool UpdateState);
	void SetWorldPositionOffset(const struct FVector& Param_WorldPositionOffset);
	void UpdateActionIconState();

	EActionIconType GetIconType() const;
	EActionIconSubQuestState GetSubQuestState() const;
	bool IsActionAbleIcon() const;
	bool IsPlayingActionIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionIcon">();
	}
	static class AActionIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionIcon>();
	}
};
static_assert(alignof(AActionIcon) == 0x000008, "Wrong alignment on AActionIcon");
static_assert(sizeof(AActionIcon) == 0x000298, "Wrong size on AActionIcon");
static_assert(offsetof(AActionIcon, PairActionIconActor) == 0x000230, "Member 'AActionIcon::PairActionIconActor' has a wrong offset!");
static_assert(offsetof(AActionIcon, ShowBoxComponent) == 0x000240, "Member 'AActionIcon::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(AActionIcon, EventBoxComponent) == 0x000248, "Member 'AActionIcon::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AActionIcon, WorldPositionOffset) == 0x000270, "Member 'AActionIcon::WorldPositionOffset' has a wrong offset!");
static_assert(offsetof(AActionIcon, ActionIconType) == 0x00027C, "Member 'AActionIcon::ActionIconType' has a wrong offset!");
static_assert(offsetof(AActionIcon, ActionIconSubQuestState) == 0x00027D, "Member 'AActionIcon::ActionIconSubQuestState' has a wrong offset!");
static_assert(offsetof(AActionIcon, ActionIconSubQuestActive) == 0x00027E, "Member 'AActionIcon::ActionIconSubQuestActive' has a wrong offset!");
static_assert(offsetof(AActionIcon, UIActionIcon) == 0x000280, "Member 'AActionIcon::UIActionIcon' has a wrong offset!");
static_assert(offsetof(AActionIcon, PairActionIcon) == 0x000288, "Member 'AActionIcon::PairActionIcon' has a wrong offset!");
static_assert(offsetof(AActionIcon, OverlapEventInvalidFlag) == 0x000294, "Member 'AActionIcon::OverlapEventInvalidFlag' has a wrong offset!");

// Class BattlePrototype.ActionManager
// 0x0068 (0x0298 - 0x0230)
class AActionManager final : public AActor
{
public:
	uint8                                         Pad_1CF0[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisibilityCheckDistance;                           // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDispAreaNextUI;                                  // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDebug;                                           // 0x023D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CF1[0x5A];                                    // 0x023E(0x005A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearActionAll();
	int32 RegisterAction(class AActor* Actor);
	int32 RegisterAction2(class AActor* Actor);
	void SetBattleFlag(bool bBattle);
	void SetEnableActionCheck(bool bEnable);
	void UnregistAction(int32 Handle);
	void UnregistAction2(int32 Handle);

	bool IsExistEnableAction() const;
	bool IsExistEnableAction2() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionManager">();
	}
	static class AActionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionManager>();
	}
};
static_assert(alignof(AActionManager) == 0x000008, "Wrong alignment on AActionManager");
static_assert(sizeof(AActionManager) == 0x000298, "Wrong size on AActionManager");
static_assert(offsetof(AActionManager, VisibilityCheckDistance) == 0x000238, "Member 'AActionManager::VisibilityCheckDistance' has a wrong offset!");
static_assert(offsetof(AActionManager, IsDispAreaNextUI) == 0x00023C, "Member 'AActionManager::IsDispAreaNextUI' has a wrong offset!");
static_assert(offsetof(AActionManager, IsDebug) == 0x00023D, "Member 'AActionManager::IsDebug' has a wrong offset!");

// Class BattlePrototype.ActionManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IActionManagerInterface final : public IInterface
{
public:
	bool ActionManagerExecute(int32 Handle);
	class AActor* ActionManagerGetPairActor();
	void ActionManagerSetBattleFlag(bool bBattle);
	void ActionManagerSetIconMode(int32 Handle, EActionIconMode Mode);

	bool ActionManagerCheck(int32 Handle) const;
	float ActionManagerGetEditableAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionManagerInterface">();
	}
	static class IActionManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IActionManagerInterface>();
	}
};
static_assert(alignof(IActionManagerInterface) == 0x000008, "Wrong alignment on IActionManagerInterface");
static_assert(sizeof(IActionManagerInterface) == 0x000028, "Wrong size on IActionManagerInterface");

// Class BattlePrototype.PlayerDamageReactionInfoBase
// 0x0050 (0x0110 - 0x00C0)
class UPlayerDamageReactionInfoBase : public UActorComponent
{
public:
	class ARSCharacterBase*                       OwnerCharacter;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerScriptComponent*                 OwnerPlayerScript;                                 // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerDamageKind                             DamageKind;                                        // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerDamageKind                             DamageKindNow;                                     // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CF7[0x2];                                     // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DamageDir;                                         // 0x00D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddDamage;                                        // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CF8[0x3];                                     // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  DamageAttacker;                                    // 0x00E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  Attacker;                                          // 0x00EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHCHitStopCauseType                           HitStopCauseType;                                  // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CF9[0x3];                                     // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloatingPower;                                     // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FloatingAngle;                                     // 0x00FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHCSkillAttackType                            AttackType;                                        // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CFA[0x3];                                     // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BadStateFlag;                                      // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool BrainCrashAccess_CallFromCPP(const struct FHCHitResult& HitResult);
	bool CheckBadStateDamageCPP(int32 Flag, EHCBadState BadState);
	bool CheckFinishMetamorphosis_BPImplement(class UPlayerENpcBaseComponent* ENpcComp, EPlayerDamageKind InDamageKind, bool bFront);
	bool IsAttackerPlayerCPP();
	bool IsKnockbackLongNowCPP();
	bool StartEnemyAddDamageShake_BPImplement(bool bTriggerAttack);
	bool StartEnpcDamageMove_BPImplement(const struct FVector& Param_DamageDir, float Power, bool DeadMove);
	void UpdateDamageReactionCPP(const struct FHCHitResult& HitResult);

	bool IsAerialDamageCPP() const;
	bool IsExistDamageCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDamageReactionInfoBase">();
	}
	static class UPlayerDamageReactionInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDamageReactionInfoBase>();
	}
};
static_assert(alignof(UPlayerDamageReactionInfoBase) == 0x000008, "Wrong alignment on UPlayerDamageReactionInfoBase");
static_assert(sizeof(UPlayerDamageReactionInfoBase) == 0x000110, "Wrong size on UPlayerDamageReactionInfoBase");
static_assert(offsetof(UPlayerDamageReactionInfoBase, OwnerCharacter) == 0x0000C0, "Member 'UPlayerDamageReactionInfoBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, OwnerPlayerScript) == 0x0000C8, "Member 'UPlayerDamageReactionInfoBase::OwnerPlayerScript' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, DamageKind) == 0x0000D0, "Member 'UPlayerDamageReactionInfoBase::DamageKind' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, DamageKindNow) == 0x0000D1, "Member 'UPlayerDamageReactionInfoBase::DamageKindNow' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, DamageDir) == 0x0000D4, "Member 'UPlayerDamageReactionInfoBase::DamageDir' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, bAddDamage) == 0x0000E0, "Member 'UPlayerDamageReactionInfoBase::bAddDamage' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, DamageAttacker) == 0x0000E4, "Member 'UPlayerDamageReactionInfoBase::DamageAttacker' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, Attacker) == 0x0000EC, "Member 'UPlayerDamageReactionInfoBase::Attacker' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, HitStopCauseType) == 0x0000F4, "Member 'UPlayerDamageReactionInfoBase::HitStopCauseType' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, FloatingPower) == 0x0000F8, "Member 'UPlayerDamageReactionInfoBase::FloatingPower' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, FloatingAngle) == 0x0000FC, "Member 'UPlayerDamageReactionInfoBase::FloatingAngle' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, AttackType) == 0x000108, "Member 'UPlayerDamageReactionInfoBase::AttackType' has a wrong offset!");
static_assert(offsetof(UPlayerDamageReactionInfoBase, BadStateFlag) == 0x00010C, "Member 'UPlayerDamageReactionInfoBase::BadStateFlag' has a wrong offset!");

// Class BattlePrototype.ActorVisibleChangeBase
// 0x0030 (0x0260 - 0x0230)
class AActorVisibleChangeBase : public AActor
{
public:
	bool                                          IsCollectArrangeItem;                              // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCollectArrangeObject;                            // 0x0231(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCollectAnotherActor;                             // 0x0232(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CFF[0x5];                                     // 0x0233(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CollectorComponent;                                // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ChangeActors;                                      // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AArrangeItemBase*>               ChangeActors_ArrangeItemBase;                      // 0x0250(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CollectActors();
	void UnvisibleActors();
	void VisibleActors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorVisibleChangeBase">();
	}
	static class AActorVisibleChangeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorVisibleChangeBase>();
	}
};
static_assert(alignof(AActorVisibleChangeBase) == 0x000008, "Wrong alignment on AActorVisibleChangeBase");
static_assert(sizeof(AActorVisibleChangeBase) == 0x000260, "Wrong size on AActorVisibleChangeBase");
static_assert(offsetof(AActorVisibleChangeBase, IsCollectArrangeItem) == 0x000230, "Member 'AActorVisibleChangeBase::IsCollectArrangeItem' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, IsCollectArrangeObject) == 0x000231, "Member 'AActorVisibleChangeBase::IsCollectArrangeObject' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, IsCollectAnotherActor) == 0x000232, "Member 'AActorVisibleChangeBase::IsCollectAnotherActor' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, CollectorComponent) == 0x000238, "Member 'AActorVisibleChangeBase::CollectorComponent' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, ChangeActors) == 0x000240, "Member 'AActorVisibleChangeBase::ChangeActors' has a wrong offset!");
static_assert(offsetof(AActorVisibleChangeBase, ChangeActors_ArrangeItemBase) == 0x000250, "Member 'AActorVisibleChangeBase::ChangeActors_ArrangeItemBase' has a wrong offset!");

// Class BattlePrototype.AddContentManager
// 0x00B0 (0x00D8 - 0x0028)
class UAddContentManager final : public UObject
{
public:
	uint8                                         Pad_1D00[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _RefDataTable;                                     // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _AddContentsPresentListDataTable;                  // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, bool>                       _EntitledData;                                     // 0x0040(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D01[0x48];                                    // 0x0090(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsCheckingEntitlementInProgress();

	bool ConstructLocalEntitleData();
	bool GetAddContentRefDataCell(struct FAddContentRefDataCell* RowParam, class FName AddContentName);
	bool GetAddContentRefDataID(class FName* ID, class FName AddContentName);
	bool GetAddContentsPresentInfo(TArray<struct FAddContentsPresentInfo>* InfoList, class FName AddContentName);
	bool GetAddContentsTitleIdAndExplanationId(class FName AddContentName, class FString* TitleID, class FString* ExplanationID);
	TArray<class FName> GetAllContentsList();
	TArray<class FName> GetInvalidContentsList(const TArray<class FName>& PossessionContentsList);

	TArray<class FName> GetEntitledContentsList() const;
	bool IsEntitled(class FName AddContentName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddContentManager">();
	}
	static class UAddContentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddContentManager>();
	}
};
static_assert(alignof(UAddContentManager) == 0x000008, "Wrong alignment on UAddContentManager");
static_assert(sizeof(UAddContentManager) == 0x0000D8, "Wrong size on UAddContentManager");
static_assert(offsetof(UAddContentManager, _RefDataTable) == 0x000030, "Member 'UAddContentManager::_RefDataTable' has a wrong offset!");
static_assert(offsetof(UAddContentManager, _AddContentsPresentListDataTable) == 0x000038, "Member 'UAddContentManager::_AddContentsPresentListDataTable' has a wrong offset!");
static_assert(offsetof(UAddContentManager, _EntitledData) == 0x000040, "Member 'UAddContentManager::_EntitledData' has a wrong offset!");

// Class BattlePrototype.AjitoBase
// 0x0000 (0x0230 - 0x0230)
class AAjitoBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoBase">();
	}
	static class AAjitoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoBase>();
	}
};
static_assert(alignof(AAjitoBase) == 0x000008, "Wrong alignment on AAjitoBase");
static_assert(sizeof(AAjitoBase) == 0x000230, "Wrong size on AAjitoBase");

// Class BattlePrototype.AjitoManager
// 0x0008 (0x0238 - 0x0230)
class AAjitoManager : public AActor
{
public:
	uint8                                         Pad_1D07[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoManager">();
	}
	static class AAjitoManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoManager>();
	}
};
static_assert(alignof(AAjitoManager) == 0x000008, "Wrong alignment on AAjitoManager");
static_assert(sizeof(AAjitoManager) == 0x000238, "Wrong size on AAjitoManager");

// Class BattlePrototype.OutgameDebuggingStartupObject
// 0x0010 (0x0038 - 0x0028)
class UOutgameDebuggingStartupObject final : public UObject
{
public:
	uint8                                         Pad_1D08[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveLoadScreenParamManager*            M_pDebugSystemSaveLoadScreenParamManager;          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnActivityReleaseAccordingToTheMaximumProgressThatHasBeenReached(const class ADebuggingItemEvent* Item);
	void OnChangeLoadLevel(const class ADebuggingItemStringArray* Item);
	void OnCosmosWebManagerHttpLastErrorCodeLog(const class ADebuggingItemEvent* Item);
	void OnDispMouseRectangle(const class ADebuggingItemBool* Item);
	void OnDispTitleMainUI(const class ADebuggingItemBool* Item);
	void OnDispUserTag(const class ADebuggingItemBool* Item);
	void OnDrawInactiveUIBaseProperty(const class ADebuggingItemBool* Item);
	void OnDrawUIBaseProperty(const class ADebuggingItemBool* Item);
	void OnExecuteLoadLevel(const class ADebuggingItemEvent* Item);
	void OnForcedChangeOfExecutionResultReportList(const class ADebuggingItemStringArray* Item);
	void OnOpenPhotoMode(const class ADebuggingItemEvent* Item);
	void OnReloadLevel(const class ADebuggingItemEvent* Item);
	void OnSavedataDelete(const class ADebuggingItemEvent* Item);
	void OnSavedataDownload(const class ADebuggingItemEvent* Item);
	void OnSavedataUpload(const class ADebuggingItemEvent* Item);
	void OnSystemChangeClearFlag(const class ADebuggingItemBool* Item);
	void OnSystemChangeZeroEpClearFlag(const class ADebuggingItemBool* Item);
	void OnSystemDataCorrupt(const class ADebuggingItemBool* Item);
	void OnSystemDummyBuffer(const class ADebuggingItemBool* Item);
	void OnSystemFastFlowSkip(const class ADebuggingItemBool* Item);
	void OnSystemForcedChangeOfExecutionResultReport(const class ADebuggingItemBool* Item);
	void OnSystemMaximumProgressDisplayThatHasBeenReached(const class ADebuggingItemBool* Item);
	void OnUseMouseCursor(const class ADebuggingItemBool* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutgameDebuggingStartupObject">();
	}
	static class UOutgameDebuggingStartupObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutgameDebuggingStartupObject>();
	}
};
static_assert(alignof(UOutgameDebuggingStartupObject) == 0x000008, "Wrong alignment on UOutgameDebuggingStartupObject");
static_assert(sizeof(UOutgameDebuggingStartupObject) == 0x000038, "Wrong size on UOutgameDebuggingStartupObject");
static_assert(offsetof(UOutgameDebuggingStartupObject, M_pDebugSystemSaveLoadScreenParamManager) == 0x000030, "Member 'UOutgameDebuggingStartupObject::M_pDebugSystemSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.Em0630Interface
// 0x0000 (0x0028 - 0x0028)
class IEm0630Interface final : public IInterface
{
public:
	class USoundAtomCue* GetEm0630DamageSoundCue(int32 Param_Index);
	struct FSoundEffectDamage GetEm0630SoundEffectDamage(int32 Param_Index);
	bool SpawnEm0630DmgEffect(EHDamageEffectType DamagePointType, int32 DamageparticleTypeIndex, const struct FTransform& Transform, class AActor* Creator, ESequencerDilationOwner DilationOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Em0630Interface">();
	}
	static class IEm0630Interface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEm0630Interface>();
	}
};
static_assert(alignof(IEm0630Interface) == 0x000008, "Wrong alignment on IEm0630Interface");
static_assert(sizeof(IEm0630Interface) == 0x000028, "Wrong size on IEm0630Interface");

// Class BattlePrototype.AjitoMember
// 0x0160 (0x0390 - 0x0230)
class AAjitoMember : public AActor
{
public:
	uint8                                         Pad_1D0E[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             M_storeSkeletalMeshTransform;                      // 0x0240(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0F[0x4];                                     // 0x0270(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerID                                     PlayerId;                                          // 0x0274(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D10[0x3];                                     // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlaceID;                                           // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaceNo;                                           // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ExclusivePlaceNoList;                              // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         WithPlaceNoList;                                   // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAtPlayer;                                    // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D11[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CharacterCapsuleComponent;                         // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D12[0x1];                                     // 0x02D8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsOverlappingPlayer;                               // 0x02D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D13[0x6];                                     // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionIconCoolTime;                                // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvalableAction;                                  // 0x02E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D14[0xB];                                     // 0x02E5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActionIcon*                            ActionIcon;                                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0300(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionIconType                               ActionIconType;                                    // 0x030C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D15[0x3];                                     // 0x030D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetIconOffsetZ;                                 // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D16[0x4];                                     // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URSAjitoAnimInstance>       AnimClass;                                         // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class URSAjitoAnimInstance>    AnimationBP;                                       // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             IconOffsetDataTable;                               // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FNpcIconOffsetInfo>  IconOffsetDataInfos;                               // 0x0330(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         WaitTimeTransitionToTalk;                          // 0x0380(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTimeTransitionToIdle;                          // 0x0384(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D17[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustIconOffsetByHeadHeight();
	void AdjustIconOffsetByHeadHeightForce(float HeadHeight);
	void ClearWaitTransitionToIdle();
	void ClearWaitTransitionToTalk();
	TArray<class AActor*> GetAllOmActors();
	float GetHeadHeight();
	float GetNowDitherValue();
	bool IsActiveMakeEvent();
	bool IsTalkEnablePlayer();
	void PresentEventEnd();
	void PresentEventStart();
	void RequestTalkEnd();
	void RequestTalkStart();
	void SetActionIconType(EActionIconType Type);
	void SetActionIcoVisible(bool Visible);
	bool SetAjitoMemberMaterialScalarParameter(const class FName ParameterName, const float ParameterValue);
	bool SetAttachmentVisible(bool Visible);
	void SetIconOffsetPreset(class FName RawName);
	void SetNowDitherValue(float DitherValue);
	void SetTargetIconOffsetZ(float HeadHeight);
	bool UpdateActionIcon();
	void UpdateTargetIconOffsetZ();
	void WaitTransitionToIdle(float WaitTime);
	void WaitTransitionToTalk(float WaitTime);

	bool IsReadyToTalk() const;
	bool IsWaitTransitionToIdle() const;
	bool IsWaitTransitionToTalk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoMember">();
	}
	static class AAjitoMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoMember>();
	}
};
static_assert(alignof(AAjitoMember) == 0x000010, "Wrong alignment on AAjitoMember");
static_assert(sizeof(AAjitoMember) == 0x000390, "Wrong size on AAjitoMember");
static_assert(offsetof(AAjitoMember, SkeletalMeshComponent) == 0x000238, "Member 'AAjitoMember::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AAjitoMember, M_storeSkeletalMeshTransform) == 0x000240, "Member 'AAjitoMember::M_storeSkeletalMeshTransform' has a wrong offset!");
static_assert(offsetof(AAjitoMember, PlayerId) == 0x000274, "Member 'AAjitoMember::PlayerId' has a wrong offset!");
static_assert(offsetof(AAjitoMember, PlaceID) == 0x000278, "Member 'AAjitoMember::PlaceID' has a wrong offset!");
static_assert(offsetof(AAjitoMember, PlaceNo) == 0x00027C, "Member 'AAjitoMember::PlaceNo' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ExclusivePlaceNoList) == 0x000280, "Member 'AAjitoMember::ExclusivePlaceNoList' has a wrong offset!");
static_assert(offsetof(AAjitoMember, WithPlaceNoList) == 0x000290, "Member 'AAjitoMember::WithPlaceNoList' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionName) == 0x0002A0, "Member 'AAjitoMember::ActionName' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IsLookAtPlayer) == 0x0002A8, "Member 'AAjitoMember::IsLookAtPlayer' has a wrong offset!");
static_assert(offsetof(AAjitoMember, CharacterCapsuleComponent) == 0x0002B0, "Member 'AAjitoMember::CharacterCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ShowBoxComponent) == 0x0002B8, "Member 'AAjitoMember::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(AAjitoMember, EventBoxComponent) == 0x0002C0, "Member 'AAjitoMember::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AAjitoMember, MakeEventActorClass) == 0x0002C8, "Member 'AAjitoMember::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(AAjitoMember, MakeEventActor) == 0x0002D0, "Member 'AAjitoMember::MakeEventActor' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IsOverlappingPlayer) == 0x0002D9, "Member 'AAjitoMember::IsOverlappingPlayer' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionIconCoolTime) == 0x0002E0, "Member 'AAjitoMember::ActionIconCoolTime' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IsAvalableAction) == 0x0002E4, "Member 'AAjitoMember::IsAvalableAction' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ChildActionIcon) == 0x0002F0, "Member 'AAjitoMember::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionIcon) == 0x0002F8, "Member 'AAjitoMember::ActionIcon' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionIconWorldPositionOffset) == 0x000300, "Member 'AAjitoMember::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(AAjitoMember, ActionIconType) == 0x00030C, "Member 'AAjitoMember::ActionIconType' has a wrong offset!");
static_assert(offsetof(AAjitoMember, TargetIconOffsetZ) == 0x000310, "Member 'AAjitoMember::TargetIconOffsetZ' has a wrong offset!");
static_assert(offsetof(AAjitoMember, AnimClass) == 0x000318, "Member 'AAjitoMember::AnimClass' has a wrong offset!");
static_assert(offsetof(AAjitoMember, AnimationBP) == 0x000320, "Member 'AAjitoMember::AnimationBP' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IconOffsetDataTable) == 0x000328, "Member 'AAjitoMember::IconOffsetDataTable' has a wrong offset!");
static_assert(offsetof(AAjitoMember, IconOffsetDataInfos) == 0x000330, "Member 'AAjitoMember::IconOffsetDataInfos' has a wrong offset!");
static_assert(offsetof(AAjitoMember, WaitTimeTransitionToTalk) == 0x000380, "Member 'AAjitoMember::WaitTimeTransitionToTalk' has a wrong offset!");
static_assert(offsetof(AAjitoMember, WaitTimeTransitionToIdle) == 0x000384, "Member 'AAjitoMember::WaitTimeTransitionToIdle' has a wrong offset!");

// Class BattlePrototype.OnlineTestFindSessions
// 0x0060 (0x0090 - 0x0030)
class UOnlineTestFindSessions final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D19[0x40];                                    // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOnlineTestFindSessions* OnlineTestFindSessions(class UObject* WorldContextObject, class APlayerController* PlayerController, int32 MaxResults, bool bIsLAN);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestFindSessions">();
	}
	static class UOnlineTestFindSessions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineTestFindSessions>();
	}
};
static_assert(alignof(UOnlineTestFindSessions) == 0x000008, "Wrong alignment on UOnlineTestFindSessions");
static_assert(sizeof(UOnlineTestFindSessions) == 0x000090, "Wrong size on UOnlineTestFindSessions");
static_assert(offsetof(UOnlineTestFindSessions, OnSuccess) == 0x000030, "Member 'UOnlineTestFindSessions::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOnlineTestFindSessions, OnFailure) == 0x000040, "Member 'UOnlineTestFindSessions::OnFailure' has a wrong offset!");

// Class BattlePrototype.AjitoNpcPlaceHolderBase
// 0x0008 (0x0238 - 0x0230)
class AAjitoNpcPlaceHolderBase final : public AActor
{
public:
	int32                                         PlacementID;                                       // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailable;                                       // 0x0234(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1B[0x3];                                     // 0x0235(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetVisible(bool Visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoNpcPlaceHolderBase">();
	}
	static class AAjitoNpcPlaceHolderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoNpcPlaceHolderBase>();
	}
};
static_assert(alignof(AAjitoNpcPlaceHolderBase) == 0x000008, "Wrong alignment on AAjitoNpcPlaceHolderBase");
static_assert(sizeof(AAjitoNpcPlaceHolderBase) == 0x000238, "Wrong size on AAjitoNpcPlaceHolderBase");
static_assert(offsetof(AAjitoNpcPlaceHolderBase, PlacementID) == 0x000230, "Member 'AAjitoNpcPlaceHolderBase::PlacementID' has a wrong offset!");
static_assert(offsetof(AAjitoNpcPlaceHolderBase, IsAvailable) == 0x000234, "Member 'AAjitoNpcPlaceHolderBase::IsAvailable' has a wrong offset!");

// Class BattlePrototype.RSActorSystemBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorSystemBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorSystemBase">();
	}
	static class ARSActorSystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorSystemBase>();
	}
};
static_assert(alignof(ARSActorSystemBase) == 0x000008, "Wrong alignment on ARSActorSystemBase");
static_assert(sizeof(ARSActorSystemBase) == 0x000230, "Wrong size on ARSActorSystemBase");

// Class BattlePrototype.AjitoPlacementManager
// 0x0018 (0x0248 - 0x0230)
class AAjitoPlacementManager : public ARSActorSystemBase
{
public:
	EPlayerID                                     PlayerId;                                          // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1C[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAjitoPlacementInfo>            ActorInfos;                                        // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AjitoPlacementManager">();
	}
	static class AAjitoPlacementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAjitoPlacementManager>();
	}
};
static_assert(alignof(AAjitoPlacementManager) == 0x000008, "Wrong alignment on AAjitoPlacementManager");
static_assert(sizeof(AAjitoPlacementManager) == 0x000248, "Wrong size on AAjitoPlacementManager");
static_assert(offsetof(AAjitoPlacementManager, PlayerId) == 0x000230, "Member 'AAjitoPlacementManager::PlayerId' has a wrong offset!");
static_assert(offsetof(AAjitoPlacementManager, ActorInfos) == 0x000238, "Member 'AAjitoPlacementManager::ActorInfos' has a wrong offset!");

// Class BattlePrototype.PlayerLookAtComponent
// 0x0088 (0x0148 - 0x00C0)
class UPlayerLookAtComponent final : public UActorComponent
{
public:
	float                                         LimitDegreeUp;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitDegreeDown;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitDegreeRight;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitDegreeLeft;                                   // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtFollowSpeed;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtSocketName;                                  // 0x00D4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1D[0x4];                                     // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LookAroundCurve;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1E[0x48];                                    // 0x00E8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UTargetSearchComponent>  _TargetSearchComponent;                            // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USkeletalMeshComponent>  _MeshComponent;                                    // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class URSPlayerAnimInstance>   _PlayerAnimInstance;                               // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ForceReset();
	void SetEventLookAtActor(bool bEnable, class AActor* LookAtActor);
	void SetEventLookAtLocation(bool bEnable, const struct FVector& LookAtLocation);
	void SetLookAround(bool bLookAround);
	void SetLookAtEnabled(bool bEnabled);
	void SetLookAtLocation(bool bLookLocation, const struct FVector& LookAtLocation);

	bool IsLookAtEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLookAtComponent">();
	}
	static class UPlayerLookAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLookAtComponent>();
	}
};
static_assert(alignof(UPlayerLookAtComponent) == 0x000008, "Wrong alignment on UPlayerLookAtComponent");
static_assert(sizeof(UPlayerLookAtComponent) == 0x000148, "Wrong size on UPlayerLookAtComponent");
static_assert(offsetof(UPlayerLookAtComponent, LimitDegreeUp) == 0x0000C0, "Member 'UPlayerLookAtComponent::LimitDegreeUp' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LimitDegreeDown) == 0x0000C4, "Member 'UPlayerLookAtComponent::LimitDegreeDown' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LimitDegreeRight) == 0x0000C8, "Member 'UPlayerLookAtComponent::LimitDegreeRight' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LimitDegreeLeft) == 0x0000CC, "Member 'UPlayerLookAtComponent::LimitDegreeLeft' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LookAtFollowSpeed) == 0x0000D0, "Member 'UPlayerLookAtComponent::LookAtFollowSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LookAtSocketName) == 0x0000D4, "Member 'UPlayerLookAtComponent::LookAtSocketName' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, LookAroundCurve) == 0x0000E0, "Member 'UPlayerLookAtComponent::LookAroundCurve' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, _TargetSearchComponent) == 0x000130, "Member 'UPlayerLookAtComponent::_TargetSearchComponent' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, _MeshComponent) == 0x000138, "Member 'UPlayerLookAtComponent::_MeshComponent' has a wrong offset!");
static_assert(offsetof(UPlayerLookAtComponent, _PlayerAnimInstance) == 0x000140, "Member 'UPlayerLookAtComponent::_PlayerAnimInstance' has a wrong offset!");

// Class BattlePrototype.AnimControllerComponent
// 0x0020 (0x00E0 - 0x00C0)
class UAnimControllerComponent : public UActorComponent
{
public:
	uint8                                         Pad_1D22[0x20];                                    // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAnimControllerComponent* GetAnimControllerComponentFromActor(class AActor* Actor);

	void ReceiveNotifyDirectionControl(class UObject* Notify, bool bBegin, float RotateSpeed, bool bUseSocket, class FName SocketName);
	void ReceiveNotifySuperArmor(class UObject* Notify, int32 ResistStagger, bool bBegin);
	void RequestDamage(EHCDamageKind DamageKind, float StiffenSec, float HitStopSec, float HitStopRate, const struct FRotator& Rot);
	void RequestDamageFly();
	void RequestDamageFlyWakeup();
	void RequestFaint();
	void RequestFaintWakeup();
	void RequestTumble();
	void RequestTumbleWakeup();

	float GetDirectionControllRotateSpeed() const;
	class FName GetDirectionControlSocketName() const;
	int32 GetResistStagger() const;
	bool IsAnimDamageFly() const;
	bool IsAnimDamageFlyLanding() const;
	bool IsAnimDamageFlyRise() const;
	bool IsAnimFaint() const;
	bool IsAnimFaintDowning() const;
	bool IsAnimTumble() const;
	bool IsAnimTumbleDowning() const;
	bool IsEnableDirectionControl() const;
	bool IsUseSocketDirectionControl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimControllerComponent">();
	}
	static class UAnimControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimControllerComponent>();
	}
};
static_assert(alignof(UAnimControllerComponent) == 0x000008, "Wrong alignment on UAnimControllerComponent");
static_assert(sizeof(UAnimControllerComponent) == 0x0000E0, "Wrong size on UAnimControllerComponent");

// Class BattlePrototype.ParticleComponentListManager
// 0x0010 (0x0038 - 0x0028)
class UParticleComponentListManager final : public UObject
{
public:
	TArray<class URSParticleSystemComponentBase*> ParticleSystemComponentBases;                      // 0x0028(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleComponentListManager">();
	}
	static class UParticleComponentListManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleComponentListManager>();
	}
};
static_assert(alignof(UParticleComponentListManager) == 0x000008, "Wrong alignment on UParticleComponentListManager");
static_assert(sizeof(UParticleComponentListManager) == 0x000038, "Wrong size on UParticleComponentListManager");
static_assert(offsetof(UParticleComponentListManager, ParticleSystemComponentBases) == 0x000028, "Member 'UParticleComponentListManager::ParticleSystemComponentBases' has a wrong offset!");

// Class BattlePrototype.AnimeInterlockingManager
// 0x0088 (0x00B0 - 0x0028)
class UAnimeInterlockingManager final : public UObject
{
public:
	uint8                                         Pad_1D28[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        M_gameInstance;                                    // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingData_DataTable;                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingReward_DataTable;               // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingSubReward_DataTable;            // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingNumData_DataTable;              // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingNumReward_DataTable;            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingSubNumReward_DataTable;         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_AnimeInterlockingRewardToKins_DataTable;         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimeInterlockingChallengeQuestInfo   M_ChallengeInfo;                                   // 0x0078(0x0018)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FAnimeInterlockingSaveParams>   M_AnimeInterlockingSaveParamsList;                 // 0x0090(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimeInterlockingNumRewardSaveParams> M_AnimeInterlockingNumRewardSaveParamsList;        // 0x00A0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddAnimeInterlockingIncorrectAnswerNum(class FName AnimeInterlockingName);
	void GetAcquirableButNotAcquiredNumRewardNameList(TArray<class FName>* NameList);
	int32 GetAnimeInterlockingIncorrectAnswerNum(class FName AnimeInterlockingName);
	bool GetAnimeInterlockingNumRefData(class FName AnimeInterlockingNumName, struct FAnimeInterlockingNumRefDataCell* RefData);
	void GetAnimeInterlockingNumRefDataList(class FName AnimeInterlockingNumName, TArray<struct FAnimeInterlockingNumRefDataCell>* RefDataList);
	bool GetAnimeInterlockingNumReward(class FName AnimeInterlockingNumName, struct FAnimeInterlockingsPresentList* PresentList);
	bool GetAnimeInterlockingNumRewardSaveParams(class FName AnimeInterlockingNumName, struct FAnimeInterlockingNumRewardSaveParams* SaveParams);
	bool GetAnimeInterlockingNumSubReward(class FName AnimeInterlockingNumName, struct FAnimeInterlockingsPresentList* PresentList);
	bool GetAnimeInterlockingRefData(class FName AnimeInterlockingName, struct FAnimeInterlockingRefDataCell* RefData);
	void GetAnimeInterlockingRefDataList(class FName AnimeInterlockingName, TArray<struct FAnimeInterlockingRefDataCell>* RefDataList);
	bool GetAnimeInterlockingReward(class FName AnimeInterlockingName, struct FAnimeInterlockingsPresentList* PresentList);
	bool GetAnimeInterlockingRewardToKins(const class FString& ItemId, int32* KinsNum);
	bool GetAnimeInterlockingSaveParams(class FName AnimeInterlockingName, struct FAnimeInterlockingSaveParams* SaveParams);
	bool GetAnimeInterlockingSubReward(class FName AnimeInterlockingName, struct FAnimeInterlockingsPresentList* PresentList);
	class FName GetChallengeInfoAnimeInterlockingName();
	int32 GetQuestClearNum();
	bool IsAnimeInterlockingAchievementQuest(class FName AnimeInterlockingName);
	bool IsAnimeInterlockingGetNumReward(class FName AnimeInterlockingNumRewardName);
	bool IsAnimeInterlockingGetReward(class FName AnimeInterlockingName);
	bool IsAnimeInterlockingNewFlag(class FName AnimeInterlockingName);
	bool IsAnimeInterlockingNoticedFlag(class FName AnimeInterlockingName);
	bool IsAnimeInterlockingNumRewardAchievement(class FName AnimeInterlockingNumRewardName);
	bool IsChallengeInfoCorrectAnswer();
	bool IsEnableQuest(class FName AnimeInterlockingName);
	void SetAnimeInterlockingIncorrectAnswerNum(class FName AnimeInterlockingName, const int32 IncorrectAnswerNum);
	bool SetAnimeInterlockingNumRewardSaveParams(class FName AnimeInterlockingNumName, struct FAnimeInterlockingNumRewardSaveParams* SaveParams);
	bool SetAnimeInterlockingSaveParams(class FName AnimeInterlockingName, struct FAnimeInterlockingSaveParams* SaveParams);
	void SetChallengeInfoAnimeInterlockingName(class FName AnimeInterlockingName);
	void SetIsAnimeInterlockingAchievementQuest(class FName AnimeInterlockingName, const bool IsAchievementQuest);
	void SetIsAnimeInterlockingGetNumReward(class FName AnimeInterlockingNumRewardName, const bool IsGetNumReward);
	void SetIsAnimeInterlockingGetReward(class FName AnimeInterlockingName, const bool IsGetReward);
	void SetIsAnimeInterlockingNewFlag(class FName AnimeInterlockingName, const bool IsNewFlag);
	void SetIsAnimeInterlockingNoticedFlag(class FName AnimeInterlockingName, const bool IsNoticed);
	void SetIsAnimeInterlockingNumRewardAchievement(class FName AnimeInterlockingNumRewardName, const bool IsAchievement);
	void SetIsChallengeInfoCorrectAnswer(bool IsCorrectAnswer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimeInterlockingManager">();
	}
	static class UAnimeInterlockingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimeInterlockingManager>();
	}
};
static_assert(alignof(UAnimeInterlockingManager) == 0x000008, "Wrong alignment on UAnimeInterlockingManager");
static_assert(sizeof(UAnimeInterlockingManager) == 0x0000B0, "Wrong size on UAnimeInterlockingManager");
static_assert(offsetof(UAnimeInterlockingManager, M_gameInstance) == 0x000038, "Member 'UAnimeInterlockingManager::M_gameInstance' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingData_DataTable) == 0x000040, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingData_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingReward_DataTable) == 0x000048, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingReward_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingSubReward_DataTable) == 0x000050, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingSubReward_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingNumData_DataTable) == 0x000058, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingNumData_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingNumReward_DataTable) == 0x000060, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingNumReward_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingSubNumReward_DataTable) == 0x000068, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingSubNumReward_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingRewardToKins_DataTable) == 0x000070, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingRewardToKins_DataTable' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_ChallengeInfo) == 0x000078, "Member 'UAnimeInterlockingManager::M_ChallengeInfo' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingSaveParamsList) == 0x000090, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingSaveParamsList' has a wrong offset!");
static_assert(offsetof(UAnimeInterlockingManager, M_AnimeInterlockingNumRewardSaveParamsList) == 0x0000A0, "Member 'UAnimeInterlockingManager::M_AnimeInterlockingNumRewardSaveParamsList' has a wrong offset!");

// Class BattlePrototype.AnimNotify_OnRadialBlur
// 0x0030 (0x0068 - 0x0038)
class UAnimNotify_OnRadialBlur final : public UAnimNotify
{
public:
	int32                                         Priority;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D41[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           CurveData;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifyRadialBlurModulateType                 ModulateType;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D42[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseExecuteKind;                                  // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D43[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCurveVector* GetUseCurveData(class USkeletalMeshComponent* MeshComp) const;
	void PlayBlur(class USkeletalMeshComponent* MeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_OnRadialBlur">();
	}
	static class UAnimNotify_OnRadialBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_OnRadialBlur>();
	}
};
static_assert(alignof(UAnimNotify_OnRadialBlur) == 0x000008, "Wrong alignment on UAnimNotify_OnRadialBlur");
static_assert(sizeof(UAnimNotify_OnRadialBlur) == 0x000068, "Wrong size on UAnimNotify_OnRadialBlur");
static_assert(offsetof(UAnimNotify_OnRadialBlur, Priority) == 0x000038, "Member 'UAnimNotify_OnRadialBlur::Priority' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, CurveData) == 0x000040, "Member 'UAnimNotify_OnRadialBlur::CurveData' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, ModulateType) == 0x000048, "Member 'UAnimNotify_OnRadialBlur::ModulateType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, Location) == 0x00004C, "Member 'UAnimNotify_OnRadialBlur::Location' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, BoneName) == 0x000058, "Member 'UAnimNotify_OnRadialBlur::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_OnRadialBlur, IsUseExecuteKind) == 0x000060, "Member 'UAnimNotify_OnRadialBlur::IsUseExecuteKind' has a wrong offset!");

// Class BattlePrototype.RSAsyncTaskActorComponent
// 0x0010 (0x00D0 - 0x00C0)
class URSAsyncTaskActorComponent : public UActorComponent
{
public:
	uint8                                         Pad_1D44[0xA];                                     // 0x00C0(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugSyncExecFlag;                                // 0x00CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D45[0x5];                                     // 0x00CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetExecAsyncTask(bool bExec);

	bool IsDoneAsyncTask() const;
	bool IsIdleAsyncTask() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAsyncTaskActorComponent">();
	}
	static class URSAsyncTaskActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAsyncTaskActorComponent>();
	}
};
static_assert(alignof(URSAsyncTaskActorComponent) == 0x000008, "Wrong alignment on URSAsyncTaskActorComponent");
static_assert(sizeof(URSAsyncTaskActorComponent) == 0x0000D0, "Wrong size on URSAsyncTaskActorComponent");
static_assert(offsetof(URSAsyncTaskActorComponent, bDebugSyncExecFlag) == 0x0000CA, "Member 'URSAsyncTaskActorComponent::bDebugSyncExecFlag' has a wrong offset!");

// Class BattlePrototype.EnemyAsyncTaskComponentBase
// 0x0000 (0x00D0 - 0x00D0)
class UEnemyAsyncTaskComponentBase : public URSAsyncTaskActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAsyncTaskComponentBase">();
	}
	static class UEnemyAsyncTaskComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAsyncTaskComponentBase>();
	}
};
static_assert(alignof(UEnemyAsyncTaskComponentBase) == 0x000008, "Wrong alignment on UEnemyAsyncTaskComponentBase");
static_assert(sizeof(UEnemyAsyncTaskComponentBase) == 0x0000D0, "Wrong size on UEnemyAsyncTaskComponentBase");

// Class BattlePrototype.EnemyCalcGoalComponent
// 0x0050 (0x0120 - 0x00D0)
class UEnemyCalcGoalComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_1D46[0x50];                                    // 0x00D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAsyncTask();
	void EndAsyncTask();
	void ReSetIntervalTime();
	void SetCalcParam(const struct FVector& Start, const struct FVector& End, float Radius);
	void SetIntervalTime(float NewIntervalTime);

	struct FVector GetCalcLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyCalcGoalComponent">();
	}
	static class UEnemyCalcGoalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyCalcGoalComponent>();
	}
};
static_assert(alignof(UEnemyCalcGoalComponent) == 0x000008, "Wrong alignment on UEnemyCalcGoalComponent");
static_assert(sizeof(UEnemyCalcGoalComponent) == 0x000120, "Wrong size on UEnemyCalcGoalComponent");

// Class BattlePrototype.AnimNotify_RSPlayParticleEffect
// 0x0040 (0x00D0 - 0x0090)
class UAnimNotify_RSPlayParticleEffect : public UAnimNotify_PlayParticleEffect
{
public:
	uint8                                         Pad_1D47[0x8];                                     // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URSParticleSystemComponentBase> ComponentClass;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D48[0x3];                                     // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaleOffset;                                       // 0x00A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OptionSeeThrough;                                  // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRegistToChara;                                   // 0x00B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptTelepo;                                 // 0x00B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketLocation;                                    // 0x00B4(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketRotation;                                    // 0x00B7(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ERSParticleSystemAttachRotationOffMode        SocketRotationOffMode;                             // 0x00BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketScale;                                       // 0x00BB(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x00BE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D49[0x1];                                     // 0x00BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleComponentListManager*          ParticleComponentManager;                          // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4A[0x8];                                     // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RSPlayParticleEffect">();
	}
	static class UAnimNotify_RSPlayParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RSPlayParticleEffect>();
	}
};
static_assert(alignof(UAnimNotify_RSPlayParticleEffect) == 0x000010, "Wrong alignment on UAnimNotify_RSPlayParticleEffect");
static_assert(sizeof(UAnimNotify_RSPlayParticleEffect) == 0x0000D0, "Wrong size on UAnimNotify_RSPlayParticleEffect");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, ComponentClass) == 0x000098, "Member 'UAnimNotify_RSPlayParticleEffect::ComponentClass' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, Ignore) == 0x0000A0, "Member 'UAnimNotify_RSPlayParticleEffect::Ignore' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, ScaleOffset) == 0x0000A4, "Member 'UAnimNotify_RSPlayParticleEffect::ScaleOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, LocationType) == 0x0000B0, "Member 'UAnimNotify_RSPlayParticleEffect::LocationType' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, OptionSeeThrough) == 0x0000B1, "Member 'UAnimNotify_RSPlayParticleEffect::OptionSeeThrough' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, IsRegistToChara) == 0x0000B2, "Member 'UAnimNotify_RSPlayParticleEffect::IsRegistToChara' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, IsInterruptTelepo) == 0x0000B3, "Member 'UAnimNotify_RSPlayParticleEffect::IsInterruptTelepo' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, SocketLocation) == 0x0000B4, "Member 'UAnimNotify_RSPlayParticleEffect::SocketLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, SocketRotation) == 0x0000B7, "Member 'UAnimNotify_RSPlayParticleEffect::SocketRotation' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, SocketRotationOffMode) == 0x0000BA, "Member 'UAnimNotify_RSPlayParticleEffect::SocketRotationOffMode' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, SocketScale) == 0x0000BB, "Member 'UAnimNotify_RSPlayParticleEffect::SocketScale' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, DilationOwner) == 0x0000BE, "Member 'UAnimNotify_RSPlayParticleEffect::DilationOwner' has a wrong offset!");
static_assert(offsetof(UAnimNotify_RSPlayParticleEffect, ParticleComponentManager) == 0x0000C0, "Member 'UAnimNotify_RSPlayParticleEffect::ParticleComponentManager' has a wrong offset!");

// Class BattlePrototype.OptionParam
// 0x0100 (0x0128 - 0x0028)
class UOptionParam final : public UObject
{
public:
	uint8                                         Pad_1D4B[0x100];                                   // 0x0028(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitData(class URSGameInstance* GameInst);
	bool ReflectControllerParam();
	void ReflectParamAll();
	void ReflectParamAllConfig();
	void ReflectParamAllGraphic();
	void ReflectParamImmediate();
	void SetAntiAliasingQuality(const EOptionAAQuality& AntiAliasingQuality);
	void SetAntiAliasingQualityImmediate(const EOptionAAQuality& AntiAliasingQuality);
	void SetAttackAutoLockOn(EAttackAutoLockOn Type);
	void SetAttackAutoLockOnImmediate(EAttackAutoLockOn Type);
	void SetBGMVolume(uint8 Volume);
	void SetCameraAfterMoveType(ECameraAfterMoveType Type);
	void SetCameraAfterMoveTypeImmediate(ECameraAfterMoveType Type);
	void SetCameraPitch(EOptionCameraPitch Type);
	void SetCameraSpeed(uint8 SpeedType);
	void SetCameraYaw(EOptionCameraYaw Type);
	void SetControllerParamValue(EChangeableControllerKey TargetKey, ERSGamepadInputName NewKey);
	void SetControllerVibration(EOptionControllerVibration Type);
	void SetDefaultAll(bool IsConstruct, bool SetUeDefault);
	void SetDefaultAllConfig();
	void SetDefaultAllController();
	void SetDefaultAllGraphic(bool IsConstruct, bool SetUeDefault);
	void SetDifficulty(EHCGameDifficulty Type);
	void SetDisplayEnemyDamage(EOptionDisplayEnemyDamage Type);
	void SetDisplayLanguage(ETextLanguage Type);
	void SetDisplayLanguageImmediate(ETextLanguage Type);
	void SetEventMessageAutoPlay(EEventMessageAutoPlay Type);
	void SetEventMessageAutoPlayImmediate(EEventMessageAutoPlay Type);
	void SetFPSType(const EFPSType& FpsType);
	void SetFPSTypeImmediate(const EFPSType FpsType);
	void SetLockonActionType(ELockonActionType Type);
	void SetLockonActionTypeImmediate(ELockonActionType Type);
	void SetMinimapDisplay(EOptionMinimapDisplay Type);
	void SetMinimapRotation(EOptionMinimapRotation Type);
	void SetMinimapScaling(EOptionMinimapScaling Type);
	void SetOldScreenResolution(const struct FScreenResolutionSetting& ScreenResolution);
	void SetPostQuality(const EGradualQuality& PostQuality);
	void SetPostQualityImmediate(const EGradualQuality& PostQuality, bool IsApply);
	void SetScreenBrightness(float Param);
	void SetScreenResolution(const struct FScreenResolutionSetting& ScreenResolution);
	void SetScreenResolutionFromUserSettings();
	void SetScreenResolutionImmediate(const struct FScreenResolutionSetting& ScreenResolution, bool IsApply);
	void SetSeVolume(uint8 Volume);
	void SetShadowQuality(const EGradualQuality& ShadowQuality);
	void SetShadowQualityImmediate(const EGradualQuality& ShadowQuality, bool IsApply);
	void SetSoundOutput(EOptionSoundOutput Type);
	void SetTargetAutoChange(ETargetAutoChange Type);
	void SetTargetAutoChangeImmediate(ETargetAutoChange Type);
	void SetTargetCameraTrace(ETargetCameraTrace Type);
	void SetTargetCameraTraceImmediate(ETargetCameraTrace Type);
	void SetTextureQuality(const EGradualQuality& TextureQuality);
	void SetTextureQualityImmediate(const EGradualQuality& TextureAuality, bool IsApply);
	void SetUseBrainCrash(bool SetValue);
	void SetUseVerticalSync(bool UseVert);
	void SetUseVerticalSyncImmediate(bool UseVert, bool IsApply);
	void SetVoiceLanguage(ETextLanguage Type);
	void SetVoiceVolume(uint8 Volume);
	void SetWindowMode(const EWindowMode& WindowMode);
	void SetWindowModeImmediate(const EWindowMode& WindowMode, bool IsApply);

	EOptionAAQuality GetAntiAliasingQuality() const;
	EAttackAutoLockOn GetAttackAutoLockOn() const;
	uint8 GetBgmVolume() const;
	ECameraAfterMoveType GetCameraAfterMoveType() const;
	EOptionCameraPitch GetCameraPitch() const;
	uint8 GetCameraSpeed() const;
	EOptionCameraYaw GetCameraYaw() const;
	ERSGamepadInputName GetControllerDefaultKey(EChangeableControllerKey TargetKey) const;
	ERSGamepadInputName GetControllerParamValue(EChangeableControllerKey TargetKey) const;
	EOptionControllerVibration GetControllerVibration() const;
	EHCGameDifficulty GetDifficulty() const;
	EOptionDisplayEnemyDamage GetDisplayEnemyDamage() const;
	ETextLanguage GetDisplayLanguage() const;
	EEventMessageAutoPlay GetEventMessageAutoPlay() const;
	EFPSType GetFPSType() const;
	ELockonActionType GetLockonActionType() const;
	EOptionMinimapDisplay GetMinimapDisplay() const;
	EOptionMinimapRotation GetMinimapRotation() const;
	EOptionMinimapScaling GetMinimapScaling() const;
	struct FScreenResolutionSetting GetOldScreenResolution() const;
	EGradualQuality GetPostQuality() const;
	float GetScreenBrightness() const;
	struct FScreenResolutionSetting GetScreenResolution() const;
	ETargetCameraTrace GetSetTargetCameraTrace() const;
	uint8 GetSeVolume() const;
	EGradualQuality GetShadowQuality() const;
	EOptionSoundOutput GetSoundOutput() const;
	ETargetAutoChange GetTargetAutoChange() const;
	EGradualQuality GetTextureQuality() const;
	bool GetUseVerticalSync() const;
	ETextLanguage GetVoiceLanguage() const;
	uint8 GetVoiceVolume() const;
	EWindowMode GetWindowMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionParam">();
	}
	static class UOptionParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionParam>();
	}
};
static_assert(alignof(UOptionParam) == 0x000008, "Wrong alignment on UOptionParam");
static_assert(sizeof(UOptionParam) == 0x000128, "Wrong size on UOptionParam");

// Class BattlePrototype.UIConfigControllerSelectMulti
// 0x00A8 (0x0430 - 0x0388)
class UUIConfigControllerSelectMulti : public UUIBase
{
public:
	uint8                                         Pad_1D4D[0xA8];                                    // 0x0388(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigControllerSelectMulti">();
	}
	static class UUIConfigControllerSelectMulti* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigControllerSelectMulti>();
	}
};
static_assert(alignof(UUIConfigControllerSelectMulti) == 0x000008, "Wrong alignment on UUIConfigControllerSelectMulti");
static_assert(sizeof(UUIConfigControllerSelectMulti) == 0x000430, "Wrong size on UUIConfigControllerSelectMulti");

// Class BattlePrototype.AnimNotify_RSPlayParticleEffect_SASCopyBase
// 0x0000 (0x00D0 - 0x00D0)
class UAnimNotify_RSPlayParticleEffect_SASCopyBase final : public UAnimNotify_RSPlayParticleEffect
{
public:
	bool CheckExecNotify(class USkeletalMeshComponent* MeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RSPlayParticleEffect_SASCopyBase">();
	}
	static class UAnimNotify_RSPlayParticleEffect_SASCopyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RSPlayParticleEffect_SASCopyBase>();
	}
};
static_assert(alignof(UAnimNotify_RSPlayParticleEffect_SASCopyBase) == 0x000010, "Wrong alignment on UAnimNotify_RSPlayParticleEffect_SASCopyBase");
static_assert(sizeof(UAnimNotify_RSPlayParticleEffect_SASCopyBase) == 0x0000D0, "Wrong size on UAnimNotify_RSPlayParticleEffect_SASCopyBase");

// Class BattlePrototype.AnimNotify_RSPlayParticleEffectWithCondition
// 0x0000 (0x00D0 - 0x00D0)
class UAnimNotify_RSPlayParticleEffectWithCondition final : public UAnimNotify_RSPlayParticleEffect
{
public:
	bool CheckCondition(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_RSPlayParticleEffectWithCondition">();
	}
	static class UAnimNotify_RSPlayParticleEffectWithCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_RSPlayParticleEffectWithCondition>();
	}
};
static_assert(alignof(UAnimNotify_RSPlayParticleEffectWithCondition) == 0x000010, "Wrong alignment on UAnimNotify_RSPlayParticleEffectWithCondition");
static_assert(sizeof(UAnimNotify_RSPlayParticleEffectWithCondition) == 0x0000D0, "Wrong size on UAnimNotify_RSPlayParticleEffectWithCondition");

// Class BattlePrototype.DebugSaveDataListWindow
// 0x0008 (0x0238 - 0x0230)
class ADebugSaveDataListWindow final : public AActor
{
public:
	class USaveLoadScreenParamManager*            M_pDebugDebugSaveLoadScreenParamManager;           // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DoNewGame();
	void LoadDebugSaveData(const class FString& Filename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugSaveDataListWindow">();
	}
	static class ADebugSaveDataListWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugSaveDataListWindow>();
	}
};
static_assert(alignof(ADebugSaveDataListWindow) == 0x000008, "Wrong alignment on ADebugSaveDataListWindow");
static_assert(sizeof(ADebugSaveDataListWindow) == 0x000238, "Wrong size on ADebugSaveDataListWindow");
static_assert(offsetof(ADebugSaveDataListWindow, M_pDebugDebugSaveLoadScreenParamManager) == 0x000230, "Member 'ADebugSaveDataListWindow::M_pDebugDebugSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_DirectionControl
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_DirectionControl final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DirectionControl">();
	}
	static class UAnimNotifyState_DirectionControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DirectionControl>();
	}
};
static_assert(alignof(UAnimNotifyState_DirectionControl) == 0x000008, "Wrong alignment on UAnimNotifyState_DirectionControl");
static_assert(sizeof(UAnimNotifyState_DirectionControl) == 0x000030, "Wrong size on UAnimNotifyState_DirectionControl");

// Class BattlePrototype.NormalCaptureComponent
// 0x0038 (0x00F8 - 0x00C0)
class UNormalCaptureComponent final : public UActorComponent
{
public:
	bool                                          bInitialize;                                       // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D51[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TargetTexture;                                     // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D52[0x28];                                    // 0x00D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinalizeTexture();
	class UTexture2D* GetTexture();
	void InitializeTexture(int32 TextureSizeW, int32 TextureSizeH);
	void WriteBoneData(int32 StartPixelX, int32 CharacterIndex, class USkeletalMeshComponent* SkeletalMeshComponent);
	void WriteBoneDataFromAnim(int32 StartPixelX, int32 CharacterIndex, class USkeletalMeshComponent* SkeletalMeshComponent, class UAnimSequence* AnimSequence, float AnimTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NormalCaptureComponent">();
	}
	static class UNormalCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNormalCaptureComponent>();
	}
};
static_assert(alignof(UNormalCaptureComponent) == 0x000008, "Wrong alignment on UNormalCaptureComponent");
static_assert(sizeof(UNormalCaptureComponent) == 0x0000F8, "Wrong size on UNormalCaptureComponent");
static_assert(offsetof(UNormalCaptureComponent, bInitialize) == 0x0000C0, "Member 'UNormalCaptureComponent::bInitialize' has a wrong offset!");
static_assert(offsetof(UNormalCaptureComponent, TargetTexture) == 0x0000C8, "Member 'UNormalCaptureComponent::TargetTexture' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_RSTimedFootStepEffect
// 0x0068 (0x0098 - 0x0030)
class UAnimNotifyState_RSTimedFootStepEffect final : public UAnimNotifyState
{
public:
	TSubclassOf<class URSParticleSystemComponentBase> ComponentClass;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionType;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitSegmentOffset;                                  // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D54[0x3];                                     // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaleOffset;                                       // 0x0050(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OptionSeeThrough;                                  // 0x005D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketLocation;                                    // 0x005E(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketRotation;                                    // 0x0061(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketScale;                                       // 0x0064(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D55[0x1];                                     // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0068(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0070(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x007C(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D56[0x7];                                     // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         M_pParticle;                                       // 0x0090(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTimedFootStepEffect">();
	}
	static class UAnimNotifyState_RSTimedFootStepEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTimedFootStepEffect>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTimedFootStepEffect) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTimedFootStepEffect");
static_assert(sizeof(UAnimNotifyState_RSTimedFootStepEffect) == 0x000098, "Wrong size on UAnimNotifyState_RSTimedFootStepEffect");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, ComponentClass) == 0x000030, "Member 'UAnimNotifyState_RSTimedFootStepEffect::ComponentClass' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, ActionType) == 0x000038, "Member 'UAnimNotifyState_RSTimedFootStepEffect::ActionType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, HitSegmentOffset) == 0x000040, "Member 'UAnimNotifyState_RSTimedFootStepEffect::HitSegmentOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, Ignore) == 0x00004C, "Member 'UAnimNotifyState_RSTimedFootStepEffect::Ignore' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, ScaleOffset) == 0x000050, "Member 'UAnimNotifyState_RSTimedFootStepEffect::ScaleOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, LocationType) == 0x00005C, "Member 'UAnimNotifyState_RSTimedFootStepEffect::LocationType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, OptionSeeThrough) == 0x00005D, "Member 'UAnimNotifyState_RSTimedFootStepEffect::OptionSeeThrough' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, SocketLocation) == 0x00005E, "Member 'UAnimNotifyState_RSTimedFootStepEffect::SocketLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, SocketRotation) == 0x000061, "Member 'UAnimNotifyState_RSTimedFootStepEffect::SocketRotation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, SocketScale) == 0x000064, "Member 'UAnimNotifyState_RSTimedFootStepEffect::SocketScale' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, SocketName) == 0x000068, "Member 'UAnimNotifyState_RSTimedFootStepEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, LocationOffset) == 0x000070, "Member 'UAnimNotifyState_RSTimedFootStepEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, RotationOffset) == 0x00007C, "Member 'UAnimNotifyState_RSTimedFootStepEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, DilationOwner) == 0x000088, "Member 'UAnimNotifyState_RSTimedFootStepEffect::DilationOwner' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedFootStepEffect, M_pParticle) == 0x000090, "Member 'UAnimNotifyState_RSTimedFootStepEffect::M_pParticle' has a wrong offset!");

// Class BattlePrototype.Wp0400AnimInstance
// 0x0320 (0x0590 - 0x0270)
class UWp0400AnimInstance : public UAnimInstance
{
public:
	TWeakObjectPtr<class USceneComponent>         OwnerMeshComponent;                                // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightForeArmLocation;                              // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightForeArmRotation;                              // 0x0284(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightForeArmScale;                                 // 0x0290(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightForeArmRollLocation;                          // 0x029C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightForeArmRollRotation;                          // 0x02A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightForeArmRollScale;                             // 0x02B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandLocation;                                 // 0x02C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRotation;                                 // 0x02CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandScale;                                    // 0x02D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandHelpLocation;                             // 0x02E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandHelpRotation;                             // 0x02F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandHelpScale;                                // 0x02FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb1Location;                           // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandThumb1Rotation;                           // 0x0314(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb1Scale;                              // 0x0320(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb2Location;                           // 0x032C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandThumb2Rotation;                           // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb2Scale;                              // 0x0344(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb3Location;                           // 0x0350(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandThumb3Rotation;                           // 0x035C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandThumb3Scale;                              // 0x0368(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex1Location;                           // 0x0374(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandIndex1Rotation;                           // 0x0380(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex1Scale;                              // 0x038C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex2Location;                           // 0x0398(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandIndex2Rotation;                           // 0x03A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex2Scale;                              // 0x03B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex3Location;                           // 0x03BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandIndex3Rotation;                           // 0x03C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIndex3Scale;                              // 0x03D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddleLocation;                           // 0x03E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandMiddleRotation;                           // 0x03EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddleScale;                              // 0x03F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle1Location;                          // 0x0404(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandMiddle1Rotation;                          // 0x0410(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle1Scale;                             // 0x041C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle2Location;                          // 0x0428(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandMiddle2Rotation;                          // 0x0434(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle2Scale;                             // 0x0440(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle3Location;                          // 0x044C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandMiddle3Rotation;                          // 0x0458(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandMiddle3Scale;                             // 0x0464(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRingLocation;                             // 0x0470(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRingRotation;                             // 0x047C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRingScale;                                // 0x0488(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing1ocation;                             // 0x0494(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRing1Rotation;                            // 0x04A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing1Scale;                               // 0x04AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing2Location;                            // 0x04B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRing2Rotation;                            // 0x04C4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing2Scale;                               // 0x04D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing3Location;                            // 0x04DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRing3Rotation;                            // 0x04E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandRing3Scale;                               // 0x04F4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinkyLocation;                            // 0x0500(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandPinkyRotation;                            // 0x050C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinkyScale;                               // 0x0518(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky1Location;                           // 0x0524(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandPinky1Rotation;                           // 0x0530(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky1Scale;                              // 0x053C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky2Location;                           // 0x0548(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandPinky2Rotation;                           // 0x0554(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky2Scale;                              // 0x0560(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky3Location;                           // 0x056C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandPinky3Rotation;                           // 0x0578(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandPinky3Scale;                              // 0x0584(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Wp0400AnimInstance">();
	}
	static class UWp0400AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWp0400AnimInstance>();
	}
};
static_assert(alignof(UWp0400AnimInstance) == 0x000010, "Wrong alignment on UWp0400AnimInstance");
static_assert(sizeof(UWp0400AnimInstance) == 0x000590, "Wrong size on UWp0400AnimInstance");
static_assert(offsetof(UWp0400AnimInstance, OwnerMeshComponent) == 0x000270, "Member 'UWp0400AnimInstance::OwnerMeshComponent' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmLocation) == 0x000278, "Member 'UWp0400AnimInstance::RightForeArmLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmRotation) == 0x000284, "Member 'UWp0400AnimInstance::RightForeArmRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmScale) == 0x000290, "Member 'UWp0400AnimInstance::RightForeArmScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmRollLocation) == 0x00029C, "Member 'UWp0400AnimInstance::RightForeArmRollLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmRollRotation) == 0x0002A8, "Member 'UWp0400AnimInstance::RightForeArmRollRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightForeArmRollScale) == 0x0002B4, "Member 'UWp0400AnimInstance::RightForeArmRollScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandLocation) == 0x0002C0, "Member 'UWp0400AnimInstance::RightHandLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRotation) == 0x0002CC, "Member 'UWp0400AnimInstance::RightHandRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandScale) == 0x0002D8, "Member 'UWp0400AnimInstance::RightHandScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandHelpLocation) == 0x0002E4, "Member 'UWp0400AnimInstance::RightHandHelpLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandHelpRotation) == 0x0002F0, "Member 'UWp0400AnimInstance::RightHandHelpRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandHelpScale) == 0x0002FC, "Member 'UWp0400AnimInstance::RightHandHelpScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb1Location) == 0x000308, "Member 'UWp0400AnimInstance::RightHandThumb1Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb1Rotation) == 0x000314, "Member 'UWp0400AnimInstance::RightHandThumb1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb1Scale) == 0x000320, "Member 'UWp0400AnimInstance::RightHandThumb1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb2Location) == 0x00032C, "Member 'UWp0400AnimInstance::RightHandThumb2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb2Rotation) == 0x000338, "Member 'UWp0400AnimInstance::RightHandThumb2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb2Scale) == 0x000344, "Member 'UWp0400AnimInstance::RightHandThumb2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb3Location) == 0x000350, "Member 'UWp0400AnimInstance::RightHandThumb3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb3Rotation) == 0x00035C, "Member 'UWp0400AnimInstance::RightHandThumb3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandThumb3Scale) == 0x000368, "Member 'UWp0400AnimInstance::RightHandThumb3Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex1Location) == 0x000374, "Member 'UWp0400AnimInstance::RightHandIndex1Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex1Rotation) == 0x000380, "Member 'UWp0400AnimInstance::RightHandIndex1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex1Scale) == 0x00038C, "Member 'UWp0400AnimInstance::RightHandIndex1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex2Location) == 0x000398, "Member 'UWp0400AnimInstance::RightHandIndex2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex2Rotation) == 0x0003A4, "Member 'UWp0400AnimInstance::RightHandIndex2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex2Scale) == 0x0003B0, "Member 'UWp0400AnimInstance::RightHandIndex2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex3Location) == 0x0003BC, "Member 'UWp0400AnimInstance::RightHandIndex3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex3Rotation) == 0x0003C8, "Member 'UWp0400AnimInstance::RightHandIndex3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandIndex3Scale) == 0x0003D4, "Member 'UWp0400AnimInstance::RightHandIndex3Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddleLocation) == 0x0003E0, "Member 'UWp0400AnimInstance::RightHandMiddleLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddleRotation) == 0x0003EC, "Member 'UWp0400AnimInstance::RightHandMiddleRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddleScale) == 0x0003F8, "Member 'UWp0400AnimInstance::RightHandMiddleScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle1Location) == 0x000404, "Member 'UWp0400AnimInstance::RightHandMiddle1Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle1Rotation) == 0x000410, "Member 'UWp0400AnimInstance::RightHandMiddle1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle1Scale) == 0x00041C, "Member 'UWp0400AnimInstance::RightHandMiddle1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle2Location) == 0x000428, "Member 'UWp0400AnimInstance::RightHandMiddle2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle2Rotation) == 0x000434, "Member 'UWp0400AnimInstance::RightHandMiddle2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle2Scale) == 0x000440, "Member 'UWp0400AnimInstance::RightHandMiddle2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle3Location) == 0x00044C, "Member 'UWp0400AnimInstance::RightHandMiddle3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle3Rotation) == 0x000458, "Member 'UWp0400AnimInstance::RightHandMiddle3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandMiddle3Scale) == 0x000464, "Member 'UWp0400AnimInstance::RightHandMiddle3Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRingLocation) == 0x000470, "Member 'UWp0400AnimInstance::RightHandRingLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRingRotation) == 0x00047C, "Member 'UWp0400AnimInstance::RightHandRingRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRingScale) == 0x000488, "Member 'UWp0400AnimInstance::RightHandRingScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing1ocation) == 0x000494, "Member 'UWp0400AnimInstance::RightHandRing1ocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing1Rotation) == 0x0004A0, "Member 'UWp0400AnimInstance::RightHandRing1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing1Scale) == 0x0004AC, "Member 'UWp0400AnimInstance::RightHandRing1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing2Location) == 0x0004B8, "Member 'UWp0400AnimInstance::RightHandRing2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing2Rotation) == 0x0004C4, "Member 'UWp0400AnimInstance::RightHandRing2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing2Scale) == 0x0004D0, "Member 'UWp0400AnimInstance::RightHandRing2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing3Location) == 0x0004DC, "Member 'UWp0400AnimInstance::RightHandRing3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing3Rotation) == 0x0004E8, "Member 'UWp0400AnimInstance::RightHandRing3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandRing3Scale) == 0x0004F4, "Member 'UWp0400AnimInstance::RightHandRing3Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinkyLocation) == 0x000500, "Member 'UWp0400AnimInstance::RightHandPinkyLocation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinkyRotation) == 0x00050C, "Member 'UWp0400AnimInstance::RightHandPinkyRotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinkyScale) == 0x000518, "Member 'UWp0400AnimInstance::RightHandPinkyScale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky1Location) == 0x000524, "Member 'UWp0400AnimInstance::RightHandPinky1Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky1Rotation) == 0x000530, "Member 'UWp0400AnimInstance::RightHandPinky1Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky1Scale) == 0x00053C, "Member 'UWp0400AnimInstance::RightHandPinky1Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky2Location) == 0x000548, "Member 'UWp0400AnimInstance::RightHandPinky2Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky2Rotation) == 0x000554, "Member 'UWp0400AnimInstance::RightHandPinky2Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky2Scale) == 0x000560, "Member 'UWp0400AnimInstance::RightHandPinky2Scale' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky3Location) == 0x00056C, "Member 'UWp0400AnimInstance::RightHandPinky3Location' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky3Rotation) == 0x000578, "Member 'UWp0400AnimInstance::RightHandPinky3Rotation' has a wrong offset!");
static_assert(offsetof(UWp0400AnimInstance, RightHandPinky3Scale) == 0x000584, "Member 'UWp0400AnimInstance::RightHandPinky3Scale' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_RSTimedParticleSystem
// 0x0028 (0x0088 - 0x0060)
class UAnimNotifyState_RSTimedParticleSystem : public UAnimNotifyState_TimedParticleEffect
{
public:
	TSubclassOf<class URSParticleSystemComponentBase> ComponentClass;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D57[0x3];                                     // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaleOffset;                                       // 0x006C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OptionSeeThrough;                                  // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRegistToChara;                                   // 0x007A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptTelepo;                                 // 0x007B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketLocation;                                    // 0x007C(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketRotation;                                    // 0x007F(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ERSParticleSystemAttachRotationOffMode        SocketRotationOffMode;                             // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            SocketScale;                                       // 0x0083(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x0086(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D58[0x1];                                     // 0x0087(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTimedParticleSystem">();
	}
	static class UAnimNotifyState_RSTimedParticleSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTimedParticleSystem>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTimedParticleSystem) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTimedParticleSystem");
static_assert(sizeof(UAnimNotifyState_RSTimedParticleSystem) == 0x000088, "Wrong size on UAnimNotifyState_RSTimedParticleSystem");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, ComponentClass) == 0x000060, "Member 'UAnimNotifyState_RSTimedParticleSystem::ComponentClass' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, Ignore) == 0x000068, "Member 'UAnimNotifyState_RSTimedParticleSystem::Ignore' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, ScaleOffset) == 0x00006C, "Member 'UAnimNotifyState_RSTimedParticleSystem::ScaleOffset' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, LocationType) == 0x000078, "Member 'UAnimNotifyState_RSTimedParticleSystem::LocationType' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, OptionSeeThrough) == 0x000079, "Member 'UAnimNotifyState_RSTimedParticleSystem::OptionSeeThrough' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, IsRegistToChara) == 0x00007A, "Member 'UAnimNotifyState_RSTimedParticleSystem::IsRegistToChara' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, IsInterruptTelepo) == 0x00007B, "Member 'UAnimNotifyState_RSTimedParticleSystem::IsInterruptTelepo' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, SocketLocation) == 0x00007C, "Member 'UAnimNotifyState_RSTimedParticleSystem::SocketLocation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, SocketRotation) == 0x00007F, "Member 'UAnimNotifyState_RSTimedParticleSystem::SocketRotation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, SocketRotationOffMode) == 0x000082, "Member 'UAnimNotifyState_RSTimedParticleSystem::SocketRotationOffMode' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, SocketScale) == 0x000083, "Member 'UAnimNotifyState_RSTimedParticleSystem::SocketScale' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTimedParticleSystem, DilationOwner) == 0x000086, "Member 'UAnimNotifyState_RSTimedParticleSystem::DilationOwner' has a wrong offset!");

// Class BattlePrototype.UIConfigController
// 0x0180 (0x0508 - 0x0388)
class UUIConfigController : public UUIBase
{
public:
	float                                         LineHeight;                                        // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D59[0x17C];                                   // 0x038C(0x017C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UREDScrollBoxSimple* ScrollBox, class UUIConfigControllerSelectMulti* IndexAttack, class UUIConfigControllerSelectMulti* IndexJump, class UUIConfigControllerSelectMulti* IndexStep_Dash, class UUIConfigControllerSelectMulti* IndexSpecialAttack, class UUIConfigControllerSelectMulti* IndexSAS_Menu_OpenClose, class UUIConfigControllerSelectMulti* IndexCV_Menu_OpenClose, class UUIConfigControllerSelectMulti* IndexPsychokinesis_Low, class UUIConfigControllerSelectMulti* IndexPsychokinesis_High, class UUIConfigControllerSelectMulti* IndexAutoTargetSwitching, class UUIConfigControllerSelectMulti* IndexSAS_CV_PageSwitch, class UUIConfigControllerSelect* IndexMoveFront, class UUIConfigControllerSelect* IndexMoveBack, class UUIConfigControllerSelect* IndexMoveLeft, class UUIConfigControllerSelect* IndexMoveRight, class UUIConfigControllerSelect* IndexAction, class UUIConfigControllerSelect* IndexAction2, class UUIConfigControllerSelect* IndexPsychicField, class UUIConfigControllerSelect* IndexAssaultVision, class UUIConfigControllerSelect* IndexExecuteBrainDrive, class UUIConfigControllerSelect* IndexCameraUp, class UUIConfigControllerSelect* IndexCameraDown, class UUIConfigControllerSelect* IndexCameraLeft, class UUIConfigControllerSelect* IndexCameraRight, class UUIConfigControllerSelect* IndexLockOn, class UUIConfigControllerSelect* IndexExecuteSAS1, class UUIConfigControllerSelect* IndexExecuteSAS2, class UUIConfigControllerSelect* IndexExecuteSAS3, class UUIConfigControllerSelect* IndexExecuteSAS4, class UUIConfigControllerSelect* IndexStopSAS, class UUIConfigControllerSelect* IndexExecuteCV1, class UUIConfigControllerSelect* IndexExecuteCV2, class UUIConfigControllerSelect* IndexExecuteCV3, class UUIConfigControllerSelect* IndexExecuteCV4, class UUIConfigControllerSelect* IndexItemSelectL, class UUIConfigControllerSelect* IndexItemSelectR, class UUIConfigControllerSelect* IndexUseItem, class UUIConfigControllerSelect* IndexCampMenu, class UUIConfigControllerSelect* IndexDetailMap, class UUIConfigControllerSelect* IndexWorldMap, class UUIConfigControllerSelect* IndexBrainMessage, class UUIConfigControllerSelect* IndexPhotoMode);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigController">();
	}
	static class UUIConfigController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigController>();
	}
};
static_assert(alignof(UUIConfigController) == 0x000008, "Wrong alignment on UUIConfigController");
static_assert(sizeof(UUIConfigController) == 0x000508, "Wrong size on UUIConfigController");
static_assert(offsetof(UUIConfigController, LineHeight) == 0x000388, "Member 'UUIConfigController::LineHeight' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_RSTimedParticleSystem_SASCopyBase
// 0x0000 (0x0088 - 0x0088)
class UAnimNotifyState_RSTimedParticleSystem_SASCopyBase final : public UAnimNotifyState_RSTimedParticleSystem
{
public:
	bool CheckExecNotifyBegin(class USkeletalMeshComponent* MeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTimedParticleSystem_SASCopyBase">();
	}
	static class UAnimNotifyState_RSTimedParticleSystem_SASCopyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTimedParticleSystem_SASCopyBase>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTimedParticleSystem_SASCopyBase) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTimedParticleSystem_SASCopyBase");
static_assert(sizeof(UAnimNotifyState_RSTimedParticleSystem_SASCopyBase) == 0x000088, "Wrong size on UAnimNotifyState_RSTimedParticleSystem_SASCopyBase");

// Class BattlePrototype.DamageCalcInterface
// 0x0000 (0x0028 - 0x0028)
class IDamageCalcInterface final : public IInterface
{
public:
	bool CalcAccumulationByAttack(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, float& RefCrashCapCheckRate, class AActor* DefenseActor, EHCSkillAttackType AttackType, bool bCopyActor, const struct FHCSkillCommonInfo& SkillInfo);
	bool CalcAccumulationByDefence(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, float& RefCrashCapCheckRate, class AActor* AttackActor);
	float CalcCritical(float Critical, class AActor* DefenseActor, bool bAssassinAttack);
	bool CalcDamageByAttack(float& RefPhysicsDamage, float& RefObjDamage, float& RefFlameDamage, float& RefElectricDamage, float& RefCriticalDamageRate, class AActor* DefenseActor);
	bool CalcDamageByDefence(float& RefPhysicsDamage, float& RefObjDamage, float& RefFlameDamage, float& RefElectricDamage, float& RefCriticalDamageRate, class AActor* AttackActor);
	bool CalcDefence(float& RefPhysicsDefence, float& RefObjDefence, float& RefFlameDefence, float& RefElectricPhysics);
	float CalcFinalDamageByAttack(float Damage, class AActor* DefenseActor, const struct FHCSkillCommonInfo& SkillInfo);
	float CalcFinalDamageByDefence(float Damage, class AActor* AttackActor);
	struct FCharactersParameterTable GetCharactersParameterTableInterface();
	float GetMaxCrashScaleLimit();
	float GetMaxDamageRateLimit();
	bool IsIgnoreCritical();
	bool IsPsychicFieldDamageRateToBoss();
	bool OverwriteAttackCollisionInfo(struct FHCCollisionCommonInfo& RefCommonInfo, struct FHCSkillCommonInfo& RefSkill);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageCalcInterface">();
	}
	static class IDamageCalcInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageCalcInterface>();
	}
};
static_assert(alignof(IDamageCalcInterface) == 0x000008, "Wrong alignment on IDamageCalcInterface");
static_assert(sizeof(IDamageCalcInterface) == 0x000028, "Wrong size on IDamageCalcInterface");

// Class BattlePrototype.AnimNotifyState_RSTimedParticleSystemWithCondition
// 0x0000 (0x0088 - 0x0088)
class UAnimNotifyState_RSTimedParticleSystemWithCondition final : public UAnimNotifyState_RSTimedParticleSystem
{
public:
	bool CheckCondition(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTimedParticleSystemWithCondition">();
	}
	static class UAnimNotifyState_RSTimedParticleSystemWithCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTimedParticleSystemWithCondition>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTimedParticleSystemWithCondition) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTimedParticleSystemWithCondition");
static_assert(sizeof(UAnimNotifyState_RSTimedParticleSystemWithCondition) == 0x000088, "Wrong size on UAnimNotifyState_RSTimedParticleSystemWithCondition");

// Class BattlePrototype.AnimNotifyState_RSTrail
// 0x0040 (0x0098 - 0x0058)
class UAnimNotifyState_RSTrail final : public UAnimNotifyState_Trail
{
public:
	uint8                                         Pad_1D6D[0x1];                                     // 0x0058(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayerCopyMode;                                   // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOriginal;                                   // 0x005A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCopy;                                       // 0x005B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D6E[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URSParticleSystemComponentBase> ComponentClass;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore;                                            // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D6F[0x7];                                     // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleComponentListManager*          ParticleComponentManager;                          // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WidthScale;                                        // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutStart;                                      // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FadeOutMaterialScalarName;                         // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OptionSeeThrough;                                  // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x0089(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRegistToChara;                                   // 0x008A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptTelepo;                                 // 0x008B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D70[0xC];                                     // 0x008C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RSTrail">();
	}
	static class UAnimNotifyState_RSTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RSTrail>();
	}
};
static_assert(alignof(UAnimNotifyState_RSTrail) == 0x000008, "Wrong alignment on UAnimNotifyState_RSTrail");
static_assert(sizeof(UAnimNotifyState_RSTrail) == 0x000098, "Wrong size on UAnimNotifyState_RSTrail");
static_assert(offsetof(UAnimNotifyState_RSTrail, bPlayerCopyMode) == 0x000059, "Member 'UAnimNotifyState_RSTrail::bPlayerCopyMode' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, bIgnoreOriginal) == 0x00005A, "Member 'UAnimNotifyState_RSTrail::bIgnoreOriginal' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, bIgnoreCopy) == 0x00005B, "Member 'UAnimNotifyState_RSTrail::bIgnoreCopy' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, ComponentClass) == 0x000060, "Member 'UAnimNotifyState_RSTrail::ComponentClass' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, Ignore) == 0x000068, "Member 'UAnimNotifyState_RSTrail::Ignore' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, ParticleComponentManager) == 0x000070, "Member 'UAnimNotifyState_RSTrail::ParticleComponentManager' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, WidthScale) == 0x000078, "Member 'UAnimNotifyState_RSTrail::WidthScale' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, FadeOutStart) == 0x00007C, "Member 'UAnimNotifyState_RSTrail::FadeOutStart' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, FadeOutMaterialScalarName) == 0x000080, "Member 'UAnimNotifyState_RSTrail::FadeOutMaterialScalarName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, OptionSeeThrough) == 0x000088, "Member 'UAnimNotifyState_RSTrail::OptionSeeThrough' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, DilationOwner) == 0x000089, "Member 'UAnimNotifyState_RSTrail::DilationOwner' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, IsRegistToChara) == 0x00008A, "Member 'UAnimNotifyState_RSTrail::IsRegistToChara' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_RSTrail, IsInterruptTelepo) == 0x00008B, "Member 'UAnimNotifyState_RSTrail::IsInterruptTelepo' has a wrong offset!");

// Class BattlePrototype.DetailedMapData
// 0x0008 (0x0030 - 0x0028)
class UDetailedMapData final : public UObject
{
public:
	class UDetailedMapDBAsset*                    DetailedMapAsset_;                                 // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetDetailedMapAreaData(class FName LocationName, class FName AreaName, TArray<struct FDetailedMapContentFloorDataCell>* RDetailedMapArea);
	void GetDetailedMapDataAsset(TMap<class FName, struct FDetailedMapDBDataCell>* RDetailedMap);
	void GetDetailedMapLocationData(class FName LocationName, TMap<class FName, struct FDetailedMapContentFloorDataArrayCell>* RDetailedMapLocation);
	bool LoadDataAsset(const class FString& DtPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetailedMapData">();
	}
	static class UDetailedMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetailedMapData>();
	}
};
static_assert(alignof(UDetailedMapData) == 0x000008, "Wrong alignment on UDetailedMapData");
static_assert(sizeof(UDetailedMapData) == 0x000030, "Wrong size on UDetailedMapData");
static_assert(offsetof(UDetailedMapData, DetailedMapAsset_) == 0x000028, "Member 'UDetailedMapData::DetailedMapAsset_' has a wrong offset!");

// Class BattlePrototype.AnimNotifyState_SuperArmor
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_SuperArmor final : public UAnimNotifyState
{
public:
	int32                                         ResistStagger;                                     // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D72[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SuperArmor">();
	}
	static class UAnimNotifyState_SuperArmor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SuperArmor>();
	}
};
static_assert(alignof(UAnimNotifyState_SuperArmor) == 0x000008, "Wrong alignment on UAnimNotifyState_SuperArmor");
static_assert(sizeof(UAnimNotifyState_SuperArmor) == 0x000038, "Wrong size on UAnimNotifyState_SuperArmor");
static_assert(offsetof(UAnimNotifyState_SuperArmor, ResistStagger) == 0x000030, "Member 'UAnimNotifyState_SuperArmor::ResistStagger' has a wrong offset!");

// Class BattlePrototype.NpcManager
// 0x0048 (0x0070 - 0x0028)
class UNpcManager final : public UObject
{
public:
	TArray<class ANpcBase*>                       Npcs;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ANpcTownPeopleBase*>             NpcTowns;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASavePointBase*>                 SavePoints;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ANpcShopBase*>                   ShopNpcs;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATownPeopleManager*                     TownPeopleTickManager;                             // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize(const class UObject* WorldContextObject);
	void OnBattleModeChange(class URSGameInstance* GameInstance, const bool bBattle);
	void RegisterNpc(class ANpcBase* NPC);
	void RegisterNpcTown(class ANpcTownPeopleBase* NPC);
	void RegisterSavePoint(class ASavePointBase* SavePoint);
	void RegisterShopNpc(class ANpcShopBase* ShopNpc);
	void SetVisibleAndTickNpcTopwnAll(bool bVisible);
	void UnregisterNpc(class ANpcBase* NPC);
	void UnregisterNpcAll();
	void UnregisterNpcTown(class ANpcTownPeopleBase* NPC);
	void UnregisterNpcTownAll();
	void UnregisterSavePoint(class ASavePointBase* SavePoint);
	void UnregisterSavePointAll();
	void UnregisterShopNpc(class ANpcShopBase* ShopNpc);
	void UnregisterShopNpcAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcManager">();
	}
	static class UNpcManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcManager>();
	}
};
static_assert(alignof(UNpcManager) == 0x000008, "Wrong alignment on UNpcManager");
static_assert(sizeof(UNpcManager) == 0x000070, "Wrong size on UNpcManager");
static_assert(offsetof(UNpcManager, Npcs) == 0x000028, "Member 'UNpcManager::Npcs' has a wrong offset!");
static_assert(offsetof(UNpcManager, NpcTowns) == 0x000038, "Member 'UNpcManager::NpcTowns' has a wrong offset!");
static_assert(offsetof(UNpcManager, SavePoints) == 0x000048, "Member 'UNpcManager::SavePoints' has a wrong offset!");
static_assert(offsetof(UNpcManager, ShopNpcs) == 0x000058, "Member 'UNpcManager::ShopNpcs' has a wrong offset!");
static_assert(offsetof(UNpcManager, TownPeopleTickManager) == 0x000068, "Member 'UNpcManager::TownPeopleTickManager' has a wrong offset!");

// Class BattlePrototype.AnyObjectCreator
// 0x0030 (0x0058 - 0x0028)
class UAnyObjectCreator final : public UObject
{
public:
	TSubclassOf<class AActor>                     SpawnClass;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 SpawnObject;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSuccessConstruct;                                 // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D74[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LoadAssetName;                                     // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                LoadedObject;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyObjectCreator">();
	}
	static class UAnyObjectCreator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyObjectCreator>();
	}
};
static_assert(alignof(UAnyObjectCreator) == 0x000008, "Wrong alignment on UAnyObjectCreator");
static_assert(sizeof(UAnyObjectCreator) == 0x000058, "Wrong size on UAnyObjectCreator");
static_assert(offsetof(UAnyObjectCreator, SpawnClass) == 0x000028, "Member 'UAnyObjectCreator::SpawnClass' has a wrong offset!");
static_assert(offsetof(UAnyObjectCreator, SpawnObject) == 0x000030, "Member 'UAnyObjectCreator::SpawnObject' has a wrong offset!");
static_assert(offsetof(UAnyObjectCreator, bSuccessConstruct) == 0x000038, "Member 'UAnyObjectCreator::bSuccessConstruct' has a wrong offset!");
static_assert(offsetof(UAnyObjectCreator, LoadAssetName) == 0x000040, "Member 'UAnyObjectCreator::LoadAssetName' has a wrong offset!");
static_assert(offsetof(UAnyObjectCreator, LoadedObject) == 0x000050, "Member 'UAnyObjectCreator::LoadedObject' has a wrong offset!");

// Class BattlePrototype.PlayerCameraComponent
// 0x1450 (0x1520 - 0x00D0)
class UPlayerCameraComponent : public URSAsyncTaskActorComponent
{
public:
	TWeakObjectPtr<class UUserParamManager>       PUserParamManager;                                 // 0x00D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDeltaSecond;                                      // 0x00D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaleOwner;                                        // 0x00DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaleOwnerCheck;                                   // 0x00DD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraMode                             CameraMode;                                        // 0x00DE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraLookAtMode                       LookAtMode;                                        // 0x00DF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           PCameraActor;                                      // 0x00E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  PRootActor;                                        // 0x00E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      PRootActorCapsule;                                 // 0x00F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootActorCapsuleHeight;                            // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D75[0x4];                                     // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerScriptComponent*                 PRootActorPlayerScript;                            // 0x0100(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VRootActorPos;                                     // 0x0108(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VRootActorMove;                                    // 0x0114(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckRootPosType;                                 // 0x0120(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckRootPosMidCheck;                             // 0x0121(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D76[0x2];                                     // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FAspectRatio;                                      // 0x0124(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAspectRateVt;                                     // 0x0128(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAspectRateHz;                                     // 0x012C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DtActionParameter;                                 // 0x0130(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DtOptionParameter;                                 // 0x0138(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D77[0x3];                                     // 0x0140(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWorkPosPlayer;                                    // 0x0143(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                VWorkPosPlayer;                                    // 0x0144(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWorkPosRemote;                                    // 0x0150(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D78[0x3];                                     // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VWorkPosRemote;                                    // 0x0154(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActionResetApply;                                 // 0x0160(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D79[0x3];                                     // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FActionResetLerpTime;                              // 0x0164(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetLerpTimer;                             // 0x0168(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetKeepTime;                              // 0x016C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetKeepTimer;                             // 0x0170(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetLerpAngleStt;                          // 0x0174(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FActionResetLerpAngleEnd;                          // 0x0178(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintActionReset;                            // 0x017C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementDelay;                                    // 0x017D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryCameraEnable;                            // 0x017E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7A[0x1];                                     // 0x017F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TemporaryCameraRefName;                            // 0x0180(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraActionPriority                   TemporaryCameraPriority;                           // 0x0190(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryCameraApply;                             // 0x0191(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryRootOffsetApply;                         // 0x0192(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryRootOffsetNoRotate;                      // 0x0193(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TemporaryRootOffset;                               // 0x0194(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryDistanceOffsetApply;                     // 0x01A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7B[0x3];                                     // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TemporaryDistanceOffset;                           // 0x01A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryFovApply;                                // 0x01A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7C[0x3];                                     // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TemporaryFov;                                      // 0x01AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemporaryLockOnRate;                               // 0x01B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemporaryOptionSkipInput;                          // 0x01B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemporaryOptionSkipReturn;                         // 0x01B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TemporaryOptionSkipKeepAngle;                      // 0x01BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7D[0x3D];                                    // 0x01C0(0x003D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugTemporaryUseNew;                             // 0x01FD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintTemporary;                              // 0x01FE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistEnable;                                // 0x01FF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistSkip;                                  // 0x0200(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistAsyncRequestPrevProc;                  // 0x0201(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistAsyncRequestTaskProc;                  // 0x0202(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistAsyncRequestTaskDone;                  // 0x0203(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlopeAssistCheckNum;                               // 0x0204(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckInterval;                          // 0x0208(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckIntervalAngle;                     // 0x020C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleVtMax;                        // 0x0210(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleVtStt;                        // 0x0214(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleVtEnd;                        // 0x0218(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistCheckAngleHz;                           // 0x021C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VSlopeAssistMoveDirection;                         // 0x0220(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VSlopeAssistMoveDirectionHz;                       // 0x022C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistSkipMoveDir;                           // 0x0238(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistLerpApply;                             // 0x0239(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7E[0x2];                                     // 0x023A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeAssistLerpRate;                               // 0x023C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VSlopeAssistLerpVector;                            // 0x0240(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistLerpAngleVt;                            // 0x024C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistDelayTime;                              // 0x0250(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistDelayTimer;                             // 0x0254(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistCheckBgEnable;                         // 0x0258(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7F[0x3];                                     // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlopeAssistCheckBgOffset;                          // 0x025C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistFixAngleEnable;                        // 0x0268(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D80[0x3];                                     // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeAssistFixAngleInterval;                       // 0x026C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistFixAngleRange;                          // 0x0270(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlopeAssistSpeedLerpEnable;                       // 0x0274(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D81[0x3];                                     // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeAssistSpeedLerpMin;                           // 0x0278(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistSpeedLerpMax;                           // 0x027C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistSpeedLerpRateMax;                       // 0x0280(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeAssistSpeedLerpRate;                          // 0x0284(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 SlopeAssistResultAngleList;                        // 0x0288(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D82[0xD0];                                    // 0x0298(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugSlopeAssistSyncApply;                        // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintSlopeAssist;                            // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawSlopeAssistVector;                       // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawSlopeAssistCheckPoint;                   // 0x036B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawSlopeAssistCheckHit;                     // 0x036C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D83[0x33];                                    // 0x036D(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugPrintDistance;                               // 0x03A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTraceHit;                                    // 0x03A1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputEnable;                                      // 0x03A2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D84[0x1];                                     // 0x03A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FInputLtX;                                         // 0x03A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FInputLtY;                                         // 0x03A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FInputRtX;                                         // 0x03AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FInputRtY;                                         // 0x03B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputLt;                                          // 0x03B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputRt;                                          // 0x03B5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputUp;                                          // 0x03B6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputDn;                                          // 0x03B7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInputAngle;                                       // 0x03B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnCheckEnable;                                  // 0x03B9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D85[0x2];                                     // 0x03BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VTurnCheckOffsetUpStt;                             // 0x03BC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetUpEnd;                             // 0x03C8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetDnStt;                             // 0x03D4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetDnEnd;                             // 0x03E0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetLtStt;                             // 0x03EC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetLtEnd;                             // 0x03F8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetRtStt;                             // 0x0404(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VTurnCheckOffsetRtEnd;                             // 0x0410(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnCheckReturnEnable;                            // 0x041C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D86[0x3];                                     // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FTurnCheckReturnTime;                              // 0x0420(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D87[0x84];                                    // 0x0424(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugTurnCheckFlag1;                              // 0x04A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTurnCheckDrawCt;                             // 0x04A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTurnCheckDrawCtRay;                          // 0x04AA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D88[0x1];                                     // 0x04AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FDefaultFov;                                       // 0x04AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDefaultOffset;                                    // 0x04B0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDefaultOffsetWall;                                // 0x04BC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDefaultAngleVt;                                   // 0x04C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDefaultAngleHz;                                   // 0x04CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDefaultDistance;                                  // 0x04D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDefaultDistanceMin;                               // 0x04D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCurrentFov;                                       // 0x04D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCurrentAngleVt;                                   // 0x04DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCurrentAngleHz;                                   // 0x04E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCurrentDistance;                                  // 0x04E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VCurrentRoot;                                      // 0x04E8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VCurrentPos;                                       // 0x04F4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VCurrentLookAt;                                    // 0x0500(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VCurrentDir;                                       // 0x050C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RCurrentRot;                                       // 0x0518(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FDestinationAngleVt;                               // 0x0524(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDestinationAngleHz;                               // 0x0528(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDestinationDistance;                              // 0x052C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDestinationRoot;                                  // 0x0530(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDestinationPos;                                   // 0x053C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VDestinationDir;                                   // 0x0548(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RDestinationRot;                                   // 0x0554(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FDestinationRootRateOptionParamList;               // 0x0560(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawDestinationRootList;                     // 0x0570(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleOffsetEnable;                               // 0x0571(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleOffset;                                     // 0x0572(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleOffsetLerp;                                 // 0x0573(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleOffsetLerpSign;                             // 0x0574(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D89[0x3];                                     // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FBattleOffsetTime;                                 // 0x0578(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8A[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PBattleOffsetLerpCurve;                            // 0x0580(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FBattleOffsetTimer;                                // 0x0588(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FBattleOffsetLerpRate;                             // 0x058C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FBattleOffsetDistanceLerp;                         // 0x0590(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VBattleOffsetRootPosLerp;                          // 0x0594(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FBattleOffsetDistance;                             // 0x05A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VBattleOffsetRootPos;                              // 0x05A4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintBattleOffset;                           // 0x05B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockRootPosEnable;                                // 0x05B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockRootPosSkip;                                  // 0x05B2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8B[0x1];                                     // 0x05B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FRestoreRootPosLerpRate;                           // 0x05B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockRootPosDistance;                              // 0x05B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRestoreRootPosDistance;                           // 0x05BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VPrevRootPos;                                      // 0x05C0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockRootPos;                            // 0x05CC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8C[0x3];                                     // 0x05CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VPlayerInputMove;                                  // 0x05D0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootLerpEnable;                                   // 0x05DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8D[0x3];                                     // 0x05DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FRootLerpValueDefault;                             // 0x05E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8E[0x4];                                     // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FRootLerpValueDefaultOptionParamList;              // 0x05E8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpValueDefaultApplyOption;                  // 0x05F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpValueAction;                              // 0x05FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpValue;                                    // 0x0600(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpValueVt;                                  // 0x0604(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceDefault;                          // 0x0608(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceAction;                           // 0x060C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistance;                                 // 0x0610(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceWork;                             // 0x0614(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceMin;                              // 0x0618(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceTarget;                           // 0x061C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDistanceMove;                             // 0x0620(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootLerpActionLerp;                               // 0x0624(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8F[0x3];                                     // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RootLerpActionRefName;                             // 0x0628(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCameraActionPriority                   RootLerpActionPriority;                            // 0x0638(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D90[0x3];                                     // 0x0639(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FRootLerpActionLerpRate;                           // 0x063C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D91[0x14];                                    // 0x0640(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRootLerpAngleEnable;                              // 0x0654(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D92[0x3];                                     // 0x0655(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PRootLerpDirCurve;                                 // 0x0658(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDirLerpRate;                              // 0x0660(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpDirLerpRateMin;                           // 0x0664(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpMoveLerpValue;                            // 0x0668(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpMoveLerpRate;                             // 0x066C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpMoveLerpRateMin;                          // 0x0670(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpAngleLerpRate;                            // 0x0674(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FRootLerpAngleRate;                                // 0x0678(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootLerpCamDistEnable;                            // 0x067C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D93[0x3];                                     // 0x067D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FRootLerpCamDistRate;                              // 0x0680(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintRootLerp;                               // 0x0684(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintRootLerpAction;                         // 0x0685(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D94[0x2];                                     // 0x0686(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FSpinSpeedMaxHz;                                   // 0x0688(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinAccelHz;                                      // 0x068C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinDecelHz;                                      // 0x0690(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinDirectionHz;                                  // 0x0694(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinSpeedHz;                                      // 0x0698(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinInputHz;                                      // 0x069C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveInputHz;                                  // 0x06A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveRateHz;                                   // 0x06A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveDecelHz;                                  // 0x06A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveSpeedHz;                                  // 0x06AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinAngleMin;                                     // 0x06B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinAngleMax;                                     // 0x06B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinSpeedMaxVt;                                   // 0x06B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinAccelVt;                                      // 0x06BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinDecelVt;                                      // 0x06C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinDirectionVt;                                  // 0x06C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinSpeedVt;                                      // 0x06C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinInputVt;                                      // 0x06CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveInputVt;                                  // 0x06D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveAngleMinVt;                               // 0x06D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSpinMoveAngleMaxVt;                               // 0x06D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAngleVtDistEnable;                                // 0x06DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D95[0x3];                                     // 0x06DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FAngleVtDistRate;                                  // 0x06E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D96[0x4];                                     // 0x06E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PAngleVtDistLerpCurve;                             // 0x06E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAngleVtRootEnable;                                // 0x06F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D97[0x3];                                     // 0x06F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FAngleVtRootRate;                                  // 0x06F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VAngleVtRootOffset;                                // 0x06F8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D98[0x4];                                     // 0x0704(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PAngleVtRootLerpCurve;                             // 0x0708(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnApply;                                      // 0x0710(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D99[0x3];                                     // 0x0711(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PLockOnActor;                                      // 0x0714(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockOnOffset;                                      // 0x071C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnAngleLimitPly;                               // 0x0728(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnAngleLimitCam;                               // 0x072C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnAngleUp;                                    // 0x0730(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnAngleDn;                                    // 0x0734(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnAngleLt;                                    // 0x0738(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnAngleRt;                                    // 0x073C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugNoLerpVtAngle;                               // 0x0740(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9A[0x3];                                     // 0x0741(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VLockOnRootPly;                                    // 0x0744(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockOnRootEnm;                                    // 0x0750(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockOnLookAt;                                     // 0x075C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRoot;                                       // 0x0768(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9B[0x3];                                     // 0x0769(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VLockOnRoot;                                       // 0x076C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLookAtDistanceOffset;                             // 0x0778(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLogLockOn;                              // 0x077C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLerp;                                       // 0x077D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9C[0x2];                                     // 0x077E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnLerpTime;                                   // 0x0780(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpTimeSign;                               // 0x0784(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PLockOnLerpCurve;                                  // 0x0788(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpTimer;                                  // 0x0790(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpRate;                                   // 0x0794(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLerpAngleVtEnable;                          // 0x0798(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLerpAngleVtApply;                           // 0x0799(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9D[0x2];                                     // 0x079A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnLerpAngleVtStt;                             // 0x079C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpAngleVtEnd;                             // 0x07A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLerpAngleVtEaseBlend;                       // 0x07A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnLerp;                             // 0x07A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9E[0x3];                                     // 0x07A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PLookAtObject;                                     // 0x07AC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLookAtObj;                                  // 0x07B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnObjLerp;                                    // 0x07B5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9F[0x2];                                     // 0x07B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnObjLerpRateStt;                             // 0x07B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpRate;                                // 0x07BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpAngleMax;                            // 0x07C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTimeStart;                           // 0x07C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTime;                                // 0x07C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTimeEnd;                             // 0x07CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTimer;                               // 0x07D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpTimeSign;                            // 0x07D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PLockOnObjLerpCurve;                               // 0x07D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnObjLerpDelayApply;                          // 0x07E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA0[0x3];                                     // 0x07E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VLockOnObjLerpDelayOffsetEnd;                      // 0x07E4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockOnObjLerpDelayOffset;                         // 0x07F0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpDelayTime;                           // 0x07FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnObjLerpDelayTimer;                          // 0x0800(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnObjLerp;                          // 0x0804(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLookAtDistAngleVtLerpEnable;                // 0x0805(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA1[0x2];                                     // 0x0806(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PLockOnLookAtDistAngleVtLerp;                      // 0x0808(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLookAtDistAngleVtLerpRate;                  // 0x0810(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnLookAtDistCamDistEnable;                    // 0x0814(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA2[0x3];                                     // 0x0815(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PLockOnLookAtDistCamDistLerp;                      // 0x0818(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnLookAtDistCamDistLerpRate;                  // 0x0820(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRotateSpeedRateEnable;                      // 0x0824(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA3[0x3];                                     // 0x0825(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnRotateSpeedRateFovRateHz;                   // 0x0828(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateFovRateVt;                   // 0x082C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateAngleHz;                     // 0x0830(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateAngleVt;                     // 0x0834(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRotateSpeedRateLerp;                        // 0x0838(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRotateSpeedRateSign;                        // 0x0839(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA4[0x6];                                     // 0x083A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PLockOnRotateSpeedRateCurve;                       // 0x0840(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateTimeDecel;                   // 0x0848(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateTimeReturn;                  // 0x084C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateTimer;                       // 0x0850(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnRotateSpeedRateCurrent;                     // 0x0854(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnRotateSpeed;                      // 0x0858(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawLockOnRotateLine;                        // 0x0859(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnEnable;                               // 0x085A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnSkip;                                 // 0x085B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleHz;                              // 0x085C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleVt;                              // 0x0860(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnCheck;                                // 0x0864(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnLerpStt;                              // 0x0865(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnLerpHz;                               // 0x0866(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnLerpHzPly;                            // 0x0867(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnLerpVt;                               // 0x0868(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA5[0x3];                                     // 0x0869(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnReturnLerpTime;                             // 0x086C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FLockOnReturnLerpTimeOptionParamList;              // 0x0870(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnLerpTimer;                            // 0x0880(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleHzStt;                           // 0x0884(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleHzEnd;                           // 0x0888(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleVtStt;                           // 0x088C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnAngleVtEnd;                           // 0x0890(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnClockwise;                            // 0x0894(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA6[0x3];                                     // 0x0895(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PLockOnReturnLerpCurve;                            // 0x0898(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnActionEnableHz;                       // 0x08A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnActionApplyHz;                        // 0x08A1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnActionLerpHz;                         // 0x08A2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnReturnActionLerpEndHz;                      // 0x08A3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnActionLerpTimeHz;                     // 0x08A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnActionLerpTimerHz;                    // 0x08A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnReturnActionAngleHz;                        // 0x08AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawLockOnReturnLine;                        // 0x08B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnReturnSkip;                       // 0x08B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepAngleEnable;                                  // 0x08B2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepAngleApply;                                   // 0x08B3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FKeepAngleLookAtDistance;                          // 0x08B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockOnKeepAngleEnable;                            // 0x08B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnKeepAngleSpeedEnable;                       // 0x08B9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnKeepAngleSkip;                              // 0x08BA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnKeepAngleHzSkip;                            // 0x08BB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockOnKeepAngleHzSpeed;                           // 0x08BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnKeepAngleVtSkip;                            // 0x08C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA7[0x3];                                     // 0x08C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockOnKeepAngleVtSpeed;                           // 0x08C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockOnKeepAngleSkip;                    // 0x08C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosEnable;                               // 0x08C9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosUpdateParam;                          // 0x08CA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosSkip;                                 // 0x08CB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosUpdate;                               // 0x08CC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA8[0x3];                                     // 0x08CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VLockEnemyPos;                                     // 0x08D0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyLerpRate;                                // 0x08DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyPosLockDistanceHz;                       // 0x08E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyPosRestoreDistanceHz;                    // 0x08E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockEnemyPosPrevHz;                               // 0x08E8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosSkipHz;                               // 0x08F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA9[0x3];                                     // 0x08F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockEnemyPosLockDistanceVt;                       // 0x08F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyPosRestoreDistanceVt;                    // 0x08FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VLockEnemyPosPrevVt;                               // 0x0900(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockEnemyPosSkipVt;                               // 0x090C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DAA[0x3];                                     // 0x090D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLockEnemyPosDistMaxHz;                            // 0x0910(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLockEnemyPosDistMaxVt;                            // 0x0914(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintLockEnemyPos;                           // 0x0918(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DAB[0xB];                                     // 0x0919(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnMapGimmickLerpTime;                          // 0x0924(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraApply;                          // 0x0928(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketType;                     // 0x0929(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketOption;                   // 0x092A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DAC[0x5];                                     // 0x092B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraUniqueObjectParameter           UniqueObjectCameraParam;                           // 0x0930(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UMeshComponent*                         PUniqueObjectCameraMeshComp;                       // 0x0988(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraPlayerFix;                      // 0x0990(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DAD[0x3];                                     // 0x0991(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UniqueObjectCameraPlayerPos;                       // 0x0994(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketApply;                    // 0x09A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DAE[0x3];                                     // 0x09A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UniqueObjectCameraSocketPos;                       // 0x09A4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketLerp;                     // 0x09B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraSocketLerpEnd;                  // 0x09B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DAF[0x2];                                     // 0x09B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniqueObjectCameraSocketLerpTimeStt;               // 0x09B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraSocketLerpTimeEnd;               // 0x09B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraSocketLerpRate;                  // 0x09BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraControlType;                    // 0x09C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB0[0x3];                                     // 0x09C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               UniqueObjectCameraControlRot;                      // 0x09C4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraRemoteType;                     // 0x09D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB1[0x3];                                     // 0x09D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PUniqueObjectCameraRemoteActor;                    // 0x09D4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraLookAtLerpApply;                // 0x09DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB2[0x3];                                     // 0x09DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniqueObjectCameraLookAtRate;                      // 0x09E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraLookAtLerpTime;                  // 0x09E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraLookAtLerpTimer;                 // 0x09E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraLookAtDelayRate;                 // 0x09EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB3[0x8];                                     // 0x09F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  PUniqueObjectCameraEnemyActor;                     // 0x09F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UniqueObjectCameraEnemyActorPos;                   // 0x0A00(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  PUniqueObjectCameraObjectActor;                    // 0x0A0C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VUniqueObjectCameraLookAtPos;                      // 0x0A14(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraDistNear;                       // 0x0A20(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB4[0x3];                                     // 0x0A21(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniqueObjectCameraDistRate;                        // 0x0A24(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PUniqueObjectCameraLerpCurveStt;                   // 0x0A28(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PUniqueObjectCameraLerpCurveEnd;                   // 0x0A30(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraLerp;                           // 0x0A38(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraLerpEnd;                        // 0x0A39(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueObjectCameraLerpEndInstance;                // 0x0A3A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB5[0x1];                                     // 0x0A3B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniqueObjectCameraLerpTimer;                       // 0x0A3C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueObjectCameraLerpRate;                        // 0x0A40(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB6[0x90];                                    // 0x0A44(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUniqueObjectCameraPlayerLeft;                     // 0x0AD4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCamera;                     // 0x0AD5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraPos;                  // 0x0AD6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraPosLerp;              // 0x0AD7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraLookAt;               // 0x0AD8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraRot;                  // 0x0AD9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraFov;                  // 0x0ADA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraSocket;               // 0x0ADB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraControl;              // 0x0ADC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugUniqueObjectCameraNewLookAt;                 // 0x0ADD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintUniqueObjectCameraLookAtRate;           // 0x0ADE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawUniqueObjectCameraPos;                   // 0x0ADF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawUniqueObjectCameraPosLerp;               // 0x0AE0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawUniqueObjectCameraLookAt;                // 0x0AE1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB7[0x2];                                     // 0x0AE2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         bDebugDrawUniqueObjectCameraTime;                  // 0x0AE4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bDebugDrawUniqueObjectCameraBgTrace;               // 0x0AE8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionCameraApply;                             // 0x0AEC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionLerpStt;                                 // 0x0AED(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionLerpEnd;                                 // 0x0AEE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionActor;                                   // 0x0AEF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VAttentionPos;                                     // 0x0AF0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  PAttentionActor;                                   // 0x0AFC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB8[0x4];                                     // 0x0B04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PAttentionActorCurve;                              // 0x0B08(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionActorFixAngleVt;                         // 0x0B10(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB9[0x3];                                     // 0x0B11(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttentionActorFixAngleVt;                          // 0x0B14(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionActorOffsetDistHz;                       // 0x0B18(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DBA[0x3];                                     // 0x0B19(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttentionActorOffsetDistHz;                        // 0x0B1C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionActorOffsetDistHzSign;                    // 0x0B20(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttentionFov;                                     // 0x0B24(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DBB[0x3];                                     // 0x0B25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PAttentionFovCurve;                                // 0x0B28(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionCameraLerpTime;                           // 0x0B30(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttentionCameraLerpRate;                           // 0x0B34(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DBC[0x18];                                    // 0x0B38(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugPrintAttentionCamera;                        // 0x0B50(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerLerpAuto;                                   // 0x0B51(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DBD[0x6];                                     // 0x0B52(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FPlayerLerpTraceAngleList;                         // 0x0B58(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerLerpTraceDistance;                          // 0x0B68(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerLerpDistance;                               // 0x0B6C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerLerp;                                       // 0x0B70(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DBE[0x3];                                     // 0x0B71(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VPlayerLerpPosStt;                                 // 0x0B74(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VPlayerLerpPosEnd;                                 // 0x0B80(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerLerpRadius;                                 // 0x0B8C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PPlayerLerpCurve;                                  // 0x0B90(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARSCharacterBase>        PEnemyLerpActor;                                   // 0x0B98(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FEnemyLerpDistance;                                // 0x0BA0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FEnemyLerpRateDefault;                             // 0x0BA4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FEnemyLerpRate;                                    // 0x0BA8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FEnemyLerpRadius;                                  // 0x0BAC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerPullDistance;                               // 0x0BB0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPlayerPullMoveDistMax;                            // 0x0BB4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemyLerp;                                        // 0x0BB8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DBF[0x3];                                     // 0x0BB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VEnemyLerpPosStt;                                  // 0x0BBC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VEnemyLerpPosEnd;                                  // 0x0BC8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawPlayerLerpVector;                        // 0x0BD4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawPlayerLerpSphere;                        // 0x0BD5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawEnemyLerpSphere;                         // 0x0BD6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintEnemyLerpSphere;                        // 0x0BD7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLerpReset;                                        // 0x0BD8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLerpUpdateAngleHz;                                // 0x0BD9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraReset;                                      // 0x0BDA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC0[0x1];                                     // 0x0BDB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FLerpTime;                                         // 0x0BDC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FLerpRate;                                         // 0x0BE0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC1[0x40];                                    // 0x0BE4(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FCameraHitRadius;                                  // 0x0C24(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCameraHitRadiusPlane;                             // 0x0C28(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FCameraHitRadiusOffset;                            // 0x0C2C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraBuried;                                     // 0x0C30(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC2[0x3];                                     // 0x0C31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FDistSpeedAccel;                                   // 0x0C34(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDistSpeedMax;                                     // 0x0C38(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FDistSpeed;                                        // 0x0C3C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawTraceCorner;                             // 0x0C40(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawTraceCameraRoot;                         // 0x0C41(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawTraceCameraDistance;                     // 0x0C42(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC3[0x5];                                     // 0x0C43(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraTriggerInfo                     AreaTriggerInfo;                                   // 0x0C48(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCameraTriggerInfo                     CurrentTriggerInfo;                                // 0x0C70(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FCameraTriggerInfo>             TriggerInfoList;                                   // 0x0C98(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerInfoLerp;                                  // 0x0CA8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC4[0x3];                                     // 0x0CA9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerInfoLerpTimer;                              // 0x0CAC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PTriggerInfoLerpCurve;                             // 0x0CB0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerInfoLerpTime;                               // 0x0CB8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC5[0x4];                                     // 0x0CBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PTriggerInfoLerpCurveDefault;                      // 0x0CC0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerInfoLerpTimeDefault;                        // 0x0CC8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerInfoSkipLerp;                              // 0x0CCC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC6[0x3];                                     // 0x0CCD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TriggerInfoSkipLerpRefList;                        // 0x0CD0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerCameraPreset                    PresetBasic;                                       // 0x0CE0(0x00E0)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerCameraPreset                    PresetOffset;                                      // 0x0DC0(0x00E0)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayerCameraPreset                    CurrentPreset;                                     // 0x0EA0(0x00E0)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bDebugNewTriggerEndLerp;                           // 0x0F80(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC7[0x217];                                   // 0x0F81(0x0217)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraTriggerInfo                     NextTriggerInfo;                                   // 0x1198(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAssistRootHeight;                                 // 0x11C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC8[0x3];                                     // 0x11C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FAssistRootHeightDistYut;                          // 0x11C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightDistKsn;                          // 0x11C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightDistMax;                          // 0x11CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightDistRangeMin;                     // 0x11D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightDistRangeMax;                     // 0x11D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleYut;                         // 0x11D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleKsn;                         // 0x11DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleMax;                         // 0x11E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleRangeMin;                    // 0x11E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FAssistRootHeightAngleRangeMax;                    // 0x11E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDbDispAssistRootHeight;                           // 0x11EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC9[0x7F];                                    // 0x11ED(0x007F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAsyncRequestPrevProc;                             // 0x126C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAsyncRequestTaskProc;                             // 0x126D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAsyncTaskDone;                                    // 0x126E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DCA[0x1];                                     // 0x126F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActorMoveDistMin;                                  // 0x1270(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DCB[0xA4];                                    // 0x1274(0x00A4)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DbDrawTrace;                                       // 0x1318(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintRootOffsetHz;                           // 0x1319(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawTraceRootOffsetHz;                       // 0x131A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDbTemp0;                                          // 0x131B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDbTemp1;                                          // 0x131C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDbTemp2;                                          // 0x131D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DCC[0x202];                                   // 0x131E(0x0202)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCameraPreset(const struct FPlayerCameraPreset& Preset);
	void ApplyOptionParam();
	void ApplyTriggerInfo(const struct FCameraTriggerInfo& TriggerInfo);
	void CalcAngleVtDistRate();
	void CalcDefaultCameraLocationRotation(const struct FVector& RootPos, const struct FRotator& RootRot, struct FVector* CamPos, struct FRotator* CamRot);
	float CalcUniqueObjectPlayerLerpAngle(const struct FVector& PosCam, const struct FVector& PosPly);
	bool CheckRootOffsetHz();
	struct FVector CheckRootPos(const struct FVector& PosRoot, bool bDebugDraw);
	void DebugAddRecordList(int32 Posidx, int32 LineIdx, const struct FVector& Value0, const struct FVector& Value1);
	void DebugAddRecordListCamPos(const struct FVector& PosCam);
	void DebugDrawLockOnReturnLine();
	void DebugDrawLockOnRotateSpeedRateLine();
	void DebugDrawRecordList();
	void DebugInitRecordList(const TArray<float>& Radius, const TArray<struct FColor>& Color);
	void DebugResetRecordList();
	void DebugSetRecordListDraw(bool Flag);
	void DebugSetRecordListShowIndex(int32 CommandNo);
	void DisableTemporaryParameter(float LerpTime, const class FString& RefName, EPlayerCameraActionPriority Prio, EEasingFunc EaseFunc, float EaseBlendExp);
	void EnableTemporaryParameter(float LerpTime, const class FString& RefName, EPlayerCameraActionPriority Prio, const struct FVector& Offset, bool bEnableRootOffset, bool bRootOffsetNoRotate, const struct FVector& RootOffset, bool bEnableDistance, float Distance, bool bEnableFov, float FOV, EEasingFunc EaseFunc, float EaseBlendExp);
	float GetAspectRatio();
	float GetCameraFieldOfView();
	struct FVector GetCameraLocation();
	float GetCameraLockOnLerpRate();
	bool GetCameraPreset(EPlayerCameraPreset PresetName, struct FPlayerCameraPreset* DstPreset, bool bOffset);
	struct FRotator GetCameraRotation();
	struct FVector GetLockEnemyPos();
	float GetLockOnLookAtObjRate();
	float GetLockOnReturnAngleHz();
	struct FVector GetLockRootPos(bool bLockCheck);
	EPlayerCameraMode GetPlayerCameraMode();
	struct FVector GetRootActorLocation(bool bSkipCheck);
	bool GetRootActorMeshComponent();
	struct FRotator GetRootActorRotation(bool bSkipCheck);
	void Initialize();
	bool IsMaleOwner();
	bool IsOptionSpinMoveDecelEnable();
	bool IsOptionSpinMoveInputEnable();
	void PostUpdateUniqueObjectCamera();
	void PrevAsyncSlopeAssist();
	void PrevUpdateUniqueObjectCamera();
	void ResetCamera(float LerpTime, bool bUpdateAngleHz, bool bSkipCheck);
	void ResetCameraHz(float LerpTime, bool bUpdateAngleHz, bool bSkipCheck);
	void ResetLockEnemyPos();
	void ResetLockOnRotateSpeedRate();
	void ResetSlopeAssist();
	void ResetTriggerInfo();
	void ResetTriggerInfoLerp();
	void SetAreaChangeSkipLerp(bool Flag, const class FString& RefName);
	void SetAreaTriggerInfo(const struct FCameraTriggerInfo& TriggerInfo, bool bLerp);
	void SetAssistKeepAngle(bool bFlag);
	void SetAssistRootHeight(bool Flag);
	void SetAssistRootHeightParam(float HeightDistY, float HeightDistK, float MinDist, float MaxDist, float HeightAngleY, float HeightAngleK, float MinAngle, float MaxAngle);
	void SetAttentionCamera(bool Flag, bool bLookAtActor, const struct FVector& LookAtPos, class AActor* PTgtActor, class UCurveFloat* PActorCurve, bool ChangeFov, float TgtFov, class UCurveFloat* PFovCurve);
	void SetAttentionCameraOption(bool bFixAngleVt, float FixAngleVt, bool bOffsetDistHz, float OffsetDistHz);
	void SetBattleCamera(bool bSign, bool bLerp);
	void SetCameraActionReset(bool Flag, float LerpTime, float KeepTime);
	void SetCameraByCameraActor(class ACameraActor* PCamActor, bool bPitch, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	void SetCameraCollisionParameter(float CamRadius, float DistSpeedAccel, float DistSpeedMax);
	void SetCameraDefault(float AngleVt, float AngleHz);
	void SetCameraFieldOfView(float FOV);
	void SetCameraInputMove(const struct FVector& InputMove, float HzRate, float VtRate);
	void SetCameraInputRotate(float SpinRateVt, float SpinRateHz);
	void SetCameraLocation(const struct FVector& Pos);
	void SetCameraLockOn(class AActor* PTargetActor);
	void SetCameraLockOnMapGimmick(class AMapGimmickObject* PMapGimmick, bool ResetOnly);
	void SetCameraMovementDelay(bool bDelay);
	void SetCameraPlayerParameter(bool bYuito);
	void SetCameraRoatatLimit(float VtAngleMin, float VtAngleMax);
	void SetCameraRoot(class AActor* Param_PRootActor, const struct FVector& Offset, bool bAttachIn);
	void SetCameraRotation(const struct FRotator& Rot, bool bOverwrite);
	void SetCameraSpeed(float SpinSpeedVt, float SpinAccelVt, float SpinDecelVt, float SpinSpeedHz, float SpinAccelHz, float SpinDecelHz);
	void SetEventTriggerInfo(bool Flag, const struct FCameraTriggerInfo& TriggerInfo);
	void SetInputMoveParameter(float DelayValue, const TArray<float>& DelayValueOptionParamList, float DelayValueVt, float DelayDistMax, float SpeedRateHz, float DecelHz, float VtAngleMin, float VtAngleMax);
	void SetLerpTriggerInfo(const struct FCameraTriggerInfo& TriggerInfo, class UCurveFloat* PEndCurve);
	void SetLockOnKeepAngleSkip(bool Flag);
	void SetLockOnLookAtObj(bool bFlag, class AActor* PObjActor, bool bDelay);
	void SetLockOnReturnAction(bool bFlag, bool bLerpHz, float LerpTimeHz, float AngleRateHz);
	void SetLockOnReturnSkip(bool Flag);
	void SetLockOnRotateSpeedLerp(bool bSign);
	void SetLockRootPosParameter(float SkipDist, float RestoreDist);
	void SetMaleOwner(bool bFlag);
	void SetOptionParam(ECameraDistance CameraDistance, uint8 LockonSpeedParam, uint8 BehindSpeed);
	void SetPlayerCamera(class AActor* CameraActor);
	void SetPlayerCameraMode(EPlayerCameraMode CamMode);
	void SetRootLerpActionName(bool Flag, const class FString& RefName, EPlayerCameraActionPriority Prio, float LerpTime, class FName ActionName);
	void SetRootLerpActionParameter(bool Flag, const class FString& RefName, EPlayerCameraActionPriority Prio, float LerpTime, float LerpValue, float MaxDist);
	void SetSlopeAssistSkip(bool Flag);
	void SetTemporaryOption(bool bSkipInput, bool bSkipReturn, bool bSkipKeepAngle);
	void SetTemporaryParameter(bool Flag, float LerpTime, const class FString& RefName, EPlayerCameraActionPriority Priority, bool bEnableRootOffset, bool bRootOffsetNoRotate, const struct FVector& RootOffset, bool bEnableCamDistance, float CamDistance, bool bEnableFov, float FOV, EEasingFunc EaseFunc, float EaseBlendExp);
	void SetUniqueObjectCamera(bool Flag, class AActor* PObjActor, class AActor* PEnmActor, const struct FCameraUniqueObjectParameter& Param);
	void SetUniqueObjectCameraControlType(bool Flag, class AActor* PObjActor, const struct FCameraUniqueObjectParameter& Param, bool bSkipResetCamera);
	void SetUniqueObjectCameraRemoteType(bool Flag, class AActor* PRemoteActor, const struct FCameraUniqueObjectParameter& Param);
	void SetUniqueObjectCameraSocketApply(bool Flag, float LerpTime);
	void SetUniqueObjectCameraSocketType(bool Flag, const struct FCameraUniqueObjectParameter& Param);
	void SetUniqueObjectCameraSocketTypeOption(class AActor* PObjActor);
	void SetUniqueObjectEnemyLerp(const struct FVector& TgtPos);
	void SetUniqueObjectLookAtRate(float LookAtRate, float LerpTime, float DelayRate);
	void SetUniqueObjectPlayerLerp(const struct FVector& TgtPos);
	void SetUniqueObjectPlayerLerpAuto(class ARSCharacterBase* PEnemyActor, float RadiusEnm, float RadiusPly);
	void SetUniqueObjectPlayerLerpParameter(const TArray<float>& AngleList, float TraceDist, float LerpDist, float EnmDist, float EnmRate);
	void SetUniqueObjectPlayerPullParameter(float PullDistance, float MoveDistMax);
	void TestTrace(const struct FVector& PosS, const struct FVector& Pose, float Radius, float DTime);
	void TickAsyncSlopeAssist();
	void UpdateAsyncParameter();
	void UpdateAsyncTrace();
	void UpdateAttentionCamera();
	void UpdateBattleCameraLerp();
	void UpdateCameraActionReset();
	void UpdateCameraLockOnLerp();
	void UpdateLockOnLookAtObjLerp(float Rate);
	void UpdateLockOnReturnAction();
	void UpdateLockOnRotateSpeedLerp();
	void UpdateRootLerpActionLerp();
	void UpdateTemporaryParameter();
	void UpdateTriggerInfoLerp();
	void UpdateUniqueObjectCameraRemoteType();
	void UpdateUniqueObjectPlayerLerp(float TimeRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraComponent">();
	}
	static class UPlayerCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCameraComponent>();
	}
};
static_assert(alignof(UPlayerCameraComponent) == 0x000008, "Wrong alignment on UPlayerCameraComponent");
static_assert(sizeof(UPlayerCameraComponent) == 0x001520, "Wrong size on UPlayerCameraComponent");
static_assert(offsetof(UPlayerCameraComponent, PUserParamManager) == 0x0000D0, "Member 'UPlayerCameraComponent::PUserParamManager' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDeltaSecond) == 0x0000D8, "Member 'UPlayerCameraComponent::FDeltaSecond' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bMaleOwner) == 0x0000DC, "Member 'UPlayerCameraComponent::bMaleOwner' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bMaleOwnerCheck) == 0x0000DD, "Member 'UPlayerCameraComponent::bMaleOwnerCheck' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, CameraMode) == 0x0000DE, "Member 'UPlayerCameraComponent::CameraMode' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LookAtMode) == 0x0000DF, "Member 'UPlayerCameraComponent::LookAtMode' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PCameraActor) == 0x0000E0, "Member 'UPlayerCameraComponent::PCameraActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PRootActor) == 0x0000E8, "Member 'UPlayerCameraComponent::PRootActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PRootActorCapsule) == 0x0000F0, "Member 'UPlayerCameraComponent::PRootActorCapsule' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RootActorCapsuleHeight) == 0x0000F8, "Member 'UPlayerCameraComponent::RootActorCapsuleHeight' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PRootActorPlayerScript) == 0x000100, "Member 'UPlayerCameraComponent::PRootActorPlayerScript' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VRootActorPos) == 0x000108, "Member 'UPlayerCameraComponent::VRootActorPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VRootActorMove) == 0x000114, "Member 'UPlayerCameraComponent::VRootActorMove' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bCheckRootPosType) == 0x000120, "Member 'UPlayerCameraComponent::bCheckRootPosType' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bCheckRootPosMidCheck) == 0x000121, "Member 'UPlayerCameraComponent::bCheckRootPosMidCheck' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAspectRatio) == 0x000124, "Member 'UPlayerCameraComponent::FAspectRatio' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAspectRateVt) == 0x000128, "Member 'UPlayerCameraComponent::FAspectRateVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAspectRateHz) == 0x00012C, "Member 'UPlayerCameraComponent::FAspectRateHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, DtActionParameter) == 0x000130, "Member 'UPlayerCameraComponent::DtActionParameter' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, DtOptionParameter) == 0x000138, "Member 'UPlayerCameraComponent::DtOptionParameter' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bWorkPosPlayer) == 0x000143, "Member 'UPlayerCameraComponent::bWorkPosPlayer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VWorkPosPlayer) == 0x000144, "Member 'UPlayerCameraComponent::VWorkPosPlayer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bWorkPosRemote) == 0x000150, "Member 'UPlayerCameraComponent::bWorkPosRemote' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VWorkPosRemote) == 0x000154, "Member 'UPlayerCameraComponent::VWorkPosRemote' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bActionResetApply) == 0x000160, "Member 'UPlayerCameraComponent::bActionResetApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetLerpTime) == 0x000164, "Member 'UPlayerCameraComponent::FActionResetLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetLerpTimer) == 0x000168, "Member 'UPlayerCameraComponent::FActionResetLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetKeepTime) == 0x00016C, "Member 'UPlayerCameraComponent::FActionResetKeepTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetKeepTimer) == 0x000170, "Member 'UPlayerCameraComponent::FActionResetKeepTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetLerpAngleStt) == 0x000174, "Member 'UPlayerCameraComponent::FActionResetLerpAngleStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FActionResetLerpAngleEnd) == 0x000178, "Member 'UPlayerCameraComponent::FActionResetLerpAngleEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintActionReset) == 0x00017C, "Member 'UPlayerCameraComponent::bDebugPrintActionReset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bMovementDelay) == 0x00017D, "Member 'UPlayerCameraComponent::bMovementDelay' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryCameraEnable) == 0x00017E, "Member 'UPlayerCameraComponent::bTemporaryCameraEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryCameraRefName) == 0x000180, "Member 'UPlayerCameraComponent::TemporaryCameraRefName' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryCameraPriority) == 0x000190, "Member 'UPlayerCameraComponent::TemporaryCameraPriority' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryCameraApply) == 0x000191, "Member 'UPlayerCameraComponent::bTemporaryCameraApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryRootOffsetApply) == 0x000192, "Member 'UPlayerCameraComponent::bTemporaryRootOffsetApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryRootOffsetNoRotate) == 0x000193, "Member 'UPlayerCameraComponent::bTemporaryRootOffsetNoRotate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryRootOffset) == 0x000194, "Member 'UPlayerCameraComponent::TemporaryRootOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryDistanceOffsetApply) == 0x0001A0, "Member 'UPlayerCameraComponent::bTemporaryDistanceOffsetApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryDistanceOffset) == 0x0001A4, "Member 'UPlayerCameraComponent::TemporaryDistanceOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTemporaryFovApply) == 0x0001A8, "Member 'UPlayerCameraComponent::bTemporaryFovApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryFov) == 0x0001AC, "Member 'UPlayerCameraComponent::TemporaryFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryLockOnRate) == 0x0001B0, "Member 'UPlayerCameraComponent::TemporaryLockOnRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryOptionSkipInput) == 0x0001B4, "Member 'UPlayerCameraComponent::TemporaryOptionSkipInput' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryOptionSkipReturn) == 0x0001B8, "Member 'UPlayerCameraComponent::TemporaryOptionSkipReturn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TemporaryOptionSkipKeepAngle) == 0x0001BC, "Member 'UPlayerCameraComponent::TemporaryOptionSkipKeepAngle' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTemporaryUseNew) == 0x0001FD, "Member 'UPlayerCameraComponent::bDebugTemporaryUseNew' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintTemporary) == 0x0001FE, "Member 'UPlayerCameraComponent::bDebugPrintTemporary' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistEnable) == 0x0001FF, "Member 'UPlayerCameraComponent::bSlopeAssistEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistSkip) == 0x000200, "Member 'UPlayerCameraComponent::bSlopeAssistSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistAsyncRequestPrevProc) == 0x000201, "Member 'UPlayerCameraComponent::bSlopeAssistAsyncRequestPrevProc' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistAsyncRequestTaskProc) == 0x000202, "Member 'UPlayerCameraComponent::bSlopeAssistAsyncRequestTaskProc' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistAsyncRequestTaskDone) == 0x000203, "Member 'UPlayerCameraComponent::bSlopeAssistAsyncRequestTaskDone' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckNum) == 0x000204, "Member 'UPlayerCameraComponent::SlopeAssistCheckNum' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckInterval) == 0x000208, "Member 'UPlayerCameraComponent::SlopeAssistCheckInterval' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckIntervalAngle) == 0x00020C, "Member 'UPlayerCameraComponent::SlopeAssistCheckIntervalAngle' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckAngleVtMax) == 0x000210, "Member 'UPlayerCameraComponent::SlopeAssistCheckAngleVtMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckAngleVtStt) == 0x000214, "Member 'UPlayerCameraComponent::SlopeAssistCheckAngleVtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckAngleVtEnd) == 0x000218, "Member 'UPlayerCameraComponent::SlopeAssistCheckAngleVtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckAngleHz) == 0x00021C, "Member 'UPlayerCameraComponent::SlopeAssistCheckAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VSlopeAssistMoveDirection) == 0x000220, "Member 'UPlayerCameraComponent::VSlopeAssistMoveDirection' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VSlopeAssistMoveDirectionHz) == 0x00022C, "Member 'UPlayerCameraComponent::VSlopeAssistMoveDirectionHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistSkipMoveDir) == 0x000238, "Member 'UPlayerCameraComponent::bSlopeAssistSkipMoveDir' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistLerpApply) == 0x000239, "Member 'UPlayerCameraComponent::bSlopeAssistLerpApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistLerpRate) == 0x00023C, "Member 'UPlayerCameraComponent::SlopeAssistLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VSlopeAssistLerpVector) == 0x000240, "Member 'UPlayerCameraComponent::VSlopeAssistLerpVector' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistLerpAngleVt) == 0x00024C, "Member 'UPlayerCameraComponent::SlopeAssistLerpAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistDelayTime) == 0x000250, "Member 'UPlayerCameraComponent::SlopeAssistDelayTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistDelayTimer) == 0x000254, "Member 'UPlayerCameraComponent::SlopeAssistDelayTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistCheckBgEnable) == 0x000258, "Member 'UPlayerCameraComponent::bSlopeAssistCheckBgEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistCheckBgOffset) == 0x00025C, "Member 'UPlayerCameraComponent::SlopeAssistCheckBgOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistFixAngleEnable) == 0x000268, "Member 'UPlayerCameraComponent::bSlopeAssistFixAngleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistFixAngleInterval) == 0x00026C, "Member 'UPlayerCameraComponent::SlopeAssistFixAngleInterval' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistFixAngleRange) == 0x000270, "Member 'UPlayerCameraComponent::SlopeAssistFixAngleRange' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bSlopeAssistSpeedLerpEnable) == 0x000274, "Member 'UPlayerCameraComponent::bSlopeAssistSpeedLerpEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistSpeedLerpMin) == 0x000278, "Member 'UPlayerCameraComponent::SlopeAssistSpeedLerpMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistSpeedLerpMax) == 0x00027C, "Member 'UPlayerCameraComponent::SlopeAssistSpeedLerpMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistSpeedLerpRateMax) == 0x000280, "Member 'UPlayerCameraComponent::SlopeAssistSpeedLerpRateMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistSpeedLerpRate) == 0x000284, "Member 'UPlayerCameraComponent::SlopeAssistSpeedLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, SlopeAssistResultAngleList) == 0x000288, "Member 'UPlayerCameraComponent::SlopeAssistResultAngleList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugSlopeAssistSyncApply) == 0x000368, "Member 'UPlayerCameraComponent::bDebugSlopeAssistSyncApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintSlopeAssist) == 0x000369, "Member 'UPlayerCameraComponent::bDebugPrintSlopeAssist' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawSlopeAssistVector) == 0x00036A, "Member 'UPlayerCameraComponent::bDebugDrawSlopeAssistVector' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawSlopeAssistCheckPoint) == 0x00036B, "Member 'UPlayerCameraComponent::bDebugDrawSlopeAssistCheckPoint' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawSlopeAssistCheckHit) == 0x00036C, "Member 'UPlayerCameraComponent::bDebugDrawSlopeAssistCheckHit' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintDistance) == 0x0003A0, "Member 'UPlayerCameraComponent::bDebugPrintDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTraceHit) == 0x0003A1, "Member 'UPlayerCameraComponent::bDebugTraceHit' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputEnable) == 0x0003A2, "Member 'UPlayerCameraComponent::bInputEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FInputLtX) == 0x0003A4, "Member 'UPlayerCameraComponent::FInputLtX' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FInputLtY) == 0x0003A8, "Member 'UPlayerCameraComponent::FInputLtY' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FInputRtX) == 0x0003AC, "Member 'UPlayerCameraComponent::FInputRtX' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FInputRtY) == 0x0003B0, "Member 'UPlayerCameraComponent::FInputRtY' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputLt) == 0x0003B4, "Member 'UPlayerCameraComponent::bInputLt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputRt) == 0x0003B5, "Member 'UPlayerCameraComponent::bInputRt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputUp) == 0x0003B6, "Member 'UPlayerCameraComponent::bInputUp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputDn) == 0x0003B7, "Member 'UPlayerCameraComponent::bInputDn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bInputAngle) == 0x0003B8, "Member 'UPlayerCameraComponent::bInputAngle' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTurnCheckEnable) == 0x0003B9, "Member 'UPlayerCameraComponent::bTurnCheckEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetUpStt) == 0x0003BC, "Member 'UPlayerCameraComponent::VTurnCheckOffsetUpStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetUpEnd) == 0x0003C8, "Member 'UPlayerCameraComponent::VTurnCheckOffsetUpEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetDnStt) == 0x0003D4, "Member 'UPlayerCameraComponent::VTurnCheckOffsetDnStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetDnEnd) == 0x0003E0, "Member 'UPlayerCameraComponent::VTurnCheckOffsetDnEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetLtStt) == 0x0003EC, "Member 'UPlayerCameraComponent::VTurnCheckOffsetLtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetLtEnd) == 0x0003F8, "Member 'UPlayerCameraComponent::VTurnCheckOffsetLtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetRtStt) == 0x000404, "Member 'UPlayerCameraComponent::VTurnCheckOffsetRtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VTurnCheckOffsetRtEnd) == 0x000410, "Member 'UPlayerCameraComponent::VTurnCheckOffsetRtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTurnCheckReturnEnable) == 0x00041C, "Member 'UPlayerCameraComponent::bTurnCheckReturnEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FTurnCheckReturnTime) == 0x000420, "Member 'UPlayerCameraComponent::FTurnCheckReturnTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTurnCheckFlag1) == 0x0004A8, "Member 'UPlayerCameraComponent::bDebugTurnCheckFlag1' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTurnCheckDrawCt) == 0x0004A9, "Member 'UPlayerCameraComponent::bDebugTurnCheckDrawCt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugTurnCheckDrawCtRay) == 0x0004AA, "Member 'UPlayerCameraComponent::bDebugTurnCheckDrawCtRay' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultFov) == 0x0004AC, "Member 'UPlayerCameraComponent::FDefaultFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDefaultOffset) == 0x0004B0, "Member 'UPlayerCameraComponent::VDefaultOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDefaultOffsetWall) == 0x0004BC, "Member 'UPlayerCameraComponent::VDefaultOffsetWall' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultAngleVt) == 0x0004C8, "Member 'UPlayerCameraComponent::FDefaultAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultAngleHz) == 0x0004CC, "Member 'UPlayerCameraComponent::FDefaultAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultDistance) == 0x0004D0, "Member 'UPlayerCameraComponent::FDefaultDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDefaultDistanceMin) == 0x0004D4, "Member 'UPlayerCameraComponent::FDefaultDistanceMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCurrentFov) == 0x0004D8, "Member 'UPlayerCameraComponent::FCurrentFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCurrentAngleVt) == 0x0004DC, "Member 'UPlayerCameraComponent::FCurrentAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCurrentAngleHz) == 0x0004E0, "Member 'UPlayerCameraComponent::FCurrentAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCurrentDistance) == 0x0004E4, "Member 'UPlayerCameraComponent::FCurrentDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VCurrentRoot) == 0x0004E8, "Member 'UPlayerCameraComponent::VCurrentRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VCurrentPos) == 0x0004F4, "Member 'UPlayerCameraComponent::VCurrentPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VCurrentLookAt) == 0x000500, "Member 'UPlayerCameraComponent::VCurrentLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VCurrentDir) == 0x00050C, "Member 'UPlayerCameraComponent::VCurrentDir' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RCurrentRot) == 0x000518, "Member 'UPlayerCameraComponent::RCurrentRot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDestinationAngleVt) == 0x000524, "Member 'UPlayerCameraComponent::FDestinationAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDestinationAngleHz) == 0x000528, "Member 'UPlayerCameraComponent::FDestinationAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDestinationDistance) == 0x00052C, "Member 'UPlayerCameraComponent::FDestinationDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDestinationRoot) == 0x000530, "Member 'UPlayerCameraComponent::VDestinationRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDestinationPos) == 0x00053C, "Member 'UPlayerCameraComponent::VDestinationPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VDestinationDir) == 0x000548, "Member 'UPlayerCameraComponent::VDestinationDir' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RDestinationRot) == 0x000554, "Member 'UPlayerCameraComponent::RDestinationRot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDestinationRootRateOptionParamList) == 0x000560, "Member 'UPlayerCameraComponent::FDestinationRootRateOptionParamList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawDestinationRootList) == 0x000570, "Member 'UPlayerCameraComponent::bDebugDrawDestinationRootList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bBattleOffsetEnable) == 0x000571, "Member 'UPlayerCameraComponent::bBattleOffsetEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bBattleOffset) == 0x000572, "Member 'UPlayerCameraComponent::bBattleOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bBattleOffsetLerp) == 0x000573, "Member 'UPlayerCameraComponent::bBattleOffsetLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bBattleOffsetLerpSign) == 0x000574, "Member 'UPlayerCameraComponent::bBattleOffsetLerpSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetTime) == 0x000578, "Member 'UPlayerCameraComponent::FBattleOffsetTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PBattleOffsetLerpCurve) == 0x000580, "Member 'UPlayerCameraComponent::PBattleOffsetLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetTimer) == 0x000588, "Member 'UPlayerCameraComponent::FBattleOffsetTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetLerpRate) == 0x00058C, "Member 'UPlayerCameraComponent::FBattleOffsetLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetDistanceLerp) == 0x000590, "Member 'UPlayerCameraComponent::FBattleOffsetDistanceLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VBattleOffsetRootPosLerp) == 0x000594, "Member 'UPlayerCameraComponent::VBattleOffsetRootPosLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FBattleOffsetDistance) == 0x0005A0, "Member 'UPlayerCameraComponent::FBattleOffsetDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VBattleOffsetRootPos) == 0x0005A4, "Member 'UPlayerCameraComponent::VBattleOffsetRootPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintBattleOffset) == 0x0005B0, "Member 'UPlayerCameraComponent::bDebugPrintBattleOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockRootPosEnable) == 0x0005B1, "Member 'UPlayerCameraComponent::bLockRootPosEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockRootPosSkip) == 0x0005B2, "Member 'UPlayerCameraComponent::bLockRootPosSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRestoreRootPosLerpRate) == 0x0005B4, "Member 'UPlayerCameraComponent::FRestoreRootPosLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockRootPosDistance) == 0x0005B8, "Member 'UPlayerCameraComponent::FLockRootPosDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRestoreRootPosDistance) == 0x0005BC, "Member 'UPlayerCameraComponent::FRestoreRootPosDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VPrevRootPos) == 0x0005C0, "Member 'UPlayerCameraComponent::VPrevRootPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockRootPos) == 0x0005CC, "Member 'UPlayerCameraComponent::bDebugPrintLockRootPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VPlayerInputMove) == 0x0005D0, "Member 'UPlayerCameraComponent::VPlayerInputMove' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bRootLerpEnable) == 0x0005DC, "Member 'UPlayerCameraComponent::bRootLerpEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValueDefault) == 0x0005E0, "Member 'UPlayerCameraComponent::FRootLerpValueDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValueDefaultOptionParamList) == 0x0005E8, "Member 'UPlayerCameraComponent::FRootLerpValueDefaultOptionParamList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValueDefaultApplyOption) == 0x0005F8, "Member 'UPlayerCameraComponent::FRootLerpValueDefaultApplyOption' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValueAction) == 0x0005FC, "Member 'UPlayerCameraComponent::FRootLerpValueAction' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValue) == 0x000600, "Member 'UPlayerCameraComponent::FRootLerpValue' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpValueVt) == 0x000604, "Member 'UPlayerCameraComponent::FRootLerpValueVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceDefault) == 0x000608, "Member 'UPlayerCameraComponent::FRootLerpDistanceDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceAction) == 0x00060C, "Member 'UPlayerCameraComponent::FRootLerpDistanceAction' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistance) == 0x000610, "Member 'UPlayerCameraComponent::FRootLerpDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceWork) == 0x000614, "Member 'UPlayerCameraComponent::FRootLerpDistanceWork' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceMin) == 0x000618, "Member 'UPlayerCameraComponent::FRootLerpDistanceMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceTarget) == 0x00061C, "Member 'UPlayerCameraComponent::FRootLerpDistanceTarget' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDistanceMove) == 0x000620, "Member 'UPlayerCameraComponent::FRootLerpDistanceMove' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bRootLerpActionLerp) == 0x000624, "Member 'UPlayerCameraComponent::bRootLerpActionLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RootLerpActionRefName) == 0x000628, "Member 'UPlayerCameraComponent::RootLerpActionRefName' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, RootLerpActionPriority) == 0x000638, "Member 'UPlayerCameraComponent::RootLerpActionPriority' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpActionLerpRate) == 0x00063C, "Member 'UPlayerCameraComponent::FRootLerpActionLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bRootLerpAngleEnable) == 0x000654, "Member 'UPlayerCameraComponent::bRootLerpAngleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PRootLerpDirCurve) == 0x000658, "Member 'UPlayerCameraComponent::PRootLerpDirCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDirLerpRate) == 0x000660, "Member 'UPlayerCameraComponent::FRootLerpDirLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpDirLerpRateMin) == 0x000664, "Member 'UPlayerCameraComponent::FRootLerpDirLerpRateMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpMoveLerpValue) == 0x000668, "Member 'UPlayerCameraComponent::FRootLerpMoveLerpValue' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpMoveLerpRate) == 0x00066C, "Member 'UPlayerCameraComponent::FRootLerpMoveLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpMoveLerpRateMin) == 0x000670, "Member 'UPlayerCameraComponent::FRootLerpMoveLerpRateMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpAngleLerpRate) == 0x000674, "Member 'UPlayerCameraComponent::FRootLerpAngleLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpAngleRate) == 0x000678, "Member 'UPlayerCameraComponent::FRootLerpAngleRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bRootLerpCamDistEnable) == 0x00067C, "Member 'UPlayerCameraComponent::bRootLerpCamDistEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FRootLerpCamDistRate) == 0x000680, "Member 'UPlayerCameraComponent::FRootLerpCamDistRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintRootLerp) == 0x000684, "Member 'UPlayerCameraComponent::bDebugPrintRootLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintRootLerpAction) == 0x000685, "Member 'UPlayerCameraComponent::bDebugPrintRootLerpAction' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinSpeedMaxHz) == 0x000688, "Member 'UPlayerCameraComponent::FSpinSpeedMaxHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinAccelHz) == 0x00068C, "Member 'UPlayerCameraComponent::FSpinAccelHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinDecelHz) == 0x000690, "Member 'UPlayerCameraComponent::FSpinDecelHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinDirectionHz) == 0x000694, "Member 'UPlayerCameraComponent::FSpinDirectionHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinSpeedHz) == 0x000698, "Member 'UPlayerCameraComponent::FSpinSpeedHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinInputHz) == 0x00069C, "Member 'UPlayerCameraComponent::FSpinInputHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveInputHz) == 0x0006A0, "Member 'UPlayerCameraComponent::FSpinMoveInputHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveRateHz) == 0x0006A4, "Member 'UPlayerCameraComponent::FSpinMoveRateHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveDecelHz) == 0x0006A8, "Member 'UPlayerCameraComponent::FSpinMoveDecelHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveSpeedHz) == 0x0006AC, "Member 'UPlayerCameraComponent::FSpinMoveSpeedHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinAngleMin) == 0x0006B0, "Member 'UPlayerCameraComponent::FSpinAngleMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinAngleMax) == 0x0006B4, "Member 'UPlayerCameraComponent::FSpinAngleMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinSpeedMaxVt) == 0x0006B8, "Member 'UPlayerCameraComponent::FSpinSpeedMaxVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinAccelVt) == 0x0006BC, "Member 'UPlayerCameraComponent::FSpinAccelVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinDecelVt) == 0x0006C0, "Member 'UPlayerCameraComponent::FSpinDecelVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinDirectionVt) == 0x0006C4, "Member 'UPlayerCameraComponent::FSpinDirectionVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinSpeedVt) == 0x0006C8, "Member 'UPlayerCameraComponent::FSpinSpeedVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinInputVt) == 0x0006CC, "Member 'UPlayerCameraComponent::FSpinInputVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveInputVt) == 0x0006D0, "Member 'UPlayerCameraComponent::FSpinMoveInputVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveAngleMinVt) == 0x0006D4, "Member 'UPlayerCameraComponent::FSpinMoveAngleMinVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FSpinMoveAngleMaxVt) == 0x0006D8, "Member 'UPlayerCameraComponent::FSpinMoveAngleMaxVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAngleVtDistEnable) == 0x0006DC, "Member 'UPlayerCameraComponent::bAngleVtDistEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAngleVtDistRate) == 0x0006E0, "Member 'UPlayerCameraComponent::FAngleVtDistRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAngleVtDistLerpCurve) == 0x0006E8, "Member 'UPlayerCameraComponent::PAngleVtDistLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAngleVtRootEnable) == 0x0006F0, "Member 'UPlayerCameraComponent::bAngleVtRootEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAngleVtRootRate) == 0x0006F4, "Member 'UPlayerCameraComponent::FAngleVtRootRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VAngleVtRootOffset) == 0x0006F8, "Member 'UPlayerCameraComponent::VAngleVtRootOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAngleVtRootLerpCurve) == 0x000708, "Member 'UPlayerCameraComponent::PAngleVtRootLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnApply) == 0x000710, "Member 'UPlayerCameraComponent::bLockOnApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnActor) == 0x000714, "Member 'UPlayerCameraComponent::PLockOnActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LockOnOffset) == 0x00071C, "Member 'UPlayerCameraComponent::LockOnOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LockOnAngleLimitPly) == 0x000728, "Member 'UPlayerCameraComponent::LockOnAngleLimitPly' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LockOnAngleLimitCam) == 0x00072C, "Member 'UPlayerCameraComponent::LockOnAngleLimitCam' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnAngleUp) == 0x000730, "Member 'UPlayerCameraComponent::FLockOnAngleUp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnAngleDn) == 0x000734, "Member 'UPlayerCameraComponent::FLockOnAngleDn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnAngleLt) == 0x000738, "Member 'UPlayerCameraComponent::FLockOnAngleLt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnAngleRt) == 0x00073C, "Member 'UPlayerCameraComponent::FLockOnAngleRt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugNoLerpVtAngle) == 0x000740, "Member 'UPlayerCameraComponent::bDebugNoLerpVtAngle' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnRootPly) == 0x000744, "Member 'UPlayerCameraComponent::VLockOnRootPly' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnRootEnm) == 0x000750, "Member 'UPlayerCameraComponent::VLockOnRootEnm' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnLookAt) == 0x00075C, "Member 'UPlayerCameraComponent::VLockOnLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnRoot) == 0x000768, "Member 'UPlayerCameraComponent::bLockOnRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnRoot) == 0x00076C, "Member 'UPlayerCameraComponent::VLockOnRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLookAtDistanceOffset) == 0x000778, "Member 'UPlayerCameraComponent::FLookAtDistanceOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLogLockOn) == 0x00077C, "Member 'UPlayerCameraComponent::bDebugPrintLogLockOn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLerp) == 0x00077D, "Member 'UPlayerCameraComponent::bLockOnLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpTime) == 0x000780, "Member 'UPlayerCameraComponent::FLockOnLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpTimeSign) == 0x000784, "Member 'UPlayerCameraComponent::FLockOnLerpTimeSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnLerpCurve) == 0x000788, "Member 'UPlayerCameraComponent::PLockOnLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpTimer) == 0x000790, "Member 'UPlayerCameraComponent::FLockOnLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpRate) == 0x000794, "Member 'UPlayerCameraComponent::FLockOnLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLerpAngleVtEnable) == 0x000798, "Member 'UPlayerCameraComponent::bLockOnLerpAngleVtEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLerpAngleVtApply) == 0x000799, "Member 'UPlayerCameraComponent::bLockOnLerpAngleVtApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpAngleVtStt) == 0x00079C, "Member 'UPlayerCameraComponent::FLockOnLerpAngleVtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpAngleVtEnd) == 0x0007A0, "Member 'UPlayerCameraComponent::FLockOnLerpAngleVtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLerpAngleVtEaseBlend) == 0x0007A4, "Member 'UPlayerCameraComponent::FLockOnLerpAngleVtEaseBlend' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnLerp) == 0x0007A8, "Member 'UPlayerCameraComponent::bDebugPrintLockOnLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLookAtObject) == 0x0007AC, "Member 'UPlayerCameraComponent::PLookAtObject' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLookAtObj) == 0x0007B4, "Member 'UPlayerCameraComponent::bLockOnLookAtObj' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnObjLerp) == 0x0007B5, "Member 'UPlayerCameraComponent::bLockOnObjLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpRateStt) == 0x0007B8, "Member 'UPlayerCameraComponent::FLockOnObjLerpRateStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpRate) == 0x0007BC, "Member 'UPlayerCameraComponent::FLockOnObjLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpAngleMax) == 0x0007C0, "Member 'UPlayerCameraComponent::FLockOnObjLerpAngleMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTimeStart) == 0x0007C4, "Member 'UPlayerCameraComponent::FLockOnObjLerpTimeStart' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTime) == 0x0007C8, "Member 'UPlayerCameraComponent::FLockOnObjLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTimeEnd) == 0x0007CC, "Member 'UPlayerCameraComponent::FLockOnObjLerpTimeEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTimer) == 0x0007D0, "Member 'UPlayerCameraComponent::FLockOnObjLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpTimeSign) == 0x0007D4, "Member 'UPlayerCameraComponent::FLockOnObjLerpTimeSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnObjLerpCurve) == 0x0007D8, "Member 'UPlayerCameraComponent::PLockOnObjLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnObjLerpDelayApply) == 0x0007E0, "Member 'UPlayerCameraComponent::bLockOnObjLerpDelayApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnObjLerpDelayOffsetEnd) == 0x0007E4, "Member 'UPlayerCameraComponent::VLockOnObjLerpDelayOffsetEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockOnObjLerpDelayOffset) == 0x0007F0, "Member 'UPlayerCameraComponent::VLockOnObjLerpDelayOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpDelayTime) == 0x0007FC, "Member 'UPlayerCameraComponent::FLockOnObjLerpDelayTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnObjLerpDelayTimer) == 0x000800, "Member 'UPlayerCameraComponent::FLockOnObjLerpDelayTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnObjLerp) == 0x000804, "Member 'UPlayerCameraComponent::bDebugPrintLockOnObjLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLookAtDistAngleVtLerpEnable) == 0x000805, "Member 'UPlayerCameraComponent::bLockOnLookAtDistAngleVtLerpEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnLookAtDistAngleVtLerp) == 0x000808, "Member 'UPlayerCameraComponent::PLockOnLookAtDistAngleVtLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLookAtDistAngleVtLerpRate) == 0x000810, "Member 'UPlayerCameraComponent::FLockOnLookAtDistAngleVtLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnLookAtDistCamDistEnable) == 0x000814, "Member 'UPlayerCameraComponent::bLockOnLookAtDistCamDistEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnLookAtDistCamDistLerp) == 0x000818, "Member 'UPlayerCameraComponent::PLockOnLookAtDistCamDistLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnLookAtDistCamDistLerpRate) == 0x000820, "Member 'UPlayerCameraComponent::FLockOnLookAtDistCamDistLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnRotateSpeedRateEnable) == 0x000824, "Member 'UPlayerCameraComponent::bLockOnRotateSpeedRateEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateFovRateHz) == 0x000828, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateFovRateHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateFovRateVt) == 0x00082C, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateFovRateVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateAngleHz) == 0x000830, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateAngleVt) == 0x000834, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnRotateSpeedRateLerp) == 0x000838, "Member 'UPlayerCameraComponent::bLockOnRotateSpeedRateLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnRotateSpeedRateSign) == 0x000839, "Member 'UPlayerCameraComponent::bLockOnRotateSpeedRateSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnRotateSpeedRateCurve) == 0x000840, "Member 'UPlayerCameraComponent::PLockOnRotateSpeedRateCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateTimeDecel) == 0x000848, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateTimeDecel' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateTimeReturn) == 0x00084C, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateTimeReturn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateTimer) == 0x000850, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnRotateSpeedRateCurrent) == 0x000854, "Member 'UPlayerCameraComponent::FLockOnRotateSpeedRateCurrent' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnRotateSpeed) == 0x000858, "Member 'UPlayerCameraComponent::bDebugPrintLockOnRotateSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawLockOnRotateLine) == 0x000859, "Member 'UPlayerCameraComponent::bDebugDrawLockOnRotateLine' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnEnable) == 0x00085A, "Member 'UPlayerCameraComponent::bLockOnReturnEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnSkip) == 0x00085B, "Member 'UPlayerCameraComponent::bLockOnReturnSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleHz) == 0x00085C, "Member 'UPlayerCameraComponent::FLockOnReturnAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleVt) == 0x000860, "Member 'UPlayerCameraComponent::FLockOnReturnAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnCheck) == 0x000864, "Member 'UPlayerCameraComponent::bLockOnReturnCheck' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnLerpStt) == 0x000865, "Member 'UPlayerCameraComponent::bLockOnReturnLerpStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnLerpHz) == 0x000866, "Member 'UPlayerCameraComponent::bLockOnReturnLerpHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnLerpHzPly) == 0x000867, "Member 'UPlayerCameraComponent::bLockOnReturnLerpHzPly' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnLerpVt) == 0x000868, "Member 'UPlayerCameraComponent::bLockOnReturnLerpVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnLerpTime) == 0x00086C, "Member 'UPlayerCameraComponent::FLockOnReturnLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnLerpTimeOptionParamList) == 0x000870, "Member 'UPlayerCameraComponent::FLockOnReturnLerpTimeOptionParamList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnLerpTimer) == 0x000880, "Member 'UPlayerCameraComponent::FLockOnReturnLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleHzStt) == 0x000884, "Member 'UPlayerCameraComponent::FLockOnReturnAngleHzStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleHzEnd) == 0x000888, "Member 'UPlayerCameraComponent::FLockOnReturnAngleHzEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleVtStt) == 0x00088C, "Member 'UPlayerCameraComponent::FLockOnReturnAngleVtStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnAngleVtEnd) == 0x000890, "Member 'UPlayerCameraComponent::FLockOnReturnAngleVtEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnClockwise) == 0x000894, "Member 'UPlayerCameraComponent::bLockOnReturnClockwise' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PLockOnReturnLerpCurve) == 0x000898, "Member 'UPlayerCameraComponent::PLockOnReturnLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnActionEnableHz) == 0x0008A0, "Member 'UPlayerCameraComponent::bLockOnReturnActionEnableHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnActionApplyHz) == 0x0008A1, "Member 'UPlayerCameraComponent::bLockOnReturnActionApplyHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnActionLerpHz) == 0x0008A2, "Member 'UPlayerCameraComponent::bLockOnReturnActionLerpHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnReturnActionLerpEndHz) == 0x0008A3, "Member 'UPlayerCameraComponent::bLockOnReturnActionLerpEndHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnActionLerpTimeHz) == 0x0008A4, "Member 'UPlayerCameraComponent::FLockOnReturnActionLerpTimeHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnActionLerpTimerHz) == 0x0008A8, "Member 'UPlayerCameraComponent::FLockOnReturnActionLerpTimerHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnReturnActionAngleHz) == 0x0008AC, "Member 'UPlayerCameraComponent::FLockOnReturnActionAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawLockOnReturnLine) == 0x0008B0, "Member 'UPlayerCameraComponent::bDebugDrawLockOnReturnLine' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnReturnSkip) == 0x0008B1, "Member 'UPlayerCameraComponent::bDebugPrintLockOnReturnSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bKeepAngleEnable) == 0x0008B2, "Member 'UPlayerCameraComponent::bKeepAngleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bKeepAngleApply) == 0x0008B3, "Member 'UPlayerCameraComponent::bKeepAngleApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FKeepAngleLookAtDistance) == 0x0008B4, "Member 'UPlayerCameraComponent::FKeepAngleLookAtDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleEnable) == 0x0008B8, "Member 'UPlayerCameraComponent::bLockOnKeepAngleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleSpeedEnable) == 0x0008B9, "Member 'UPlayerCameraComponent::bLockOnKeepAngleSpeedEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleSkip) == 0x0008BA, "Member 'UPlayerCameraComponent::bLockOnKeepAngleSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleHzSkip) == 0x0008BB, "Member 'UPlayerCameraComponent::bLockOnKeepAngleHzSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnKeepAngleHzSpeed) == 0x0008BC, "Member 'UPlayerCameraComponent::FLockOnKeepAngleHzSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockOnKeepAngleVtSkip) == 0x0008C0, "Member 'UPlayerCameraComponent::bLockOnKeepAngleVtSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockOnKeepAngleVtSpeed) == 0x0008C4, "Member 'UPlayerCameraComponent::FLockOnKeepAngleVtSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockOnKeepAngleSkip) == 0x0008C8, "Member 'UPlayerCameraComponent::bDebugPrintLockOnKeepAngleSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosEnable) == 0x0008C9, "Member 'UPlayerCameraComponent::bLockEnemyPosEnable' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosUpdateParam) == 0x0008CA, "Member 'UPlayerCameraComponent::bLockEnemyPosUpdateParam' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosSkip) == 0x0008CB, "Member 'UPlayerCameraComponent::bLockEnemyPosSkip' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosUpdate) == 0x0008CC, "Member 'UPlayerCameraComponent::bLockEnemyPosUpdate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockEnemyPos) == 0x0008D0, "Member 'UPlayerCameraComponent::VLockEnemyPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyLerpRate) == 0x0008DC, "Member 'UPlayerCameraComponent::FLockEnemyLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosLockDistanceHz) == 0x0008E0, "Member 'UPlayerCameraComponent::FLockEnemyPosLockDistanceHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosRestoreDistanceHz) == 0x0008E4, "Member 'UPlayerCameraComponent::FLockEnemyPosRestoreDistanceHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockEnemyPosPrevHz) == 0x0008E8, "Member 'UPlayerCameraComponent::VLockEnemyPosPrevHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosSkipHz) == 0x0008F4, "Member 'UPlayerCameraComponent::bLockEnemyPosSkipHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosLockDistanceVt) == 0x0008F8, "Member 'UPlayerCameraComponent::FLockEnemyPosLockDistanceVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosRestoreDistanceVt) == 0x0008FC, "Member 'UPlayerCameraComponent::FLockEnemyPosRestoreDistanceVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VLockEnemyPosPrevVt) == 0x000900, "Member 'UPlayerCameraComponent::VLockEnemyPosPrevVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLockEnemyPosSkipVt) == 0x00090C, "Member 'UPlayerCameraComponent::bLockEnemyPosSkipVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosDistMaxHz) == 0x000910, "Member 'UPlayerCameraComponent::FLockEnemyPosDistMaxHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLockEnemyPosDistMaxVt) == 0x000914, "Member 'UPlayerCameraComponent::FLockEnemyPosDistMaxVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintLockEnemyPos) == 0x000918, "Member 'UPlayerCameraComponent::bDebugPrintLockEnemyPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, LockOnMapGimmickLerpTime) == 0x000924, "Member 'UPlayerCameraComponent::LockOnMapGimmickLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraApply) == 0x000928, "Member 'UPlayerCameraComponent::bUniqueObjectCameraApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketType) == 0x000929, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketType' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketOption) == 0x00092A, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketOption' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraParam) == 0x000930, "Member 'UPlayerCameraComponent::UniqueObjectCameraParam' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraMeshComp) == 0x000988, "Member 'UPlayerCameraComponent::PUniqueObjectCameraMeshComp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraPlayerFix) == 0x000990, "Member 'UPlayerCameraComponent::bUniqueObjectCameraPlayerFix' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraPlayerPos) == 0x000994, "Member 'UPlayerCameraComponent::UniqueObjectCameraPlayerPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketApply) == 0x0009A0, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraSocketPos) == 0x0009A4, "Member 'UPlayerCameraComponent::UniqueObjectCameraSocketPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketLerp) == 0x0009B0, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraSocketLerpEnd) == 0x0009B1, "Member 'UPlayerCameraComponent::bUniqueObjectCameraSocketLerpEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraSocketLerpTimeStt) == 0x0009B4, "Member 'UPlayerCameraComponent::UniqueObjectCameraSocketLerpTimeStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraSocketLerpTimeEnd) == 0x0009B8, "Member 'UPlayerCameraComponent::UniqueObjectCameraSocketLerpTimeEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraSocketLerpRate) == 0x0009BC, "Member 'UPlayerCameraComponent::UniqueObjectCameraSocketLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraControlType) == 0x0009C0, "Member 'UPlayerCameraComponent::bUniqueObjectCameraControlType' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraControlRot) == 0x0009C4, "Member 'UPlayerCameraComponent::UniqueObjectCameraControlRot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraRemoteType) == 0x0009D0, "Member 'UPlayerCameraComponent::bUniqueObjectCameraRemoteType' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraRemoteActor) == 0x0009D4, "Member 'UPlayerCameraComponent::PUniqueObjectCameraRemoteActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraLookAtLerpApply) == 0x0009DC, "Member 'UPlayerCameraComponent::bUniqueObjectCameraLookAtLerpApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLookAtRate) == 0x0009E0, "Member 'UPlayerCameraComponent::UniqueObjectCameraLookAtRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLookAtLerpTime) == 0x0009E4, "Member 'UPlayerCameraComponent::UniqueObjectCameraLookAtLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLookAtLerpTimer) == 0x0009E8, "Member 'UPlayerCameraComponent::UniqueObjectCameraLookAtLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLookAtDelayRate) == 0x0009EC, "Member 'UPlayerCameraComponent::UniqueObjectCameraLookAtDelayRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraEnemyActor) == 0x0009F8, "Member 'UPlayerCameraComponent::PUniqueObjectCameraEnemyActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraEnemyActorPos) == 0x000A00, "Member 'UPlayerCameraComponent::UniqueObjectCameraEnemyActorPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraObjectActor) == 0x000A0C, "Member 'UPlayerCameraComponent::PUniqueObjectCameraObjectActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VUniqueObjectCameraLookAtPos) == 0x000A14, "Member 'UPlayerCameraComponent::VUniqueObjectCameraLookAtPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraDistNear) == 0x000A20, "Member 'UPlayerCameraComponent::bUniqueObjectCameraDistNear' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraDistRate) == 0x000A24, "Member 'UPlayerCameraComponent::UniqueObjectCameraDistRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraLerpCurveStt) == 0x000A28, "Member 'UPlayerCameraComponent::PUniqueObjectCameraLerpCurveStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PUniqueObjectCameraLerpCurveEnd) == 0x000A30, "Member 'UPlayerCameraComponent::PUniqueObjectCameraLerpCurveEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraLerp) == 0x000A38, "Member 'UPlayerCameraComponent::bUniqueObjectCameraLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraLerpEnd) == 0x000A39, "Member 'UPlayerCameraComponent::bUniqueObjectCameraLerpEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraLerpEndInstance) == 0x000A3A, "Member 'UPlayerCameraComponent::bUniqueObjectCameraLerpEndInstance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLerpTimer) == 0x000A3C, "Member 'UPlayerCameraComponent::UniqueObjectCameraLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, UniqueObjectCameraLerpRate) == 0x000A40, "Member 'UPlayerCameraComponent::UniqueObjectCameraLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bUniqueObjectCameraPlayerLeft) == 0x000AD4, "Member 'UPlayerCameraComponent::bUniqueObjectCameraPlayerLeft' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCamera) == 0x000AD5, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCamera' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraPos) == 0x000AD6, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraPosLerp) == 0x000AD7, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraPosLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraLookAt) == 0x000AD8, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraRot) == 0x000AD9, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraRot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraFov) == 0x000ADA, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraSocket) == 0x000ADB, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraSocket' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraControl) == 0x000ADC, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraControl' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugUniqueObjectCameraNewLookAt) == 0x000ADD, "Member 'UPlayerCameraComponent::bDebugUniqueObjectCameraNewLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintUniqueObjectCameraLookAtRate) == 0x000ADE, "Member 'UPlayerCameraComponent::bDebugPrintUniqueObjectCameraLookAtRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraPos) == 0x000ADF, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraPosLerp) == 0x000AE0, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraPosLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraLookAt) == 0x000AE1, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraLookAt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraTime) == 0x000AE4, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawUniqueObjectCameraBgTrace) == 0x000AE8, "Member 'UPlayerCameraComponent::bDebugDrawUniqueObjectCameraBgTrace' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionCameraApply) == 0x000AEC, "Member 'UPlayerCameraComponent::bAttentionCameraApply' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionLerpStt) == 0x000AED, "Member 'UPlayerCameraComponent::bAttentionLerpStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionLerpEnd) == 0x000AEE, "Member 'UPlayerCameraComponent::bAttentionLerpEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionActor) == 0x000AEF, "Member 'UPlayerCameraComponent::bAttentionActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VAttentionPos) == 0x000AF0, "Member 'UPlayerCameraComponent::VAttentionPos' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAttentionActor) == 0x000AFC, "Member 'UPlayerCameraComponent::PAttentionActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAttentionActorCurve) == 0x000B08, "Member 'UPlayerCameraComponent::PAttentionActorCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionActorFixAngleVt) == 0x000B10, "Member 'UPlayerCameraComponent::bAttentionActorFixAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionActorFixAngleVt) == 0x000B14, "Member 'UPlayerCameraComponent::AttentionActorFixAngleVt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionActorOffsetDistHz) == 0x000B18, "Member 'UPlayerCameraComponent::bAttentionActorOffsetDistHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionActorOffsetDistHz) == 0x000B1C, "Member 'UPlayerCameraComponent::AttentionActorOffsetDistHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionActorOffsetDistHzSign) == 0x000B20, "Member 'UPlayerCameraComponent::AttentionActorOffsetDistHzSign' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAttentionFov) == 0x000B24, "Member 'UPlayerCameraComponent::bAttentionFov' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PAttentionFovCurve) == 0x000B28, "Member 'UPlayerCameraComponent::PAttentionFovCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionCameraLerpTime) == 0x000B30, "Member 'UPlayerCameraComponent::AttentionCameraLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AttentionCameraLerpRate) == 0x000B34, "Member 'UPlayerCameraComponent::AttentionCameraLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintAttentionCamera) == 0x000B50, "Member 'UPlayerCameraComponent::bDebugPrintAttentionCamera' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bPlayerLerpAuto) == 0x000B51, "Member 'UPlayerCameraComponent::bPlayerLerpAuto' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerLerpTraceAngleList) == 0x000B58, "Member 'UPlayerCameraComponent::FPlayerLerpTraceAngleList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerLerpTraceDistance) == 0x000B68, "Member 'UPlayerCameraComponent::FPlayerLerpTraceDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerLerpDistance) == 0x000B6C, "Member 'UPlayerCameraComponent::FPlayerLerpDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bPlayerLerp) == 0x000B70, "Member 'UPlayerCameraComponent::bPlayerLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VPlayerLerpPosStt) == 0x000B74, "Member 'UPlayerCameraComponent::VPlayerLerpPosStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VPlayerLerpPosEnd) == 0x000B80, "Member 'UPlayerCameraComponent::VPlayerLerpPosEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerLerpRadius) == 0x000B8C, "Member 'UPlayerCameraComponent::FPlayerLerpRadius' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PPlayerLerpCurve) == 0x000B90, "Member 'UPlayerCameraComponent::PPlayerLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PEnemyLerpActor) == 0x000B98, "Member 'UPlayerCameraComponent::PEnemyLerpActor' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FEnemyLerpDistance) == 0x000BA0, "Member 'UPlayerCameraComponent::FEnemyLerpDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FEnemyLerpRateDefault) == 0x000BA4, "Member 'UPlayerCameraComponent::FEnemyLerpRateDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FEnemyLerpRate) == 0x000BA8, "Member 'UPlayerCameraComponent::FEnemyLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FEnemyLerpRadius) == 0x000BAC, "Member 'UPlayerCameraComponent::FEnemyLerpRadius' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerPullDistance) == 0x000BB0, "Member 'UPlayerCameraComponent::FPlayerPullDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FPlayerPullMoveDistMax) == 0x000BB4, "Member 'UPlayerCameraComponent::FPlayerPullMoveDistMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bEnemyLerp) == 0x000BB8, "Member 'UPlayerCameraComponent::bEnemyLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VEnemyLerpPosStt) == 0x000BBC, "Member 'UPlayerCameraComponent::VEnemyLerpPosStt' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, VEnemyLerpPosEnd) == 0x000BC8, "Member 'UPlayerCameraComponent::VEnemyLerpPosEnd' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawPlayerLerpVector) == 0x000BD4, "Member 'UPlayerCameraComponent::bDebugDrawPlayerLerpVector' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawPlayerLerpSphere) == 0x000BD5, "Member 'UPlayerCameraComponent::bDebugDrawPlayerLerpSphere' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawEnemyLerpSphere) == 0x000BD6, "Member 'UPlayerCameraComponent::bDebugDrawEnemyLerpSphere' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintEnemyLerpSphere) == 0x000BD7, "Member 'UPlayerCameraComponent::bDebugPrintEnemyLerpSphere' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLerpReset) == 0x000BD8, "Member 'UPlayerCameraComponent::bLerpReset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bLerpUpdateAngleHz) == 0x000BD9, "Member 'UPlayerCameraComponent::bLerpUpdateAngleHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bCameraReset) == 0x000BDA, "Member 'UPlayerCameraComponent::bCameraReset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLerpTime) == 0x000BDC, "Member 'UPlayerCameraComponent::FLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FLerpRate) == 0x000BE0, "Member 'UPlayerCameraComponent::FLerpRate' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCameraHitRadius) == 0x000C24, "Member 'UPlayerCameraComponent::FCameraHitRadius' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCameraHitRadiusPlane) == 0x000C28, "Member 'UPlayerCameraComponent::FCameraHitRadiusPlane' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FCameraHitRadiusOffset) == 0x000C2C, "Member 'UPlayerCameraComponent::FCameraHitRadiusOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bCameraBuried) == 0x000C30, "Member 'UPlayerCameraComponent::bCameraBuried' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDistSpeedAccel) == 0x000C34, "Member 'UPlayerCameraComponent::FDistSpeedAccel' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDistSpeedMax) == 0x000C38, "Member 'UPlayerCameraComponent::FDistSpeedMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FDistSpeed) == 0x000C3C, "Member 'UPlayerCameraComponent::FDistSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawTraceCorner) == 0x000C40, "Member 'UPlayerCameraComponent::bDebugDrawTraceCorner' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawTraceCameraRoot) == 0x000C41, "Member 'UPlayerCameraComponent::bDebugDrawTraceCameraRoot' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawTraceCameraDistance) == 0x000C42, "Member 'UPlayerCameraComponent::bDebugDrawTraceCameraDistance' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, AreaTriggerInfo) == 0x000C48, "Member 'UPlayerCameraComponent::AreaTriggerInfo' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, CurrentTriggerInfo) == 0x000C70, "Member 'UPlayerCameraComponent::CurrentTriggerInfo' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoList) == 0x000C98, "Member 'UPlayerCameraComponent::TriggerInfoList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTriggerInfoLerp) == 0x000CA8, "Member 'UPlayerCameraComponent::bTriggerInfoLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoLerpTimer) == 0x000CAC, "Member 'UPlayerCameraComponent::TriggerInfoLerpTimer' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PTriggerInfoLerpCurve) == 0x000CB0, "Member 'UPlayerCameraComponent::PTriggerInfoLerpCurve' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoLerpTime) == 0x000CB8, "Member 'UPlayerCameraComponent::TriggerInfoLerpTime' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PTriggerInfoLerpCurveDefault) == 0x000CC0, "Member 'UPlayerCameraComponent::PTriggerInfoLerpCurveDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoLerpTimeDefault) == 0x000CC8, "Member 'UPlayerCameraComponent::TriggerInfoLerpTimeDefault' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bTriggerInfoSkipLerp) == 0x000CCC, "Member 'UPlayerCameraComponent::bTriggerInfoSkipLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, TriggerInfoSkipLerpRefList) == 0x000CD0, "Member 'UPlayerCameraComponent::TriggerInfoSkipLerpRefList' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PresetBasic) == 0x000CE0, "Member 'UPlayerCameraComponent::PresetBasic' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, PresetOffset) == 0x000DC0, "Member 'UPlayerCameraComponent::PresetOffset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, CurrentPreset) == 0x000EA0, "Member 'UPlayerCameraComponent::CurrentPreset' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugNewTriggerEndLerp) == 0x000F80, "Member 'UPlayerCameraComponent::bDebugNewTriggerEndLerp' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, NextTriggerInfo) == 0x001198, "Member 'UPlayerCameraComponent::NextTriggerInfo' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAssistRootHeight) == 0x0011C0, "Member 'UPlayerCameraComponent::bAssistRootHeight' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistYut) == 0x0011C4, "Member 'UPlayerCameraComponent::FAssistRootHeightDistYut' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistKsn) == 0x0011C8, "Member 'UPlayerCameraComponent::FAssistRootHeightDistKsn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistMax) == 0x0011CC, "Member 'UPlayerCameraComponent::FAssistRootHeightDistMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistRangeMin) == 0x0011D0, "Member 'UPlayerCameraComponent::FAssistRootHeightDistRangeMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightDistRangeMax) == 0x0011D4, "Member 'UPlayerCameraComponent::FAssistRootHeightDistRangeMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleYut) == 0x0011D8, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleYut' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleKsn) == 0x0011DC, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleKsn' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleMax) == 0x0011E0, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleRangeMin) == 0x0011E4, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleRangeMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, FAssistRootHeightAngleRangeMax) == 0x0011E8, "Member 'UPlayerCameraComponent::FAssistRootHeightAngleRangeMax' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDbDispAssistRootHeight) == 0x0011EC, "Member 'UPlayerCameraComponent::bDbDispAssistRootHeight' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAsyncRequestPrevProc) == 0x00126C, "Member 'UPlayerCameraComponent::bAsyncRequestPrevProc' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAsyncRequestTaskProc) == 0x00126D, "Member 'UPlayerCameraComponent::bAsyncRequestTaskProc' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bAsyncTaskDone) == 0x00126E, "Member 'UPlayerCameraComponent::bAsyncTaskDone' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, ActorMoveDistMin) == 0x001270, "Member 'UPlayerCameraComponent::ActorMoveDistMin' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, DbDrawTrace) == 0x001318, "Member 'UPlayerCameraComponent::DbDrawTrace' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugPrintRootOffsetHz) == 0x001319, "Member 'UPlayerCameraComponent::bDebugPrintRootOffsetHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDebugDrawTraceRootOffsetHz) == 0x00131A, "Member 'UPlayerCameraComponent::bDebugDrawTraceRootOffsetHz' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDbTemp0) == 0x00131B, "Member 'UPlayerCameraComponent::bDbTemp0' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDbTemp1) == 0x00131C, "Member 'UPlayerCameraComponent::bDbTemp1' has a wrong offset!");
static_assert(offsetof(UPlayerCameraComponent, bDbTemp2) == 0x00131D, "Member 'UPlayerCameraComponent::bDbTemp2' has a wrong offset!");

// Class BattlePrototype.DebuggingItemAppVersionGroup
// 0x0010 (0x02E0 - 0x02D0)
class ADebuggingItemAppVersionGroup final : public ADebuggingItemGroup
{
public:
	TWeakObjectPtr<class ADebuggingItemLabel>     DispLabel;                                         // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       VersionInt;                                        // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnExecChangeReleaseVersion(const class ADebuggingItemEvent* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemAppVersionGroup">();
	}
	static class ADebuggingItemAppVersionGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemAppVersionGroup>();
	}
};
static_assert(alignof(ADebuggingItemAppVersionGroup) == 0x000008, "Wrong alignment on ADebuggingItemAppVersionGroup");
static_assert(sizeof(ADebuggingItemAppVersionGroup) == 0x0002E0, "Wrong size on ADebuggingItemAppVersionGroup");
static_assert(offsetof(ADebuggingItemAppVersionGroup, DispLabel) == 0x0002D0, "Member 'ADebuggingItemAppVersionGroup::DispLabel' has a wrong offset!");
static_assert(offsetof(ADebuggingItemAppVersionGroup, VersionInt) == 0x0002D8, "Member 'ADebuggingItemAppVersionGroup::VersionInt' has a wrong offset!");

// Class BattlePrototype.AriseCollaboParamDebugGroup
// 0x0020 (0x02F0 - 0x02D0)
class AAriseCollaboParamDebugGroup final : public ADebuggingItemGroup
{
public:
	TWeakObjectPtr<class ADebuggingItemBool>      IsCheckedSave;                                     // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecParamChange;                                   // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecCheckSave;                                     // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USaveLoadScreenParamManager*            DebugSaveLoadScreenParamManager;                   // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnExecuteCheckSave(const class ADebuggingItemEvent* Item);
	void OnExecuteParameterChange(const class ADebuggingItemEvent* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AriseCollaboParamDebugGroup">();
	}
	static class AAriseCollaboParamDebugGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAriseCollaboParamDebugGroup>();
	}
};
static_assert(alignof(AAriseCollaboParamDebugGroup) == 0x000008, "Wrong alignment on AAriseCollaboParamDebugGroup");
static_assert(sizeof(AAriseCollaboParamDebugGroup) == 0x0002F0, "Wrong size on AAriseCollaboParamDebugGroup");
static_assert(offsetof(AAriseCollaboParamDebugGroup, IsCheckedSave) == 0x0002D0, "Member 'AAriseCollaboParamDebugGroup::IsCheckedSave' has a wrong offset!");
static_assert(offsetof(AAriseCollaboParamDebugGroup, ExecParamChange) == 0x0002D8, "Member 'AAriseCollaboParamDebugGroup::ExecParamChange' has a wrong offset!");
static_assert(offsetof(AAriseCollaboParamDebugGroup, ExecCheckSave) == 0x0002E0, "Member 'AAriseCollaboParamDebugGroup::ExecCheckSave' has a wrong offset!");
static_assert(offsetof(AAriseCollaboParamDebugGroup, DebugSaveLoadScreenParamManager) == 0x0002E8, "Member 'AAriseCollaboParamDebugGroup::DebugSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.UIConfigSelectBase
// 0x0078 (0x0400 - 0x0388)
class UUIConfigSelectBase : public UUIBase
{
public:
	uint8                                         Pad_1DFD[0x78];                                    // 0x0388(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelectBase">();
	}
	static class UUIConfigSelectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelectBase>();
	}
};
static_assert(alignof(UUIConfigSelectBase) == 0x000008, "Wrong alignment on UUIConfigSelectBase");
static_assert(sizeof(UUIConfigSelectBase) == 0x000400, "Wrong size on UUIConfigSelectBase");

// Class BattlePrototype.ArrangeItemBase
// 0x00E8 (0x0318 - 0x0230)
class AArrangeItemBase : public AActor
{
public:
	uint8                                         Pad_1DFF[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsDoBeginPlay;                                     // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E00[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActionIconSupportParamID;                          // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0250(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               ActionIconType;                                    // 0x025C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E01[0x3];                                     // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ID;                                                // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 RandomArrangeItemID;                               // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E02[0x4];                                     // 0x0280(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelID;                                           // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GroupID;                                           // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E03[0x4];                                     // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ArrangeItemId;                                     // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FArrangeItemDataCell                   ArrangeItemDataCell;                               // 0x02A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          Acquired;                                          // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInvisivleInEvent;                                // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E04[0x6];                                     // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        IntervalTime;                                      // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OnScenarioFlagName;                                // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          AddItemSeCue;                                      // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          AcquisitionFailureSound;                           // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E05[0x6];                                     // 0x0300(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WhetherToGetFullItem;                              // 0x0306(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EArrangeItemBrainTalkType                     BrainTalkType;                                     // 0x0307(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoGet;                                          // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E06[0x3];                                     // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EvetBoxSize;                                       // 0x030C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnAcquire(bool IsInitialize);
	void OnBindAcquire(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnBindShowBoxBeginOverlap(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRebirth(bool IsInitialize);
	void RestoreVisible();
	void Setup();
	void SetVisible(const bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemBase">();
	}
	static class AArrangeItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeItemBase>();
	}
};
static_assert(alignof(AArrangeItemBase) == 0x000008, "Wrong alignment on AArrangeItemBase");
static_assert(sizeof(AArrangeItemBase) == 0x000318, "Wrong size on AArrangeItemBase");
static_assert(offsetof(AArrangeItemBase, IsDoBeginPlay) == 0x000238, "Member 'AArrangeItemBase::IsDoBeginPlay' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ChildActionIcon) == 0x000240, "Member 'AArrangeItemBase::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ActionIconSupportParamID) == 0x000248, "Member 'AArrangeItemBase::ActionIconSupportParamID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ActionIconWorldPositionOffset) == 0x000250, "Member 'AArrangeItemBase::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ActionIconType) == 0x00025C, "Member 'AArrangeItemBase::ActionIconType' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ID) == 0x000260, "Member 'AArrangeItemBase::ID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, RandomArrangeItemID) == 0x000270, "Member 'AArrangeItemBase::RandomArrangeItemID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, LevelID) == 0x000284, "Member 'AArrangeItemBase::LevelID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, GroupID) == 0x000288, "Member 'AArrangeItemBase::GroupID' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ArrangeItemId) == 0x000290, "Member 'AArrangeItemBase::ArrangeItemId' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ArrangeItemDataCell) == 0x0002A0, "Member 'AArrangeItemBase::ArrangeItemDataCell' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, Acquired) == 0x0002C8, "Member 'AArrangeItemBase::Acquired' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, IsInvisivleInEvent) == 0x0002C9, "Member 'AArrangeItemBase::IsInvisivleInEvent' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, IntervalTime) == 0x0002D0, "Member 'AArrangeItemBase::IntervalTime' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, OnScenarioFlagName) == 0x0002D8, "Member 'AArrangeItemBase::OnScenarioFlagName' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, AddItemSeCue) == 0x0002E0, "Member 'AArrangeItemBase::AddItemSeCue' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, AcquisitionFailureSound) == 0x0002E8, "Member 'AArrangeItemBase::AcquisitionFailureSound' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, ShowBoxComponent) == 0x0002F0, "Member 'AArrangeItemBase::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, EventBoxComponent) == 0x0002F8, "Member 'AArrangeItemBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, WhetherToGetFullItem) == 0x000306, "Member 'AArrangeItemBase::WhetherToGetFullItem' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, BrainTalkType) == 0x000307, "Member 'AArrangeItemBase::BrainTalkType' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, bAutoGet) == 0x000308, "Member 'AArrangeItemBase::bAutoGet' has a wrong offset!");
static_assert(offsetof(AArrangeItemBase, EvetBoxSize) == 0x00030C, "Member 'AArrangeItemBase::EvetBoxSize' has a wrong offset!");

// Class BattlePrototype.ArrangeItemIDSetter
// 0x0000 (0x0028 - 0x0028)
class UArrangeItemIDSetter final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemIDSetter">();
	}
	static class UArrangeItemIDSetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrangeItemIDSetter>();
	}
};
static_assert(alignof(UArrangeItemIDSetter) == 0x000008, "Wrong alignment on UArrangeItemIDSetter");
static_assert(sizeof(UArrangeItemIDSetter) == 0x000028, "Wrong size on UArrangeItemIDSetter");

// Class BattlePrototype.PlayerAIBaseComponent
// 0x0300 (0x03C0 - 0x00C0)
class UPlayerAIBaseComponent : public UActorComponent
{
public:
	uint8                                         Pad_1E09[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameTimer>                     ThinkTimerList;                                    // 0x00C8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0A[0x8];                                     // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Param_ThreatTime;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0B[0x4];                                     // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerAIThreatActorData>       ThreatDataArray;                                   // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameTimer                             EventMoveForceEndTimer;                            // 0x00F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DodgeRangeAttackDistance;                          // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnpcUniqueObjDodgeProbability;                     // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0C[0x28];                                    // 0x010C(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerAIMoveModeCPP                          MoveModeCPP;                                       // 0x0134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeftPos;                                          // 0x0135(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCircleDirClockwise;                               // 0x0136(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0D[0x1];                                     // 0x0137(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveCircleSpeed;                                   // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JumpDestination;                                   // 0x013C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OrderJumpNum;                                      // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThinkDistance;                                     // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentGoalBaseLocation;                           // 0x0150(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentGoalRelativeLocation;                       // 0x015C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentGoalDesiredRelativeLocation;                // 0x0168(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableGoalRelativeLocation;                       // 0x0174(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0E[0x3];                                     // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSGoalActorBase*                       MoveGoalActor;                                     // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentGoalArmLength;                              // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentGoalYaw;                                    // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PrevThinkLastActorForward;                         // 0x0188(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCircleNear;                                       // 0x0194(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0F[0x3];                                     // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             NearCircleMoveTimer;                               // 0x0198(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         NearCircleMoveNearDist;                            // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NearCircleMoveFarDist;                             // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                JumpDir;                                           // 0x01AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerAICheckMoveWallParamIn          AsyncCheckWallParamIn;                             // 0x01B8(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bOwnerENPC;                                        // 0x01D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvalidKeepOut;                                   // 0x01D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttackHit;                                        // 0x01DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E10[0x1];                                     // 0x01DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ARSCharacterBase>        BattleTargetActor;                                 // 0x01DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             UpdateTargetTimer;                                 // 0x01E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bUpdateBattleTarget;                               // 0x01F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBattleModeFlag;                                   // 0x01F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceUpdateTarget;                                // 0x01F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E11[0x1];                                     // 0x01F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AttackCount;                                       // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NoAttackTime;                                      // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBattleActionStartFlag;                            // 0x01FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E12[0x3];                                     // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateBattleTargetIntervalTime;                    // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDodgeAble;                                        // 0x0204(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDodgeAttack;                                      // 0x0205(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E13[0x2];                                     // 0x0206(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             DodgeIntervalTimer;                                // 0x0208(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                BattleDodgeDir;                                    // 0x0214(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDodgeRangeAttack;                                 // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E14[0x3];                                     // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DodgeRangeAttackDir;                               // 0x0224(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DodgeIntervalTime;                                 // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceDodgeIntervalTime;                            // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LeftStick;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeftStickScale;                                    // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeftStickScaleEnable;                             // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E15[0x3];                                     // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       bEnableInputStick;                                 // 0x0248(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bMoveStickBack;                                    // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMoveStickDetour;                                  // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E16[0x2];                                     // 0x029A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveStickDetourYawAngle;                           // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAITargetSearchModeCPP                  TargetSearchModeCPP;                               // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIOrder                                Order;                                             // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E17[0x2];                                     // 0x02A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RANGE_NEAR;                                        // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RANGE_FAR;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RANGE_TOO_FAR;                                     // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOVE_AIM_CIRRCLE_SPEED;                            // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOVE_CIRCLE_SPEED;                                 // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOVE_CIRCLE_SPEED_FAR;                             // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_WARY_HP_RATE_1;                                // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_WARY_HP_RATE_2;                                // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_WARY_PROBABILITY_DOWN_1;                       // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_WARY_PROBABILITY_DOWN_2;                       // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_ATTACK_PROBABILITY_UP_TIME_1;                  // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_ATTACK_PROBABILITY_UP_TIME_2;                  // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_ATTACK_PROBABILITY_UP_VALUE_1;                 // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_ATTACK_PROBABILITY_UP_VALUE_2;                 // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_MOVE_PROBABILITY_DOWN_TIME;                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_MOVE_PROBABILITY_DOWN_VALUE;                   // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_ATTACK_PROBABILITY_DOWN_THREAT_VALUE;          // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NPC_ASSIST_ATTACK_PROBABILITY_UP_VALUE;            // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_REVIVE_DISTANCE;                               // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPC_REVIVE_DISTANCE_FAR;                           // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CONFUSION_FRIEND_PRIORITY_OFFSET;                  // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           EvaluateLocationTimerHandle;                       // 0x02F8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBeginEvaluateLocation;                            // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFirstEvaluate;                                    // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResetBehaviorTree;                                // 0x0302(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEventWait;                                        // 0x0303(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIBattleThinkTypeCPP                   CurrentBattleThinkCPP;                             // 0x0304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIBattleThinkParamCPP                  CurrentBattleThinkParamCPP;                        // 0x0305(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E18[0x2];                                     // 0x0306(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 StealthThinkRateList;                              // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EPlayerAIBattleThinkTypeCPP>           StealthThinkTypeListCPP;                           // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIBattleThinkTypeCPP                   ReserveThinkTypeCPP;                               // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIBattleThinkParamCPP                  ReserveThinkParamCPP;                              // 0x0329(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReserveNextThink;                                 // 0x032A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishMetamorphosis;                              // 0x032B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ThinkPhaseTransition;                              // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIThinkTableTypeCPP                    CurrentThinkTableTypeCPP;                          // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEventMove;                                        // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E19[0x6];                                     // 0x0332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        EventMovePosList;                                  // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 EventMoveRadiusList;                               // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EventMoveWalkScale;                                // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ClaimantNameEventMove;                             // 0x035C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterHitPriority                         StoreCharacterHitPriority;                         // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStoreCharacterHitPriority;                        // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEventMoveAfterWait;                               // 0x0366(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEventMoveWalkFlag;                                // 0x0367(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseItemThink;                                     // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EConsumeItemID                                UseItemID;                                         // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAssistItem;                                       // 0x036A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1A[0x1];                                     // 0x036B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ControlPlayerDist;                                 // 0x036C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BattleTargetDist;                                  // 0x0378(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleTargetAngle;                                 // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelfRecoveryFlag;                                 // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1B[0x3];                                     // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelfRecoveryNum;                                   // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDrawLocationEvaluate;                        // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1C[0x3];                                     // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialTargetLength;                               // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableTargetChangeResetThink;                    // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1D[0x7];                                     // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerScriptComponent*                 OwnerPlayerScript;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCppFunc;                                       // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1E[0x7];                                     // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      CollisionObjectTypesForGroundHit;                  // 0x03B0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool BeginEvaluateLocation_CallFromCPP();
	bool BindCheckBattleActionStart_CallFromCPP();
	float CalcDistanceTargetEvaluateCPP(const struct FVector& TargetLocation);
	struct FVector CalcMoveToActorLocationCPP(class ACharacter* Self);
	struct FVector CalcStickDir_BattleDodgeCPP();
	struct FVector2D CalcStickDirCPP();
	float CalcTargetEvaluate_CallFromCPP(class ARSCharacterBase* EvaluateTarget);
	int32 CalcThinkTransitionProbabilityCPP(int32 Probability, EPlayerAIBattleThinkTypeCPP Action);
	int32 CalcThinkTransitionProbabilityCPP_CheckMoveOrAttackOrOthers(EPlayerAIBattleThinkTypeCPP Action);
	bool CalcThinkTransitionProbabilityCPP_NeedsHPCheckByThinkType(EPlayerAIBattleThinkTypeCPP Action);
	void CancelUseItemCPP();
	void ChangeThinkTableTypeCPP(EPlayerAIThinkTableTypeCPP ThinkTableType, bool bResetThink);
	bool CheckBattleThinkTransition_CallFromCPP(EPlayerAIBattleThinkTransitionCPP Transition);
	bool CheckDodgeRangeAttack(struct FVector* DodgeDir);
	bool CheckEventMovePosCPP(bool bCheckDistance);
	void CheckGoalLocationKeepOutCPP();
	bool CheckInAttackArea_CallFromCPP(const struct FVector& CheckLocation);
	bool CheckMovePosCPP();
	void CheckMoveWallCPP(EPlayerAIMoveWallCPP* OutWall, struct FVector* OutLocation);
	bool CheckPsychicObjectCPP(bool bCapture, bool bAttack);
	bool CheckSelfRecovery_CallFromCPP();
	void ClearDodgeRangeAttackData();
	TArray<struct FPlayerAIThreatActorData> DebugGetThreatDataArray();
	bool DebugUpdate_CallFromCPP();
	void DecreaseSelfRecoveryNumCPP();
	void DisableStickInputCPP(class FName ClaimantName);
	void EnableStickInputCPP(class FName ClaimantName);
	bool EndEvaluateLocation_CallFromCPP();
	void EndEventMoveCPP();
	void EndEventWaitCPP();
	TArray<EObjectTypeQuery> GetCollisionObjectTypesForGroundHit_CallFromCPP();
	void GetEventMovePosActorCPP(class AActor** OutPosActor, float* OutAcceptRadius);
	EPlayerAIBattleThinkTypeCPP GetStealthThinkCPP();
	void InitializeAI();
	void InitializeFixParam(const struct FPlayerAIComponentInitializeParam& Param);
	void InitializeThinkTimerList(int32 TimerNum);
	bool IsPsychicAbleCPP();
	bool IsRegisterThreatActor(class AActor* CheckActor);
	bool IsThinkTimerOverByIndex(int32 Param_Index);
	void JumpOrderCPP(const struct FVector& Destination);
	void MainUpdateCPP();
	bool NextBattleThink_CallFromCPP();
	struct FVector NormalizeVectorXY_CPP(const struct FVector& InVec);
	void NotifyAttackStartCPP();
	void NotifyForceWarpCPP();
	void NotifyMoveBrainFieldCPP(bool bToBrainField);
	void NotifyResetBehaviorTreeCPP();
	void OnAttackHitCPP();
	void OnClearReserveReturnMovePlayer();
	void OnEventStartCPP();
	void OnInitializeAI();
	void OnJumpCPP();
	void OnMovementCollisionLandCPP();
	void OnReserveReturnMovePlayer();
	void OnUpdateAI();
	void OnUpdateUpdateEvaluateLocationCPP();
	void PostUpdateCPP();
	void PreUpdateCPP();
	bool PreUpdateCPP_RangeAttack_BPImplement();
	void RegisterEvaluateLocationCPP();
	void RegisterThreatActor(class AActor* ThreatActor);
	void RequestUseItemCPP(EConsumeItemID Item_id_in, bool bAssist);
	void ReserveNextThinkCPP(EPlayerAIBattleThinkTypeCPP ThinkType, EPlayerAIBattleThinkParamCPP Param);
	void ResetBattleThinkCPP();
	bool RestartBattleAI_CallFromCPP(bool bInEvent);
	class ARSCharacterBase* SearchTargetCPP(const TArray<class ARSCharacterBase*>& TargetList);
	void SetAttackHit(bool Value);
	void SetBattleModeCPP(bool bBattle);
	void SetBattleTargetCPP(class ARSCharacterBase* TargetActor);
	void SetBattleTargetDist(const struct FVector& Value);
	bool SetBattleThink_CallFromCPP(EPlayerAIBattleThinkTypeCPP Action, EPlayerAIBattleThinkParamCPP Param);
	void SetDisableChangeTargetResetThinkCPP(bool InDisable);
	void SetEventMoveCPP(const TArray<struct FVector>& Pos_list_in, const TArray<float>& Radius_list_in, bool Walk, bool bAfterWait, float MaxMoveTime);
	void SetEventWaitCPP();
	bool SetFinishMetamorphosisCPP(bool bFinish);
	void SetForceUpdateTarget(bool Value);
	void SetInvalidKeepOutCPP(bool IsInvalid);
	void SetLeftStickScale(bool bEnable, float Scale);
	void SetMoveLocationCPP(const struct FVector& Location, float ArmLength, float Yaw);
	void SetMoveModeCPP(EPlayerAIMoveModeCPP Mode);
	void SetMoveModeFromThinkCPP(EPlayerAIBattleThinkTypeCPP Think);
	void SetMoveStickBackCPP(bool bBack);
	void SetMoveStickDetourCPP(bool bEnable, float YawAngle);
	void SetOrderCPP(EPlayerAIOrder _Order);
	void SetOwnerPlayerScript(class UPlayerScriptComponent* Comp);
	void SetSelfRecoveryNum(int32 Value);
	void SetTargetSearchModeCPP(EPlayerAITargetSearchModeCPP Value);
	void SetThinkKeepOutCPP();
	bool SetThinkPhaseTransitionCPP(int32 NewPhase);
	void SetThinkTimerByIndex(int32 Param_Index, float Time);
	bool SetupUseItem_CallFromCPP();
	bool UnbindCheckBattleActionStart_CallFromCPP();
	void UpdateAI();
	bool UpdateBattleDodgeDir_CallFromCPP();
	void UpdateBattleTargetActorCPP();
	bool UpdateCheckBattleActionStartCPP();
	void UpdateCheckRangeAttack(class UHitCheckComponent* HitCheck);
	void UpdateCheckRangeAttackEnpc(class UHitCheckComponent* HitCheck);
	void UpdateCounterCPP();
	void UpdateCPP();
	void UpdateDataCPP();
	void UpdateDodge_BattleCPP();
	void UpdateDodge_FollowPlayerCPP();
	void UpdateDodgeBattle_Enpc_BPImplement(bool* bOK, bool* OutDodgeNormalAttack, bool* OutDodgeRangeAttack, bool* OutForceDodge);
	void UpdateDodgeCPP();
	void UpdateEventMoveCPP();
	void UpdateMovePos_ApproachTargetCPP();
	void UpdateMovePos_CircleCPP();
	void UpdateMovePos_FollowPlayerCPP();
	void UpdateMovePosCPP();
	void UpdateMoveWallCPP();
	void UpdateThinkTimerList(class AActor* UpdateActor);
	void UpdateThreatData(float DeltaSeconds);

	struct FVector CalcStickDir_BattleAttackCPP() const;
	bool CheckDistanceCPP(const struct FVector& RefPos1, const struct FVector& RefPos2, float Distance, bool bIgnoreHeight) const;
	bool CheckDistanceFromVectorCPP(const struct FVector& Dist, float Distance, bool bIgnoreHeight) const;
	bool CheckDistanceFromVectorXY_CPP(const struct FVector& Vec, float Distance) const;
	bool CheckDistanceFromVectorXYZ_CPP(const struct FVector& Vec, float Distance) const;
	bool CheckNpcReviveCPP(float InDistance) const;
	bool CheckUnderSiegeCPP() const;
	int32 GetAttackCountCPP() const;
	ERSAttackInputKind GetAttackInputKindCPP() const;
	class AActor* GetBattleTargetActorCPP() const;
	struct FVector GetBattleTargetDist() const;
	struct FVector GetControlPlayerDistCPP() const;
	EPlayerAIBattleThinkTypeCPP GetCurrentBattleThinkCPP() const;
	EPlayerAIBattleThinkParamCPP GetCurrentBattleThinkParamCPP() const;
	class UDataTable* GetCurrentThinkTable_CallFromCPP() const;
	class UPlayerAIEvaluateLocationComponent* GetEvaluateLocation() const;
	float GetEventMoveLeftStickX_CPP() const;
	float GetEventMoveLeftStickY_CPP() const;
	float GetLeftStickScale() const;
	EPlayerAIMoveModeCPP GetMoveModeCPP() const;
	class AActor* GetMovePosActorCPP() const;
	EPlayerAIOrder GetOrderCPP() const;
	int32 GetSelfRecoveryNum() const;
	float GetTargetAngleCPP(const struct FVector& BaseDirection, const struct FVector& TargetDirection) const;
	float GetTargetAngleXY_CPP(const struct FVector& BaseDirection, const struct FVector& TargetDirection) const;
	void GetTargetEvaluateData_CallFromCPP(struct FPlayerAIEvaluateTargetParameter* OutParam) const;
	int32 GetThinkPhaseTransitionCPP() const;
	EConsumeItemID GetUseItemID_CPP() const;
	bool IsAttackAbleCPP() const;
	bool IsAttackAbleCPP_TypeCheck(EPlayerAIBattleThinkTypeCPP ThinkType) const;
	bool IsAttackHit() const;
	bool IsAttackThinkCPP(EPlayerAIBattleThinkTypeCPP Type) const;
	bool IsBattleActionStartCPP() const;
	bool IsBattleThinkCPP(EPlayerAIBattleThinkTypeCPP Type) const;
	bool IsDodgeAbleCPP() const;
	bool IsEnableStickInputCPP() const;
	bool IsEventMoveCPP() const;
	bool IsEventMoveEndCPP() const;
	bool IsEventWaitCPP() const;
	bool IsFinishMetamorphosisCPP() const;
	bool IsForceUpdateTarget() const;
	bool IsJumpAbleCPP() const;
	bool IsLeftStickScaleEnable() const;
	bool IsPsychicAbleCPP_TypeCheck(EPlayerAIBattleThinkTypeCPP ThinkType) const;
	bool IsPsychicComboThinkCPP() const;
	bool IsRangeFarCPP(const struct FVector& Dist) const;
	bool IsRangeMiddleCPP(const struct FVector& Dist) const;
	bool IsRangeNearCPP(const struct FVector& Dist) const;
	bool IsRangeTooFarCPP(const struct FVector& Dist) const;
	bool IsResetBehaviorTreeCPP() const;
	bool IsSelfRecoveryCPP() const;
	bool IsUpdateCPP() const;
	bool IsUseCppFunc() const;
	bool IsUseItemThinkCPP() const;
	bool IsWaitBattleStartCPP() const;
	bool SearchPsychicObjectCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAIBaseComponent">();
	}
	static class UPlayerAIBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAIBaseComponent>();
	}
};
static_assert(alignof(UPlayerAIBaseComponent) == 0x000008, "Wrong alignment on UPlayerAIBaseComponent");
static_assert(sizeof(UPlayerAIBaseComponent) == 0x0003C0, "Wrong size on UPlayerAIBaseComponent");
static_assert(offsetof(UPlayerAIBaseComponent, ThinkTimerList) == 0x0000C8, "Member 'UPlayerAIBaseComponent::ThinkTimerList' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, Param_ThreatTime) == 0x0000E0, "Member 'UPlayerAIBaseComponent::Param_ThreatTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ThreatDataArray) == 0x0000E8, "Member 'UPlayerAIBaseComponent::ThreatDataArray' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EventMoveForceEndTimer) == 0x0000F8, "Member 'UPlayerAIBaseComponent::EventMoveForceEndTimer' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, DodgeRangeAttackDistance) == 0x000104, "Member 'UPlayerAIBaseComponent::DodgeRangeAttackDistance' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EnpcUniqueObjDodgeProbability) == 0x000108, "Member 'UPlayerAIBaseComponent::EnpcUniqueObjDodgeProbability' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MoveModeCPP) == 0x000134, "Member 'UPlayerAIBaseComponent::MoveModeCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bLeftPos) == 0x000135, "Member 'UPlayerAIBaseComponent::bLeftPos' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bCircleDirClockwise) == 0x000136, "Member 'UPlayerAIBaseComponent::bCircleDirClockwise' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MoveCircleSpeed) == 0x000138, "Member 'UPlayerAIBaseComponent::MoveCircleSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, JumpDestination) == 0x00013C, "Member 'UPlayerAIBaseComponent::JumpDestination' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, OrderJumpNum) == 0x000148, "Member 'UPlayerAIBaseComponent::OrderJumpNum' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ThinkDistance) == 0x00014C, "Member 'UPlayerAIBaseComponent::ThinkDistance' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalBaseLocation) == 0x000150, "Member 'UPlayerAIBaseComponent::CurrentGoalBaseLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalRelativeLocation) == 0x00015C, "Member 'UPlayerAIBaseComponent::CurrentGoalRelativeLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalDesiredRelativeLocation) == 0x000168, "Member 'UPlayerAIBaseComponent::CurrentGoalDesiredRelativeLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEnableGoalRelativeLocation) == 0x000174, "Member 'UPlayerAIBaseComponent::bEnableGoalRelativeLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MoveGoalActor) == 0x000178, "Member 'UPlayerAIBaseComponent::MoveGoalActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalArmLength) == 0x000180, "Member 'UPlayerAIBaseComponent::CurrentGoalArmLength' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentGoalYaw) == 0x000184, "Member 'UPlayerAIBaseComponent::CurrentGoalYaw' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, PrevThinkLastActorForward) == 0x000188, "Member 'UPlayerAIBaseComponent::PrevThinkLastActorForward' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bCircleNear) == 0x000194, "Member 'UPlayerAIBaseComponent::bCircleNear' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NearCircleMoveTimer) == 0x000198, "Member 'UPlayerAIBaseComponent::NearCircleMoveTimer' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NearCircleMoveNearDist) == 0x0001A4, "Member 'UPlayerAIBaseComponent::NearCircleMoveNearDist' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NearCircleMoveFarDist) == 0x0001A8, "Member 'UPlayerAIBaseComponent::NearCircleMoveFarDist' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, JumpDir) == 0x0001AC, "Member 'UPlayerAIBaseComponent::JumpDir' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, AsyncCheckWallParamIn) == 0x0001B8, "Member 'UPlayerAIBaseComponent::AsyncCheckWallParamIn' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bOwnerENPC) == 0x0001D8, "Member 'UPlayerAIBaseComponent::bOwnerENPC' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bInvalidKeepOut) == 0x0001D9, "Member 'UPlayerAIBaseComponent::bInvalidKeepOut' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bAttackHit) == 0x0001DA, "Member 'UPlayerAIBaseComponent::bAttackHit' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, BattleTargetActor) == 0x0001DC, "Member 'UPlayerAIBaseComponent::BattleTargetActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, UpdateTargetTimer) == 0x0001E4, "Member 'UPlayerAIBaseComponent::UpdateTargetTimer' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bUpdateBattleTarget) == 0x0001F0, "Member 'UPlayerAIBaseComponent::bUpdateBattleTarget' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bBattleModeFlag) == 0x0001F1, "Member 'UPlayerAIBaseComponent::bBattleModeFlag' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bForceUpdateTarget) == 0x0001F2, "Member 'UPlayerAIBaseComponent::bForceUpdateTarget' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, AttackCount) == 0x0001F4, "Member 'UPlayerAIBaseComponent::AttackCount' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NoAttackTime) == 0x0001F8, "Member 'UPlayerAIBaseComponent::NoAttackTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bBattleActionStartFlag) == 0x0001FC, "Member 'UPlayerAIBaseComponent::bBattleActionStartFlag' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, UpdateBattleTargetIntervalTime) == 0x000200, "Member 'UPlayerAIBaseComponent::UpdateBattleTargetIntervalTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDodgeAble) == 0x000204, "Member 'UPlayerAIBaseComponent::bDodgeAble' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDodgeAttack) == 0x000205, "Member 'UPlayerAIBaseComponent::bDodgeAttack' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, DodgeIntervalTimer) == 0x000208, "Member 'UPlayerAIBaseComponent::DodgeIntervalTimer' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, BattleDodgeDir) == 0x000214, "Member 'UPlayerAIBaseComponent::BattleDodgeDir' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDodgeRangeAttack) == 0x000220, "Member 'UPlayerAIBaseComponent::bDodgeRangeAttack' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, DodgeRangeAttackDir) == 0x000224, "Member 'UPlayerAIBaseComponent::DodgeRangeAttackDir' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, DodgeIntervalTime) == 0x000230, "Member 'UPlayerAIBaseComponent::DodgeIntervalTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ForceDodgeIntervalTime) == 0x000234, "Member 'UPlayerAIBaseComponent::ForceDodgeIntervalTime' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, LeftStick) == 0x000238, "Member 'UPlayerAIBaseComponent::LeftStick' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, LeftStickScale) == 0x000240, "Member 'UPlayerAIBaseComponent::LeftStickScale' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bLeftStickScaleEnable) == 0x000244, "Member 'UPlayerAIBaseComponent::bLeftStickScaleEnable' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEnableInputStick) == 0x000248, "Member 'UPlayerAIBaseComponent::bEnableInputStick' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bMoveStickBack) == 0x000298, "Member 'UPlayerAIBaseComponent::bMoveStickBack' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bMoveStickDetour) == 0x000299, "Member 'UPlayerAIBaseComponent::bMoveStickDetour' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MoveStickDetourYawAngle) == 0x00029C, "Member 'UPlayerAIBaseComponent::MoveStickDetourYawAngle' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, TargetSearchModeCPP) == 0x0002A0, "Member 'UPlayerAIBaseComponent::TargetSearchModeCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, Order) == 0x0002A1, "Member 'UPlayerAIBaseComponent::Order' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, RANGE_NEAR) == 0x0002A4, "Member 'UPlayerAIBaseComponent::RANGE_NEAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, RANGE_FAR) == 0x0002A8, "Member 'UPlayerAIBaseComponent::RANGE_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, RANGE_TOO_FAR) == 0x0002AC, "Member 'UPlayerAIBaseComponent::RANGE_TOO_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MOVE_AIM_CIRRCLE_SPEED) == 0x0002B0, "Member 'UPlayerAIBaseComponent::MOVE_AIM_CIRRCLE_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MOVE_CIRCLE_SPEED) == 0x0002B4, "Member 'UPlayerAIBaseComponent::MOVE_CIRCLE_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, MOVE_CIRCLE_SPEED_FAR) == 0x0002B8, "Member 'UPlayerAIBaseComponent::MOVE_CIRCLE_SPEED_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_WARY_HP_RATE_1) == 0x0002BC, "Member 'UPlayerAIBaseComponent::NPC_WARY_HP_RATE_1' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_WARY_HP_RATE_2) == 0x0002C0, "Member 'UPlayerAIBaseComponent::NPC_WARY_HP_RATE_2' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_WARY_PROBABILITY_DOWN_1) == 0x0002C4, "Member 'UPlayerAIBaseComponent::NPC_WARY_PROBABILITY_DOWN_1' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_WARY_PROBABILITY_DOWN_2) == 0x0002C8, "Member 'UPlayerAIBaseComponent::NPC_WARY_PROBABILITY_DOWN_2' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_UP_TIME_1) == 0x0002CC, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_UP_TIME_1' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_UP_TIME_2) == 0x0002D0, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_UP_TIME_2' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_UP_VALUE_1) == 0x0002D4, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_UP_VALUE_1' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_UP_VALUE_2) == 0x0002D8, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_UP_VALUE_2' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_MOVE_PROBABILITY_DOWN_TIME) == 0x0002DC, "Member 'UPlayerAIBaseComponent::NPC_MOVE_PROBABILITY_DOWN_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_MOVE_PROBABILITY_DOWN_VALUE) == 0x0002E0, "Member 'UPlayerAIBaseComponent::NPC_MOVE_PROBABILITY_DOWN_VALUE' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ATTACK_PROBABILITY_DOWN_THREAT_VALUE) == 0x0002E4, "Member 'UPlayerAIBaseComponent::NPC_ATTACK_PROBABILITY_DOWN_THREAT_VALUE' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_ASSIST_ATTACK_PROBABILITY_UP_VALUE) == 0x0002E8, "Member 'UPlayerAIBaseComponent::NPC_ASSIST_ATTACK_PROBABILITY_UP_VALUE' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_REVIVE_DISTANCE) == 0x0002EC, "Member 'UPlayerAIBaseComponent::NPC_REVIVE_DISTANCE' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, NPC_REVIVE_DISTANCE_FAR) == 0x0002F0, "Member 'UPlayerAIBaseComponent::NPC_REVIVE_DISTANCE_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CONFUSION_FRIEND_PRIORITY_OFFSET) == 0x0002F4, "Member 'UPlayerAIBaseComponent::CONFUSION_FRIEND_PRIORITY_OFFSET' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EvaluateLocationTimerHandle) == 0x0002F8, "Member 'UPlayerAIBaseComponent::EvaluateLocationTimerHandle' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bBeginEvaluateLocation) == 0x000300, "Member 'UPlayerAIBaseComponent::bBeginEvaluateLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bFirstEvaluate) == 0x000301, "Member 'UPlayerAIBaseComponent::bFirstEvaluate' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bResetBehaviorTree) == 0x000302, "Member 'UPlayerAIBaseComponent::bResetBehaviorTree' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEventWait) == 0x000303, "Member 'UPlayerAIBaseComponent::bEventWait' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentBattleThinkCPP) == 0x000304, "Member 'UPlayerAIBaseComponent::CurrentBattleThinkCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentBattleThinkParamCPP) == 0x000305, "Member 'UPlayerAIBaseComponent::CurrentBattleThinkParamCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, StealthThinkRateList) == 0x000308, "Member 'UPlayerAIBaseComponent::StealthThinkRateList' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, StealthThinkTypeListCPP) == 0x000318, "Member 'UPlayerAIBaseComponent::StealthThinkTypeListCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ReserveThinkTypeCPP) == 0x000328, "Member 'UPlayerAIBaseComponent::ReserveThinkTypeCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ReserveThinkParamCPP) == 0x000329, "Member 'UPlayerAIBaseComponent::ReserveThinkParamCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bReserveNextThink) == 0x00032A, "Member 'UPlayerAIBaseComponent::bReserveNextThink' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bFinishMetamorphosis) == 0x00032B, "Member 'UPlayerAIBaseComponent::bFinishMetamorphosis' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ThinkPhaseTransition) == 0x00032C, "Member 'UPlayerAIBaseComponent::ThinkPhaseTransition' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CurrentThinkTableTypeCPP) == 0x000330, "Member 'UPlayerAIBaseComponent::CurrentThinkTableTypeCPP' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEventMove) == 0x000331, "Member 'UPlayerAIBaseComponent::bEventMove' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EventMovePosList) == 0x000338, "Member 'UPlayerAIBaseComponent::EventMovePosList' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EventMoveRadiusList) == 0x000348, "Member 'UPlayerAIBaseComponent::EventMoveRadiusList' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, EventMoveWalkScale) == 0x000358, "Member 'UPlayerAIBaseComponent::EventMoveWalkScale' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ClaimantNameEventMove) == 0x00035C, "Member 'UPlayerAIBaseComponent::ClaimantNameEventMove' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, StoreCharacterHitPriority) == 0x000364, "Member 'UPlayerAIBaseComponent::StoreCharacterHitPriority' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bStoreCharacterHitPriority) == 0x000365, "Member 'UPlayerAIBaseComponent::bStoreCharacterHitPriority' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEventMoveAfterWait) == 0x000366, "Member 'UPlayerAIBaseComponent::bEventMoveAfterWait' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bEventMoveWalkFlag) == 0x000367, "Member 'UPlayerAIBaseComponent::bEventMoveWalkFlag' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bUseItemThink) == 0x000368, "Member 'UPlayerAIBaseComponent::bUseItemThink' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, UseItemID) == 0x000369, "Member 'UPlayerAIBaseComponent::UseItemID' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bAssistItem) == 0x00036A, "Member 'UPlayerAIBaseComponent::bAssistItem' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, ControlPlayerDist) == 0x00036C, "Member 'UPlayerAIBaseComponent::ControlPlayerDist' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, BattleTargetDist) == 0x000378, "Member 'UPlayerAIBaseComponent::BattleTargetDist' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, BattleTargetAngle) == 0x000384, "Member 'UPlayerAIBaseComponent::BattleTargetAngle' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bSelfRecoveryFlag) == 0x000388, "Member 'UPlayerAIBaseComponent::bSelfRecoveryFlag' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, SelfRecoveryNum) == 0x00038C, "Member 'UPlayerAIBaseComponent::SelfRecoveryNum' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDebugDrawLocationEvaluate) == 0x000390, "Member 'UPlayerAIBaseComponent::bDebugDrawLocationEvaluate' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, InitialTargetLength) == 0x000394, "Member 'UPlayerAIBaseComponent::InitialTargetLength' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bDisableTargetChangeResetThink) == 0x000398, "Member 'UPlayerAIBaseComponent::bDisableTargetChangeResetThink' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, OwnerPlayerScript) == 0x0003A0, "Member 'UPlayerAIBaseComponent::OwnerPlayerScript' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, bUseCppFunc) == 0x0003A8, "Member 'UPlayerAIBaseComponent::bUseCppFunc' has a wrong offset!");
static_assert(offsetof(UPlayerAIBaseComponent, CollisionObjectTypesForGroundHit) == 0x0003B0, "Member 'UPlayerAIBaseComponent::CollisionObjectTypesForGroundHit' has a wrong offset!");

// Class BattlePrototype.ArrangeItemManager
// 0x0090 (0x02C0 - 0x0230)
class AArrangeItemManager final : public AActor
{
public:
	uint8                                         Pad_1E36[0x18];                                    // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrangeItemListForSaveData>    M_allArrangeItemList;                              // 0x0248(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRandomArrangeItemIDInfo>       M_allRandomArrangeItemIDInfo;                      // 0x0258(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        M_timerCount;                                      // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EChangeMinimapStateType ChangeType, class FName ID)> OnChangeMinimapStateDelegate;                      // 0x0270(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAcquireDispather;                                // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRebirthDispather;                                // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	double                                        M_LotteryPrintDispEndTime;                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         M_LotteryPrintTextList;                            // 0x02A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isLotteryPrintDispDrawed;                        // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isDebugLotteryPrintDispFlag;                     // 0x02B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isDebugForceRepopTimeFlag;                       // 0x02BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E37[0x1];                                     // 0x02BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_debugForceRepopTime;                             // 0x02BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ChangeAreaWork();
	bool GetArrangeItemParam(const class FName ID, float* IntervalTime, bool* Acquired, bool* Accessed);
	bool SetAccessed(const class FName ID, const bool Flag);
	bool SetAcquired(const class FName ID, const bool Flag);
	bool SetIntervalTime(const class FName ID, const float ArrangeItemIntervaltime, float* ResultIntervalTime);
	void SetRandomArrangeParam2Actor(class AArrangeItemBase* _actor);
	bool SetRebirth(const class FName ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemManager">();
	}
	static class AArrangeItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeItemManager>();
	}
};
static_assert(alignof(AArrangeItemManager) == 0x000008, "Wrong alignment on AArrangeItemManager");
static_assert(sizeof(AArrangeItemManager) == 0x0002C0, "Wrong size on AArrangeItemManager");
static_assert(offsetof(AArrangeItemManager, M_allArrangeItemList) == 0x000248, "Member 'AArrangeItemManager::M_allArrangeItemList' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_allRandomArrangeItemIDInfo) == 0x000258, "Member 'AArrangeItemManager::M_allRandomArrangeItemIDInfo' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_timerCount) == 0x000268, "Member 'AArrangeItemManager::M_timerCount' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, OnChangeMinimapStateDelegate) == 0x000270, "Member 'AArrangeItemManager::OnChangeMinimapStateDelegate' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, OnAcquireDispather) == 0x000280, "Member 'AArrangeItemManager::OnAcquireDispather' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, OnRebirthDispather) == 0x000290, "Member 'AArrangeItemManager::OnRebirthDispather' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_LotteryPrintDispEndTime) == 0x0002A0, "Member 'AArrangeItemManager::M_LotteryPrintDispEndTime' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_LotteryPrintTextList) == 0x0002A8, "Member 'AArrangeItemManager::M_LotteryPrintTextList' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_isLotteryPrintDispDrawed) == 0x0002B8, "Member 'AArrangeItemManager::M_isLotteryPrintDispDrawed' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_isDebugLotteryPrintDispFlag) == 0x0002B9, "Member 'AArrangeItemManager::M_isDebugLotteryPrintDispFlag' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_isDebugForceRepopTimeFlag) == 0x0002BA, "Member 'AArrangeItemManager::M_isDebugForceRepopTimeFlag' has a wrong offset!");
static_assert(offsetof(AArrangeItemManager, M_debugForceRepopTime) == 0x0002BC, "Member 'AArrangeItemManager::M_debugForceRepopTime' has a wrong offset!");

// Class BattlePrototype.ArrangeItemParticle
// 0x0028 (0x0340 - 0x0318)
class AArrangeItemParticle : public AArrangeItemBase
{
public:
	class URSParticleSystemComponentBase*         ParticleComponent;                                 // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         ParticleComponentSub1;                             // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         AcquiredParticleComponent;                         // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         AcquiredParticleComponentSub1;                     // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          AcquiredSeCue;                                     // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UParticleSystem* GetEmitterTemplate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemParticle">();
	}
	static class AArrangeItemParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeItemParticle>();
	}
};
static_assert(alignof(AArrangeItemParticle) == 0x000008, "Wrong alignment on AArrangeItemParticle");
static_assert(sizeof(AArrangeItemParticle) == 0x000340, "Wrong size on AArrangeItemParticle");
static_assert(offsetof(AArrangeItemParticle, ParticleComponent) == 0x000318, "Member 'AArrangeItemParticle::ParticleComponent' has a wrong offset!");
static_assert(offsetof(AArrangeItemParticle, ParticleComponentSub1) == 0x000320, "Member 'AArrangeItemParticle::ParticleComponentSub1' has a wrong offset!");
static_assert(offsetof(AArrangeItemParticle, AcquiredParticleComponent) == 0x000328, "Member 'AArrangeItemParticle::AcquiredParticleComponent' has a wrong offset!");
static_assert(offsetof(AArrangeItemParticle, AcquiredParticleComponentSub1) == 0x000330, "Member 'AArrangeItemParticle::AcquiredParticleComponentSub1' has a wrong offset!");
static_assert(offsetof(AArrangeItemParticle, AcquiredSeCue) == 0x000338, "Member 'AArrangeItemParticle::AcquiredSeCue' has a wrong offset!");

// Class BattlePrototype.ArrangeItemParticleEvent
// 0x0000 (0x0340 - 0x0340)
class AArrangeItemParticleEvent final : public AArrangeItemParticle
{
public:
	bool DoEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeItemParticleEvent">();
	}
	static class AArrangeItemParticleEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeItemParticleEvent>();
	}
};
static_assert(alignof(AArrangeItemParticleEvent) == 0x000008, "Wrong alignment on AArrangeItemParticleEvent");
static_assert(sizeof(AArrangeItemParticleEvent) == 0x000340, "Wrong size on AArrangeItemParticleEvent");

// Class BattlePrototype.ItemCaptureParamExporter
// 0x0000 (0x0028 - 0x0028)
class UItemCaptureParamExporter final : public UBlueprintFunctionLibrary
{
public:
	static void ExportItemDataTableType(const struct FItemDataTableRaw& ItemDataTableRaw, const class FString& OutputJsonPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCaptureParamExporter">();
	}
	static class UItemCaptureParamExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCaptureParamExporter>();
	}
};
static_assert(alignof(UItemCaptureParamExporter) == 0x000008, "Wrong alignment on UItemCaptureParamExporter");
static_assert(sizeof(UItemCaptureParamExporter) == 0x000028, "Wrong size on UItemCaptureParamExporter");

// Class BattlePrototype.UITitleCrossSave
// 0x00B0 (0x0438 - 0x0388)
class UUITitleCrossSave final : public UUIBase
{
public:
	uint8                                         Pad_1E3D[0xB0];                                    // 0x0388(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextTitle, class UREDTextBlock* TextHelp, class UUIGuide* UIGuide, class UUITitleCrossSave_UpdatingWidget* UiUpdatingWidget, class UUITitleCrossSave_ConfirmWindow* UiConfirmWindow);
	void Start(class ARSTitleManager* TitleManager);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleCrossSave">();
	}
	static class UUITitleCrossSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleCrossSave>();
	}
};
static_assert(alignof(UUITitleCrossSave) == 0x000008, "Wrong alignment on UUITitleCrossSave");
static_assert(sizeof(UUITitleCrossSave) == 0x000438, "Wrong size on UUITitleCrossSave");

// Class BattlePrototype.ArrangeObject
// 0x0078 (0x02A8 - 0x0230)
class AArrangeObject : public AActor
{
public:
	uint8                                         Pad_1E3E[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsDoBeginPlay;                                     // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E3F[0x3];                                     // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelID;                                           // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupID;                                           // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ArrangeMesh;                                       // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FirstPosition;                                     // 0x0250(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FirstRotation;                                     // 0x025C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TempPosition;                                      // 0x0268(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TempRotation;                                      // 0x0274(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UFootStepComponent*                     FootStepComponent;                                 // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitActorInfo>                  HitActorList;                                      // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSeInterval;                                     // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaySeVelocity;                                    // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRunSeVelocity;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E40[0x4];                                     // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeObject">();
	}
	static class AArrangeObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArrangeObject>();
	}
};
static_assert(alignof(AArrangeObject) == 0x000008, "Wrong alignment on AArrangeObject");
static_assert(sizeof(AArrangeObject) == 0x0002A8, "Wrong size on AArrangeObject");
static_assert(offsetof(AArrangeObject, IsDoBeginPlay) == 0x000238, "Member 'AArrangeObject::IsDoBeginPlay' has a wrong offset!");
static_assert(offsetof(AArrangeObject, ID) == 0x00023C, "Member 'AArrangeObject::ID' has a wrong offset!");
static_assert(offsetof(AArrangeObject, LevelID) == 0x000240, "Member 'AArrangeObject::LevelID' has a wrong offset!");
static_assert(offsetof(AArrangeObject, GroupID) == 0x000244, "Member 'AArrangeObject::GroupID' has a wrong offset!");
static_assert(offsetof(AArrangeObject, ArrangeMesh) == 0x000248, "Member 'AArrangeObject::ArrangeMesh' has a wrong offset!");
static_assert(offsetof(AArrangeObject, FirstPosition) == 0x000250, "Member 'AArrangeObject::FirstPosition' has a wrong offset!");
static_assert(offsetof(AArrangeObject, FirstRotation) == 0x00025C, "Member 'AArrangeObject::FirstRotation' has a wrong offset!");
static_assert(offsetof(AArrangeObject, TempPosition) == 0x000268, "Member 'AArrangeObject::TempPosition' has a wrong offset!");
static_assert(offsetof(AArrangeObject, TempRotation) == 0x000274, "Member 'AArrangeObject::TempRotation' has a wrong offset!");
static_assert(offsetof(AArrangeObject, FootStepComponent) == 0x000280, "Member 'AArrangeObject::FootStepComponent' has a wrong offset!");
static_assert(offsetof(AArrangeObject, HitActorList) == 0x000288, "Member 'AArrangeObject::HitActorList' has a wrong offset!");
static_assert(offsetof(AArrangeObject, HitSeInterval) == 0x000298, "Member 'AArrangeObject::HitSeInterval' has a wrong offset!");
static_assert(offsetof(AArrangeObject, PlaySeVelocity) == 0x00029C, "Member 'AArrangeObject::PlaySeVelocity' has a wrong offset!");
static_assert(offsetof(AArrangeObject, PlayRunSeVelocity) == 0x0002A0, "Member 'AArrangeObject::PlayRunSeVelocity' has a wrong offset!");

// Class BattlePrototype.ModelViewerBase
// 0x0090 (0x02C0 - 0x0230)
class AModelViewerBase final : public AActor
{
public:
	uint8                                         Pad_1E42[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           _modelViewerCamera;                                // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARSCharacterBase*                       _modelViewerPlayer;                                // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANpcBase*                               _modelViewerPlayerNpc;                             // 0x0248(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANpcSkeletalMeshActor*                  _modelViewerSkeletalNpc;                           // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ARSCharacterBase>>   CharacterList;                                     // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectIndex;                                       // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E43[0x4];                                     // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _PlayingMotionAsset;                               // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _PlayingMotionAssetLength;                         // 0x0278(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E44[0x4];                                     // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorReferenceInfo>            ActorReferenceInfoList;                            // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         CharacterNametList;                                // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAssetData>                     AnimationAssetList;                                // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         FaceNameList;                                      // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static int32 CompareFName(class FName Param1, class FName Param2);
	static void GetFolderNameListByPath(TArray<class FString>* FolderNameList, const class FString& SearchFolderPathFromContents);
	static TSoftClassPtr<class UClass> GetNpcBase(const class FString& AssetPath);
	static TSoftClassPtr<class UClass> GetNpcSkeletalMeshActor(const class FString& AssetPath);
	static TSoftClassPtr<class UClass> GetRSCharacterBase(const class FString& AssetPath);

	void AddActorReferenceInfo(TSoftClassPtr<class UClass> CharaActor);
	void AddCharacter(const TArray<TSubclassOf<class ARSCharacterBase>>& List);
	void ChangeNextIndex();
	void ChangePrevIndex();
	bool CompareAssetPath(const class FString& ModelBPDisplayName, const class FString& AnimationPath);
	void CreateAnimationFileList(class FName CharacterIdentifier, class FName CharacterName);
	void CreateCharacterFileList();
	void CreateFaceNameList(class FName CharacterName);
	void CreateWidget();
	void Debug_CreateModelViewerCharacter(TSubclassOf<class ARSCharacterBase> CharacterBP, const class FString& PlayerStartName);
	void Debug_CreateModelViewerCharacterNpc(TSubclassOf<class ANpcBase> CharacterBP, const class FString& PlayerStartName);
	void Debug_CreateModelViewerSkeletalNpc(TSubclassOf<class ANpcSkeletalMeshActor> CharacterBP, const class FString& PlayerStartName);
	class FString GetActorReferenceAssetName(TSoftClassPtr<class UClass> CharaActor);
	class FString GetActorReferencePackageName(TSoftClassPtr<class UClass> CharaActor);
	class FString GetActorReferenceToString(TSoftClassPtr<class UClass> CharaActor);
	float GetCurrentAnimationFrame(const int32 Digit);
	float GetCurrentAnimationTime();
	class FString GetDebugDrawMotionInfo();
	float GetMaxAnimationTime();
	class ACameraActor* GetModelViewerCamera();
	class ARSCharacterBase* GetModelViewerPlayer();
	class ANpcBase* GetModelViewerPlayerNpc();
	class ANpcSkeletalMeshActor* GetModelViewerSkeletalNpc();
	int32 GetSelectAnimationComboboxIndex();
	TSubclassOf<class ARSCharacterBase> GetSelectCharacter();
	int32 GetSelectCharacterComboboxIndex();
	int32 GetSelectFaceComboboxIndex();
	void InitializePlayerInfo();
	bool IsPlayAnimationMontage();
	void LoadCharacter(const int32 Param_Index);
	void LoadCharacterRequest(const bool IsReload);
	class USaveGame* ModelViewerLoad(const class FString& SlotName, const int32 UserIndex);
	bool ModelViewerSave(class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex);
	void OnChangeSelectCharacter(const int32 Param_Index);
	bool PauseAnimation();
	bool PlayAnimation(class UObject* MotionAsset, const bool IsReplay, float InTimeToStartMontageAt);
	void SetAnimationComboBox();
	void SetCharacterComboBox();
	void SetFaceComboBox();
	void SetModelViewerCamera(class ACameraActor* CameraActor);
	void SortAssetDatalist(TArray<struct FAssetData>* AssetDataList);
	void SpawnCharacter(const int32 CharacterIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModelViewerBase">();
	}
	static class AModelViewerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AModelViewerBase>();
	}
};
static_assert(alignof(AModelViewerBase) == 0x000008, "Wrong alignment on AModelViewerBase");
static_assert(sizeof(AModelViewerBase) == 0x0002C0, "Wrong size on AModelViewerBase");
static_assert(offsetof(AModelViewerBase, _modelViewerCamera) == 0x000238, "Member 'AModelViewerBase::_modelViewerCamera' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _modelViewerPlayer) == 0x000240, "Member 'AModelViewerBase::_modelViewerPlayer' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _modelViewerPlayerNpc) == 0x000248, "Member 'AModelViewerBase::_modelViewerPlayerNpc' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _modelViewerSkeletalNpc) == 0x000250, "Member 'AModelViewerBase::_modelViewerSkeletalNpc' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, CharacterList) == 0x000258, "Member 'AModelViewerBase::CharacterList' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, SelectIndex) == 0x000268, "Member 'AModelViewerBase::SelectIndex' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _PlayingMotionAsset) == 0x000270, "Member 'AModelViewerBase::_PlayingMotionAsset' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, _PlayingMotionAssetLength) == 0x000278, "Member 'AModelViewerBase::_PlayingMotionAssetLength' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, ActorReferenceInfoList) == 0x000280, "Member 'AModelViewerBase::ActorReferenceInfoList' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, CharacterNametList) == 0x000290, "Member 'AModelViewerBase::CharacterNametList' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, AnimationAssetList) == 0x0002A0, "Member 'AModelViewerBase::AnimationAssetList' has a wrong offset!");
static_assert(offsetof(AModelViewerBase, FaceNameList) == 0x0002B0, "Member 'AModelViewerBase::FaceNameList' has a wrong offset!");

// Class BattlePrototype.ArrangeObjectManager
// 0x0010 (0x0038 - 0x0028)
class UArrangeObjectManager final : public UObject
{
public:
	TArray<class AArrangeObject*>                 ArrangeObjects;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BackupFirstObjectInfo(const int32 LevelID, const int32 GroupID);
	void BackupObjectInfo(const int32 LevelID, const int32 GroupID);
	class AArrangeObject* GetArrangeObject(const int32 ID);
	void Initialize(const class UObject* WorldContextObject);
	void RegisterObject(class AArrangeObject* ArrangeObject);
	void RestoreFirstObjectInfo(const int32 LevelID, const int32 GroupID);
	void RestoreObjectInfo(const int32 LevelID, const int32 GroupID);
	void SetEnableCollision(const bool Flag, const bool bHiddenCheck);
	void SetVisible(const bool IsVisible, const int32 LevelID, const int32 GroupID);
	void UnregisterObject(class AArrangeObject* ArrangeObject);
	void UnregisterObjectAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArrangeObjectManager">();
	}
	static class UArrangeObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArrangeObjectManager>();
	}
};
static_assert(alignof(UArrangeObjectManager) == 0x000008, "Wrong alignment on UArrangeObjectManager");
static_assert(sizeof(UArrangeObjectManager) == 0x000038, "Wrong size on UArrangeObjectManager");
static_assert(offsetof(UArrangeObjectManager, ArrangeObjects) == 0x000028, "Member 'UArrangeObjectManager::ArrangeObjects' has a wrong offset!");

// Class BattlePrototype.UIShopPartyStatusIcon
// 0x0120 (0x04A8 - 0x0388)
class UUIShopPartyStatusIcon : public UUIBase
{
public:
	struct FSlateColor                            ColorEqual;                                        // 0x0388(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            ColorUp;                                           // 0x03B0(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            ColorDown;                                         // 0x03D8(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E4C[0xA8];                                    // 0x0400(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDark, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimDarkMax, class UImage* ImageEquip, class UImage* ImageDone, class UOverlay* OverlayParamL, class UHorizonFlipbookWidget* ArrowL_UP, class UHorizonFlipbookWidget* ArrowL_DOWN, class UTextBlock* TextNumL, class UOverlay* OverlayParamR, class UHorizonFlipbookWidget* ArrowR_UP, class UHorizonFlipbookWidget* ArrowR_DOWN, class UTextBlock* TextNumR, class UOverlay* OverlayBondSet, class UTextBlock* TextBondNum, class UPaperFlipbook* PfArrowUP, class UPaperFlipbook* PfArrowDown, class UImage* ImageEWeaponSkin);
	void SetEquipOrLoveIcon(EEquipOrLoveIcon Type);
	void SetFaceIcon(EPlayerID CharacterId);
	void SetParameterIcon(int32 Param_Index, int32 Icon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopPartyStatusIcon">();
	}
	static class UUIShopPartyStatusIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopPartyStatusIcon>();
	}
};
static_assert(alignof(UUIShopPartyStatusIcon) == 0x000008, "Wrong alignment on UUIShopPartyStatusIcon");
static_assert(sizeof(UUIShopPartyStatusIcon) == 0x0004A8, "Wrong size on UUIShopPartyStatusIcon");
static_assert(offsetof(UUIShopPartyStatusIcon, ColorEqual) == 0x000388, "Member 'UUIShopPartyStatusIcon::ColorEqual' has a wrong offset!");
static_assert(offsetof(UUIShopPartyStatusIcon, ColorUp) == 0x0003B0, "Member 'UUIShopPartyStatusIcon::ColorUp' has a wrong offset!");
static_assert(offsetof(UUIShopPartyStatusIcon, ColorDown) == 0x0003D8, "Member 'UUIShopPartyStatusIcon::ColorDown' has a wrong offset!");

// Class BattlePrototype.AssetFuncLib
// 0x0000 (0x0028 - 0x0028)
class UAssetFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> GetAssetAllDependencies(class FName AssetName);
	static TArray<class FName> GetAssetDependencies(class FName AssetName, bool Hard, bool Soft, bool SearchableName, bool Manage);
	static TArray<class FName> GetAssetHardDependencies(class FName AssetName);
	static TArray<class FName> GetAssetManageDependencies(class FName AssetName);
	static TArray<class FName> GetAssetPackagesDependencies(class FName AssetName);
	static TArray<class FName> GetAssetSearchableNameDependencies(class FName AssetName);
	static TArray<class FName> GetAssetSoftDependencies(class FName AssetName);
	static bool GetPackagePath(class UObject* Object, class FName* OutName);
	static class FString GetPrimaryAssetPath(const struct FPrimaryAssetId& PrimaryAssetId);
	static bool IsChapterChunkLoaded(int32 ChapterNo);
	static bool IsChunkLoaded(const int32 ChunkId, const bool IsNotExistError);
	static bool IsFullInstallPackage();
	static bool IsReadyForceMipLevelsToBeResidentByTexture(class UTexture2D* Texture);
	static bool IsReadyForceMipLevelToBeResidentByTexture(class UTexture2D* Texture, int32 RequestLevel);
	static void ModifyAssets(const TArray<class UObject*>& Assets);
	static class FName ObjectSoftRefToName(const TSoftObjectPtr<class UObject>& Object);
	static class FString ObjectSoftRefToString(const TSoftObjectPtr<class UObject>& Object);
	static class FString ObjectSoftRefToStringRaw(const TSoftObjectPtr<class UObject>& Object);
	static void ResetForceMipLevelsToBeResidentBySkeletalMeshComp(class USkeletalMeshComponent* SkelMeshComp);
	static void ResetForceMipLevelsToBeResidentByTexture(class UTexture2D* Texture);
	static void SetChapterChunkPriority(int32 ChapterNo);
	static void SetForceMipLevelsToBeResidentBySkeletalMeshComp(class USkeletalMeshComponent* SkelMeshComp, float Seconds, int32 CinematicLODGroupMask, bool HighProirity);
	static void SetForceMipLevelsToBeResidentByTexture(class UTexture2D* Texture, float Seconds, int32 CinematicLODGroupMask, bool HighProirity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetFuncLib">();
	}
	static class UAssetFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetFuncLib>();
	}
};
static_assert(alignof(UAssetFuncLib) == 0x000008, "Wrong alignment on UAssetFuncLib");
static_assert(sizeof(UAssetFuncLib) == 0x000028, "Wrong size on UAssetFuncLib");

// Class BattlePrototype.AssetLoadComponent
// 0x0020 (0x00E0 - 0x00C0)
class UAssetLoadComponent : public UActorComponent
{
public:
	class USoundAtomCueSheet*                     SoundCueSheet;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                ParticleList;                                      // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E55[0x8];                                     // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetLoadComponent">();
	}
	static class UAssetLoadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetLoadComponent>();
	}
};
static_assert(alignof(UAssetLoadComponent) == 0x000008, "Wrong alignment on UAssetLoadComponent");
static_assert(sizeof(UAssetLoadComponent) == 0x0000E0, "Wrong size on UAssetLoadComponent");
static_assert(offsetof(UAssetLoadComponent, SoundCueSheet) == 0x0000C0, "Member 'UAssetLoadComponent::SoundCueSheet' has a wrong offset!");
static_assert(offsetof(UAssetLoadComponent, ParticleList) == 0x0000C8, "Member 'UAssetLoadComponent::ParticleList' has a wrong offset!");

// Class BattlePrototype.PlayerRenderSettings
// 0x0010 (0x0038 - 0x0028)
class UPlayerRenderSettings final : public UObject
{
public:
	TArray<struct FHeightGradationSettings>       HeightGradationSettingsArray;                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerRenderSettings">();
	}
	static class UPlayerRenderSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerRenderSettings>();
	}
};
static_assert(alignof(UPlayerRenderSettings) == 0x000008, "Wrong alignment on UPlayerRenderSettings");
static_assert(sizeof(UPlayerRenderSettings) == 0x000038, "Wrong size on UPlayerRenderSettings");
static_assert(offsetof(UPlayerRenderSettings, HeightGradationSettingsArray) == 0x000028, "Member 'UPlayerRenderSettings::HeightGradationSettingsArray' has a wrong offset!");

// Class BattlePrototype.AssetMemoryData
// 0x0028 (0x0050 - 0x0028)
class UAssetMemoryData final : public UObject
{
public:
	class FName                                   ObjectPath;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetName;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetClass;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        PhysicalSize;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        VirtualSize;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetMemoryData">();
	}
	static class UAssetMemoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetMemoryData>();
	}
};
static_assert(alignof(UAssetMemoryData) == 0x000008, "Wrong alignment on UAssetMemoryData");
static_assert(sizeof(UAssetMemoryData) == 0x000050, "Wrong size on UAssetMemoryData");
static_assert(offsetof(UAssetMemoryData, ObjectPath) == 0x000028, "Member 'UAssetMemoryData::ObjectPath' has a wrong offset!");
static_assert(offsetof(UAssetMemoryData, AssetName) == 0x000030, "Member 'UAssetMemoryData::AssetName' has a wrong offset!");
static_assert(offsetof(UAssetMemoryData, AssetClass) == 0x000038, "Member 'UAssetMemoryData::AssetClass' has a wrong offset!");
static_assert(offsetof(UAssetMemoryData, PhysicalSize) == 0x000040, "Member 'UAssetMemoryData::PhysicalSize' has a wrong offset!");
static_assert(offsetof(UAssetMemoryData, VirtualSize) == 0x000048, "Member 'UAssetMemoryData::VirtualSize' has a wrong offset!");

// Class BattlePrototype.PlayerDriveComponent
// 0x0220 (0x02E0 - 0x00C0)
class UPlayerDriveComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchBeginDrive;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchEndDrive;                                  // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchSetDriveGauge;                             // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchDriveGaugeMax;                             // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRegenerateHP;                              // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchNotifyBrainFieldStock;                     // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchNotifyParameterMax;                        // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E56[0x60];                                    // 0x0130(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DisableDriveClaimantList;                          // 0x0190(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E57[0x140];                                   // 0x01A0(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBrainCrashDefeatedEnemy(int32 DefeatedNum, bool bUniqueBrainCrash);
	void AddBrainFieldCount(bool bItemUse, bool bNoEffect);
	void AddDefeatedEnemy(int32 DefeatedNum);
	void BeginDriveMode(bool bDelayTimerTick, bool bDisableTimer, bool bNpcDrive);
	void BeginDriveTimer();
	bool CheckNpcDrive(ENpcDriveCheckType CheckType, int32 bondsLevel, float PlayerDriveRate, float PlayerHpRate);
	void ClearReserveNpcDrive();
	void DirectDriveTimeSetting(float CurrentTime, float ExtendTime);
	void DisableDrive(bool bDisable, class FName ClaimantName);
	void EndDriveMode(bool bInterruption, bool bLocationChange);
	void ForceBeginNpcDriveInterval();
	void OnNotifyDriveEvent(ENotifyDriveEvent Type, int32 Param);
	void ReserveNpcDrive(bool bCrashVision);
	void ResetBrainFieldCount();
	void ResetDriveGauge();
	void ResetNpcDriveInterval();
	void RestrictDriveBegin(bool bRestrict);
	void SetDriveCommonParameter(const struct FPlayerDriveCommonParameter& Parameter);
	void SetDriveGaugeDirect(float Value);
	void SetDriveGaugeIncreaseRate(float Rate);
	void SetDriveGaugeParameter(const struct FPlayerDriveGaugeParameter& Parameter);
	void SetDriveParameter(const struct FPlayerDriveParameter& Parameter);
	void SetExtendTimeBrainCrash(float ExtendTime);
	void SetNexusDriveSeeThroughAddRate(float Rate);
	void SetNpcDriveData(struct FNpcDriveData& InData);
	void SetPauseDriveTimer(bool bPause);
	void SetRecoveryBadStatus(bool bEnable);
	void SetRegenerate(bool bEnable);
	void SetRegenerateHPRate(float Rate);
	void SetRegenerateInterval(float Interval);
	void SetSASCharge(bool bEnable);
	void UpdateDriveTick(float DeltaSeconds);
	void UpdateNpcDriveInterval(float DeltaSeconds);

	float GetAttackAnimationPlayRate() const;
	float GetAttackRate() const;
	int32 GetBrainFieldCount() const;
	float GetCrashRate() const;
	float GetCurrentDriveTime() const;
	float GetCurrentDriveTimeRate() const;
	float GetCurrentParameterRate() const;
	float GetDisableDriveLastEnemyHpRate() const;
	float GetDriveGauge() const;
	float GetDriveGaugeRate() const;
	float GetDriveTimerRemain() const;
	float GetMaxDriveGauge() const;
	float GetMaxDriveTime() const;
	float GetMoveSpeedRate() const;
	float GetNpcDriveIntervalTimerRemain() const;
	float GetParameterMaxTime() const;
	float GetPsychicGaugeRate() const;
	float GetPsychicWaitGaugeRate() const;
	bool IsDebugAlwaysDrive() const;
	bool IsDebugInfiniteDrive() const;
	bool IsDriveMode() const;
	bool IsEnableBrainField() const;
	bool IsEnableDrive() const;
	bool IsEnableDriveNpc(bool bIgnoreInterval) const;
	bool IsRecoveryBadStatus() const;
	bool IsReservedNpcDrive() const;
	bool IsSASCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDriveComponent">();
	}
	static class UPlayerDriveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDriveComponent>();
	}
};
static_assert(alignof(UPlayerDriveComponent) == 0x000008, "Wrong alignment on UPlayerDriveComponent");
static_assert(sizeof(UPlayerDriveComponent) == 0x0002E0, "Wrong size on UPlayerDriveComponent");
static_assert(offsetof(UPlayerDriveComponent, DispatchBeginDrive) == 0x0000C0, "Member 'UPlayerDriveComponent::DispatchBeginDrive' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchEndDrive) == 0x0000D0, "Member 'UPlayerDriveComponent::DispatchEndDrive' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchSetDriveGauge) == 0x0000E0, "Member 'UPlayerDriveComponent::DispatchSetDriveGauge' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchDriveGaugeMax) == 0x0000F0, "Member 'UPlayerDriveComponent::DispatchDriveGaugeMax' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchRegenerateHP) == 0x000100, "Member 'UPlayerDriveComponent::DispatchRegenerateHP' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchNotifyBrainFieldStock) == 0x000110, "Member 'UPlayerDriveComponent::DispatchNotifyBrainFieldStock' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DispatchNotifyParameterMax) == 0x000120, "Member 'UPlayerDriveComponent::DispatchNotifyParameterMax' has a wrong offset!");
static_assert(offsetof(UPlayerDriveComponent, DisableDriveClaimantList) == 0x000190, "Member 'UPlayerDriveComponent::DisableDriveClaimantList' has a wrong offset!");

// Class BattlePrototype.At8200AnimInstance
// 0x0490 (0x0700 - 0x0270)
class UAt8200AnimInstance final : public UAnimInstance
{
public:
	TWeakObjectPtr<class USceneComponent>         OwnerMeshComponent;                                // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Head_Location;                                     // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Head_Rotation;                                     // 0x0284(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Head_Scale;                                        // 0x0290(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FacialRoot_Location;                               // 0x029C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FacialRoot_Rotation;                               // 0x02A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                FacialRoot_Scale;                                  // 0x02B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp_Location;                               // 0x02C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyeUp_Rotation;                               // 0x02CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp_Scale;                                  // 0x02D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp1_Location;                              // 0x02E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyeUp1_Rotation;                              // 0x02F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp1_Scale;                                 // 0x02FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp2_Location;                              // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyeUp2_Rotation;                              // 0x0314(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp2_Scale;                                 // 0x0320(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp3_Location;                              // 0x032C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyeUp3_Rotation;                              // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp3_Scale;                                 // 0x0344(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp4_Location;                              // 0x0350(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyeUp4_Rotation;                              // 0x035C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUp4_Scale;                                 // 0x0368(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp_Location;                                // 0x0374(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyeUp_Rotation;                                // 0x0380(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp_Scale;                                   // 0x038C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp1_Location;                               // 0x0398(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyeUp1_Rotation;                               // 0x03A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp1_Scale;                                  // 0x03B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp2_Location;                               // 0x03BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyeUp2_Rotation;                               // 0x03C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp2_Scale;                                  // 0x03D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp3_Location;                               // 0x03E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyeUp3_Rotation;                               // 0x03EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp3_Scale;                                  // 0x03F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp4_Location;                               // 0x0404(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyeUp4_Rotation;                               // 0x0410(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUp4_Scale;                                  // 0x041C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUnder_Location;                            // 0x0428(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyeUnder_Rotation;                            // 0x0434(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUnder_Scale;                               // 0x0440(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUnder1_Location;                           // 0x044C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyeUnder1_Rotation;                           // 0x0458(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUnder1_Scale;                              // 0x0464(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUnder2_Location;                           // 0x0470(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyeUnder2_Rotation;                           // 0x047C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyeUnder2_Scale;                              // 0x0488(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUnder_Location;                             // 0x0494(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyeUnder_Rotation;                             // 0x04A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUnder_Scale;                                // 0x04AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUnder1_Location;                            // 0x04B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyeUnder1_Rotation;                            // 0x04C4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUnder1_Scale;                               // 0x04D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUnder2_Location;                            // 0x04DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyeUnder2_Rotation;                            // 0x04E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyeUnder2_Scale;                               // 0x04F4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow_Location;                             // 0x0500(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyebrow_Rotation;                             // 0x050C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow_Scale;                                // 0x0518(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow1_Location;                            // 0x0524(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyebrow1_Rotation;                            // 0x0530(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow1_Scale;                               // 0x053C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow2_Location;                            // 0x0548(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyebrow2_Rotation;                            // 0x0554(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow2_Scale;                               // 0x0560(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow3_Location;                            // 0x056C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyebrow3_Rotation;                            // 0x0578(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow3_Scale;                               // 0x0584(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow4_Location;                            // 0x0590(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyebrow4_Rotation;                            // 0x059C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow4_Scale;                               // 0x05A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow5_Location;                            // 0x05B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightEyebrow5_Rotation;                            // 0x05C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightEyebrow5_Scale;                               // 0x05CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow_Location;                              // 0x05D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyebrow_Rotation;                              // 0x05E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow_Scale;                                 // 0x05F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow1_Location;                             // 0x05FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyebrow1_Rotation;                             // 0x0608(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow1_Scale;                                // 0x0614(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow2_Location;                             // 0x0620(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyebrow2_Rotation;                             // 0x062C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow2_Scale;                                // 0x0638(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow3_Location;                             // 0x0644(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyebrow3_Rotation;                             // 0x0650(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow3_Scale;                                // 0x065C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow4_Location;                             // 0x0668(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyebrow4_Rotation;                             // 0x0674(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow4_Scale;                                // 0x0680(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow5_Location;                             // 0x068C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftEyebrow5_Rotation;                             // 0x0698(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftEyebrow5_Scale;                                // 0x06A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightCheck_Location;                               // 0x06B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightCheck_Rotation;                               // 0x06BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightCheck_Scale;                                  // 0x06C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftCheck_Location;                                // 0x06D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftCheck_Rotation;                                // 0x06E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftCheck_Scale;                                   // 0x06EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E5D[0x8];                                     // 0x06F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"At8200AnimInstance">();
	}
	static class UAt8200AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAt8200AnimInstance>();
	}
};
static_assert(alignof(UAt8200AnimInstance) == 0x000010, "Wrong alignment on UAt8200AnimInstance");
static_assert(sizeof(UAt8200AnimInstance) == 0x000700, "Wrong size on UAt8200AnimInstance");
static_assert(offsetof(UAt8200AnimInstance, OwnerMeshComponent) == 0x000270, "Member 'UAt8200AnimInstance::OwnerMeshComponent' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, Head_Location) == 0x000278, "Member 'UAt8200AnimInstance::Head_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, Head_Rotation) == 0x000284, "Member 'UAt8200AnimInstance::Head_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, Head_Scale) == 0x000290, "Member 'UAt8200AnimInstance::Head_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, FacialRoot_Location) == 0x00029C, "Member 'UAt8200AnimInstance::FacialRoot_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, FacialRoot_Rotation) == 0x0002A8, "Member 'UAt8200AnimInstance::FacialRoot_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, FacialRoot_Scale) == 0x0002B4, "Member 'UAt8200AnimInstance::FacialRoot_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp_Location) == 0x0002C0, "Member 'UAt8200AnimInstance::RightEyeUp_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp_Rotation) == 0x0002CC, "Member 'UAt8200AnimInstance::RightEyeUp_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp_Scale) == 0x0002D8, "Member 'UAt8200AnimInstance::RightEyeUp_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp1_Location) == 0x0002E4, "Member 'UAt8200AnimInstance::RightEyeUp1_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp1_Rotation) == 0x0002F0, "Member 'UAt8200AnimInstance::RightEyeUp1_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp1_Scale) == 0x0002FC, "Member 'UAt8200AnimInstance::RightEyeUp1_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp2_Location) == 0x000308, "Member 'UAt8200AnimInstance::RightEyeUp2_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp2_Rotation) == 0x000314, "Member 'UAt8200AnimInstance::RightEyeUp2_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp2_Scale) == 0x000320, "Member 'UAt8200AnimInstance::RightEyeUp2_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp3_Location) == 0x00032C, "Member 'UAt8200AnimInstance::RightEyeUp3_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp3_Rotation) == 0x000338, "Member 'UAt8200AnimInstance::RightEyeUp3_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp3_Scale) == 0x000344, "Member 'UAt8200AnimInstance::RightEyeUp3_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp4_Location) == 0x000350, "Member 'UAt8200AnimInstance::RightEyeUp4_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp4_Rotation) == 0x00035C, "Member 'UAt8200AnimInstance::RightEyeUp4_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUp4_Scale) == 0x000368, "Member 'UAt8200AnimInstance::RightEyeUp4_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp_Location) == 0x000374, "Member 'UAt8200AnimInstance::LeftEyeUp_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp_Rotation) == 0x000380, "Member 'UAt8200AnimInstance::LeftEyeUp_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp_Scale) == 0x00038C, "Member 'UAt8200AnimInstance::LeftEyeUp_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp1_Location) == 0x000398, "Member 'UAt8200AnimInstance::LeftEyeUp1_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp1_Rotation) == 0x0003A4, "Member 'UAt8200AnimInstance::LeftEyeUp1_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp1_Scale) == 0x0003B0, "Member 'UAt8200AnimInstance::LeftEyeUp1_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp2_Location) == 0x0003BC, "Member 'UAt8200AnimInstance::LeftEyeUp2_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp2_Rotation) == 0x0003C8, "Member 'UAt8200AnimInstance::LeftEyeUp2_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp2_Scale) == 0x0003D4, "Member 'UAt8200AnimInstance::LeftEyeUp2_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp3_Location) == 0x0003E0, "Member 'UAt8200AnimInstance::LeftEyeUp3_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp3_Rotation) == 0x0003EC, "Member 'UAt8200AnimInstance::LeftEyeUp3_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp3_Scale) == 0x0003F8, "Member 'UAt8200AnimInstance::LeftEyeUp3_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp4_Location) == 0x000404, "Member 'UAt8200AnimInstance::LeftEyeUp4_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp4_Rotation) == 0x000410, "Member 'UAt8200AnimInstance::LeftEyeUp4_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUp4_Scale) == 0x00041C, "Member 'UAt8200AnimInstance::LeftEyeUp4_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUnder_Location) == 0x000428, "Member 'UAt8200AnimInstance::RightEyeUnder_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUnder_Rotation) == 0x000434, "Member 'UAt8200AnimInstance::RightEyeUnder_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUnder_Scale) == 0x000440, "Member 'UAt8200AnimInstance::RightEyeUnder_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUnder1_Location) == 0x00044C, "Member 'UAt8200AnimInstance::RightEyeUnder1_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUnder1_Rotation) == 0x000458, "Member 'UAt8200AnimInstance::RightEyeUnder1_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUnder1_Scale) == 0x000464, "Member 'UAt8200AnimInstance::RightEyeUnder1_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUnder2_Location) == 0x000470, "Member 'UAt8200AnimInstance::RightEyeUnder2_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUnder2_Rotation) == 0x00047C, "Member 'UAt8200AnimInstance::RightEyeUnder2_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyeUnder2_Scale) == 0x000488, "Member 'UAt8200AnimInstance::RightEyeUnder2_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUnder_Location) == 0x000494, "Member 'UAt8200AnimInstance::LeftEyeUnder_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUnder_Rotation) == 0x0004A0, "Member 'UAt8200AnimInstance::LeftEyeUnder_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUnder_Scale) == 0x0004AC, "Member 'UAt8200AnimInstance::LeftEyeUnder_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUnder1_Location) == 0x0004B8, "Member 'UAt8200AnimInstance::LeftEyeUnder1_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUnder1_Rotation) == 0x0004C4, "Member 'UAt8200AnimInstance::LeftEyeUnder1_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUnder1_Scale) == 0x0004D0, "Member 'UAt8200AnimInstance::LeftEyeUnder1_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUnder2_Location) == 0x0004DC, "Member 'UAt8200AnimInstance::LeftEyeUnder2_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUnder2_Rotation) == 0x0004E8, "Member 'UAt8200AnimInstance::LeftEyeUnder2_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyeUnder2_Scale) == 0x0004F4, "Member 'UAt8200AnimInstance::LeftEyeUnder2_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow_Location) == 0x000500, "Member 'UAt8200AnimInstance::RightEyebrow_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow_Rotation) == 0x00050C, "Member 'UAt8200AnimInstance::RightEyebrow_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow_Scale) == 0x000518, "Member 'UAt8200AnimInstance::RightEyebrow_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow1_Location) == 0x000524, "Member 'UAt8200AnimInstance::RightEyebrow1_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow1_Rotation) == 0x000530, "Member 'UAt8200AnimInstance::RightEyebrow1_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow1_Scale) == 0x00053C, "Member 'UAt8200AnimInstance::RightEyebrow1_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow2_Location) == 0x000548, "Member 'UAt8200AnimInstance::RightEyebrow2_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow2_Rotation) == 0x000554, "Member 'UAt8200AnimInstance::RightEyebrow2_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow2_Scale) == 0x000560, "Member 'UAt8200AnimInstance::RightEyebrow2_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow3_Location) == 0x00056C, "Member 'UAt8200AnimInstance::RightEyebrow3_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow3_Rotation) == 0x000578, "Member 'UAt8200AnimInstance::RightEyebrow3_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow3_Scale) == 0x000584, "Member 'UAt8200AnimInstance::RightEyebrow3_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow4_Location) == 0x000590, "Member 'UAt8200AnimInstance::RightEyebrow4_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow4_Rotation) == 0x00059C, "Member 'UAt8200AnimInstance::RightEyebrow4_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow4_Scale) == 0x0005A8, "Member 'UAt8200AnimInstance::RightEyebrow4_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow5_Location) == 0x0005B4, "Member 'UAt8200AnimInstance::RightEyebrow5_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow5_Rotation) == 0x0005C0, "Member 'UAt8200AnimInstance::RightEyebrow5_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightEyebrow5_Scale) == 0x0005CC, "Member 'UAt8200AnimInstance::RightEyebrow5_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow_Location) == 0x0005D8, "Member 'UAt8200AnimInstance::LeftEyebrow_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow_Rotation) == 0x0005E4, "Member 'UAt8200AnimInstance::LeftEyebrow_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow_Scale) == 0x0005F0, "Member 'UAt8200AnimInstance::LeftEyebrow_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow1_Location) == 0x0005FC, "Member 'UAt8200AnimInstance::LeftEyebrow1_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow1_Rotation) == 0x000608, "Member 'UAt8200AnimInstance::LeftEyebrow1_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow1_Scale) == 0x000614, "Member 'UAt8200AnimInstance::LeftEyebrow1_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow2_Location) == 0x000620, "Member 'UAt8200AnimInstance::LeftEyebrow2_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow2_Rotation) == 0x00062C, "Member 'UAt8200AnimInstance::LeftEyebrow2_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow2_Scale) == 0x000638, "Member 'UAt8200AnimInstance::LeftEyebrow2_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow3_Location) == 0x000644, "Member 'UAt8200AnimInstance::LeftEyebrow3_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow3_Rotation) == 0x000650, "Member 'UAt8200AnimInstance::LeftEyebrow3_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow3_Scale) == 0x00065C, "Member 'UAt8200AnimInstance::LeftEyebrow3_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow4_Location) == 0x000668, "Member 'UAt8200AnimInstance::LeftEyebrow4_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow4_Rotation) == 0x000674, "Member 'UAt8200AnimInstance::LeftEyebrow4_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow4_Scale) == 0x000680, "Member 'UAt8200AnimInstance::LeftEyebrow4_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow5_Location) == 0x00068C, "Member 'UAt8200AnimInstance::LeftEyebrow5_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow5_Rotation) == 0x000698, "Member 'UAt8200AnimInstance::LeftEyebrow5_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftEyebrow5_Scale) == 0x0006A4, "Member 'UAt8200AnimInstance::LeftEyebrow5_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightCheck_Location) == 0x0006B0, "Member 'UAt8200AnimInstance::RightCheck_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightCheck_Rotation) == 0x0006BC, "Member 'UAt8200AnimInstance::RightCheck_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, RightCheck_Scale) == 0x0006C8, "Member 'UAt8200AnimInstance::RightCheck_Scale' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftCheck_Location) == 0x0006D4, "Member 'UAt8200AnimInstance::LeftCheck_Location' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftCheck_Rotation) == 0x0006E0, "Member 'UAt8200AnimInstance::LeftCheck_Rotation' has a wrong offset!");
static_assert(offsetof(UAt8200AnimInstance, LeftCheck_Scale) == 0x0006EC, "Member 'UAt8200AnimInstance::LeftCheck_Scale' has a wrong offset!");

// Class BattlePrototype.AttachEffectBackgroundVolume
// 0x0028 (0x0290 - 0x0268)
class AAttachEffectBackgroundVolume final : public AVolume
{
public:
	TArray<class AEffectBackground*>              Particles;                                         // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Subtract;                                          // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Unbound;                                           // 0x0279(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E5E[0x16];                                    // 0x027A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachEffectBackgroundVolume">();
	}
	static class AAttachEffectBackgroundVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAttachEffectBackgroundVolume>();
	}
};
static_assert(alignof(AAttachEffectBackgroundVolume) == 0x000008, "Wrong alignment on AAttachEffectBackgroundVolume");
static_assert(sizeof(AAttachEffectBackgroundVolume) == 0x000290, "Wrong size on AAttachEffectBackgroundVolume");
static_assert(offsetof(AAttachEffectBackgroundVolume, Particles) == 0x000268, "Member 'AAttachEffectBackgroundVolume::Particles' has a wrong offset!");
static_assert(offsetof(AAttachEffectBackgroundVolume, Subtract) == 0x000278, "Member 'AAttachEffectBackgroundVolume::Subtract' has a wrong offset!");
static_assert(offsetof(AAttachEffectBackgroundVolume, Unbound) == 0x000279, "Member 'AAttachEffectBackgroundVolume::Unbound' has a wrong offset!");

// Class BattlePrototype.AttackComponentBase
// 0x0030 (0x00F0 - 0x00C0)
class UAttackComponentBase : public UActorComponent
{
public:
	uint8                                         Pad_1E5F[0x10];                                    // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerAnimControllerComponent*         _animCon;                                          // 0x00D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E60[0x18];                                    // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAttackComponentBase* FindAttackComponentBySASVisionActor(class AActor* Actor, TSubclassOf<class AActor> ActorClass);
	static class UAttackComponentBase* FindAttackingComponent(class AActor* Actor);

	void AddComboCount();
	bool CheckStartAttack(float DeltaTime);
	bool ClearInput();
	void ClearInputAll();
	void DestroySASVisionActor();
	void DisappearSASVisionActor();
	bool InputButtonByCombo(bool bPressed, bool bComboFirst);
	bool IsAttackCombo();
	void OnChangeAnimKind(EPlayerAnimKind NewKind, EPlayerAnimKind OldKind);
	bool OnChangeAttacking(bool bAttacking);
	bool OnCustomAttackTimingNotified(const class FString& CustomName);
	bool OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	bool OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void SetAttacking(bool bAttacking, bool bAddComboCount);
	void SetAttackInputKind(ERSAttackInputKind Kind);
	void SpawnSASVisionActor(TSubclassOf<class AActor> ActorClass, class FName LocationTagName, bool bFollow);

	class UAttackInputComponent* GetAttackInputComponent() const;
	ERSAttackInputKind GetAttackInputKind() const;
	ERSAttackInputKind GetBranchComboAttackInputKind() const;
	int32 GetBranchComboCount() const;
	class UPlayerAnimControllerComponent* GetOwnerAnimCon() const;
	bool IsAttacking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackComponentBase">();
	}
	static class UAttackComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackComponentBase>();
	}
};
static_assert(alignof(UAttackComponentBase) == 0x000008, "Wrong alignment on UAttackComponentBase");
static_assert(sizeof(UAttackComponentBase) == 0x0000F0, "Wrong size on UAttackComponentBase");
static_assert(offsetof(UAttackComponentBase, _animCon) == 0x0000D0, "Member 'UAttackComponentBase::_animCon' has a wrong offset!");

// Class BattlePrototype.JumpComponent
// 0x0020 (0x00E0 - 0x00C0)
class UJumpComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStartJump;                                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E66[0x10];                                    // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputJump();
	void ReceiveOnGround();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JumpComponent">();
	}
	static class UJumpComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJumpComponent>();
	}
};
static_assert(alignof(UJumpComponent) == 0x000008, "Wrong alignment on UJumpComponent");
static_assert(sizeof(UJumpComponent) == 0x0000E0, "Wrong size on UJumpComponent");
static_assert(offsetof(UJumpComponent, OnStartJump) == 0x0000C0, "Member 'UJumpComponent::OnStartJump' has a wrong offset!");

// Class BattlePrototype.AttackInputComponent
// 0x3070 (0x3130 - 0x00C0)
class UAttackInputComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnComboInputEnd;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangePsychicComboLevel;                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeFlyingPsychicComboLevel;                   // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E67[0x3028];                                  // 0x00F0(0x3028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAttackComponentBase*>           _inputAttackComponentList;                         // 0x3118(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E68[0x8];                                     // 0x3128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddComboCount(ERSAttackInputKind Kind, ERSAttackInputKind branchKind, int32 branchComboCount);
	void AddComboPattern(class FName PatternName, ERSAttackInputKind InputKind, const TArray<class UAttackComponentBase*>& AttackComps, float ComboInterval, int32 MaxUseCount);
	void AddPsychicComboCount();
	void BeginComboInterval();
	void ChangeComboPattern(class FName PatternName);
	void CheckStartAttack(float DeltaTime);
	void ClearComboPattern(class FName PatternName);
	void ClearInputAll();
	void ClearPsychicComboCount();
	void ClearUseCount();
	void DebugSetComboDisp(bool bDisp);
	class UAttackComponentBase* FindAttackingComponent(ERSAttackInputKind Kind);
	TArray<class UAttackComponentBase*> GetInputAttackComponentList();
	int32 GetPsychicComboCount();
	int32 GetRemainUseCount(ERSAttackInputKind Kind);
	void InputAttackByPC(ERSAttackInputKind InputKind, bool bPressed);
	bool IsAttackedFlyingCombo();
	bool IsAttacking();
	bool IsAttackingByKind(ERSAttackInputKind Kind);
	bool IsCheckStartAttack(ERSAttackInputKind AttackKind);
	bool IsComboInterval(ERSAttackInputKind Kind, bool bCheckWaitFlag);
	bool IsDisableCombo(ERSAttackInputKind Kind);
	bool IsRegisterCombo(ERSAttackInputKind Kind);
	void OnAttackComponentChangeAttacking(class UAttackComponentBase* AttackComp, bool bAttacking);
	void OverwriteComboCount(int32 ComboCount);
	void RegisterCurrentAttackComponent(class UAttackComponentBase* AttackComp);
	void ResetCombo();
	void ResetComboByInputKind(ERSAttackInputKind Kind);
	void ResetFlyingCombo();
	void ResetPsychicComboLevel();
	void ResetSasHologramAttack();
	void SetAttackedFlyingCombo();
	void SetComboAttackInputKind(ERSAttackInputKind Kind);
	void SetDisableCombo(ERSAttackInputKind Kind, bool bDisable);
	void SetFlyingPsychicComboLevel(int32 PsychicComboLevel);
	void SetPsychicComboLevel(int32 PsychicComboLevel);
	void UnregisterCurrentAttackComponent(class UAttackComponentBase* AttackComp);

	ERSAttackInputKind GetComboAttackInputKind() const;
	ERSAttackInputKind GetComboAttackInputKindPrev() const;
	int32 GetComboCount() const;
	int32 GetComboCountByInputKind(ERSAttackInputKind Kind) const;
	class FName GetComboPattern() const;
	int32 GetFlyingPsychicComboLevel() const;
	int32 GetFlyingPsychicComboLevelMax() const;
	int32 GetPsychicComboLevel() const;
	int32 GetPsychicComboLevelMax() const;
	bool IsWaitPsychicCombo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackInputComponent">();
	}
	static class UAttackInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackInputComponent>();
	}
};
static_assert(alignof(UAttackInputComponent) == 0x000008, "Wrong alignment on UAttackInputComponent");
static_assert(sizeof(UAttackInputComponent) == 0x003130, "Wrong size on UAttackInputComponent");
static_assert(offsetof(UAttackInputComponent, OnComboInputEnd) == 0x0000C0, "Member 'UAttackInputComponent::OnComboInputEnd' has a wrong offset!");
static_assert(offsetof(UAttackInputComponent, OnChangePsychicComboLevel) == 0x0000D0, "Member 'UAttackInputComponent::OnChangePsychicComboLevel' has a wrong offset!");
static_assert(offsetof(UAttackInputComponent, OnChangeFlyingPsychicComboLevel) == 0x0000E0, "Member 'UAttackInputComponent::OnChangeFlyingPsychicComboLevel' has a wrong offset!");
static_assert(offsetof(UAttackInputComponent, _inputAttackComponentList) == 0x003118, "Member 'UAttackInputComponent::_inputAttackComponentList' has a wrong offset!");

// Class BattlePrototype.GimmickManager
// 0x0020 (0x0048 - 0x0028)
class UGimmickManager final : public UObject
{
public:
	TArray<class AGimmickObjectBase*>             Gimmicks;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGimmickActionBase*>             GimmickActions;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize(const class UObject* WorldContextObject);
	void OnBattleModeChange(class URSGameInstance* GameInstance, const bool bBattle);
	void RegisterGimmick(class AGimmickObjectBase* Gimmick);
	void RegisterGimmickAction(class AGimmickActionBase* GimmickAction);
	void UnregisterGimmick(class AGimmickObjectBase* Gimmick);
	void UnregisterGimmickAction(class AGimmickActionBase* GimmickAction);
	void UnregisterGimmickActionAll();
	void UnregisterGimmickAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickManager">();
	}
	static class UGimmickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGimmickManager>();
	}
};
static_assert(alignof(UGimmickManager) == 0x000008, "Wrong alignment on UGimmickManager");
static_assert(sizeof(UGimmickManager) == 0x000048, "Wrong size on UGimmickManager");
static_assert(offsetof(UGimmickManager, Gimmicks) == 0x000028, "Member 'UGimmickManager::Gimmicks' has a wrong offset!");
static_assert(offsetof(UGimmickManager, GimmickActions) == 0x000038, "Member 'UGimmickManager::GimmickActions' has a wrong offset!");

// Class BattlePrototype.AttackPropertyMediatorComponent
// 0x0050 (0x0110 - 0x00C0)
class UAttackPropertyMediatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_1E70[0x50];                                    // 0x00C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAttackPropertyMediatorComponent* FindAttackPropertyMediator(class AActor* Actor);
	static class UAttackPropertyMediatorComponent* GetAttackPropertyMediator(class AActor* Actor);

	void ClearAttackRate(const class FName& ClaimantName);
	void SetAttackRate(const class FName& ClaimantName, float AttackRate);

	float CalcTotalAttackRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackPropertyMediatorComponent">();
	}
	static class UAttackPropertyMediatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackPropertyMediatorComponent>();
	}
};
static_assert(alignof(UAttackPropertyMediatorComponent) == 0x000008, "Wrong alignment on UAttackPropertyMediatorComponent");
static_assert(sizeof(UAttackPropertyMediatorComponent) == 0x000110, "Wrong size on UAttackPropertyMediatorComponent");

// Class BattlePrototype.UITitleCrossSave_ConfirmWindow_Parts_Select2
// 0x0158 (0x04E0 - 0x0388)
class UUITitleCrossSave_ConfirmWindow_Parts_Select2 final : public UUIBase
{
public:
	uint8                                         Pad_1E71[0x158];                                   // 0x0388(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut, class UREDTextBlock* TextIndex);
	void InitializeThis();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleCrossSave_ConfirmWindow_Parts_Select2">();
	}
	static class UUITitleCrossSave_ConfirmWindow_Parts_Select2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleCrossSave_ConfirmWindow_Parts_Select2>();
	}
};
static_assert(alignof(UUITitleCrossSave_ConfirmWindow_Parts_Select2) == 0x000008, "Wrong alignment on UUITitleCrossSave_ConfirmWindow_Parts_Select2");
static_assert(sizeof(UUITitleCrossSave_ConfirmWindow_Parts_Select2) == 0x0004E0, "Wrong size on UUITitleCrossSave_ConfirmWindow_Parts_Select2");

// Class BattlePrototype.AutoAimComponent
// 0x0070 (0x0130 - 0x00C0)
class UAutoAimComponent final : public UActorComponent
{
public:
	float                                         _aimSpeed;                                         // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimSpeedInternalLock;                             // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxAimAngle;                                      // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInternalLock;                                   // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isToCamera;                                       // 0x00CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isToBrainCrash;                                   // 0x00CE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E74[0x1];                                     // 0x00CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _offsetDegree;                                     // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDirectionOfRotation                          _directionOfRotation;                              // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E75[0x3];                                     // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _frontDegree;                                      // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isToWeakPoint;                                    // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E76[0x53];                                    // 0x00DD(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAutoAimComponent* GetAutoAimComponentFromActor(class AActor* Actor);

	void BeginAutoAim(class UObject* Notify, float AimSpeed, float MaxAimAngle, bool IsInternalLock, bool IsToCamera, class AActor* brainCrashActor, class UMeshComponent* SocketRotateMesh, class FName SocketName, float OffsetDegree, EDirectionOfRotation DirectionOfRotation, float FrontDegree, float AimSpeedInternalLock, bool FindAimTargetWhenNoTarget, bool IsDetectTargetChange, bool IsToWeakPoint);
	void BeginAutoAimLocation(class UObject* Notify, float AimSpeed, float MaxAimAngle, const struct FVector& AimLocation, class UMeshComponent* SocketRotateMesh, class FName SocketName, float OffsetDegree, EDirectionOfRotation DirectionOfRotation, float FrontDegree);
	void EndAutoAim(class UObject* Notify);
	void LockLocation(bool bLock, const struct FVector& Param_LockLocation);
	void PauseAutoAim(bool bPause);
	float UpdateFromDirectionOfRotation(float Rot, float Sign);
	void UpdateRotateAim(float DeltaSeconds);

	bool IsBindOwnerTick() const;
	bool IsLockLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoAimComponent">();
	}
	static class UAutoAimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoAimComponent>();
	}
};
static_assert(alignof(UAutoAimComponent) == 0x000008, "Wrong alignment on UAutoAimComponent");
static_assert(sizeof(UAutoAimComponent) == 0x000130, "Wrong size on UAutoAimComponent");
static_assert(offsetof(UAutoAimComponent, _aimSpeed) == 0x0000C0, "Member 'UAutoAimComponent::_aimSpeed' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _aimSpeedInternalLock) == 0x0000C4, "Member 'UAutoAimComponent::_aimSpeedInternalLock' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _maxAimAngle) == 0x0000C8, "Member 'UAutoAimComponent::_maxAimAngle' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _isInternalLock) == 0x0000CC, "Member 'UAutoAimComponent::_isInternalLock' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _isToCamera) == 0x0000CD, "Member 'UAutoAimComponent::_isToCamera' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _isToBrainCrash) == 0x0000CE, "Member 'UAutoAimComponent::_isToBrainCrash' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _offsetDegree) == 0x0000D0, "Member 'UAutoAimComponent::_offsetDegree' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _directionOfRotation) == 0x0000D4, "Member 'UAutoAimComponent::_directionOfRotation' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _frontDegree) == 0x0000D8, "Member 'UAutoAimComponent::_frontDegree' has a wrong offset!");
static_assert(offsetof(UAutoAimComponent, _isToWeakPoint) == 0x0000DC, "Member 'UAutoAimComponent::_isToWeakPoint' has a wrong offset!");

// Class BattlePrototype.AutoRecoverComponent
// 0x0018 (0x00D8 - 0x00C0)
class UAutoRecoverComponent final : public UActorComponent
{
public:
	float                                         _HPRecoverStartSec;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _HPRecoverSpeed;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _autoRecoverHPFraction;                            // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _PPRecoverStartSec;                                // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _autoRecoverFullPPSec;                             // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _autoRecoverPPFraction;                            // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ProcessAutoRecoverHP(float DelataTime, bool EnableRecover);
	void ProcessAutoRecoverPP(float DelataTime, bool EnableRecover);
	void Setup(float HpRecoverSpeed, float HpRecoverStartSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoRecoverComponent">();
	}
	static class UAutoRecoverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoRecoverComponent>();
	}
};
static_assert(alignof(UAutoRecoverComponent) == 0x000008, "Wrong alignment on UAutoRecoverComponent");
static_assert(sizeof(UAutoRecoverComponent) == 0x0000D8, "Wrong size on UAutoRecoverComponent");
static_assert(offsetof(UAutoRecoverComponent, _HPRecoverStartSec) == 0x0000C0, "Member 'UAutoRecoverComponent::_HPRecoverStartSec' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _HPRecoverSpeed) == 0x0000C4, "Member 'UAutoRecoverComponent::_HPRecoverSpeed' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _autoRecoverHPFraction) == 0x0000C8, "Member 'UAutoRecoverComponent::_autoRecoverHPFraction' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _PPRecoverStartSec) == 0x0000CC, "Member 'UAutoRecoverComponent::_PPRecoverStartSec' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _autoRecoverFullPPSec) == 0x0000D0, "Member 'UAutoRecoverComponent::_autoRecoverFullPPSec' has a wrong offset!");
static_assert(offsetof(UAutoRecoverComponent, _autoRecoverPPFraction) == 0x0000D4, "Member 'UAutoRecoverComponent::_autoRecoverPPFraction' has a wrong offset!");

// Class BattlePrototype.NpcSkeletalMeshActor
// 0x00D0 (0x0300 - 0x0230)
class ANpcSkeletalMeshActor : public AActor
{
public:
	uint8                                         Pad_1E80[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CharacterCapsuleComponent;                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMeshDataTableID;                                // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMaterialDataTableID;                            // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BPOverrideMaterialID;                              // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E81[0x3];                                     // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideOverlapInterpolateSeconds;                     // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForcedLOD;                                         // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E82[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNpcSkeletalMeshComponent*              SkeletalMesh;                                      // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalBody;                                      // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalBodyLower;                                 // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalFace;                                      // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalHair;                                      // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>         SkeletalParts;                                     // 0x0280(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             M_storeSkeletalMeshTransform;                      // 0x0290(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             M_storeSkeletalBodyTransform;                      // 0x02C0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E83[0x10];                                    // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USkeletalMeshComponent* GetSkeletalBody();
	class USkeletalMeshComponent* GetSkeletalFace();
	class UNpcSkeletalMeshComponent* GetSkeletalMesh();
	void GetValidSkeletalMeshComponents(TArray<class USkeletalMeshComponent*>* MeshComps);
	void PresentEventEnd();
	void PresentEventStart();
	void RefreshMesh();
	void ResetMeshes(int32 MeshDataTableID, int32 MaterialDataTableID);
	void SetForcedLOD(int32 Level);
	void SetHideOverlap(bool bHide, bool bOneFrame);
	void SetInfiniteBounds(bool Enable);
	void SetLightChannnel(bool Channel0, bool Channel1, bool Channel2);
	void SetNpcTickEnabled(bool Enabled);
	void SetNpcTickInterval(float Value);
	void SetRenderLayer(uint8 NewRenderLayer);
	void SetScalarArrayParameterValue(const TArray<class FName>& ParameterNames, const TArray<float>& ParameterValues);
	void SetScalarParameterValue(class FName ParameterName, float ParameterValue);
	void SetUseShaderBoneID(bool bUse);
	void SetVector4ArrayParameterValue(const TArray<class FName>& ParameterNames, const TArray<struct FLinearColor>& ParameterValues);
	void SetVector4ParameterValue(class FName ParameterName, const struct FLinearColor& ParameterValue);
	void SetVectorParameterValue(class FName ParameterName, const struct FVector& ParameterValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcSkeletalMeshActor">();
	}
	static class ANpcSkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcSkeletalMeshActor>();
	}
};
static_assert(alignof(ANpcSkeletalMeshActor) == 0x000010, "Wrong alignment on ANpcSkeletalMeshActor");
static_assert(sizeof(ANpcSkeletalMeshActor) == 0x000300, "Wrong size on ANpcSkeletalMeshActor");
static_assert(offsetof(ANpcSkeletalMeshActor, CharacterCapsuleComponent) == 0x000238, "Member 'ANpcSkeletalMeshActor::CharacterCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, NpcMeshDataTableID) == 0x000240, "Member 'ANpcSkeletalMeshActor::NpcMeshDataTableID' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, NpcMaterialDataTableID) == 0x000244, "Member 'ANpcSkeletalMeshActor::NpcMaterialDataTableID' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, BPOverrideMaterialID) == 0x000248, "Member 'ANpcSkeletalMeshActor::BPOverrideMaterialID' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, HideOverlapInterpolateSeconds) == 0x00024C, "Member 'ANpcSkeletalMeshActor::HideOverlapInterpolateSeconds' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, ForcedLOD) == 0x000250, "Member 'ANpcSkeletalMeshActor::ForcedLOD' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalMesh) == 0x000258, "Member 'ANpcSkeletalMeshActor::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalBody) == 0x000260, "Member 'ANpcSkeletalMeshActor::SkeletalBody' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalBodyLower) == 0x000268, "Member 'ANpcSkeletalMeshActor::SkeletalBodyLower' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalFace) == 0x000270, "Member 'ANpcSkeletalMeshActor::SkeletalFace' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalHair) == 0x000278, "Member 'ANpcSkeletalMeshActor::SkeletalHair' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, SkeletalParts) == 0x000280, "Member 'ANpcSkeletalMeshActor::SkeletalParts' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, M_storeSkeletalMeshTransform) == 0x000290, "Member 'ANpcSkeletalMeshActor::M_storeSkeletalMeshTransform' has a wrong offset!");
static_assert(offsetof(ANpcSkeletalMeshActor, M_storeSkeletalBodyTransform) == 0x0002C0, "Member 'ANpcSkeletalMeshActor::M_storeSkeletalBodyTransform' has a wrong offset!");

// Class BattlePrototype.NpcTownPeopleBase
// 0x00B0 (0x03B0 - 0x0300)
class ANpcTownPeopleBase : public ANpcSkeletalMeshActor
{
public:
	uint8                                         Pad_1E84[0x8];                                     // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              AnimClass;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcAnimationKind                             FirstAnimationKind;                                // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAtPlayer;                                    // 0x0311(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E85[0x6];                                     // 0x0312(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             IconOffsetDataTable;                               // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNpcIconOffsetInfo>             IconOffsetDataInfos;                               // 0x0320(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCullingMode;                                     // 0x0330(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseTick;                                         // 0x0331(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E86[0x42];                                    // 0x0332(0x0042)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class URSNpcAnimInstance>      AnimationBP;                                       // 0x0374(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E87[0x34];                                    // 0x037C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCulling();
	float GetHeadHeight();
	void SetCulling(bool Culling);
	void SetLookAtPlayer(bool IsLookAt);
	void SetupGround();

	class UActorComponent* GetLookAtComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTownPeopleBase">();
	}
	static class ANpcTownPeopleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTownPeopleBase>();
	}
};
static_assert(alignof(ANpcTownPeopleBase) == 0x000010, "Wrong alignment on ANpcTownPeopleBase");
static_assert(sizeof(ANpcTownPeopleBase) == 0x0003B0, "Wrong size on ANpcTownPeopleBase");
static_assert(offsetof(ANpcTownPeopleBase, AnimClass) == 0x000308, "Member 'ANpcTownPeopleBase::AnimClass' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, FirstAnimationKind) == 0x000310, "Member 'ANpcTownPeopleBase::FirstAnimationKind' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IsLookAtPlayer) == 0x000311, "Member 'ANpcTownPeopleBase::IsLookAtPlayer' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IconOffsetDataTable) == 0x000318, "Member 'ANpcTownPeopleBase::IconOffsetDataTable' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IconOffsetDataInfos) == 0x000320, "Member 'ANpcTownPeopleBase::IconOffsetDataInfos' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IsCullingMode) == 0x000330, "Member 'ANpcTownPeopleBase::IsCullingMode' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, IsUseTick) == 0x000331, "Member 'ANpcTownPeopleBase::IsUseTick' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleBase, AnimationBP) == 0x000374, "Member 'ANpcTownPeopleBase::AnimationBP' has a wrong offset!");

// Class BattlePrototype.NpcTownPeople
// 0x00D0 (0x0480 - 0x03B0)
#pragma pack(push, 0x1)
class alignas(0x10) ANpcTownPeople : public ANpcTownPeopleBase
{
public:
	uint8                                         Pad_1E88[0x8];                                     // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchTick;                                      // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   CurrentSubQuestId;                                 // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SubQuestIdList;                                    // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleStartInSubQuest;                            // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleAfterSubQuestCompleted;                     // 0x03E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestProgressState                           SubQuestStatus;                                    // 0x03E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E89[0x1];                                     // 0x03E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsTalk;                                            // 0x03E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8A[0x3];                                     // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class URSNpcAnimInstance*                     NpcABPNative;                                      // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RipSyncAnimMontageNative;                          // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           BaseFacialAnimMontageNative;                       // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x0400(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MakeEventActorBPPath;                              // 0x0418(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8B[0x10];                                    // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   ChildActionIcon2;                                  // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x0450(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               ActionIconType;                                    // 0x045C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconSubQuestState                      ActionIconSubQuestState;                           // 0x045D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8C[0x1A];                                    // 0x045E(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustIconOffsetByHeadHeight();
	struct FVector GetActionIconWorldPositionOffset();
	const EQuestProgressState GetSubQuestProgress(int32 SubQuestNumber);
	bool IsDefaultRipSyncType();
	bool IsTalkEnablePlayer();
	void OnEndEventActor(class AActor* DestroyedMakeEventActor);
	void OnStartEventActor();
	void StartRipSyncMontageNative();
	void StopRipSyncMontageNative();
	void TurnToPlayer(float Speed);
	void UnregisterTownPeopleAction();
	void UpdateRipSyncNative();
	void UpdateSubQuestActionIcon();
	void UpdateSubQuestId();
	void UpdateSubQuestStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTownPeople">();
	}
	static class ANpcTownPeople* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTownPeople>();
	}
};
#pragma pack(pop)
static_assert(alignof(ANpcTownPeople) == 0x000010, "Wrong alignment on ANpcTownPeople");
static_assert(sizeof(ANpcTownPeople) == 0x000480, "Wrong size on ANpcTownPeople");
static_assert(offsetof(ANpcTownPeople, DispatchTick) == 0x0003B8, "Member 'ANpcTownPeople::DispatchTick' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, CurrentSubQuestId) == 0x0003C8, "Member 'ANpcTownPeople::CurrentSubQuestId' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, SubQuestIdList) == 0x0003D0, "Member 'ANpcTownPeople::SubQuestIdList' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, VisibleStartInSubQuest) == 0x0003E0, "Member 'ANpcTownPeople::VisibleStartInSubQuest' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, VisibleAfterSubQuestCompleted) == 0x0003E1, "Member 'ANpcTownPeople::VisibleAfterSubQuestCompleted' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, SubQuestStatus) == 0x0003E2, "Member 'ANpcTownPeople::SubQuestStatus' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, IsTalk) == 0x0003E4, "Member 'ANpcTownPeople::IsTalk' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, NpcABPNative) == 0x0003E8, "Member 'ANpcTownPeople::NpcABPNative' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, RipSyncAnimMontageNative) == 0x0003F0, "Member 'ANpcTownPeople::RipSyncAnimMontageNative' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, BaseFacialAnimMontageNative) == 0x0003F8, "Member 'ANpcTownPeople::BaseFacialAnimMontageNative' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ShowBoxComponent) == 0x000400, "Member 'ANpcTownPeople::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, EventBoxComponent) == 0x000408, "Member 'ANpcTownPeople::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, MakeEventActorClass) == 0x000410, "Member 'ANpcTownPeople::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, MakeEventActorBPPath) == 0x000418, "Member 'ANpcTownPeople::MakeEventActorBPPath' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, MakeEventActor) == 0x000428, "Member 'ANpcTownPeople::MakeEventActor' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ChildActionIcon) == 0x000440, "Member 'ANpcTownPeople::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ChildActionIcon2) == 0x000448, "Member 'ANpcTownPeople::ChildActionIcon2' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ActionIconWorldPositionOffset) == 0x000450, "Member 'ANpcTownPeople::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ActionIconType) == 0x00045C, "Member 'ANpcTownPeople::ActionIconType' has a wrong offset!");
static_assert(offsetof(ANpcTownPeople, ActionIconSubQuestState) == 0x00045D, "Member 'ANpcTownPeople::ActionIconSubQuestState' has a wrong offset!");

// Class BattlePrototype.NpcAjitoPeople
// 0x0000 (0x0480 - 0x0480)
class ANpcAjitoPeople : public ANpcTownPeople
{
public:
	int32                                         PlaceID;                                           // 0x0478(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8E[0x4];                                     // 0x047C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcAjitoPeople">();
	}
	static class ANpcAjitoPeople* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcAjitoPeople>();
	}
};
static_assert(alignof(ANpcAjitoPeople) == 0x000010, "Wrong alignment on ANpcAjitoPeople");
static_assert(sizeof(ANpcAjitoPeople) == 0x000480, "Wrong size on ANpcAjitoPeople");
static_assert(offsetof(ANpcAjitoPeople, PlaceID) == 0x000478, "Member 'ANpcAjitoPeople::PlaceID' has a wrong offset!");

// Class BattlePrototype.BattleCharacterDebugInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleCharacterDebugInterface final : public IInterface
{
public:
	bool IsDebugInvincible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCharacterDebugInterface">();
	}
	static class IBattleCharacterDebugInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleCharacterDebugInterface>();
	}
};
static_assert(alignof(IBattleCharacterDebugInterface) == 0x000008, "Wrong alignment on IBattleCharacterDebugInterface");
static_assert(sizeof(IBattleCharacterDebugInterface) == 0x000028, "Wrong size on IBattleCharacterDebugInterface");

// Class BattlePrototype.MaterialAccessorComponent
// 0x02A0 (0x0360 - 0x00C0)
class UMaterialAccessorComponent : public UActorComponent
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x00C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshComponent*>                 AppendMeshes;                                      // 0x00C8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableRestoreOverrideParamters;                    // 0x00D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8F[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMACSlotParameter>              MaterialList;                                      // 0x00E0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E90[0x270];                                   // 0x00F0(0x0270)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddColorByRate(float SumValue, const struct FLinearColor& BaseColor, float Rate, const struct FLinearColor& SourceColor, struct FLinearColor* OutColor);
	void GetDefaultScalarParameter(const TArray<int32>& SearchSlots, class FName ParameterName, float* OutParameters);
	void GetDefaultScalarParameterALL(class FName ParameterName, float* OutParameters);
	void GetDefaultScalarParameterByVariable(struct FMACVariableFloat& Variable);
	void GetDefaultVectorParameter(const TArray<int32>& SearchSlots, class FName ParameterName, struct FLinearColor* OutParameters);
	void GetDefaultVectorParameterALL(class FName ParameterName, struct FLinearColor* OutParameters);
	void GetDefaultVectorParameterByVariable(struct FMACVariableVector& Variable);
	void ManualRestoreOverrideParametersBP();
	void RegisterScalarParameters(const TArray<struct FMACVariableFloat>& Variables);
	void RegisterVectorParameters(const TArray<struct FMACVariableVector>& Variables);
	void Reset();
	void RestoreParameter();
	void SetAppendMesh(const TArray<class UMeshComponent*>& InAppedMeshes);
	void SetExcludeRestoreOverrideParameters(const TArray<class FName>& ParameterNames);
	void SetScalarParameter(EMaterialAccessorSetupID SetupID, float Value, float DefaultValue, class FName ParameterName, int32 SlotHandle);
	void SetScalarParameterByRegister(const TArray<float>& Variables, const TArray<EMaterialAccessorSetupID>& SetupIDs);
	void SetScalarParameterByVariable(struct FMACVariableFloat& Variable, EMaterialAccessorSetupID SetupID);
	void SetTextureParameter(class UTexture* Texture, class FName ParameterName, int32 SlotHandle);
	int32 SetupMaterialBySlotName(const class FString& SlotName);
	void SetVectorParameter(EMaterialAccessorSetupID SetupID, const struct FLinearColor& Value, const struct FLinearColor& DefaultValue, class FName ParameterName, int32 SlotHandle);
	void SetVectorParameterByRegister(const TArray<struct FVector>& Variables, const TArray<EMaterialAccessorSetupID>& SetupIDs);
	void SetVectorParameterByVariable(struct FMACVariableVector& Variable, EMaterialAccessorSetupID SetupID);
	void SetVisibleMaterialAllLODs(bool Show, int32 SlotHandle);
	void UpdateMateiral();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialAccessorComponent">();
	}
	static class UMaterialAccessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialAccessorComponent>();
	}
};
static_assert(alignof(UMaterialAccessorComponent) == 0x000008, "Wrong alignment on UMaterialAccessorComponent");
static_assert(sizeof(UMaterialAccessorComponent) == 0x000360, "Wrong size on UMaterialAccessorComponent");
static_assert(offsetof(UMaterialAccessorComponent, Mesh) == 0x0000C0, "Member 'UMaterialAccessorComponent::Mesh' has a wrong offset!");
static_assert(offsetof(UMaterialAccessorComponent, AppendMeshes) == 0x0000C8, "Member 'UMaterialAccessorComponent::AppendMeshes' has a wrong offset!");
static_assert(offsetof(UMaterialAccessorComponent, EnableRestoreOverrideParamters) == 0x0000D8, "Member 'UMaterialAccessorComponent::EnableRestoreOverrideParamters' has a wrong offset!");
static_assert(offsetof(UMaterialAccessorComponent, MaterialList) == 0x0000E0, "Member 'UMaterialAccessorComponent::MaterialList' has a wrong offset!");

// Class BattlePrototype.PlayerMaterialAccessorComponent
// 0x0000 (0x0360 - 0x0360)
class UPlayerMaterialAccessorComponent : public UMaterialAccessorComponent
{
public:
	void SetCable(class AActor* Player);
	void SetPlayerMesh(class USkeletalMeshComponent* PlayerMesh);
	void SetupDefaultParameter(class ACharacter* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMaterialAccessorComponent">();
	}
	static class UPlayerMaterialAccessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMaterialAccessorComponent>();
	}
};
static_assert(alignof(UPlayerMaterialAccessorComponent) == 0x000008, "Wrong alignment on UPlayerMaterialAccessorComponent");
static_assert(sizeof(UPlayerMaterialAccessorComponent) == 0x000360, "Wrong size on UPlayerMaterialAccessorComponent");

// Class BattlePrototype.BattleCharacterHudInterface
// 0x0000 (0x0028 - 0x0028)
class IBattleCharacterHudInterface final : public IInterface
{
public:
	bool BrainCrashUnlock();
	int32 GetWeakNumber();
	bool SetEmphasisCrashGauge(bool bEmphasisCrashGauge);

	void GetCrashChanceCursorPoint(struct FVector* Point) const;
	void GetHpGaugePoint(struct FVector* Point) const;
	void GetTargetCursorPoint(struct FVector* Point) const;
	bool IsEmphasisCrashGauge() const;
	void IsHpGaugeAlwaysMax(bool* bAlwaysMax) const;
	void IsInvisibleHPGauge(bool* bInvisible) const;
	bool IsInvisibleMiniMap() const;
	void IsSpawnWait(bool* bSpawnWait) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleCharacterHudInterface">();
	}
	static class IBattleCharacterHudInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBattleCharacterHudInterface>();
	}
};
static_assert(alignof(IBattleCharacterHudInterface) == 0x000008, "Wrong alignment on IBattleCharacterHudInterface");
static_assert(sizeof(IBattleCharacterHudInterface) == 0x000028, "Wrong size on IBattleCharacterHudInterface");

// Class BattlePrototype.HitCheckInterface
// 0x0000 (0x0028 - 0x0028)
class IHitCheckInterface final : public IInterface
{
public:
	class AActor* GetHitCheckIgnoredActor();
	bool IsCheckFriendlyFire(class AActor* HitActor);
	bool IsIgnoreAccelerator(EHCSkillExtraType Type);
	bool IsIgnoreHitCheck(class UPrimitiveComponent* PPrimitive, const struct FVector& HitPosition);
	bool IsObstacleHitCheck(class UPrimitiveComponent* PPrimitive, class AActor* PAttacker, const struct FVector& EndPosition);
	bool IsObstacleHitCheckToActor(class AActor* PTarget);

	bool IsDisableDamageHit() const;
	bool IsOnGround(bool bIncludeObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitCheckInterface">();
	}
	static class IHitCheckInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHitCheckInterface>();
	}
};
static_assert(alignof(IHitCheckInterface) == 0x000008, "Wrong alignment on IHitCheckInterface");
static_assert(sizeof(IHitCheckInterface) == 0x000028, "Wrong size on IHitCheckInterface");

// Class BattlePrototype.BattlefieldManager
// 0x00E0 (0x0310 - 0x0230)
class ABattlefieldManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_1E9D[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchBattleFieldBegin;                          // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBattleFieldEnd;                            // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBattleFieldRushEnd;                        // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FString, struct FBattlefieldInfo>  CurrentBFInfos;                                    // 0x0268(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         FenceLotterySeed;                                  // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x02BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsActiveEvent;                                     // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9E[0x3];                                     // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMakeEventActor>            MakeEventActorClass;                               // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMakeEventActor*                        MakeEventActor;                                    // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E9F[0x8];                                     // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AllFenceActors;                                    // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EA0[0x8];                                     // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AllTriggerActors;                                  // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EA1[0x8];                                     // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BroadcastBattlefieldRushEnd(int32 GroupID, int32 SubGroupID);
	bool EndAllBattlefieldForce();
	bool EndBattlefield(int32 BFGroupID);
	bool EndBattlefieldForce(int32 BFGroupID);
	bool EndEventBattlefield(int32 BFGroupID);
	void FinalizeAtStartArea();
	void GetBattlefieldInfo(int32 BFGroupID, struct FBattlefieldInfo* BFInfo, bool* IsExist);
	class AActor* GetBfFence(int32 GroupID);
	TArray<class AActor*> GetBfFenceAll(int32 GroupID);
	void GetBfFenceStatus(int32 GroupID, bool* Exist, bool* IsVisible);
	bool HaveDestroyedBattlefield(int32 BFGroupID, const class FString& TargetName);
	void InitializeAtStartArea();
	bool InitializeAtStartBattlefield(const struct FBattlefieldInfo& CurrentBFInfo);
	bool IsAnyFenceEnabled();
	bool IsBattlefieldWillAppear(int32 GroupID, float FenceBattleRate, const class FString& SeedString, const class FString& TargetName);
	bool IsExistBattlefieldEnemies(int32 BFGroupID, int32 SubGroupID, int32* FirstSubGroup);
	bool IsExistBattlefieldEnemiesStrictly(int32 BFGroupID, int32 SubGroupID);
	bool IsFenceEnabled(int32 GroupID);
	bool IsInFence(const struct FVector& Pos, int32 GroupID);
	bool IsInSplineLoop(const struct FVector& Pos, class USplineComponent* Spline);
	bool IsInSplineLoopDetail(const struct FVector& Pos, class USplineComponent* Spline);
	bool IsPlayerInFence(int32 GroupID);
	bool IsStartBattlefield(int32 BFGroupID);
	bool OnLoad_SaveData();
	bool OnSave_SaveData();
	bool OverwriteTmpBfInfo(int32 GroupID, const class FString& TriggerName);
	bool RepopBattlefieldEnemy(int32 BFGroupID);
	bool RepopBattlefieldInfos(int32 LocationId, int32 AreaId, const class FString& SeedString);
	bool ResetFenceRandomSeed();
	bool SetBattlefieldInfo(int32 BFGroupID, const struct FBattlefieldInfo& BFInfo);
	bool SetCurrentBattlefieldInfos(const TMap<class FString, struct FBattlefieldInfo>& Infos);
	void SetCurrentLocationAndArea(int32 LocationId, int32 AreaId);
	void SetEnableEnemyOutField(bool Enable, int32 BFGroupID);
	bool SetFenceEnable(int32 FenceID, bool Enable);
	bool SetFenceEnableForce(int32 FenceID, bool Enable);
	bool StartBattlefield(EBattlefieldEventType EventType, int32 BFGroupID, int32 SubGroupID, const TArray<struct FBattlefieldTutorialInfo>& AdditionalTutorialInfo, TSubclassOf<class AMakeEventActor> Param_MakeEventActorClass, int32 TutorialGroupID, int32 TutorialSubGroupID, float FenceBattleRate, const class FString& SeedString, bool IsOnceBattle);
	bool StartEventBattlefield(int32 BFGroupID, int32 SubGroupID);
	bool StartEventInBattleField(TSubclassOf<class AMakeEventActor> Param_MakeEventActorClass);
	bool StartWipeoutBattlefield(int32 BFGroupID);
	void UpdateAtStartArea();

	const struct FBattlefieldInfo GetCurrentBattlefieldInfo(bool* Exist) const;
	bool IsCharacterInBattleField(const struct FBattlefieldInfo& InInfo, class ARSCharacterBase* InCharacter) const;
	bool IsCharacterInCurrentBattleField(class ARSCharacterBase* InCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlefieldManager">();
	}
	static class ABattlefieldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattlefieldManager>();
	}
};
static_assert(alignof(ABattlefieldManager) == 0x000008, "Wrong alignment on ABattlefieldManager");
static_assert(sizeof(ABattlefieldManager) == 0x000310, "Wrong size on ABattlefieldManager");
static_assert(offsetof(ABattlefieldManager, DispatchBattleFieldBegin) == 0x000238, "Member 'ABattlefieldManager::DispatchBattleFieldBegin' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, DispatchBattleFieldEnd) == 0x000248, "Member 'ABattlefieldManager::DispatchBattleFieldEnd' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, DispatchBattleFieldRushEnd) == 0x000258, "Member 'ABattlefieldManager::DispatchBattleFieldRushEnd' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, CurrentBFInfos) == 0x000268, "Member 'ABattlefieldManager::CurrentBFInfos' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, FenceLotterySeed) == 0x0002B8, "Member 'ABattlefieldManager::FenceLotterySeed' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, RandomStream) == 0x0002BC, "Member 'ABattlefieldManager::RandomStream' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, IsActiveEvent) == 0x0002C4, "Member 'ABattlefieldManager::IsActiveEvent' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, MakeEventActorClass) == 0x0002C8, "Member 'ABattlefieldManager::MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, MakeEventActor) == 0x0002D0, "Member 'ABattlefieldManager::MakeEventActor' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, AllFenceActors) == 0x0002E0, "Member 'ABattlefieldManager::AllFenceActors' has a wrong offset!");
static_assert(offsetof(ABattlefieldManager, AllTriggerActors) == 0x0002F8, "Member 'ABattlefieldManager::AllTriggerActors' has a wrong offset!");

// Class BattlePrototype.BattleLogBuffer
// 0x0010 (0x0038 - 0x0028)
class UBattleLogBuffer final : public UObject
{
public:
	TArray<struct FBattleLogParam>                battleLogBufferArray;                              // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddBattleLogBuffer(const struct FBattleLogParam& Param);
	void Clear();
	TArray<struct FBattleLogParam> GetBattleLogBuffer();
	void Initialize();

	bool IsExistLogBuffer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleLogBuffer">();
	}
	static class UBattleLogBuffer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleLogBuffer>();
	}
};
static_assert(alignof(UBattleLogBuffer) == 0x000008, "Wrong alignment on UBattleLogBuffer");
static_assert(sizeof(UBattleLogBuffer) == 0x000038, "Wrong size on UBattleLogBuffer");
static_assert(offsetof(UBattleLogBuffer, battleLogBufferArray) == 0x000028, "Member 'UBattleLogBuffer::battleLogBufferArray' has a wrong offset!");

// Class BattlePrototype.BattleManager
// 0x00D0 (0x0300 - 0x0230)
class ABattleManager : public AActor
{
public:
	uint8                                         Pad_1ECD[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharacterBase*>               _battleActorList;                                  // 0x0238(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1ECE[0x8];                                     // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _ForceBattleList;                                  // 0x0250(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BATTLEFIELD_SPEEDRUN_TIME;                         // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BATTLEFIELD_HORDE_ENEMY_NUM;                       // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ECF[0x8];                                     // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorBattleEndLogData>         _BattleLogDataList;                                // 0x0270(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _IsSimulatorMissionBattle;                         // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED0[0x3];                                     // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OneFrameHitEffectMax;                              // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Other;                            // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Npc;                              // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Enemy;                            // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_PlayerDamage;                     // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Player;                           // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitEffectPoolNum_Special;                          // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Other;                              // 0x02A0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Npc;                                // 0x02B0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Enemy;                              // 0x02C0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_PlayerDamage;                       // 0x02D0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Player;                             // 0x02E0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPoolHitEffectData>             _HitEffectPool_Special;                            // 0x02F0(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddBattleActor(class ARSCharacterBase* Actor);
	void BeginRecordBattleLog(bool bBattleField);
	void ClearBattleActor();
	void EndRecordBattleLog(bool bBattleField);
	void ForceEndRecordBattleLog();
	class UBattleSettingComponent* GetBattleSetting();
	class UBattleSituationComponent* GetSituation();
	bool PlayBrainTalkStealthLost();
	void PoolHitEffectData(class AActor* HitActor, const struct FHCHitResult& HitResult, bool bNoLimit);
	void RemoveBattleActor(class ARSCharacterBase* Actor, EReasonBattleEnd Reason);
	void SetBattleMode(bool bBattle);
	void SetForceBattle(bool bForce, class FName ClaimantName);
	void StartTutorialOperation(class FName HelpTutoID, float DelaySec);

	bool CheckBattleLog_StealthLost() const;
	const TArray<class ARSCharacterBase*> GetBattleActorList() const;
	bool IsBattleMode() const;
	bool IsForceBattle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleManager">();
	}
	static class ABattleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleManager>();
	}
};
static_assert(alignof(ABattleManager) == 0x000008, "Wrong alignment on ABattleManager");
static_assert(sizeof(ABattleManager) == 0x000300, "Wrong size on ABattleManager");
static_assert(offsetof(ABattleManager, _battleActorList) == 0x000238, "Member 'ABattleManager::_battleActorList' has a wrong offset!");
static_assert(offsetof(ABattleManager, _ForceBattleList) == 0x000250, "Member 'ABattleManager::_ForceBattleList' has a wrong offset!");
static_assert(offsetof(ABattleManager, BATTLEFIELD_SPEEDRUN_TIME) == 0x000260, "Member 'ABattleManager::BATTLEFIELD_SPEEDRUN_TIME' has a wrong offset!");
static_assert(offsetof(ABattleManager, BATTLEFIELD_HORDE_ENEMY_NUM) == 0x000264, "Member 'ABattleManager::BATTLEFIELD_HORDE_ENEMY_NUM' has a wrong offset!");
static_assert(offsetof(ABattleManager, _BattleLogDataList) == 0x000270, "Member 'ABattleManager::_BattleLogDataList' has a wrong offset!");
static_assert(offsetof(ABattleManager, _IsSimulatorMissionBattle) == 0x000280, "Member 'ABattleManager::_IsSimulatorMissionBattle' has a wrong offset!");
static_assert(offsetof(ABattleManager, OneFrameHitEffectMax) == 0x000284, "Member 'ABattleManager::OneFrameHitEffectMax' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Other) == 0x000288, "Member 'ABattleManager::HitEffectPoolNum_Other' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Npc) == 0x00028C, "Member 'ABattleManager::HitEffectPoolNum_Npc' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Enemy) == 0x000290, "Member 'ABattleManager::HitEffectPoolNum_Enemy' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_PlayerDamage) == 0x000294, "Member 'ABattleManager::HitEffectPoolNum_PlayerDamage' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Player) == 0x000298, "Member 'ABattleManager::HitEffectPoolNum_Player' has a wrong offset!");
static_assert(offsetof(ABattleManager, HitEffectPoolNum_Special) == 0x00029C, "Member 'ABattleManager::HitEffectPoolNum_Special' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Other) == 0x0002A0, "Member 'ABattleManager::_HitEffectPool_Other' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Npc) == 0x0002B0, "Member 'ABattleManager::_HitEffectPool_Npc' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Enemy) == 0x0002C0, "Member 'ABattleManager::_HitEffectPool_Enemy' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_PlayerDamage) == 0x0002D0, "Member 'ABattleManager::_HitEffectPool_PlayerDamage' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Player) == 0x0002E0, "Member 'ABattleManager::_HitEffectPool_Player' has a wrong offset!");
static_assert(offsetof(ABattleManager, _HitEffectPool_Special) == 0x0002F0, "Member 'ABattleManager::_HitEffectPool_Special' has a wrong offset!");

// Class BattlePrototype.NpcBase
// 0x0060 (0x0290 - 0x0230)
class ANpcBase : public AActor
{
public:
	uint8                                         Pad_1ED4[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NpcMeshDataTableID;                                // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMaterialDataTableID;                            // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED5[0x8];                                     // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CharacterCapsuleComponent;                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNpcSkeletalMeshComponent*              SkeletalMeshComponent;                             // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalBody;                                      // 0x0258(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalBodyLower;                                 // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalFace;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalHair;                                      // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>         SkeletalParts;                                     // 0x0278(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RefreshMesh();
	void SetLightChannnel(bool Channel0, bool Channel1, bool Channel2);
	void SetRenderLayer(uint8 NewRenderLayer);
	void SetScalarParameterValue(class FName ParameterName, float ParameterValue);
	void SetVectorParameterValue(class FName ParameterName, const struct FVector& ParameterValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcBase">();
	}
	static class ANpcBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcBase>();
	}
};
static_assert(alignof(ANpcBase) == 0x000008, "Wrong alignment on ANpcBase");
static_assert(sizeof(ANpcBase) == 0x000290, "Wrong size on ANpcBase");
static_assert(offsetof(ANpcBase, NpcMeshDataTableID) == 0x000238, "Member 'ANpcBase::NpcMeshDataTableID' has a wrong offset!");
static_assert(offsetof(ANpcBase, NpcMaterialDataTableID) == 0x00023C, "Member 'ANpcBase::NpcMaterialDataTableID' has a wrong offset!");
static_assert(offsetof(ANpcBase, CharacterCapsuleComponent) == 0x000248, "Member 'ANpcBase::CharacterCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalMeshComponent) == 0x000250, "Member 'ANpcBase::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalBody) == 0x000258, "Member 'ANpcBase::SkeletalBody' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalBodyLower) == 0x000260, "Member 'ANpcBase::SkeletalBodyLower' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalFace) == 0x000268, "Member 'ANpcBase::SkeletalFace' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalHair) == 0x000270, "Member 'ANpcBase::SkeletalHair' has a wrong offset!");
static_assert(offsetof(ANpcBase, SkeletalParts) == 0x000278, "Member 'ANpcBase::SkeletalParts' has a wrong offset!");
static_assert(offsetof(ANpcBase, EventBoxComponent) == 0x000288, "Member 'ANpcBase::EventBoxComponent' has a wrong offset!");

// Class BattlePrototype.NpcTalker
// 0x0058 (0x02E8 - 0x0290)
class ANpcTalker final : public ANpcBase
{
public:
	uint8                                         Pad_1ED6[0x8];                                     // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_messageTableName;                                // 0x0298(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UREDLuaScriptComponent*                 M_pLuaScriptComponent;                             // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMakeEventActor>            M_MakeEventActorClass;                             // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMakeEventActor*                        M_makeEventActor;                                  // 0x02C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1ED7[0x8];                                     // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   M_pChildActionIcon;                                // 0x02D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_actionIconWorldPositionOffset;                   // 0x02D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               M_actionIconType;                                  // 0x02E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconSubQuestState                      M_actionIconSubQuestState;                         // 0x02E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1ED8[0x2];                                     // 0x02E6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMessageTableName(const class FString& TableName);

	class FString GetMessageTableName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTalker">();
	}
	static class ANpcTalker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTalker>();
	}
};
static_assert(alignof(ANpcTalker) == 0x000008, "Wrong alignment on ANpcTalker");
static_assert(sizeof(ANpcTalker) == 0x0002E8, "Wrong size on ANpcTalker");
static_assert(offsetof(ANpcTalker, M_messageTableName) == 0x000298, "Member 'ANpcTalker::M_messageTableName' has a wrong offset!");
static_assert(offsetof(ANpcTalker, ShowBoxComponent) == 0x0002A8, "Member 'ANpcTalker::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_pLuaScriptComponent) == 0x0002B0, "Member 'ANpcTalker::M_pLuaScriptComponent' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_MakeEventActorClass) == 0x0002B8, "Member 'ANpcTalker::M_MakeEventActorClass' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_makeEventActor) == 0x0002C0, "Member 'ANpcTalker::M_makeEventActor' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_pChildActionIcon) == 0x0002D0, "Member 'ANpcTalker::M_pChildActionIcon' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_actionIconWorldPositionOffset) == 0x0002D8, "Member 'ANpcTalker::M_actionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_actionIconType) == 0x0002E4, "Member 'ANpcTalker::M_actionIconType' has a wrong offset!");
static_assert(offsetof(ANpcTalker, M_actionIconSubQuestState) == 0x0002E5, "Member 'ANpcTalker::M_actionIconSubQuestState' has a wrong offset!");

// Class BattlePrototype.DebugInfoScreenBase
// 0x0098 (0x02C8 - 0x0230)
class ADebugInfoScreenBase : public AActor
{
public:
	TArray<struct FDebugInfoScreenData>           DataList;                                          // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED9[0x20];                                    // 0x0240(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            RenderWidget;                                      // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTextBlock*>                     TextWidgetList;                                    // 0x0268(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EDA[0x50];                                    // 0x0278(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugInfoScreenBase">();
	}
	static class ADebugInfoScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugInfoScreenBase>();
	}
};
static_assert(alignof(ADebugInfoScreenBase) == 0x000008, "Wrong alignment on ADebugInfoScreenBase");
static_assert(sizeof(ADebugInfoScreenBase) == 0x0002C8, "Wrong size on ADebugInfoScreenBase");
static_assert(offsetof(ADebugInfoScreenBase, DataList) == 0x000230, "Member 'ADebugInfoScreenBase::DataList' has a wrong offset!");
static_assert(offsetof(ADebugInfoScreenBase, RenderWidget) == 0x000260, "Member 'ADebugInfoScreenBase::RenderWidget' has a wrong offset!");
static_assert(offsetof(ADebugInfoScreenBase, TextWidgetList) == 0x000268, "Member 'ADebugInfoScreenBase::TextWidgetList' has a wrong offset!");

// Class BattlePrototype.DebugInfoScreenParticle
// 0x0000 (0x02C8 - 0x02C8)
class ADebugInfoScreenParticle final : public ADebugInfoScreenBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugInfoScreenParticle">();
	}
	static class ADebugInfoScreenParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugInfoScreenParticle>();
	}
};
static_assert(alignof(ADebugInfoScreenParticle) == 0x000008, "Wrong alignment on ADebugInfoScreenParticle");
static_assert(sizeof(ADebugInfoScreenParticle) == 0x0002C8, "Wrong size on ADebugInfoScreenParticle");

// Class BattlePrototype.BattlePrototypeUtility
// 0x0000 (0x0028 - 0x0028)
class UBattlePrototypeUtility final : public UObject
{
public:
	static void DrawDebugPrintString(class UObject* CallingObj, const class FString& InString, float ScreenX, float ScreenY, class AActor* TargetActor, const struct FLinearColor& TextColor, float Scale);
	static const struct FIntPoint GetAppBaseResolution();
	static void GetCallStack(class FString* Output);
	static void GetCallStackBP(class FString* Output);
	static int32 GetDebugBadState();
	static int32 GetMasterReleaseVersion();
	static bool IsDay1PatchReleaseVersion();
	static bool IsDebugAreaSceneSelectable();
	static bool IsDebugBrainCrashOpend();
	static bool IsDebugDirectPause();
	static bool IsDebugDrawAI();
	static bool IsDebugDrawAttackCollision();
	static bool IsDebugDrawNonLockonTargetSearch();
	static bool IsDebugDrawPrintString();
	static bool IsDebugDrawTargetSearch();
	static bool IsDebugEnemyDamagePartHitPrint();
	static bool IsDebugEnemyDrawData();
	static bool IsDebugEnemyInvincible();
	static bool IsDebugEnemyParameter();
	static bool IsDebugParticleSpawnDisable();
	static bool IsDebugPlayerInvincible();
	static bool IsDebugSASBetaEnable();
	static bool IsDebugSASInfinity();
	static bool IsDebugSoundSpawnDisable();
	static bool IsDLC1PatchReleaseVersion();
	static bool IsDLC2PatchReleaseVersion();
	static bool IsDLC3PatchReleaseVersion();
	static bool IsDLC4PatchReleaseVersion();
	static bool IsEnableUserReview202005EOM();
	static bool IsMasterReleaseVersion();
	static bool IsNotSaveLoadDebugingParameter();
	static bool IsTrialFeedbackPatchReleaseVersion();
	static void SetDebugAreaSceneSelectable(bool Flag);
	static void SetNotSaveLoadDebugingParameter(bool Flag);
	static class FString SimpleFloatToString(float Value);
	static class FString SimpleIntToString(int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePrototypeUtility">();
	}
	static class UBattlePrototypeUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePrototypeUtility>();
	}
};
static_assert(alignof(UBattlePrototypeUtility) == 0x000008, "Wrong alignment on UBattlePrototypeUtility");
static_assert(sizeof(UBattlePrototypeUtility) == 0x000028, "Wrong size on UBattlePrototypeUtility");

// Class BattlePrototype.BattleSettingComponent
// 0x0018 (0x00D8 - 0x00C0)
class UBattleSettingComponent : public UActorComponent
{
public:
	float                                         AttackExPsychicRateForArmor;                       // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EnemyLockOnMax;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EnemyAttackActionMax;                              // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WinceAccumulationStopSeconds;                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         KnockBackAccumulationStopSeconds;                  // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DownAccumulationStopSeconds;                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetAttackExPsychicRateForArmor();
	void SetAttackExPsychicRateForArmor(float Value);

	float GetDownAccumationStopSeconds() const;
	int32 GetEnemyAttackActionMax() const;
	int32 GetEnemyLockOnMax() const;
	float GetKnockBackAccumationStopSeconds() const;
	float GetWinceAccumationStopSeconds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSettingComponent">();
	}
	static class UBattleSettingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSettingComponent>();
	}
};
static_assert(alignof(UBattleSettingComponent) == 0x000008, "Wrong alignment on UBattleSettingComponent");
static_assert(sizeof(UBattleSettingComponent) == 0x0000D8, "Wrong size on UBattleSettingComponent");
static_assert(offsetof(UBattleSettingComponent, AttackExPsychicRateForArmor) == 0x0000C0, "Member 'UBattleSettingComponent::AttackExPsychicRateForArmor' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, EnemyLockOnMax) == 0x0000C4, "Member 'UBattleSettingComponent::EnemyLockOnMax' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, EnemyAttackActionMax) == 0x0000C8, "Member 'UBattleSettingComponent::EnemyAttackActionMax' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, WinceAccumulationStopSeconds) == 0x0000CC, "Member 'UBattleSettingComponent::WinceAccumulationStopSeconds' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, KnockBackAccumulationStopSeconds) == 0x0000D0, "Member 'UBattleSettingComponent::KnockBackAccumulationStopSeconds' has a wrong offset!");
static_assert(offsetof(UBattleSettingComponent, DownAccumulationStopSeconds) == 0x0000D4, "Member 'UBattleSettingComponent::DownAccumulationStopSeconds' has a wrong offset!");

// Class BattlePrototype.BattleSimulatorCameraEventDataParam
// 0x0020 (0x0050 - 0x0030)
class UBattleSimulatorCameraEventDataParam final : public UDataAsset
{
public:
	float                                         BlendTime;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtHeightOffset;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunc;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDE[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDF[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSimulatorCameraEventDataParam">();
	}
	static class UBattleSimulatorCameraEventDataParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSimulatorCameraEventDataParam>();
	}
};
static_assert(alignof(UBattleSimulatorCameraEventDataParam) == 0x000008, "Wrong alignment on UBattleSimulatorCameraEventDataParam");
static_assert(sizeof(UBattleSimulatorCameraEventDataParam) == 0x000050, "Wrong size on UBattleSimulatorCameraEventDataParam");
static_assert(offsetof(UBattleSimulatorCameraEventDataParam, BlendTime) == 0x000030, "Member 'UBattleSimulatorCameraEventDataParam::BlendTime' has a wrong offset!");
static_assert(offsetof(UBattleSimulatorCameraEventDataParam, Distance) == 0x000034, "Member 'UBattleSimulatorCameraEventDataParam::Distance' has a wrong offset!");
static_assert(offsetof(UBattleSimulatorCameraEventDataParam, HeightOffset) == 0x000038, "Member 'UBattleSimulatorCameraEventDataParam::HeightOffset' has a wrong offset!");
static_assert(offsetof(UBattleSimulatorCameraEventDataParam, LookAtHeightOffset) == 0x00003C, "Member 'UBattleSimulatorCameraEventDataParam::LookAtHeightOffset' has a wrong offset!");
static_assert(offsetof(UBattleSimulatorCameraEventDataParam, BlendFunc) == 0x000040, "Member 'UBattleSimulatorCameraEventDataParam::BlendFunc' has a wrong offset!");
static_assert(offsetof(UBattleSimulatorCameraEventDataParam, BlendExp) == 0x000044, "Member 'UBattleSimulatorCameraEventDataParam::BlendExp' has a wrong offset!");
static_assert(offsetof(UBattleSimulatorCameraEventDataParam, FOV) == 0x000048, "Member 'UBattleSimulatorCameraEventDataParam::FOV' has a wrong offset!");

// Class BattlePrototype.BattleSimulatorManager
// 0x0360 (0x0590 - 0x0230)
class ABattleSimulatorManager : public AActor
{
public:
	uint8                                         Pad_1EE0[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUnuseEndMissionCheck;                             // 0x0240(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalledFinishMoveStart;                            // 0x0241(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE1[0x6];                                     // 0x0242(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PauseTimerList;                                    // 0x0248(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           SlowTimerList;                                     // 0x0258(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EE2[0x8];                                     // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              MissionCompleteDateTime;                           // 0x0270(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             MissionScoreDataTable;                             // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBattleSimulatorResult                 StoreMissionScoreResult;                           // 0x0280(0x0048)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBattleSimulatorJewelPoolResult        StoreMissionJewelPoolResult;                       // 0x02C8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UDataTable*                             RareSpawnCondisionDataTable;                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BattleSimulatorDetailDataTable;                    // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BattleSimulatorReleaseConditonDataTable;           // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE3[0x2A8];                                   // 0x02E8(0x02A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Add_EnemyBadStatus(int32 Num);
	void Add_HitUniqueObject(int32 Num);
	void Add_KillCombinationVision(int32 Num);
	void Add_KillDrive(int32 Num);
	void Add_KillUniqueObject(int32 Num);
	void Add_PlayerBadStatus(int32 Num);
	void AddEndMissionEventCommand();
	void AddRareEnemyAppearanceNum(int32 Num, bool IsYuito);
	void AddRareEnemySubjugatopmNum(int32 Num, bool IsYuito);
	void AddScore_BrainCrash(int32 Num);
	int32 AddScore_EnemyDamage(int32 Damage, const struct FHCHitResult& HitResult, EBattleSimulatorEnemyDamageAddType AddType, float HpRate, bool bBoss);
	int32 AddScore_EnemyDamageDirect(int32 Damage);
	void AddScore_Item(int32 Num);
	void AddScore_PlayerDamage(int32 Damage, const struct FHCHitResult& HitResult);
	void AddScore_PlayerDamageDirect(int32 Damage);
	void BeginMission();
	void BeginMissionCheck();
	struct FBattleSimulatorJewelPoolResult CalcMissionJewelPoolResult();
	struct FBattleSimulatorResult CalcMissionResult();
	void CancelMission();
	void ClearRareEnemyAppearanceNum(bool IsYuito);
	void ClearRareEnemySubjugationNum(bool IsYuito);
	void ClearScore();
	void DrawDebugPrintMissionResult();
	void DrawDebugPrintScorePoint();
	void EndMission();
	class AActor* GetActorAndHpRateEnemyHpRate(float* HpRate);
	float GetBattleTime();
	int32 GetBrainCrashNum();
	class FName GetCurrentMissionName();
	int32 GetEnemyBadStatusNum();
	int32 GetEnemyDamageSum();
	int32 GetHitUniqueObjectNum();
	bool GetIsNew(class FName DataName, bool IsYuito);
	int32 GetItemNum();
	int32 GetJewelPoolTotalDefeatedCount(class FName DataName, bool IsYuito);
	int32 GetKillCombinationVisionNum();
	int32 GetKillDriveNum();
	int32 GetKillUniqueObjectNum();
	struct FDateTime GetMissionCompleteDateTime();
	struct FBattleSimulatorMissionDetailData GetMissionDetailData(class FName DataName);
	int32 GetMissionID();
	TArray<class FName> GetPauseTimerList();
	int32 GetPlayerBadStatusNum();
	int32 GetPlayerDamageSum();
	class FName GetPrevMissionName();
	int32 GetRareEnemyAppearanceNum(bool IsYuito);
	int32 GetRareEnmySubjugationNum(bool IsYuito);
	struct FBattleSimulatorRareSpawnCondisionData GetRareSpawnCondisionData(class FName DataName);
	struct FBattleSimulatorMissionReleaseCondition GetReleaseConditionData(class FName DataName);
	TMap<EBattleSimulatorPublicationCategory, struct FBattleSimulatorReleaseDataList> GetReleaseConditionList();
	struct FBattleSimulatorResult GetSaveResult(class FName DataName, bool IsYuito);
	bool IsCurrentMissionTypeKillJewelPool();
	bool IsCurrentPlayerYuito();
	bool IsMissionActive();
	bool IsMissionCleared(class FName DataName, bool IsYuito);
	bool IsMissionReleased(class FName DataName, bool IsYuito);
	bool IsMissionStartBefore();
	bool IsOpenBattleSimulator();
	void OnBeforeSimulatorResult();
	void OnCancelMission();
	void OnFinishMission();
	void OnFinishMissionBP();
	void OnMissionEnemyDead();
	void OnMissionSubMakeEvent(class AActor* Actor);
	void OnSetPauseTimer();
	void ResetBattleTime();
	void Set_TagAndHpRateEnemyHpRate(class FName EnemyTag, float HpRate);
	void SetBattleSimulatorPlayerInvalidDamage(bool InvalidDamage);
	void SetBattleTIme(float Time);
	void SetCheckActorEnemyHpRate(bool bCheck);
	void SetDebugEnableTimerSlow(bool bSet);
	void SetDebugOutputEnemyBrainCrashDamageLog(bool bOutput);
	void SetDebugOutputEnemyDamageLog(bool bOutput);
	void SetDebugOutputMissionResult(bool bOutput);
	void SetIgnoreFenceFinishMission(bool IgnoreFenceFinishMission);
	void SetIsNew(bool IsNew, class FName DataName, bool IsYuito);
	void SetMissionCleared(class FName DataName, bool IsCleared, bool IsYuito);
	void SetMissionData(class FName DataName);
	void SetMissionDetailData(class FName DataName);
	void SetMissionReleased(class FName DataName, bool IsReleased, bool IsYuito);
	void SetMissionStartBefore(bool StartBefore);
	void SetPauseTimer(bool bPause, class FName ClaimantName);
	void SetReleaseConditionData(class FName DataName);
	void SetRetryDialogSelectNo(int32 SelectNo);
	void SetSlowTimer(bool bSlow, class FName ClaimantName);
	void StopPrintResultPoint();
	void StoreMissionCompleteDateTime();
	void UpdateCheckActorEnemyHpRate();

	bool IsTimerPause() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSimulatorManager">();
	}
	static class ABattleSimulatorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleSimulatorManager>();
	}
};
static_assert(alignof(ABattleSimulatorManager) == 0x000008, "Wrong alignment on ABattleSimulatorManager");
static_assert(sizeof(ABattleSimulatorManager) == 0x000590, "Wrong size on ABattleSimulatorManager");
static_assert(offsetof(ABattleSimulatorManager, bUnuseEndMissionCheck) == 0x000240, "Member 'ABattleSimulatorManager::bUnuseEndMissionCheck' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, bCalledFinishMoveStart) == 0x000241, "Member 'ABattleSimulatorManager::bCalledFinishMoveStart' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, PauseTimerList) == 0x000248, "Member 'ABattleSimulatorManager::PauseTimerList' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, SlowTimerList) == 0x000258, "Member 'ABattleSimulatorManager::SlowTimerList' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, MissionCompleteDateTime) == 0x000270, "Member 'ABattleSimulatorManager::MissionCompleteDateTime' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, MissionScoreDataTable) == 0x000278, "Member 'ABattleSimulatorManager::MissionScoreDataTable' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, StoreMissionScoreResult) == 0x000280, "Member 'ABattleSimulatorManager::StoreMissionScoreResult' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, StoreMissionJewelPoolResult) == 0x0002C8, "Member 'ABattleSimulatorManager::StoreMissionJewelPoolResult' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, RareSpawnCondisionDataTable) == 0x0002D0, "Member 'ABattleSimulatorManager::RareSpawnCondisionDataTable' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, BattleSimulatorDetailDataTable) == 0x0002D8, "Member 'ABattleSimulatorManager::BattleSimulatorDetailDataTable' has a wrong offset!");
static_assert(offsetof(ABattleSimulatorManager, BattleSimulatorReleaseConditonDataTable) == 0x0002E0, "Member 'ABattleSimulatorManager::BattleSimulatorReleaseConditonDataTable' has a wrong offset!");

// Class BattlePrototype.RSPlatformFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSPlatformFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FName ConvertKeyboardName(const class FName OldKey, ELocalizedKeyboardType OldType, ELocalizedKeyboardType NewType);
	static void ConvertKeyboardNames(const TArray<class FName>& OldKeys, ELocalizedKeyboardType OldType, TArray<class FName>* NewKeys, ELocalizedKeyboardType NewType);
	static void DisplayRequestActive();
	static void DisplayRequestRelease();
	static bool GetDisplayRequestState();
	static ELocalizedKeyboardType GetLocalizedKeyboardType();
	static class FString GetLocalizedPath(ETextLanguage TextLang);
	static EPlatFormConsoleType GetPlatformConsoleType();
	static ERegionType GetPlatformRegion();
	static EPlatFormType GetPlatformType();
	static ETextLanguage GetSystemTextLanguage();
	static ETextLanguage GetSystemVoiceLanguage();
	static bool IsCrossButtonDecide();
	static bool IsEnableShareRecording();
	static bool SetCurrentCulture(ETextLanguage TextLang);
	static void SetEnableShareRecording(bool IsEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlatformFunctionLibrary">();
	}
	static class URSPlatformFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSPlatformFunctionLibrary>();
	}
};
static_assert(alignof(URSPlatformFunctionLibrary) == 0x000008, "Wrong alignment on URSPlatformFunctionLibrary");
static_assert(sizeof(URSPlatformFunctionLibrary) == 0x000028, "Wrong size on URSPlatformFunctionLibrary");

// Class BattlePrototype.BattleSituationComponent
// 0x0038 (0x00F8 - 0x00C0)
class UBattleSituationComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChangeSituation;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         IgnoreChangeSituationRemainTimer;                  // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalSituationRemainTimer;                        // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IgnoreChangeSituationTime;                         // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeSituationTime;                               // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBattleSituationType                          SituationType;                                     // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EFC[0x17];                                    // 0x00E1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeSituation(EBattleSituationType Type);
	void GetSituationParameter(EBattleSituationActionType ActionType, float* RemainTime, int32* Priority);
	void OnAction(const struct FActionParameter& Parameter);

	EBattleSituationType GetSituation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleSituationComponent">();
	}
	static class UBattleSituationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleSituationComponent>();
	}
};
static_assert(alignof(UBattleSituationComponent) == 0x000008, "Wrong alignment on UBattleSituationComponent");
static_assert(sizeof(UBattleSituationComponent) == 0x0000F8, "Wrong size on UBattleSituationComponent");
static_assert(offsetof(UBattleSituationComponent, OnChangeSituation) == 0x0000C0, "Member 'UBattleSituationComponent::OnChangeSituation' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, IgnoreChangeSituationRemainTimer) == 0x0000D0, "Member 'UBattleSituationComponent::IgnoreChangeSituationRemainTimer' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, NormalSituationRemainTimer) == 0x0000D4, "Member 'UBattleSituationComponent::NormalSituationRemainTimer' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, IgnoreChangeSituationTime) == 0x0000D8, "Member 'UBattleSituationComponent::IgnoreChangeSituationTime' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, ChangeSituationTime) == 0x0000DC, "Member 'UBattleSituationComponent::ChangeSituationTime' has a wrong offset!");
static_assert(offsetof(UBattleSituationComponent, SituationType) == 0x0000E0, "Member 'UBattleSituationComponent::SituationType' has a wrong offset!");

// Class BattlePrototype.IceConditionEffectActor
// 0x0020 (0x0250 - 0x0230)
class AIceConditionEffectActor final : public AActor
{
public:
	class UParticleSystem*                        _pBeginEffect;                                     // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _pEndEffect;                                       // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _pEffectComp;                                      // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _pRootSceneComp;                                   // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FinishEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IceConditionEffectActor">();
	}
	static class AIceConditionEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIceConditionEffectActor>();
	}
};
static_assert(alignof(AIceConditionEffectActor) == 0x000008, "Wrong alignment on AIceConditionEffectActor");
static_assert(sizeof(AIceConditionEffectActor) == 0x000250, "Wrong size on AIceConditionEffectActor");
static_assert(offsetof(AIceConditionEffectActor, _pBeginEffect) == 0x000230, "Member 'AIceConditionEffectActor::_pBeginEffect' has a wrong offset!");
static_assert(offsetof(AIceConditionEffectActor, _pEndEffect) == 0x000238, "Member 'AIceConditionEffectActor::_pEndEffect' has a wrong offset!");
static_assert(offsetof(AIceConditionEffectActor, _pEffectComp) == 0x000240, "Member 'AIceConditionEffectActor::_pEffectComp' has a wrong offset!");
static_assert(offsetof(AIceConditionEffectActor, _pRootSceneComp) == 0x000248, "Member 'AIceConditionEffectActor::_pRootSceneComp' has a wrong offset!");

// Class BattlePrototype.BlendableVolume
// 0x0020 (0x0288 - 0x0268)
class ABlendableVolume : public AVolume
{
public:
	uint8                                         Pad_1EFE[0xC];                                     // 0x0268(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Priority;                                          // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendRadius;                                       // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUnbound : 1;                                      // 0x0280(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1EFF[0x7];                                     // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendableVolume">();
	}
	static class ABlendableVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlendableVolume>();
	}
};
static_assert(alignof(ABlendableVolume) == 0x000008, "Wrong alignment on ABlendableVolume");
static_assert(sizeof(ABlendableVolume) == 0x000288, "Wrong size on ABlendableVolume");
static_assert(offsetof(ABlendableVolume, Priority) == 0x000274, "Member 'ABlendableVolume::Priority' has a wrong offset!");
static_assert(offsetof(ABlendableVolume, BlendRadius) == 0x000278, "Member 'ABlendableVolume::BlendRadius' has a wrong offset!");
static_assert(offsetof(ABlendableVolume, BlendWeight) == 0x00027C, "Member 'ABlendableVolume::BlendWeight' has a wrong offset!");

// Class BattlePrototype.BlendableVolumeManager
// 0x0018 (0x0248 - 0x0230)
class ABlendableVolumeManager : public AActor
{
public:
	uint8                                         Pad_1F00[0x18];                                    // 0x0230(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintAddCalcVolume(const class ABlendableVolume* Volume, float Weight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlendableVolumeManager">();
	}
	static class ABlendableVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlendableVolumeManager>();
	}
};
static_assert(alignof(ABlendableVolumeManager) == 0x000008, "Wrong alignment on ABlendableVolumeManager");
static_assert(sizeof(ABlendableVolumeManager) == 0x000248, "Wrong size on ABlendableVolumeManager");

// Class BattlePrototype.BlownAwayComponent
// 0x0018 (0x00D8 - 0x00C0)
class UBlownAwayComponent final : public UActorComponent
{
public:
	bool                                          _isBlowOnDamage;                                   // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F02[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _guardBlowPowerRate;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F03[0x10];                                    // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBlownAwayComponent* GetBlownAwayComponentFromActor(class AActor* Actor);

	void AddDamageBlowImpulse(const struct FHCHitResult& HitResult, bool IsGuard);
	void SetIsBlowOnDamage(bool blowEnable);

	struct FVector GetBlowImpulse(const class AActor* AttackActor, const struct FRotator& blowAngle, float blowPower) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlownAwayComponent">();
	}
	static class UBlownAwayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlownAwayComponent>();
	}
};
static_assert(alignof(UBlownAwayComponent) == 0x000008, "Wrong alignment on UBlownAwayComponent");
static_assert(sizeof(UBlownAwayComponent) == 0x0000D8, "Wrong size on UBlownAwayComponent");
static_assert(offsetof(UBlownAwayComponent, _isBlowOnDamage) == 0x0000C0, "Member 'UBlownAwayComponent::_isBlowOnDamage' has a wrong offset!");
static_assert(offsetof(UBlownAwayComponent, _guardBlowPowerRate) == 0x0000C4, "Member 'UBlownAwayComponent::_guardBlowPowerRate' has a wrong offset!");

// Class BattlePrototype.OnlineTestGameSession
// 0x0110 (0x0358 - 0x0248)
class AOnlineTestGameSession final : public AGameSession
{
public:
	uint8                                         Pad_1F06[0x110];                                   // 0x0248(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestGameSession">();
	}
	static class AOnlineTestGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnlineTestGameSession>();
	}
};
static_assert(alignof(AOnlineTestGameSession) == 0x000008, "Wrong alignment on AOnlineTestGameSession");
static_assert(sizeof(AOnlineTestGameSession) == 0x000358, "Wrong size on AOnlineTestGameSession");

// Class BattlePrototype.FootStepInterface
// 0x0000 (0x0028 - 0x0028)
class IFootStepInterface final : public IInterface
{
public:
	bool FootStepPlay(const EGamePhysicalSurfaceType PhysicsType, const ECharacterPhysicalActionType ActionType, const struct FTransform& Transform, class AActor* Creator, const bool IsPlayEffect, const bool IsPlaySound);
	bool FootStepPlayEffect(const EGamePhysicalSurfaceType PhysicsType, const class FName ActionType, const struct FTransform& Transform, class AActor* Creator);
	bool FootStepPlaySound(const EGamePhysicalSurfaceType PhysicsType, const class FName ActionType, const struct FTransform& Transform, class AActor* Creator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootStepInterface">();
	}
	static class IFootStepInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFootStepInterface>();
	}
};
static_assert(alignof(IFootStepInterface) == 0x000008, "Wrong alignment on IFootStepInterface");
static_assert(sizeof(IFootStepInterface) == 0x000028, "Wrong size on IFootStepInterface");

// Class BattlePrototype.BrainCrashFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBrainCrashFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void EditorSetBCSequenceSettingsFromJSONString(class UDataTable* DataTable, const class FString& JsonString);
	static int32 GetBCSafePointAllowAllRotation();
	static int32 GetBCSafePointAllowRotationBit(const struct FBrainCrashSafePoint& SafePoint, int32 EnemyIndex);
	static struct FTransform GetBCSafePointBoxTransform(const struct FVector& Location, const struct FBrainCrashSequenceSettingsData& SeqenceSetting, float RotationYaw, float HeightFloating, float Scale);
	static struct FTransform GetBCSafePointCylinderTransform(const struct FVector& Location, const struct FBrainCrashSequenceSettingsData& SeqenceSetting, float HeightFloating, float Scale);
	static bool IsBCSafePointAllowAllRotation(int32 RotationBit);
	static void SearchBCSafePoint(bool* HitNearLocation, struct FTransform* NearLocationTransform, float* NearLocationLength, bool* HitNearAngle, struct FTransform* NearAngleTransform, float* NearAngleLength, float* NearAngleAngle, const struct FBrainCrashSafePoint& SafePoints, class UBrainCrashParam* Param, int32 RotationAngle, int32 EnemyIndex, const struct FVector& Location, const struct FVector& SequencerCenterLocation, float TargetRawDir, float TargetNormalizedDir);
	static void SearchBCSafePointList(bool* HitNearLocation, struct FTransform* NearLocationTransform, float* NearLocationLength, bool* HitNearAngle, struct FTransform* NearAngleTransform, float* NearAngleLength, const TArray<struct FBrainCrashSafePoint>& SafePoints, const TArray<class USplineMeshComponent*>& BattleFieldMeshComps, class UBrainCrashParam* Param, const struct FBrainCrashSequenceSettings& SequencerSetting, int32 RotationAngle, int32 EnemyIndex, const struct FVector& Location, const struct FVector& SequencerCenterLocation, float TargetRawDir, float TargetNormalizedDir);
	static void SetBCSafePointAllowRotationBit(struct FBrainCrashSafePoint& RefSafePoint, int32 EnemyIndex, int32 AllowRotateBit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashFunctionLibrary">();
	}
	static class UBrainCrashFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainCrashFunctionLibrary>();
	}
};
static_assert(alignof(UBrainCrashFunctionLibrary) == 0x000008, "Wrong alignment on UBrainCrashFunctionLibrary");
static_assert(sizeof(UBrainCrashFunctionLibrary) == 0x000028, "Wrong size on UBrainCrashFunctionLibrary");

// Class BattlePrototype.UICaption
// 0x0000 (0x0388 - 0x0388)
class UUICaption : public UUIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICaption">();
	}
	static class UUICaption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICaption>();
	}
};
static_assert(alignof(UUICaption) == 0x000008, "Wrong alignment on UUICaption");
static_assert(sizeof(UUICaption) == 0x000388, "Wrong size on UUICaption");

// Class BattlePrototype.BrainCrashManager
// 0x00D0 (0x0300 - 0x0230)
class ABrainCrashManager : public AActor
{
public:
	uint8                                         Pad_1F18[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEmptyTriggerTransform;                            // 0x0238(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F19[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastTriggerTransform;                              // 0x0240(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1A[0x90];                                    // 0x0270(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckUseCutin();
	int32 GetSafePointGroupPlayerID(class UBrainCrashLocationSettings* LocationSettings);
	TArray<struct FBrainCrashSafePoint> GetSafePointGroupPoints(class UBrainCrashLocationSettings* LocationSettings);
	TArray<struct FBrainCrashSafePoint> GetSafePointGroupPointsFromID(class UBrainCrashLocationSettings* LocationSettings, int32 SafePointID);
	TArray<struct FBrainCrashSafePoint> GetSafePointGroupPointsFromUnbound(class UBrainCrashLocationSettings* LocationSettings);
	bool GetTriggerTransform(struct FTransform* TriggerTransform);
	class ABrainCrashSettingVolume* GetTriggerTransformVolume();
	bool SearchUniqueFinishEnemyLocation(struct FTransform& OutEnmeyTransform, const struct FTransform& SeqeuncerEnemyTransform, const struct FTransform& SeqeuncerPlayerTransform, const struct FTransform& PlayerTransform, const TArray<struct FVector>& CollisionCheckOffset, int32 CollisionCheckRadius, const TArray<EObjectTypeQuery>& CollisionObjectTypes, EDrawDebugTrace CollisionDebugType);
	void SetupSafePointGroup(class UBrainCrashLocationSettings* LocationSettings, bool ForceUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashManager">();
	}
	static class ABrainCrashManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainCrashManager>();
	}
};
static_assert(alignof(ABrainCrashManager) == 0x000010, "Wrong alignment on ABrainCrashManager");
static_assert(sizeof(ABrainCrashManager) == 0x000300, "Wrong size on ABrainCrashManager");
static_assert(offsetof(ABrainCrashManager, bEmptyTriggerTransform) == 0x000238, "Member 'ABrainCrashManager::bEmptyTriggerTransform' has a wrong offset!");
static_assert(offsetof(ABrainCrashManager, LastTriggerTransform) == 0x000240, "Member 'ABrainCrashManager::LastTriggerTransform' has a wrong offset!");

// Class BattlePrototype.BrainCrashParam
// 0x0040 (0x0070 - 0x0030)
class UBrainCrashParam final : public UDataAsset
{
public:
	float                                         CameraInterpStartTime;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      CameraInterpStartFunc;                             // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F21[0x3];                                     // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraInterpStartEaseExp;                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraInterpFinishTime;                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      CameraInterpFinishFunc;                            // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F22[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraInterpFinishEaseExp;                         // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DitherHiddenSeconds;                               // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointPriorityAngleLength;                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointPriorityAngle;                            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointLimitLength;                              // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointLimitAngle;                               // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafePointLimitHeight;                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GeneralDamageSeconds;                              // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GeneralDamageMaxIntervalSeconds;                   // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniqueWaitSecdons;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F23[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashParam">();
	}
	static class UBrainCrashParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainCrashParam>();
	}
};
static_assert(alignof(UBrainCrashParam) == 0x000008, "Wrong alignment on UBrainCrashParam");
static_assert(sizeof(UBrainCrashParam) == 0x000070, "Wrong size on UBrainCrashParam");
static_assert(offsetof(UBrainCrashParam, CameraInterpStartTime) == 0x000030, "Member 'UBrainCrashParam::CameraInterpStartTime' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpStartFunc) == 0x000034, "Member 'UBrainCrashParam::CameraInterpStartFunc' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpStartEaseExp) == 0x000038, "Member 'UBrainCrashParam::CameraInterpStartEaseExp' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpFinishTime) == 0x00003C, "Member 'UBrainCrashParam::CameraInterpFinishTime' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpFinishFunc) == 0x000040, "Member 'UBrainCrashParam::CameraInterpFinishFunc' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, CameraInterpFinishEaseExp) == 0x000044, "Member 'UBrainCrashParam::CameraInterpFinishEaseExp' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, DitherHiddenSeconds) == 0x000048, "Member 'UBrainCrashParam::DitherHiddenSeconds' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointPriorityAngleLength) == 0x00004C, "Member 'UBrainCrashParam::SafePointPriorityAngleLength' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointPriorityAngle) == 0x000050, "Member 'UBrainCrashParam::SafePointPriorityAngle' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointLimitLength) == 0x000054, "Member 'UBrainCrashParam::SafePointLimitLength' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointLimitAngle) == 0x000058, "Member 'UBrainCrashParam::SafePointLimitAngle' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, SafePointLimitHeight) == 0x00005C, "Member 'UBrainCrashParam::SafePointLimitHeight' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, GeneralDamageSeconds) == 0x000060, "Member 'UBrainCrashParam::GeneralDamageSeconds' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, GeneralDamageMaxIntervalSeconds) == 0x000064, "Member 'UBrainCrashParam::GeneralDamageMaxIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UBrainCrashParam, UniqueWaitSecdons) == 0x000068, "Member 'UBrainCrashParam::UniqueWaitSecdons' has a wrong offset!");

// Class BattlePrototype.DebuggingItemLabel
// 0x0030 (0x02F8 - 0x02C8)
class ADebuggingItemLabel final : public ADebuggingItemBase
{
public:
	class FText                                   DispLabel;                                         // 0x02C8(0x0018)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F24[0x8];                                     // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemLabel">();
	}
	static class ADebuggingItemLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemLabel>();
	}
};
static_assert(alignof(ADebuggingItemLabel) == 0x000008, "Wrong alignment on ADebuggingItemLabel");
static_assert(sizeof(ADebuggingItemLabel) == 0x0002F8, "Wrong size on ADebuggingItemLabel");
static_assert(offsetof(ADebuggingItemLabel, DispLabel) == 0x0002C8, "Member 'ADebuggingItemLabel::DispLabel' has a wrong offset!");
static_assert(offsetof(ADebuggingItemLabel, OnChanged) == 0x0002E0, "Member 'ADebuggingItemLabel::OnChanged' has a wrong offset!");

// Class BattlePrototype.UIConfigGraphics
// 0x0090 (0x0418 - 0x0388)
class UUIConfigGraphics : public UUIBase
{
public:
	uint8                                         Pad_1F25[0x90];                                    // 0x0388(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UREDScrollBoxSimple* ScrollBox, class UUIConfigSelect3* UiAntiAliasingQuality, class UUIConfigSelect2* UiVSync, class UUIConfigSelect3* UiTextureQuality, class UUIConfigSelect3* UiShadowQuality, class UUIConfigSelect3* UiPostProccessingQuality, class UUIConfigSelectMulti* UiResolution, class UUIConfigSelect3* UiWindowMode, class UUIConfigSelect3* UiFrameRate);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigGraphics">();
	}
	static class UUIConfigGraphics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigGraphics>();
	}
};
static_assert(alignof(UUIConfigGraphics) == 0x000008, "Wrong alignment on UUIConfigGraphics");
static_assert(sizeof(UUIConfigGraphics) == 0x000418, "Wrong size on UUIConfigGraphics");

// Class BattlePrototype.BrainCrashLocationSettings
// 0x0010 (0x0040 - 0x0030)
class UBrainCrashLocationSettings final : public UDataAsset
{
public:
	TArray<struct FBrainCrashSafePoint>           SafePoints;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashLocationSettings">();
	}
	static class UBrainCrashLocationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainCrashLocationSettings>();
	}
};
static_assert(alignof(UBrainCrashLocationSettings) == 0x000008, "Wrong alignment on UBrainCrashLocationSettings");
static_assert(sizeof(UBrainCrashLocationSettings) == 0x000040, "Wrong size on UBrainCrashLocationSettings");
static_assert(offsetof(UBrainCrashLocationSettings, SafePoints) == 0x000030, "Member 'UBrainCrashLocationSettings::SafePoints' has a wrong offset!");

// Class BattlePrototype.EnemyAnimControllerComponent
// 0x0038 (0x0118 - 0x00E0)
class UEnemyAnimControllerComponent final : public UAnimControllerComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class URSEnemyAnimInstance>    _animBP;                                           // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F26[0x20];                                    // 0x00F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UEnemyAnimControllerComponent* GetEnemyAnimControllerComponentFromActor(class AActor* Actor);

	void BeginAction(EnemyActionAnimKind Action);
	void BeginAttack(EnemyAttackAnimKind Attack);
	void BeginDie();
	void BeginExcite();
	void BeginGetUp();
	void BeginMove(EnemyMoveAnimKind Move);
	void BeginMoveBackward();
	bool CheckEndExcite(bool IsEndAnim);
	bool CheckGoToIdleMove(bool IsEndAnim);
	void EndMoveBackward();
	void OnEndAnimDie();
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void SetAliveAnimKind(EnemyAliveAnimKind Alive);
	void SetAnimRootMotionScale(float Scale);
	void SetBrainCrash(EnemyBrainCrashAnimKind Crash);
	void SetCrashChance(EnemyCrashChanceAnimKind Chance);
	void SetDamage(EnemyDamageAnimKind Damage);
	void SetDamageDown(EnemyDamageDownAnimKind Damage);
	void SetDead(EnemyDeadAnimKind Dead);
	void SetEnemyKind(EnemyKind Kind);
	void SetIgnoreStandUpSuperArmor(bool IsIgnoreStandUpSuperArmor);
	void SetIgnoreSuperArmor(bool IsIgnoreSuperArmor);
	void SetInitLayout(EnemyInitLayoutAnimKind Layout);
	void SetLanded(bool Landed);
	void SetMove(EnemyMoveAnimKind Move);
	void SetSuperArmor(bool IsSuperArmor);
	void SetSwitchAnimKind(EnemySwitchAnimKind Anim);
	void UpdateAnimDirectionAndSpeed();

	bool AliveToDie() const;
	bool CheckFaintToWakeup(bool IsEndAnim) const;
	float DotOfHitDirAndRight() const;
	float DotOfHitDirAndUp() const;
	float GetDirection() const;
	EnemyActionAnimKind GetEnemyActionAnimKind() const;
	EnemyAliveAnimKind GetEnemyAliveAnimKind() const;
	EnemyAttackAnimKind GetEnemyAttackAnimKind() const;
	EnemyBrainCrashAnimKind GetEnemyBrainCrashAnimKind() const;
	EnemyCrashChanceAnimKind GetEnemyCrashChanceAnimKind() const;
	EnemyDamageAnimKind GetEnemyDamageAnimKind() const;
	EnemyDamageDownAnimKind GetEnemyDamageDownAnimKind() const;
	EnemyDeadAnimKind GetEnemyDeadAnimKind() const;
	EnemyKind GetEnemyKind() const;
	EnemyMoveAnimKind GetMove() const;
	float GetSpeed() const;
	EnemySwitchAnimKind GetSwitchAnimKind() const;
	bool IsAction(EnemyActionAnimKind Action) const;
	bool IsActionAnimKind(const TArray<EnemyActionAnimKind>& KindArray) const;
	bool IsASNodePlayEnd() const;
	bool IsAttack(EnemyAttackAnimKind Attack) const;
	bool IsAttackAnimKind(const TArray<EnemyAttackAnimKind>& KindArray) const;
	bool IsAttackFlg() const;
	bool IsBrainCrashAnimKind() const;
	bool IsCrashChanceAnimKind() const;
	bool IsDamage() const;
	bool IsDamageAnimKindBlow() const;
	bool IsDamageAnimKindDamageChance() const;
	bool IsDamageAnimKindDown() const;
	bool IsDamageAnimKindKnockBack() const;
	bool IsDamageAnimKindLaunch() const;
	bool IsDamageAnimKindSpecialDamage() const;
	bool IsDamageAnimKindSpecialDamageDown() const;
	bool IsDamageAnimKindWince() const;
	bool IsDamageAnimLight2() const;
	bool IsDamageAnimStateB() const;
	bool IsDeadComplete() const;
	bool IsDie() const;
	bool IsIgnoreCrashChance() const;
	bool IsLanded() const;
	bool IsMove(EnemyMoveAnimKind Move) const;
	bool IsPossibleDamageAnimKind() const;
	bool IsPossibleDamageAnimKindBlow() const;
	bool IsPossibleDamageAnimKindDamageChance() const;
	bool IsPossibleDamageAnimKindDown() const;
	bool IsPossibleDamageAnimKindKnockBack() const;
	bool IsPossibleDamageAnimKindLaunch() const;
	bool IsPossibleDamageAnimKindSpecialDamageDown() const;
	bool IsPossibleDamageAnimKindWince() const;
	bool IsPressDownAnimKind() const;
	bool StateAliveIsAction() const;
	bool StateAliveIsAttack() const;
	bool StateAliveIsDamage() const;
	bool StateAliveIsIdleMove() const;
	bool StateAliveIsInitLayout() const;
	bool StateIsBack() const;
	bool StateIsExcite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAnimControllerComponent">();
	}
	static class UEnemyAnimControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAnimControllerComponent>();
	}
};
static_assert(alignof(UEnemyAnimControllerComponent) == 0x000008, "Wrong alignment on UEnemyAnimControllerComponent");
static_assert(sizeof(UEnemyAnimControllerComponent) == 0x000118, "Wrong size on UEnemyAnimControllerComponent");
static_assert(offsetof(UEnemyAnimControllerComponent, DispatchMontageBlendingOut) == 0x0000E0, "Member 'UEnemyAnimControllerComponent::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UEnemyAnimControllerComponent, _animBP) == 0x0000F0, "Member 'UEnemyAnimControllerComponent::_animBP' has a wrong offset!");

// Class BattlePrototype.BrainCrashPointGroupVolume
// 0x0020 (0x0288 - 0x0268)
class ABrainCrashPointGroupVolume final : public AVolume
{
public:
	int32                                         GroupID;                                           // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnbound;                                          // 0x0271(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2A[0x16];                                    // 0x0272(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashPointGroupVolume">();
	}
	static class ABrainCrashPointGroupVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainCrashPointGroupVolume>();
	}
};
static_assert(alignof(ABrainCrashPointGroupVolume) == 0x000008, "Wrong alignment on ABrainCrashPointGroupVolume");
static_assert(sizeof(ABrainCrashPointGroupVolume) == 0x000288, "Wrong size on ABrainCrashPointGroupVolume");
static_assert(offsetof(ABrainCrashPointGroupVolume, GroupID) == 0x000268, "Member 'ABrainCrashPointGroupVolume::GroupID' has a wrong offset!");
static_assert(offsetof(ABrainCrashPointGroupVolume, Priority) == 0x00026C, "Member 'ABrainCrashPointGroupVolume::Priority' has a wrong offset!");
static_assert(offsetof(ABrainCrashPointGroupVolume, bEnabled) == 0x000270, "Member 'ABrainCrashPointGroupVolume::bEnabled' has a wrong offset!");
static_assert(offsetof(ABrainCrashPointGroupVolume, bUnbound) == 0x000271, "Member 'ABrainCrashPointGroupVolume::bUnbound' has a wrong offset!");

// Class BattlePrototype.UIConfigBrightness
// 0x00A0 (0x0428 - 0x0388)
class UUIConfigBrightness : public UUIBase
{
public:
	int32                                         MinX;                                              // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxX;                                              // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F2B[0x98];                                    // 0x0390(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBrightness(float FValue);
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UImage* ImageSlider, class UTextBlock* TextDescription, class UREDOverlay* Gauge_set);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigBrightness">();
	}
	static class UUIConfigBrightness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigBrightness>();
	}
};
static_assert(alignof(UUIConfigBrightness) == 0x000008, "Wrong alignment on UUIConfigBrightness");
static_assert(sizeof(UUIConfigBrightness) == 0x000428, "Wrong size on UUIConfigBrightness");
static_assert(offsetof(UUIConfigBrightness, MinX) == 0x000388, "Member 'UUIConfigBrightness::MinX' has a wrong offset!");
static_assert(offsetof(UUIConfigBrightness, MaxX) == 0x00038C, "Member 'UUIConfigBrightness::MaxX' has a wrong offset!");

// Class BattlePrototype.BrainCrashSafePointConfigVolume
// 0x0008 (0x0270 - 0x0268)
class ABrainCrashSafePointConfigVolume final : public AVolume
{
public:
	bool                                          bDisableMakePoint;                                 // 0x0268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2D[0x7];                                     // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashSafePointConfigVolume">();
	}
	static class ABrainCrashSafePointConfigVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainCrashSafePointConfigVolume>();
	}
};
static_assert(alignof(ABrainCrashSafePointConfigVolume) == 0x000008, "Wrong alignment on ABrainCrashSafePointConfigVolume");
static_assert(sizeof(ABrainCrashSafePointConfigVolume) == 0x000270, "Wrong size on ABrainCrashSafePointConfigVolume");
static_assert(offsetof(ABrainCrashSafePointConfigVolume, bDisableMakePoint) == 0x000268, "Member 'ABrainCrashSafePointConfigVolume::bDisableMakePoint' has a wrong offset!");

// Class BattlePrototype.BrainCrashSettingVolume
// 0x0048 (0x02B0 - 0x0268)
class ABrainCrashSettingVolume final : public AVolume
{
public:
	uint8                                         Pad_1F2E[0x8];                                     // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TriggerTransform;                                  // 0x0270(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x02A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnbound;                                          // 0x02A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2F[0xA];                                     // 0x02A6(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FitGroundTriggerTransform();

	struct FTransform GetTriggerTransformWS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainCrashSettingVolume">();
	}
	static class ABrainCrashSettingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainCrashSettingVolume>();
	}
};
static_assert(alignof(ABrainCrashSettingVolume) == 0x000010, "Wrong alignment on ABrainCrashSettingVolume");
static_assert(sizeof(ABrainCrashSettingVolume) == 0x0002B0, "Wrong size on ABrainCrashSettingVolume");
static_assert(offsetof(ABrainCrashSettingVolume, TriggerTransform) == 0x000270, "Member 'ABrainCrashSettingVolume::TriggerTransform' has a wrong offset!");
static_assert(offsetof(ABrainCrashSettingVolume, Priority) == 0x0002A0, "Member 'ABrainCrashSettingVolume::Priority' has a wrong offset!");
static_assert(offsetof(ABrainCrashSettingVolume, bEnabled) == 0x0002A4, "Member 'ABrainCrashSettingVolume::bEnabled' has a wrong offset!");
static_assert(offsetof(ABrainCrashSettingVolume, bUnbound) == 0x0002A5, "Member 'ABrainCrashSettingVolume::bUnbound' has a wrong offset!");

// Class BattlePrototype.DropItemManager
// 0x00A0 (0x02D0 - 0x0230)
class ADropItemManager final : public AActor
{
public:
	uint8                                         Pad_1F30[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADropItem*>                      AllDataDropDatas_;                                 // 0x0238(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ADropItem*>                      AllCoreDropDatas_;                                 // 0x0248(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 DataDropActiveData_;                               // 0x0258(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 CoreDropActiveData_;                               // 0x0268(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F31[0x50];                                    // 0x0278(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsItemGetDebugOn;                                  // 0x02C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F32[0x7];                                     // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalledAtEndBrainField();
	void CalledAtStartBrainField();
	void ChangeActiveAllCoreDrops();
	void ChangeActiveAllDataDrops();
	void ChangeAllDropStateToDrop(float FirstDelay);
	void ControlDataDropActivateAtArea(const class FString& NextLevelName);
	void DoActiveCoreDrop(const struct FVector& Location, class FName ItemId, int32 ItemNum, bool bAutoTaken, class UParticleSystem* DropParticle, class UParticleSystem* AquParticle, class UParticleSystem* GetParticle);
	void DoActiveDataDrop(const struct FVector& Location, class FName ItemId, int32 ItemNum, bool bAutoTaken, class UParticleSystem* DropParticle, class UParticleSystem* AquParticle, class UParticleSystem* GetParticle, class FName CharID);
	void DoActiveStockDataDrop(const struct FVector& Location);
	void DoNotActiveCoreDrop(class ADropItem* ItemAdress);
	void DoNotActiveDataDrop(class ADropItem* ItemAdress);
	void RedropLandingItem(int32 ItemIndex);
	void RegistAllCoreDropDatas(class ADropItem* ItemAdress);
	void RegistAllDataDropDatas(class ADropItem* ItemAdress);
	void RegistStockDataItemData(const struct FDataItemSpawnState& Data);
	void SetActiveDropVisibility(bool Visibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropItemManager">();
	}
	static class ADropItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADropItemManager>();
	}
};
static_assert(alignof(ADropItemManager) == 0x000008, "Wrong alignment on ADropItemManager");
static_assert(sizeof(ADropItemManager) == 0x0002D0, "Wrong size on ADropItemManager");
static_assert(offsetof(ADropItemManager, AllDataDropDatas_) == 0x000238, "Member 'ADropItemManager::AllDataDropDatas_' has a wrong offset!");
static_assert(offsetof(ADropItemManager, AllCoreDropDatas_) == 0x000248, "Member 'ADropItemManager::AllCoreDropDatas_' has a wrong offset!");
static_assert(offsetof(ADropItemManager, DataDropActiveData_) == 0x000258, "Member 'ADropItemManager::DataDropActiveData_' has a wrong offset!");
static_assert(offsetof(ADropItemManager, CoreDropActiveData_) == 0x000268, "Member 'ADropItemManager::CoreDropActiveData_' has a wrong offset!");
static_assert(offsetof(ADropItemManager, IsItemGetDebugOn) == 0x0002C8, "Member 'ADropItemManager::IsItemGetDebugOn' has a wrong offset!");

// Class BattlePrototype.UIBrainMessage
// 0x0020 (0x03A8 - 0x0388)
class UUIBrainMessage : public UUIBase
{
public:
	bool                                          M_FlagReplyBondsEpisode;                           // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagReplyTest;                                   // 0x0389(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagReplyClose;                                  // 0x038A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagMouseInput;                                  // 0x038B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F35[0x1C];                                    // 0x038C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ClearCurrentNewFlagNative(int32 Param_Index, class UUserWidget* Widget);
	void ClearLockInput();
	void InitializeList(class UREDScrollBox* ScrollBox, class UREDScrollBox* ScrollboxMessage);
	bool InitListMessageNative(int32 Param_Index);
	bool IsUpdateBrainThreadMouseFocus(int32* CursorIndex);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void PlayMessageScrollSE();
	void ResetDefaultThread();
	void ResetReplyBondsEpisodeFlag();
	void SetDefaultThread(class FName ThreadID);
	void SetFlagEnableClose(bool IsPlay);
	void SetOldScrollOffset(float Offset);
	void StopMessageScrollSE();
	void UpdateBrainMessageMouseFocus();
	bool UpdateBrainMessageMouseSE();
	bool UpdateThreadTitleNative(int32 Param_Index);

	bool GetFlagEnableClose() const;
	bool IsLockInput() const;
	bool IsReplyBondsEpisode() const;
	bool IsReplyClose() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainMessage">();
	}
	static class UUIBrainMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainMessage>();
	}
};
static_assert(alignof(UUIBrainMessage) == 0x000008, "Wrong alignment on UUIBrainMessage");
static_assert(sizeof(UUIBrainMessage) == 0x0003A8, "Wrong size on UUIBrainMessage");
static_assert(offsetof(UUIBrainMessage, M_FlagReplyBondsEpisode) == 0x000388, "Member 'UUIBrainMessage::M_FlagReplyBondsEpisode' has a wrong offset!");
static_assert(offsetof(UUIBrainMessage, M_FlagReplyTest) == 0x000389, "Member 'UUIBrainMessage::M_FlagReplyTest' has a wrong offset!");
static_assert(offsetof(UUIBrainMessage, M_FlagReplyClose) == 0x00038A, "Member 'UUIBrainMessage::M_FlagReplyClose' has a wrong offset!");
static_assert(offsetof(UUIBrainMessage, M_FlagMouseInput) == 0x00038B, "Member 'UUIBrainMessage::M_FlagMouseInput' has a wrong offset!");

// Class BattlePrototype.BrainFieldEnemyLocation
// 0x0008 (0x0238 - 0x0230)
class ABrainFieldEnemyLocation final : public AActor
{
public:
	int32                                         LocationNo;                                        // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3B[0x4];                                     // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainFieldEnemyLocation">();
	}
	static class ABrainFieldEnemyLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainFieldEnemyLocation>();
	}
};
static_assert(alignof(ABrainFieldEnemyLocation) == 0x000008, "Wrong alignment on ABrainFieldEnemyLocation");
static_assert(sizeof(ABrainFieldEnemyLocation) == 0x000238, "Wrong size on ABrainFieldEnemyLocation");
static_assert(offsetof(ABrainFieldEnemyLocation, LocationNo) == 0x000230, "Member 'ABrainFieldEnemyLocation::LocationNo' has a wrong offset!");

// Class BattlePrototype.GameBaseLevelActor
// 0x0008 (0x0240 - 0x0238)
class AGameBaseLevelActor final : public ALevelScriptActor
{
public:
	uint8                                         Pad_1F3C[0x8];                                     // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBaseLevelActor">();
	}
	static class AGameBaseLevelActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameBaseLevelActor>();
	}
};
static_assert(alignof(AGameBaseLevelActor) == 0x000008, "Wrong alignment on AGameBaseLevelActor");
static_assert(sizeof(AGameBaseLevelActor) == 0x000240, "Wrong size on AGameBaseLevelActor");

// Class BattlePrototype.BrainFieldEnemyLocationWave
// 0x0008 (0x0238 - 0x0230)
class ABrainFieldEnemyLocationWave final : public AActor
{
public:
	int32                                         LocationNo;                                        // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LongAway;                                          // 0x0234(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3D[0x3];                                     // 0x0235(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainFieldEnemyLocationWave">();
	}
	static class ABrainFieldEnemyLocationWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainFieldEnemyLocationWave>();
	}
};
static_assert(alignof(ABrainFieldEnemyLocationWave) == 0x000008, "Wrong alignment on ABrainFieldEnemyLocationWave");
static_assert(sizeof(ABrainFieldEnemyLocationWave) == 0x000238, "Wrong size on ABrainFieldEnemyLocationWave");
static_assert(offsetof(ABrainFieldEnemyLocationWave, LocationNo) == 0x000230, "Member 'ABrainFieldEnemyLocationWave::LocationNo' has a wrong offset!");
static_assert(offsetof(ABrainFieldEnemyLocationWave, LongAway) == 0x000234, "Member 'ABrainFieldEnemyLocationWave::LongAway' has a wrong offset!");

// Class BattlePrototype.UIChromaticAberration
// 0x0028 (0x0050 - 0x0028)
class UUIChromaticAberration final : public UObject
{
public:
	class URetainerBox*                           RetainerBox;                                       // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               Material;                                          // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         Image;                                             // 0x0038(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EChromaticAberrationType                      Type;                                              // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F3E[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Setup(class URetainerBox* InRetainerBox, class UImage* ImageRed, class UImage* ImageGreen, class UImage* ImageBlue);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIChromaticAberration">();
	}
	static class UUIChromaticAberration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIChromaticAberration>();
	}
};
static_assert(alignof(UUIChromaticAberration) == 0x000008, "Wrong alignment on UUIChromaticAberration");
static_assert(sizeof(UUIChromaticAberration) == 0x000050, "Wrong size on UUIChromaticAberration");
static_assert(offsetof(UUIChromaticAberration, RetainerBox) == 0x000028, "Member 'UUIChromaticAberration::RetainerBox' has a wrong offset!");
static_assert(offsetof(UUIChromaticAberration, Material) == 0x000030, "Member 'UUIChromaticAberration::Material' has a wrong offset!");
static_assert(offsetof(UUIChromaticAberration, Image) == 0x000038, "Member 'UUIChromaticAberration::Image' has a wrong offset!");
static_assert(offsetof(UUIChromaticAberration, Type) == 0x000048, "Member 'UUIChromaticAberration::Type' has a wrong offset!");

// Class BattlePrototype.BrainFieldManager
// 0x0970 (0x0BA0 - 0x0230)
class ABrainFieldManager : public AActor
{
public:
	uint8                                         Pad_1F3F[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxTrainEnemy;                                     // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugCollisionMode;                                // 0x023C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F40[0x953];                                   // 0x023D(0x0953)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_EDBrainFieldBattleEndNativeEvent;                // 0x0B90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	void Broadcast_EDBrainFieldBattleEndNativeEvent(EBrainFieldEndType EndType);
	void CalcJumpBrainFieldTransformEnemy(TArray<struct FTransform>* OutTransforms, const TArray<class AActor*>& Enemies, const TArray<struct FTransform>& NormalFieldTransforms, const TArray<bool>& IsWaves, const struct FVector& NormalFieldPlayerLocation);
	void CalcJumpBrainFieldTransformEnemyCustomCollision(TArray<struct FTransform>* OutTransforms, const TArray<class AActor*>& Enemies, const TArray<struct FTransform>& NormalFieldTransforms, const struct FVector& CustomCollisionPlayerLocation, float BrainFieldPlayerHeight);
	void CalcJumpBrainFieldTransformEnemyCustomCollision2(TArray<struct FTransform>* OutTransforms, const TArray<class AActor*>& Enemies, const struct FBrainFieldSettingsLocation& LocationSetting, float BrainFieldPlayerHeight, bool UserPlayer, class AActor* UserActor);
	void DebugCheckEnemyWaveTransformNativeCollision(const struct FTransform& PlayerTransform, struct FTransform* EnemyTransform, bool* ValidIndex, bool* UseCollision, int32 Param_Index, bool LongAway);
	TArray<class AActor*> GetBrainFieldActors(class ULevelStreaming* Level);
	bool GetEnemyLocationWave(struct FTransform* EnemyTransform, int32 Param_Index, bool LongAway);
	bool GetEnemyLocationWaveFromNo(struct FTransform* EnemyTransform, int32 LocationNo);
	int32 GetEnemyLocationWaveNum(bool LongAway);
	bool GetLocationSettings(const TArray<class AActor*>& TrainEnemyList, struct FBrainFieldSettingsLocation* OutSettings);
	void GetNormalLevelActorListNative(const struct FBrainFieldNormalLevelActorListInput& Inputs, TArray<class AActor*>* NormalLevelActors, TArray<class AActor*>* Characters, TArray<class AActor*>* Weapons, TArray<class AActor*>* PsychicObjects, TArray<class AActor*>* PsychicGrabs, TArray<class AActor*>* EffectBackround, TArray<class AActor*>* EffectBackroundMother);
	bool GetUserIsPlayer();
	bool InBranField_FromNative();
	bool IsInvokeBrainField_FromNative();
	bool IsPerformanceSequencer_FromNative();
	void IsValidEventCommandTypeAtBrainField(EEventTriggerCheckType EventCommandType, bool CheckBrainTalkEvent, bool* IsValid);
	void SelectJumpBrainFieldTrainEnemy(TArray<class AActor*>* TrainList, TArray<class AActor*>* NoTrainList, const TArray<class AActor*>& TargetEnemyListBattleField, const TArray<class AActor*>& TargetEnemyListBattleFieldWave, const TArray<class AActor*>& TargetEnemyListNormal, const struct FVector& NormalFieldPlayerLocation);
	void SetupEnemyWaveTransformNative(const TArray<class ARSCharacterBase*>& Enemies, const TArray<struct FBrainFieldWaveEnemyFlag>& EnemyFlags, const struct FTransform& PlayerTransform);
	void VisibleNormalActorsNative(bool IsVisible, int32 ObjectNum, int32& VisibleSplitIndex, const TArray<class AActor*>& ActorList, TArray<struct FBrainFieldRestoreFlag>& SettingFlags);

	bool GetEnemyLocation(struct FTransform* EnemyTransform, int32 Param_Index) const;
	int32 GetEnemyLocationNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainFieldManager">();
	}
	static class ABrainFieldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainFieldManager>();
	}
};
static_assert(alignof(ABrainFieldManager) == 0x000008, "Wrong alignment on ABrainFieldManager");
static_assert(sizeof(ABrainFieldManager) == 0x000BA0, "Wrong size on ABrainFieldManager");
static_assert(offsetof(ABrainFieldManager, MaxTrainEnemy) == 0x000238, "Member 'ABrainFieldManager::MaxTrainEnemy' has a wrong offset!");
static_assert(offsetof(ABrainFieldManager, DebugCollisionMode) == 0x00023C, "Member 'ABrainFieldManager::DebugCollisionMode' has a wrong offset!");
static_assert(offsetof(ABrainFieldManager, M_EDBrainFieldBattleEndNativeEvent) == 0x000B90, "Member 'ABrainFieldManager::M_EDBrainFieldBattleEndNativeEvent' has a wrong offset!");

// Class BattlePrototype.BrainFieldSettingsActor
// 0x0230 (0x0460 - 0x0230)
class ABrainFieldSettingsActor final : public AActor
{
public:
	struct FBrainFieldSettings                    Settings;                                          // 0x0230(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUseCollisionLocationOrigin;                       // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultPlayerStartLeftRight;                   // 0x0259(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4D[0x6];                                     // 0x025A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerStartMain;                                   // 0x0260(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerStartLeft;                                   // 0x0290(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerStartRight;                                  // 0x02C0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnemyRelativeJump;                                // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4E[0xF];                                     // 0x02F1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EnemyStart01;                                      // 0x0300(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EnemyStart02;                                      // 0x0330(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EnemyStart03;                                      // 0x0360(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EnemyStart04;                                      // 0x0390(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseRestoreTransform;                              // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4F[0xF];                                     // 0x03C1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerRestoreMain;                                 // 0x03D0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerRestoreLeft;                                 // 0x0400(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PlayerRestoreRight;                                // 0x0430(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainFieldSettingsActor">();
	}
	static class ABrainFieldSettingsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainFieldSettingsActor>();
	}
};
static_assert(alignof(ABrainFieldSettingsActor) == 0x000010, "Wrong alignment on ABrainFieldSettingsActor");
static_assert(sizeof(ABrainFieldSettingsActor) == 0x000460, "Wrong size on ABrainFieldSettingsActor");
static_assert(offsetof(ABrainFieldSettingsActor, Settings) == 0x000230, "Member 'ABrainFieldSettingsActor::Settings' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, bUseCollisionLocationOrigin) == 0x000258, "Member 'ABrainFieldSettingsActor::bUseCollisionLocationOrigin' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, bUseDefaultPlayerStartLeftRight) == 0x000259, "Member 'ABrainFieldSettingsActor::bUseDefaultPlayerStartLeftRight' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerStartMain) == 0x000260, "Member 'ABrainFieldSettingsActor::PlayerStartMain' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerStartLeft) == 0x000290, "Member 'ABrainFieldSettingsActor::PlayerStartLeft' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerStartRight) == 0x0002C0, "Member 'ABrainFieldSettingsActor::PlayerStartRight' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, bEnemyRelativeJump) == 0x0002F0, "Member 'ABrainFieldSettingsActor::bEnemyRelativeJump' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, EnemyStart01) == 0x000300, "Member 'ABrainFieldSettingsActor::EnemyStart01' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, EnemyStart02) == 0x000330, "Member 'ABrainFieldSettingsActor::EnemyStart02' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, EnemyStart03) == 0x000360, "Member 'ABrainFieldSettingsActor::EnemyStart03' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, EnemyStart04) == 0x000390, "Member 'ABrainFieldSettingsActor::EnemyStart04' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, bUseRestoreTransform) == 0x0003C0, "Member 'ABrainFieldSettingsActor::bUseRestoreTransform' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerRestoreMain) == 0x0003D0, "Member 'ABrainFieldSettingsActor::PlayerRestoreMain' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerRestoreLeft) == 0x000400, "Member 'ABrainFieldSettingsActor::PlayerRestoreLeft' has a wrong offset!");
static_assert(offsetof(ABrainFieldSettingsActor, PlayerRestoreRight) == 0x000430, "Member 'ABrainFieldSettingsActor::PlayerRestoreRight' has a wrong offset!");

// Class BattlePrototype.DebuggingItemWidgetBase
// 0x0008 (0x0238 - 0x0230)
class UDebuggingItemWidgetBase final : public UUserWidget
{
public:
	class ADebuggingItemBase*                     Item;                                              // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemWidgetBase">();
	}
	static class UDebuggingItemWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebuggingItemWidgetBase>();
	}
};
static_assert(alignof(UDebuggingItemWidgetBase) == 0x000008, "Wrong alignment on UDebuggingItemWidgetBase");
static_assert(sizeof(UDebuggingItemWidgetBase) == 0x000238, "Wrong size on UDebuggingItemWidgetBase");
static_assert(offsetof(UDebuggingItemWidgetBase, Item) == 0x000230, "Member 'UDebuggingItemWidgetBase::Item' has a wrong offset!");

// Class BattlePrototype.UIConfigSelect5
// 0x01E8 (0x05E8 - 0x0400)
class UUIConfigSelect5 : public UUIConfigSelectBase
{
public:
	uint8                                         Pad_1F50[0x1E8];                                   // 0x0400(0x01E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelect5">();
	}
	static class UUIConfigSelect5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelect5>();
	}
};
static_assert(alignof(UUIConfigSelect5) == 0x000008, "Wrong alignment on UUIConfigSelect5");
static_assert(sizeof(UUIConfigSelect5) == 0x0005E8, "Wrong size on UUIConfigSelect5");

// Class BattlePrototype.BrainMessageData
// 0x0010 (0x0038 - 0x0028)
class UBrainMessageData final : public UObject
{
public:
	class UBrainMessageDBAsset*                   brainMessageDataAsset_;                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             birthdayData_;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetAllBirthdayRowNames(TArray<class FName>* RowNames);
	int32 GetAllThreadNum();
	bool GetBirthdayDataCell(const class FName RowName, struct FBirthdayBrainMessageData* Cell);
	class UBrainMessageDBAsset* GetBrainMessageDataAsset();
	struct FBrainMessageDBDataCell GetBrainMessageDataCellFromAsset(class FName RowName, bool* IsFound);
	bool LoadDataAsset(const class FString& DtPath, const class FString& birthdayPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainMessageData">();
	}
	static class UBrainMessageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainMessageData>();
	}
};
static_assert(alignof(UBrainMessageData) == 0x000008, "Wrong alignment on UBrainMessageData");
static_assert(sizeof(UBrainMessageData) == 0x000038, "Wrong size on UBrainMessageData");
static_assert(offsetof(UBrainMessageData, brainMessageDataAsset_) == 0x000028, "Member 'UBrainMessageData::brainMessageDataAsset_' has a wrong offset!");
static_assert(offsetof(UBrainMessageData, birthdayData_) == 0x000030, "Member 'UBrainMessageData::birthdayData_' has a wrong offset!");

// Class BattlePrototype.DamageAcceptInterface
// 0x0000 (0x0028 - 0x0028)
class IDamageAcceptInterface final : public IInterface
{
public:
	bool IsStartDamageAnimAdditional(const struct FHCHitResult& HitResult, int32 Damage, bool IsDown);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAcceptInterface">();
	}
	static class IDamageAcceptInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageAcceptInterface>();
	}
};
static_assert(alignof(IDamageAcceptInterface) == 0x000008, "Wrong alignment on IDamageAcceptInterface");
static_assert(sizeof(IDamageAcceptInterface) == 0x000028, "Wrong size on IDamageAcceptInterface");

// Class BattlePrototype.BrainMessageDBAsset
// 0x0050 (0x0078 - 0x0028)
class UBrainMessageDBAsset final : public UObject
{
public:
	TMap<class FName, struct FBrainMessageDBDataCell> brainMessageDBMap_;                                // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();
	void ConvertArray(struct FBrainMessageContentData* bMesData, const struct FBrainMessageRowDataCell& RowCell);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainMessageDBAsset">();
	}
	static class UBrainMessageDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainMessageDBAsset>();
	}
};
static_assert(alignof(UBrainMessageDBAsset) == 0x000008, "Wrong alignment on UBrainMessageDBAsset");
static_assert(sizeof(UBrainMessageDBAsset) == 0x000078, "Wrong size on UBrainMessageDBAsset");
static_assert(offsetof(UBrainMessageDBAsset, brainMessageDBMap_) == 0x000028, "Member 'UBrainMessageDBAsset::brainMessageDBMap_' has a wrong offset!");

// Class BattlePrototype.UIConfigKeyboardMouseListIndex
// 0x00E0 (0x0468 - 0x0388)
class UUIConfigKeyboardMouseListIndex : public UUIBase
{
public:
	uint8                                         Pad_1F56[0xE0];                                    // 0x0388(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeMouseHit(class UREDOverlay* Pg_set_2, class UREDOverlay* Pg_set_3);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect_L, class UWidgetAnimation* AnimSelect_L_in, class UWidgetAnimation* AnimSelect_L_out, class UWidgetAnimation* AnimDecision_L, class UWidgetAnimation* AnimSelect_L2, class UWidgetAnimation* AnimCancel_L2, class UWidgetAnimation* AnimSelect_R, class UWidgetAnimation* AnimSelect_R_in, class UWidgetAnimation* AnimSelect_R_out, class UWidgetAnimation* AnimDecision_R, class UWidgetAnimation* AnimSelect_R2, class UWidgetAnimation* AnimCancel_R2, class UWidgetAnimation* AnimChange_L_R, class UWidgetAnimation* AnimChange_R_L, class UTextBlock* TextTitle);
	void InitializeThisFixed(class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimSelect2, class UWidgetAnimation* AnimSelect2_in, class UWidgetAnimation* AnimSelect2_out, class UTextBlock* TextTitle2, class UOverlay* OverlayFrameSet1, class UOverlay* OverlayFrameSet2, class USpacer* SpacerSet2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigKeyboardMouseListIndex">();
	}
	static class UUIConfigKeyboardMouseListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigKeyboardMouseListIndex>();
	}
};
static_assert(alignof(UUIConfigKeyboardMouseListIndex) == 0x000008, "Wrong alignment on UUIConfigKeyboardMouseListIndex");
static_assert(sizeof(UUIConfigKeyboardMouseListIndex) == 0x000468, "Wrong size on UUIConfigKeyboardMouseListIndex");

// Class BattlePrototype.BrainMessageParamManager
// 0x0128 (0x0150 - 0x0028)
class UBrainMessageParamManager final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnChangeNoticeUiStateDelegate;                     // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URSGameInstance*                        GameInst_;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrainMessageData*                      brainMessageData_;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelManager*                          LevelManager_;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FThreadData>                    ThreadDatas_;                                      // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F57[0xE8];                                    // 0x0060(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDebugReplyTime_DEBUG;                          // 0x0148(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F58[0x3];                                     // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugReplyTime_DEBUG;                              // 0x014C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddMessageIgnorConditions(const int32 TargetThread, const int32 MessageNum);
	void AllOpenMessageIgnorConditionsAndLock(const int32 TargetThread);
	bool CheckAppropriateThreadFromTitleID(class FName TitleID, EPlayerID MainPlayerID);
	void CheckMessageConditions(int32 ThreadNum, int32 MessageNum, bool IsReply, const bool IsNoticeEnable);
	void DoChangeMainPlayer();
	void FinishWork(class URSGameInstance* GameInst);
	int32 GetAlreadyEmergenceNum(int32 ThreadNum);
	int32 GetAlreadyLookNum(int32 ThreadNum);
	const TArray<int32> GetEmergenceMessageNum(int32 ThreadNum);
	bool GetIsOpenThread(int32 ThreadNum);
	int32 GetNextMessageNum(int32 ThreadNum);
	void GetSortedIndexArray(EBrainMesSortType SortType, TArray<int32>* SortedIndexArray);
	void GetSortedIndexArrayForSortID(TArray<int32>* ResultArray);
	struct FBirthdayBrainMessageData GetThreadNameFromBirthdayID(class FName ThreadID);
	int32 GetThreadNumFromThreadID(class FName ThreadID);
	bool GetTiedBondsEPID(int32 ThreadNum, int32 MessageNum, class FString* bondsBPReference);
	void InitAtExNewGame(EPlayerID MainPlayerID);
	void InitBirthdayData();
	void InitData(class URSGameInstance* GameInst);
	bool IsActiveThreadTimer(int32 ThreadNum);
	bool IsBanToReply(int32 ThreadNum, int32 MessageNum);
	bool IsReadyToReply(int32 ThreadNum, int32 MessageNum, bool IgnoreCommonTimming);
	void ResumeThreadTimer();
	void SetAlreadyEmergenceNum(int32 ThreadNum, int32 LookNum);
	void SetAlreadyLookNum(int32 ThreadNum, int32 LookNum);
	void SetIsOpenThred(int32 ThreadNum, bool IsOpen);
	void SetStopUpdatingMessageFlag(bool bStop);
	TArray<class FName> StartAndGetBirthdayThreadID(int32 Year, int32 Month, int32 Day);
	void StopThreadTimer();
	void UpdateMessageIndication(int32 ThreadNum, int32 MessageNum, bool IsReply, const bool IsNoticeEnable);
	void UpdateMessageIndication_Bind();
	void UpdateMessageIndication_BindInner(int32 ThreadNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainMessageParamManager">();
	}
	static class UBrainMessageParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainMessageParamManager>();
	}
};
static_assert(alignof(UBrainMessageParamManager) == 0x000008, "Wrong alignment on UBrainMessageParamManager");
static_assert(sizeof(UBrainMessageParamManager) == 0x000150, "Wrong size on UBrainMessageParamManager");
static_assert(offsetof(UBrainMessageParamManager, OnChangeNoticeUiStateDelegate) == 0x000028, "Member 'UBrainMessageParamManager::OnChangeNoticeUiStateDelegate' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, GameInst_) == 0x000038, "Member 'UBrainMessageParamManager::GameInst_' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, brainMessageData_) == 0x000040, "Member 'UBrainMessageParamManager::brainMessageData_' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, LevelManager_) == 0x000048, "Member 'UBrainMessageParamManager::LevelManager_' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, ThreadDatas_) == 0x000050, "Member 'UBrainMessageParamManager::ThreadDatas_' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, bUseDebugReplyTime_DEBUG) == 0x000148, "Member 'UBrainMessageParamManager::bUseDebugReplyTime_DEBUG' has a wrong offset!");
static_assert(offsetof(UBrainMessageParamManager, DebugReplyTime_DEBUG) == 0x00014C, "Member 'UBrainMessageParamManager::DebugReplyTime_DEBUG' has a wrong offset!");

// Class BattlePrototype.BrainTalkBattleManager
// 0x0C68 (0x0C90 - 0x0028)
class UBrainTalkBattleManager final : public UObject
{
public:
	class URSGameInstance*                        _gameInstance;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSystemBrainTalkManageStructParam> M_BrainTalkSystemConditionManageList;              // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSystemBrainTalkManageStructParam> M_BrainTalkEnemyConditionManageList;               // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSystemBrainTalkManageStructParam> M_BrainTalkTutorialConditionManageList;            // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSystemBrainTalkManageStructParam> M_BrainTalkGimmickConditionManageList;             // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkOnceCheck_Category           M_BrainTalkOnceCheck;                              // 0x0070(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_WataruHarukaExistenceProgressID> M_BrainTalkBt_WataruHarukaNoExistenceProgressIDList; // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_InvalidProgressID> M_BrainTalkBt_InvalidProgressIDList;               // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkCh_InvalidProgressID> M_BrainTalkCh_InvalidProgressIDList;               // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EBrainTalkChGroup>                     M_BrainTalkCharacterGroup;                         // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_Hp30p>             M_BrainTalkBt_Hp30pList;                           // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_Hp30pList_Param;                     // 0x00D0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillByEn>          M_BrainTalkBt_KillByEnList;                        // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillByEnList_Param;                  // 0x00F0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BrainCrashByEn>    M_BrainTalkBt_BrainCrashByEnList;                  // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BrainCrashByEnList_Param;            // 0x0110(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BadStateByEn>      M_BrainTalkBt_BadStateByEnList;                    // 0x0120(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BadStateByEnList_Param;              // 0x0130(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BadStateForEn>     M_BrainTalkBt_BadStateForEnList;                   // 0x0140(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BadStateForEnList_Param;             // 0x0150(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_Recovery>          M_BrainTalkBt_RecoveryList;                        // 0x0160(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RecoveryList_Param;                  // 0x0170(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_Revival>           M_BrainTalkBt_RevivalList;                         // 0x0180(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RevivalList_Param;                   // 0x0190(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BFActivate>        M_BrainTalkBt_BFActivateList;                      // 0x01A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BFActivateList_Param;                // 0x01B0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasCombo>          M_BrainTalkBt_SasComboList;                        // 0x01C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasComboList_Param;                  // 0x01D0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_PsychicCombo>      M_BrainTalkBt_PsychicComboList;                    // 0x01E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_PsychicComboList_Param;              // 0x01F0(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DriveActive>       M_BrainTalkBt_DriveActiveList;                     // 0x0200(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DriveActiveList_Param;               // 0x0210(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_HiKizunaEffect>    M_BrainTalkBt_HiKizunaEffectList;                  // 0x0220(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_HiKizunaEffectList_Param;            // 0x0230(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_TouchBFWall>       M_BrainTalkBt_TouchBFWallList;                     // 0x0240(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_TouchBFWallList_Param;               // 0x0250(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_NearCC>            M_BrainTalkBt_NearCCList;                          // 0x0260(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_NearCCList_Param;                    // 0x0270(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BattleEscape>      M_BrainTalkBt_BattleEscapeList;                    // 0x0280(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BattleEscapeList_Param;              // 0x0290(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KizunaLvUp>        M_BrainTalkBt_KizunaLvUpList;                      // 0x02A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KizunaLvUpList_Param;                // 0x02B0(0x0010)(NativeAccessSpecifierPrivate)
	EBrainTalkKizunaLvUpFlow                      M_KizunaLvUpFlow;                                  // 0x02C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F65[0x3];                                     // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_KizunaLvUpReplayTime;                            // 0x02C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EPlayerID>                             M_KizunaLvUpReplayPlayerList;                      // 0x02C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DamageTakeOver>    M_BrainTalkBt_DamageTakeOverList;                  // 0x02D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DamageTakeOverList_Param;            // 0x02E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_LvUp>              M_BrainTalkBt_LvUpList;                            // 0x02F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_LvUpList_Param;                      // 0x0308(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DeadInarow>        M_BrainTalkBt_DeadInarowList;                      // 0x0318(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DeadInarowList_Param;                // 0x0328(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SallyTimes>        M_BrainTalkBt_SallyTimesList;                      // 0x0338(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SallyTimesList_Param;                // 0x0348(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_NoSallyTimes>      M_BrainTalkBt_NoSallyTimesList;                    // 0x0358(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_NoSallyTimesList_Param;              // 0x0368(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_JumpOff>           M_BrainTalkBt_JumpOffList;                         // 0x0378(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_JumpOffList_Param;                   // 0x0388(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_PLChangeAttachment> M_BrainTalkBt_PLChangeAttachmentList;              // 0x0398(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_PLChangeAttachmentList_Param;        // 0x03A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_PLDead>            M_BrainTalkBt_PLDeadList;                          // 0x03B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_PLDeadList_Param;                    // 0x03C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillEnRest>        M_BrainTalkBt_KillEnRestList;                      // 0x03D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillEnRestList_Param;                // 0x03E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnForPT>    M_BrainTalkBt_KillAllEnForPTList;                  // 0x03F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnForPTList_Param;            // 0x0408(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnForPL>    M_BrainTalkBt_KillAllEnForPLList;                  // 0x0418(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnForPLList_Param;            // 0x0428(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnShortTime> M_BrainTalkBt_KillAllEnShortTimeList;              // 0x0438(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnShortTimeList_Param;        // 0x0448(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnStrEn>    M_BrainTalkBt_KillAllEnStrEnList;                  // 0x0458(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnStrEnList_Param;            // 0x0468(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnManyEn>   M_BrainTalkBt_KillAllEnManyEnList;                 // 0x0478(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnManyEnList_Param;           // 0x0488(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillAllEnManyWeakEn> M_BrainTalkBt_KillAllEnManyWeakEnList;             // 0x0498(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillAllEnManyWeakEnList_Param;       // 0x04A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillEnStrategy>    M_BrainTalkBt_KillEnStrategyList;                  // 0x04B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillEnStrategyList_Param;            // 0x04C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscStrEn>         M_BrainTalkBt_DiscStrEnList;                       // 0x04D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscStrEnList_Param;                 // 0x04E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DestroyShell>      M_BrainTalkBt_DestroyShellList;                    // 0x04F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DestroyShellList_Param;              // 0x0508(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EnemyDown>         M_BrainTalkBt_EnemyDownList;                       // 0x0518(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EnemyDownList_Param;                 // 0x0528(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscEn>            M_BrainTalkBt_DiscEnList;                          // 0x0538(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscEnList_Param;                    // 0x0548(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DispCrashTrg>      M_BrainTalkBt_DispCrashTrgList;                    // 0x0558(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DispCrashTrgList_Param;              // 0x0568(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillEnemyBC>       M_BrainTalkBt_KillEnemyBCList;                     // 0x0578(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillEnemyBCList_Param;               // 0x0588(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EnBerserkSign>     M_BrainTalkBt_EnBerserkSignList;                   // 0x0598(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EnBerserkSignList_Param;             // 0x05A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EnBerserk>         M_BrainTalkBt_EnBerserkList;                       // 0x05B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EnBerserkList_Param;                 // 0x05C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_AttackEnShell>     M_BrainTalkBt_AttackEnShellList;                   // 0x05D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_AttackEnShellList_Param;             // 0x05E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_AttackEnWeak>      M_BrainTalkBt_AttackEnWeakList;                    // 0x05F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_AttackEnWeakList_Param;              // 0x0608(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_FirstStrike>       M_BrainTalkBt_FirstStrikeList;                     // 0x0618(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_FirstStrikeList_Param;               // 0x0628(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_OilEnAtkFire>      M_BrainTalkBt_OilEnAtkFireList;                    // 0x0638(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_OilEnAtkFireList_Param;              // 0x0648(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_WaterEnAtkElectric> M_BrainTalkBt_WaterEnAtkElectricList;              // 0x0658(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_WaterEnAtkElectricList_Param;        // 0x0668(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscStealth>       M_BrainTalkBt_DiscStealthList;                     // 0x0678(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscStealthList_Param;               // 0x0688(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscSasValidEn>    M_BrainTalkBt_DiscSasValidEnList;                  // 0x0698(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscSasValidEnList_Param;            // 0x06A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_StealthLosePL>     M_BrainTalkBt_StealthLosePLList;                   // 0x06B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_StealthLosePLList_Param;             // 0x06C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasNoUse>          M_BrainTalkBt_SasNoUseList;                        // 0x06D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasNoUseList_Param;                  // 0x06E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasContinuity>     M_BrainTalkBt_SasContinuityList;                   // 0x06F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasContinuityList_Param;             // 0x0708(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasHoloPossible>   M_BrainTalkBt_SasHoloPossibleList;                 // 0x0718(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasHoloPossibleList_Param;           // 0x0728(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_SasHoloPursuit>    M_BrainTalkBt_SasHoloPursuitList;                  // 0x0738(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_SasHoloPursuitList_Param;            // 0x0748(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GetItem>           M_BrainTalkBt_GetItemList;                         // 0x0758(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_GetItemList_Param;                   // 0x0768(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EnemyDrop>         M_BrainTalkBt_EnemyDropList;                       // 0x0778(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EnemyDropList_Param;                 // 0x0788(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_UnopenedTreasure>  M_BrainTalkBt_UnopenedTreasureList;                // 0x0798(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_UnopenedTreasureList_Param;          // 0x07A8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GatherPoint>       M_BrainTalkBt_GatherPointList;                     // 0x07B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_GatherPointList_Param;               // 0x07C8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_RecoveryItemZero>  M_BrainTalkBt_RecoveryItemZeroList;                // 0x07D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RecoveryItemZeroList_Param;          // 0x07E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DiscQuestEnemy>    M_BrainTalkBt_DiscQuestEnemyList;                  // 0x07F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DiscQuestEnemyList_Param;            // 0x0808(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_ClearQuest>        M_BrainTalkBt_ClearQuestList;                      // 0x0818(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_ClearQuestList_Param;                // 0x0828(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BirthKizunaEp>     M_BrainTalkBt_BirthKizunaEpList;                   // 0x0838(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EPlayerID>                             M_BrainTalkBt_BirthKizunaEp_FadePlayList;          // 0x0848(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BirthKizunaEpList_Param;             // 0x0858(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_KillQuestTgtEn>    M_BrainTalkBt_KillQuestTgtEnList;                  // 0x0868(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_KillQuestTgtEnList_Param;            // 0x0878(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GetQuestTgtItem>   M_BrainTalkBt_GetQuestTgtItemList;                 // 0x0888(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_GetQuestTgtItemList_Param;           // 0x0898(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_PTChangeAttachment> M_BrainTalkBt_PTChangeAttachmentList;              // 0x08A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_PTChangeAttachmentList_Param;        // 0x08B8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DriveGaugeMax>     M_BrainTalkBt_DriveGaugeMaxList;                   // 0x08C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DriveGaugeMaxList_Param;             // 0x08D8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EquipStrongestWeapon> M_BrainTalkBt_EquipStrongestWeaponList;            // 0x08E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EquipStrongestWeaponList_Param;      // 0x08F8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_WaitingVoice>      M_BrainTalkBt_WaitingVoiceList;                    // 0x0908(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_WaitingVoiceList_Param;              // 0x0918(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_RecoveryHpToPL>    M_BrainTalkBt_RecoveryHpToPLList;                  // 0x0928(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RecoveryHpToPLList_Param;            // 0x0938(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_RecoveryAbToPL>    M_BrainTalkBt_RecoveryAbToPLList;                  // 0x0948(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_RecoveryAbToPLList_Param;            // 0x0958(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_OsoroiAttachment>  M_BrainTalkBt_OsoroiAttachmentList;                // 0x0968(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_OsoroiAttachmentList_Param;          // 0x0978(0x0010)(NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      M_BrainTalkBt_OsoroiAttachment_BeforePlayTimeList; // 0x0988(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_LvUp_PL>           M_BrainTalkBt_LvUp_PLList;                         // 0x09D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_LvUp_PLList_Param;                   // 0x09E8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_QuestNpcNearbyCanBeOrdered> M_BrainTalkBt_QuestNpcNearbyCanBeOrderedList;      // 0x09F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_QuestNpcNearbyCanBeOrderedList_Param; // 0x0A08(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_DriveActiveFriend> M_BrainTalkBt_DriveActiveFriendList;               // 0x0A18(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_DriveActiveFriendList_Param;         // 0x0A28(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_EnableSAS_DriveActivationFriend> M_BrainTalkBt_EnableSAS_DriveActivationFriendList; // 0x0A38(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_EnableSAS_DriveActivationFriendList_Param; // 0x0A48(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F66[0x18];                                    // 0x0A58(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrainTalkBt_BattleSim_BattleStart> M_BrainTalkBt_BattleSim_BattleStartList;           // 0x0A70(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BattleSim_BattleStartList_Param;     // 0x0A80(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BattleSim_BattleStart_ENPC> M_BrainTalkBt_BattleSim_BattleStart_ENPCList;      // 0x0A90(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BattleSim_BattleStart_ENPCList_Param; // 0x0AA0(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F67[0x18];                                    // 0x0AB0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrainTalkBt_ReturnToTheAjito>  M_BrainTalkBt_ReturnToTheAjitoList;                // 0x0AC8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_ReturnToTheAjitoList_Param;          // 0x0AD8(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F68[0xA0];                                    // 0x0AE8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrainTalkBt_GiveItemsFromFriendsWithAjito> M_BrainTalkBt_GiveItemsFromFriendsWithAjitoList;   // 0x0B88(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_GiveItemsFromFriendsWithAjitoList_Param; // 0x0B98(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GiveItemsFromFriendsWithAjito_GroupLotteryTable> M_BrainTalkBt_GiveItemsFromFriendsWithAjito_GroupLotteryTableList; // 0x0BA8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GiveItemsFromFriendsWithAjito_ItemLotteryTable> M_BrainTalkBt_GiveItemsFromFriendsWithAjito_ItemLotteryTableList; // 0x0BB8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GiveItemsFromFriendsWithField> M_BrainTalkBt_GiveItemsFromFriendsWithFieldList;   // 0x0BC8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_GiveItemsFromFriendsWithFieldList_Param; // 0x0BD8(0x0010)(NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_GiveItemsFromFriendsWithField_ItemLotteryTable> M_BrainTalkBt_GiveItemsFromFriendsWithField_ItemLotteryTableList; // 0x0BE8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 M_BrainTalkBt_GiveItemsFromFriendsWithField_CharacterEaseOfSelectionValue; // 0x0BF8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkBt_BattleSim_BattleStart_RevivalBoss> M_BrainTalkBt_BattleSim_BattleStart_RevivalBossList; // 0x0C08(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrainTalkBattle_ConditionsParam       M_BrainTalkBt_BattleSim_BattleStart_RevivalBossList_Param; // 0x0C18(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F69[0x18];                                    // 0x0C28(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrainTalkEm_ConditionParam>    M_BrainTalkEm_ConditionParamList;                  // 0x0C40(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkTutorial_ConditionParam> M_BrainTalkTutorial_ConditionParamList;            // 0x0C50(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkGimmick_ConditionParam> M_BrainTalkGimmick_ConditionParamList;             // 0x0C60(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F6A[0x20];                                    // 0x0C70(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainTalkBattleManager">();
	}
	static class UBrainTalkBattleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrainTalkBattleManager>();
	}
};
static_assert(alignof(UBrainTalkBattleManager) == 0x000008, "Wrong alignment on UBrainTalkBattleManager");
static_assert(sizeof(UBrainTalkBattleManager) == 0x000C90, "Wrong size on UBrainTalkBattleManager");
static_assert(offsetof(UBrainTalkBattleManager, _gameInstance) == 0x000028, "Member 'UBrainTalkBattleManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkSystemConditionManageList) == 0x000030, "Member 'UBrainTalkBattleManager::M_BrainTalkSystemConditionManageList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkEnemyConditionManageList) == 0x000040, "Member 'UBrainTalkBattleManager::M_BrainTalkEnemyConditionManageList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkTutorialConditionManageList) == 0x000050, "Member 'UBrainTalkBattleManager::M_BrainTalkTutorialConditionManageList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkGimmickConditionManageList) == 0x000060, "Member 'UBrainTalkBattleManager::M_BrainTalkGimmickConditionManageList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkOnceCheck) == 0x000070, "Member 'UBrainTalkBattleManager::M_BrainTalkOnceCheck' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WataruHarukaNoExistenceProgressIDList) == 0x000080, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WataruHarukaNoExistenceProgressIDList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_InvalidProgressIDList) == 0x000090, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_InvalidProgressIDList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkCh_InvalidProgressIDList) == 0x0000A0, "Member 'UBrainTalkBattleManager::M_BrainTalkCh_InvalidProgressIDList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkCharacterGroup) == 0x0000B0, "Member 'UBrainTalkBattleManager::M_BrainTalkCharacterGroup' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_Hp30pList) == 0x0000C0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_Hp30pList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_Hp30pList_Param) == 0x0000D0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_Hp30pList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillByEnList) == 0x0000E0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillByEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillByEnList_Param) == 0x0000F0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillByEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BrainCrashByEnList) == 0x000100, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BrainCrashByEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BrainCrashByEnList_Param) == 0x000110, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BrainCrashByEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BadStateByEnList) == 0x000120, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BadStateByEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BadStateByEnList_Param) == 0x000130, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BadStateByEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BadStateForEnList) == 0x000140, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BadStateForEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BadStateForEnList_Param) == 0x000150, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BadStateForEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryList) == 0x000160, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryList_Param) == 0x000170, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RevivalList) == 0x000180, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RevivalList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RevivalList_Param) == 0x000190, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RevivalList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BFActivateList) == 0x0001A0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BFActivateList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BFActivateList_Param) == 0x0001B0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BFActivateList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasComboList) == 0x0001C0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasComboList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasComboList_Param) == 0x0001D0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasComboList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PsychicComboList) == 0x0001E0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PsychicComboList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PsychicComboList_Param) == 0x0001F0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PsychicComboList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveActiveList) == 0x000200, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveActiveList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveActiveList_Param) == 0x000210, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveActiveList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_HiKizunaEffectList) == 0x000220, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_HiKizunaEffectList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_HiKizunaEffectList_Param) == 0x000230, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_HiKizunaEffectList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_TouchBFWallList) == 0x000240, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_TouchBFWallList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_TouchBFWallList_Param) == 0x000250, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_TouchBFWallList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_NearCCList) == 0x000260, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_NearCCList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_NearCCList_Param) == 0x000270, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_NearCCList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleEscapeList) == 0x000280, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleEscapeList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleEscapeList_Param) == 0x000290, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleEscapeList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KizunaLvUpList) == 0x0002A0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KizunaLvUpList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KizunaLvUpList_Param) == 0x0002B0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KizunaLvUpList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_KizunaLvUpFlow) == 0x0002C0, "Member 'UBrainTalkBattleManager::M_KizunaLvUpFlow' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_KizunaLvUpReplayTime) == 0x0002C4, "Member 'UBrainTalkBattleManager::M_KizunaLvUpReplayTime' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_KizunaLvUpReplayPlayerList) == 0x0002C8, "Member 'UBrainTalkBattleManager::M_KizunaLvUpReplayPlayerList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DamageTakeOverList) == 0x0002D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DamageTakeOverList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DamageTakeOverList_Param) == 0x0002E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DamageTakeOverList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_LvUpList) == 0x0002F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_LvUpList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_LvUpList_Param) == 0x000308, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_LvUpList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DeadInarowList) == 0x000318, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DeadInarowList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DeadInarowList_Param) == 0x000328, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DeadInarowList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SallyTimesList) == 0x000338, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SallyTimesList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SallyTimesList_Param) == 0x000348, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SallyTimesList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_NoSallyTimesList) == 0x000358, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_NoSallyTimesList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_NoSallyTimesList_Param) == 0x000368, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_NoSallyTimesList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_JumpOffList) == 0x000378, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_JumpOffList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_JumpOffList_Param) == 0x000388, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_JumpOffList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PLChangeAttachmentList) == 0x000398, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PLChangeAttachmentList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PLChangeAttachmentList_Param) == 0x0003A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PLChangeAttachmentList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PLDeadList) == 0x0003B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PLDeadList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PLDeadList_Param) == 0x0003C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PLDeadList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnRestList) == 0x0003D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnRestList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnRestList_Param) == 0x0003E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnRestList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnForPTList) == 0x0003F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnForPTList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnForPTList_Param) == 0x000408, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnForPTList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnForPLList) == 0x000418, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnForPLList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnForPLList_Param) == 0x000428, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnForPLList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnShortTimeList) == 0x000438, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnShortTimeList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnShortTimeList_Param) == 0x000448, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnShortTimeList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnStrEnList) == 0x000458, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnStrEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnStrEnList_Param) == 0x000468, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnStrEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnManyEnList) == 0x000478, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnManyEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnManyEnList_Param) == 0x000488, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnManyEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnManyWeakEnList) == 0x000498, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnManyWeakEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillAllEnManyWeakEnList_Param) == 0x0004A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillAllEnManyWeakEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnStrategyList) == 0x0004B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnStrategyList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnStrategyList_Param) == 0x0004C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnStrategyList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscStrEnList) == 0x0004D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscStrEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscStrEnList_Param) == 0x0004E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscStrEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DestroyShellList) == 0x0004F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DestroyShellList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DestroyShellList_Param) == 0x000508, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DestroyShellList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnemyDownList) == 0x000518, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnemyDownList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnemyDownList_Param) == 0x000528, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnemyDownList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscEnList) == 0x000538, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscEnList_Param) == 0x000548, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DispCrashTrgList) == 0x000558, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DispCrashTrgList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DispCrashTrgList_Param) == 0x000568, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DispCrashTrgList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnemyBCList) == 0x000578, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnemyBCList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillEnemyBCList_Param) == 0x000588, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillEnemyBCList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnBerserkSignList) == 0x000598, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnBerserkSignList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnBerserkSignList_Param) == 0x0005A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnBerserkSignList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnBerserkList) == 0x0005B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnBerserkList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnBerserkList_Param) == 0x0005C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnBerserkList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_AttackEnShellList) == 0x0005D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_AttackEnShellList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_AttackEnShellList_Param) == 0x0005E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_AttackEnShellList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_AttackEnWeakList) == 0x0005F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_AttackEnWeakList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_AttackEnWeakList_Param) == 0x000608, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_AttackEnWeakList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_FirstStrikeList) == 0x000618, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_FirstStrikeList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_FirstStrikeList_Param) == 0x000628, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_FirstStrikeList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_OilEnAtkFireList) == 0x000638, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_OilEnAtkFireList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_OilEnAtkFireList_Param) == 0x000648, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_OilEnAtkFireList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WaterEnAtkElectricList) == 0x000658, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WaterEnAtkElectricList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WaterEnAtkElectricList_Param) == 0x000668, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WaterEnAtkElectricList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscStealthList) == 0x000678, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscStealthList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscStealthList_Param) == 0x000688, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscStealthList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscSasValidEnList) == 0x000698, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscSasValidEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscSasValidEnList_Param) == 0x0006A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscSasValidEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_StealthLosePLList) == 0x0006B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_StealthLosePLList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_StealthLosePLList_Param) == 0x0006C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_StealthLosePLList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasNoUseList) == 0x0006D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasNoUseList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasNoUseList_Param) == 0x0006E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasNoUseList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasContinuityList) == 0x0006F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasContinuityList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasContinuityList_Param) == 0x000708, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasContinuityList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasHoloPossibleList) == 0x000718, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasHoloPossibleList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasHoloPossibleList_Param) == 0x000728, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasHoloPossibleList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasHoloPursuitList) == 0x000738, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasHoloPursuitList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_SasHoloPursuitList_Param) == 0x000748, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_SasHoloPursuitList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GetItemList) == 0x000758, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GetItemList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GetItemList_Param) == 0x000768, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GetItemList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnemyDropList) == 0x000778, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnemyDropList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnemyDropList_Param) == 0x000788, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnemyDropList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_UnopenedTreasureList) == 0x000798, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_UnopenedTreasureList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_UnopenedTreasureList_Param) == 0x0007A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_UnopenedTreasureList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GatherPointList) == 0x0007B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GatherPointList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GatherPointList_Param) == 0x0007C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GatherPointList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryItemZeroList) == 0x0007D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryItemZeroList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryItemZeroList_Param) == 0x0007E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryItemZeroList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscQuestEnemyList) == 0x0007F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscQuestEnemyList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DiscQuestEnemyList_Param) == 0x000808, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DiscQuestEnemyList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_ClearQuestList) == 0x000818, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_ClearQuestList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_ClearQuestList_Param) == 0x000828, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_ClearQuestList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BirthKizunaEpList) == 0x000838, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BirthKizunaEpList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BirthKizunaEp_FadePlayList) == 0x000848, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BirthKizunaEp_FadePlayList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BirthKizunaEpList_Param) == 0x000858, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BirthKizunaEpList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillQuestTgtEnList) == 0x000868, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillQuestTgtEnList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_KillQuestTgtEnList_Param) == 0x000878, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_KillQuestTgtEnList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GetQuestTgtItemList) == 0x000888, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GetQuestTgtItemList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GetQuestTgtItemList_Param) == 0x000898, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GetQuestTgtItemList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PTChangeAttachmentList) == 0x0008A8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PTChangeAttachmentList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_PTChangeAttachmentList_Param) == 0x0008B8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_PTChangeAttachmentList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveGaugeMaxList) == 0x0008C8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveGaugeMaxList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveGaugeMaxList_Param) == 0x0008D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveGaugeMaxList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EquipStrongestWeaponList) == 0x0008E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EquipStrongestWeaponList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EquipStrongestWeaponList_Param) == 0x0008F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EquipStrongestWeaponList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WaitingVoiceList) == 0x000908, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WaitingVoiceList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_WaitingVoiceList_Param) == 0x000918, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_WaitingVoiceList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryHpToPLList) == 0x000928, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryHpToPLList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryHpToPLList_Param) == 0x000938, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryHpToPLList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryAbToPLList) == 0x000948, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryAbToPLList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_RecoveryAbToPLList_Param) == 0x000958, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_RecoveryAbToPLList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_OsoroiAttachmentList) == 0x000968, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_OsoroiAttachmentList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_OsoroiAttachmentList_Param) == 0x000978, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_OsoroiAttachmentList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_OsoroiAttachment_BeforePlayTimeList) == 0x000988, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_OsoroiAttachment_BeforePlayTimeList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_LvUp_PLList) == 0x0009D8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_LvUp_PLList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_LvUp_PLList_Param) == 0x0009E8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_LvUp_PLList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_QuestNpcNearbyCanBeOrderedList) == 0x0009F8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_QuestNpcNearbyCanBeOrderedList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_QuestNpcNearbyCanBeOrderedList_Param) == 0x000A08, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_QuestNpcNearbyCanBeOrderedList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveActiveFriendList) == 0x000A18, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveActiveFriendList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_DriveActiveFriendList_Param) == 0x000A28, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_DriveActiveFriendList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnableSAS_DriveActivationFriendList) == 0x000A38, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnableSAS_DriveActivationFriendList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_EnableSAS_DriveActivationFriendList_Param) == 0x000A48, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_EnableSAS_DriveActivationFriendList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleSim_BattleStartList) == 0x000A70, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleSim_BattleStartList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleSim_BattleStartList_Param) == 0x000A80, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleSim_BattleStartList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleSim_BattleStart_ENPCList) == 0x000A90, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleSim_BattleStart_ENPCList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleSim_BattleStart_ENPCList_Param) == 0x000AA0, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleSim_BattleStart_ENPCList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_ReturnToTheAjitoList) == 0x000AC8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_ReturnToTheAjitoList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_ReturnToTheAjitoList_Param) == 0x000AD8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_ReturnToTheAjitoList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GiveItemsFromFriendsWithAjitoList) == 0x000B88, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GiveItemsFromFriendsWithAjitoList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GiveItemsFromFriendsWithAjitoList_Param) == 0x000B98, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GiveItemsFromFriendsWithAjitoList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GiveItemsFromFriendsWithAjito_GroupLotteryTableList) == 0x000BA8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GiveItemsFromFriendsWithAjito_GroupLotteryTableList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GiveItemsFromFriendsWithAjito_ItemLotteryTableList) == 0x000BB8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GiveItemsFromFriendsWithAjito_ItemLotteryTableList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GiveItemsFromFriendsWithFieldList) == 0x000BC8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GiveItemsFromFriendsWithFieldList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GiveItemsFromFriendsWithFieldList_Param) == 0x000BD8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GiveItemsFromFriendsWithFieldList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GiveItemsFromFriendsWithField_ItemLotteryTableList) == 0x000BE8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GiveItemsFromFriendsWithField_ItemLotteryTableList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_GiveItemsFromFriendsWithField_CharacterEaseOfSelectionValue) == 0x000BF8, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_GiveItemsFromFriendsWithField_CharacterEaseOfSelectionValue' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleSim_BattleStart_RevivalBossList) == 0x000C08, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleSim_BattleStart_RevivalBossList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkBt_BattleSim_BattleStart_RevivalBossList_Param) == 0x000C18, "Member 'UBrainTalkBattleManager::M_BrainTalkBt_BattleSim_BattleStart_RevivalBossList_Param' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkEm_ConditionParamList) == 0x000C40, "Member 'UBrainTalkBattleManager::M_BrainTalkEm_ConditionParamList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkTutorial_ConditionParamList) == 0x000C50, "Member 'UBrainTalkBattleManager::M_BrainTalkTutorial_ConditionParamList' has a wrong offset!");
static_assert(offsetof(UBrainTalkBattleManager, M_BrainTalkGimmick_ConditionParamList) == 0x000C60, "Member 'UBrainTalkBattleManager::M_BrainTalkGimmick_ConditionParamList' has a wrong offset!");

// Class BattlePrototype.EnemyAiComponentBase
// 0x0060 (0x0120 - 0x00C0)
class UEnemyAiComponentBase : public UActorComponent
{
public:
	TWeakObjectPtr<class ARSCharacterBase>        MOwnerCharacter;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         MCurrentAction;                                    // 0x00C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEnemyThinkActionType                         MThinkActionType;                                  // 0x00C9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MEnableAllowance;                                  // 0x00CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F6B[0x1];                                     // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MAllowanceWaitSeconds;                             // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             MAllowanceWaitTimer;                               // 0x00D0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          MCanAttackOnce;                                    // 0x00DC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F6C[0x43];                                    // 0x00DD(0x0043)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckIdleMoveActionNative(uint8 CheckAction, const TArray<uint8>& IdleMoveAction);
	bool CheckIsAiActionParam(bool NotProbability, float LProbability, float LHp, uint8 ActionEnum);
	float GetActionTimeNative(uint8 CurAction);
	float GetAiTimer_FromNative(uint8 ActionEnym);
	void Initialize(class UEnemyScriptComponent* EnemyScript, bool IsFlyEnemy, float AIActionHeight);
	bool IsAiActionNative(uint8 ActionEnum, float* Range_Work, float* NoRange_Work, float* Angle_Work, float* NoAngle_Work, TArray<uint8>* LConditions, bool bIgnoreMove, class ARSCharacterBase* MTargetCharacter, bool IsContrlPlayer, float TargetHeight, bool* IsPreCondition, bool NotProbability);
	bool IsAttackingOtherEnemyNative(class ARSCharacterBase* MTargetCharacter);
	bool IsCommonAreaOKNative(EEnemyThinkActionType ActionType, float TargetHeight);
	bool IsPossibleAttackNative(bool IsControlPlayer, bool IgnoreOutofScreen, bool IgnoreRestrictAttackOther, class ARSCharacterBase* MTargetCharacter);
	bool IsPossibleMoveNative(bool IgnoreOutofScreen, bool IgnoreRestrictAttackOther, class ARSCharacterBase* MTargetCharacter);
	bool IsPreConditionOKNative(EEnemyThinkActionType ActionType, bool bNeedRay, bool IgnoreOutofScreen, bool IgnoreRestrictAttackOther, bool NotBrainField, bool bIgnoreMove, class ARSCharacterBase* MTargetCharacter, bool IsContrlPlayer, float TargetHeight);
	bool IsTimerOKNative(uint8 ActionEnym);
	void NotifyExecAttack();
	void ResetReserveActionNative();
	void SetActionFromReservedNative();
	void SetActionNative(uint8 ActionEnum, class FName Action, class ARSCharacterBase* MTargetCharacter, bool bIgnoreMove);
	void SetCurrentAction(uint8 Value);
	void SetIdleMoveActionNative(TArray<uint8>& IdleMoveAction);
	void SetReserveActionNative(uint8 Action, float Param00, float Param01);
	void SetThinkActionType(EEnemyThinkActionType Type);
	void SetWaitNextActionTimer(float Seconds);

	uint8 GetCurrentAction() const;
	EEnemyThinkActionType GetThinkActionType() const;
	bool IsCanAttack() const;
	bool IsDamageNative() const;
	bool IsEventNative() const;
	bool IsHpPercentDownNative(float Percent, bool* Error) const;
	bool IsIdleMoveNative(bool IsIdleMove) const;
	bool IsRandomCheckNative(float CheckValue) const;
	bool IsReservedActionNative() const;
	bool IsTimeCheckNative(float CheckValue) const;
	bool IsWaitNextActionTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAiComponentBase">();
	}
	static class UEnemyAiComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAiComponentBase>();
	}
};
static_assert(alignof(UEnemyAiComponentBase) == 0x000008, "Wrong alignment on UEnemyAiComponentBase");
static_assert(sizeof(UEnemyAiComponentBase) == 0x000120, "Wrong size on UEnemyAiComponentBase");
static_assert(offsetof(UEnemyAiComponentBase, MOwnerCharacter) == 0x0000C0, "Member 'UEnemyAiComponentBase::MOwnerCharacter' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MCurrentAction) == 0x0000C8, "Member 'UEnemyAiComponentBase::MCurrentAction' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MThinkActionType) == 0x0000C9, "Member 'UEnemyAiComponentBase::MThinkActionType' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MEnableAllowance) == 0x0000CA, "Member 'UEnemyAiComponentBase::MEnableAllowance' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MAllowanceWaitSeconds) == 0x0000CC, "Member 'UEnemyAiComponentBase::MAllowanceWaitSeconds' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MAllowanceWaitTimer) == 0x0000D0, "Member 'UEnemyAiComponentBase::MAllowanceWaitTimer' has a wrong offset!");
static_assert(offsetof(UEnemyAiComponentBase, MCanAttackOnce) == 0x0000DC, "Member 'UEnemyAiComponentBase::MCanAttackOnce' has a wrong offset!");

// Class BattlePrototype.UICharaSelectMenu
// 0x0100 (0x0488 - 0x0388)
class UUICharaSelectMenu final : public UUIBase
{
public:
	TDelegate<void(int32 Cursor)>                 M_OnEventSelectStart;                              // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class ARSTitleManager*                        M_pTitleManager;                                   // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8A[0x10];                                    // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserParamManager*                      UserParamManager;                                  // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatabaseManager*                       DatabaseManager;                                   // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8B[0xC8];                                    // 0x03C0(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCursor();
	bool GetDecideScenario();
	void InitializeAnime(class UWidgetAnimation* In_anime, class UWidgetAnimation* Default_anime, class UWidgetAnimation* Default_none_anime, class UWidgetAnimation* Out_anime, class UWidgetAnimation* In_yuito_anime, class UWidgetAnimation* Default_yuito_anime, class UWidgetAnimation* Decision_yuito_anime, class UWidgetAnimation* Out_yuito_anime, class UWidgetAnimation* In_kasane_anime, class UWidgetAnimation* Default_kasane_anime, class UWidgetAnimation* Decision_kasane_anime, class UWidgetAnimation* On_kasane_anime);
	void InitializeCharaSelect(class UUIGuide* UGuide, class UTextBlock* Charaselectguide, class UTextBlock* Charatext, class UTextBlock* CharaName, class UTextBlock* Characlear, class UBorder* Clearborder, class UREDImage* Mouse_yuito_hit, class UREDImage* Mouse_kasane_hit, class UREDImage* Mouse_yuito_hit2, class UREDImage* Mouse_kasane_hit2);
	void InitializeParts(int32 Param_Index, class UUICharaSelectParts* Charaparts);
	void SetCharacterOutLine(int32 CursorIndex);
	void SetScenarioCrear(bool Yuito, bool Kasane);
	void SetTitleManager(class ARSTitleManager* Ptitlemanager);
	void Start(ECharaSelectType Type);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaSelectMenu">();
	}
	static class UUICharaSelectMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaSelectMenu>();
	}
};
static_assert(alignof(UUICharaSelectMenu) == 0x000008, "Wrong alignment on UUICharaSelectMenu");
static_assert(sizeof(UUICharaSelectMenu) == 0x000488, "Wrong size on UUICharaSelectMenu");
static_assert(offsetof(UUICharaSelectMenu, M_OnEventSelectStart) == 0x000388, "Member 'UUICharaSelectMenu::M_OnEventSelectStart' has a wrong offset!");
static_assert(offsetof(UUICharaSelectMenu, M_pTitleManager) == 0x000398, "Member 'UUICharaSelectMenu::M_pTitleManager' has a wrong offset!");
static_assert(offsetof(UUICharaSelectMenu, UserParamManager) == 0x0003B0, "Member 'UUICharaSelectMenu::UserParamManager' has a wrong offset!");
static_assert(offsetof(UUICharaSelectMenu, DatabaseManager) == 0x0003B8, "Member 'UUICharaSelectMenu::DatabaseManager' has a wrong offset!");

// Class BattlePrototype.BrainTalkManager
// 0x00B0 (0x02E0 - 0x0230)
class ABrainTalkManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_1F8D[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8E[0x10];                                    // 0x0240(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrainTalkBattleManager*                M_pBrainTalkBattleManager;                         // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalk_CategoryDatatable>   M_BrainTalkMasterDataQueCategoryDatatableList;     // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBrainTalkMasterData>           M_BrainTalkMasterDataQueList;                      // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8F[0x8];                                     // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_StrongestWeaponIdList;                           // 0x0280(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isUpdateEquipIdList;                             // 0x0290(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F90[0x7];                                     // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerInfo>                    M_OpenMenuWindowEquipIdList;                       // 0x0298(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isEnableBrainTalk_ReturnToTheAjito;              // 0x02A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isEnableBrainTalk_QuestNpcNearbyCanBeOrdered;    // 0x02A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isEnableBrainTalk_QuestNpcNearbyCanBeOrdered_ManualAreaChange; // 0x02AA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_BrainTalkBt_BattleSim_BattleStart_BattleStartFlag; // 0x02AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_VisionSimulatorResultBTLockFlag;                 // 0x02AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F91[0x3];                                     // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_dataTable;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrainTalkPriority                            M_Priority;                                        // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F92[0x3];                                     // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_ReferenceIndex;                                  // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_massageWaitTime;                                 // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isPauseBrainTalk;                                // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isFinishBrainTalk;                               // 0x02C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isNoStopBrainTalk;                               // 0x02C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F93[0x1];                                     // 0x02C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrainTalkBt_PlayInfo>          M_BrainTalkBt_PlayReqList;                         // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isStartTalkEventPauseBT;                         // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isStartTalkEventKeepPlayingBT;                   // 0x02D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebbugBrainTalkAllInvalidFlag;                   // 0x02DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebbugBrainTalkBTInvalidFlag;                    // 0x02DB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebugDispBrainTalkLogFlag;                       // 0x02DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebugBTGiveItemsFromFriendsWithAjitoLogFlag;     // 0x02DD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebugBTGiveItemsFromFriendsWithFieldForceEnable; // 0x02DE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_DebugBTGiveItemsFromFriendsWithFieldLogFlag;     // 0x02DF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddBrainTalkMasterDataQueList(const struct FBrainTalkMasterData& Data, const struct FBrainTalk_CategoryDatatable& CategoryDatatable);
	void BPFL_PauseBrainTalkAtEndTalkEventAfter();
	void BPFL_PauseBrainTalkAtStartTalkEventBefore();
	bool BrainTalkBt_AttackEnShell();
	bool BrainTalkBt_AttackEnWeak();
	bool BrainTalkBt_BadStateByEn(const EPlayerID BadStateMember, const EHCSkillAttribute BadState);
	bool BrainTalkBt_BadStateForEn(const EPlayerID BadStateMember, const EHCSkillAttribute BadState);
	bool BrainTalkBt_BattleEscape();
	bool BrainTalkBt_BattleSim_BattleStart(const int32 Difficulty);
	bool BrainTalkBt_BattleSim_BattleStart_ENPC(const class FString& EnemyId);
	bool BrainTalkBt_BattleSim_BattleStart_RevivalBoss(const class FString& EnemyId);
	bool BrainTalkBt_BFActivate();
	bool BrainTalkBt_BirthKizunaEp(const EPlayerID EpCharacter);
	bool BrainTalkBt_BrainCrashByEn();
	bool BrainTalkBt_ClearQuest();
	bool BrainTalkBt_DamageTakeOver(const EPlayerID TakeOverCharacter);
	bool BrainTalkBt_DeadInarow(const int32 DeadNum);
	bool BrainTalkBt_DestroyShell();
	bool BrainTalkBt_DiscEn();
	bool BrainTalkBt_DiscQuestEnemy();
	bool BrainTalkBt_DiscSasValidEn(E_SASKindNative SasEffect);
	bool BrainTalkBt_DiscStealth();
	bool BrainTalkBt_DiscStrEn();
	bool BrainTalkBt_DispCrashTrg();
	bool BrainTalkBt_DriveActive();
	bool BrainTalkBt_DriveActiveFriend(const EPlayerID TalkCharaID);
	bool BrainTalkBt_DriveGaugeMax();
	bool BrainTalkBt_EnableSAS_DriveActivationFriend(const EPlayerID TalkCharaID);
	bool BrainTalkBt_EnBerserk();
	bool BrainTalkBt_EnBerserkSign();
	bool BrainTalkBt_EnemyDown(const EPlayerID DownCharacter);
	bool BrainTalkBt_EnemyDrop(const EItemRarity Rarity);
	bool BrainTalkBt_EquipStrongestWeapon(const EPlayerID EquiCharacter);
	bool BrainTalkBt_FirstStrike();
	bool BrainTalkBt_GatherPoint();
	bool BrainTalkBt_GetItem(const EItemRarity Rarity);
	bool BrainTalkBt_GetQuestTgtItem();
	bool BrainTalkBt_GiveItemsFromFriendsWithAjito();
	bool BrainTalkBt_GiveItemsFromFriendsWithField();
	bool BrainTalkBt_HiKizunaEffect(const EPlayerID HologramPlayerID);
	bool BrainTalkBt_Hp30p();
	bool BrainTalkBt_JumpOff();
	bool BrainTalkBt_KillAllEnForPL();
	bool BrainTalkBt_KillAllEnForPT(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillAllEnManyEn(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillAllEnManyWeakEn(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillAllEnShortTime(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillAllEnStrEn(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillByEn();
	bool BrainTalkBt_KillEnemyBC();
	bool BrainTalkBt_KillEnRest(const EPlayerID KillCharacter);
	bool BrainTalkBt_KillEnStrategy();
	bool BrainTalkBt_KillQuestTgtEn();
	bool BrainTalkBt_KizunaLvUp(const EPlayerID KizunaLvUpCharacter, const bool IsRetry);
	bool BrainTalkBt_LvUp(const EPlayerID LvUpCharacter);
	bool BrainTalkBt_LvUp_PL();
	bool BrainTalkBt_NearCC();
	bool BrainTalkBt_NoSallyTimes(const EPlayerID TargetCharacter, const int32 NoSallyMinutes, const int32 BeforeBTMinutes);
	bool BrainTalkBt_OilEnAtkFire();
	bool BrainTalkBt_OsoroiAttachment(const EPlayerID PlayerId, const EPlayerID TalkCharaID, const class FString& AttachmentItemID);
	bool BrainTalkBt_PLChangeAttachment();
	bool BrainTalkBt_PLDead();
	bool BrainTalkBt_PsychicCombo(const int32 ComboNum);
	bool BrainTalkBt_PTChangeAttachment(const EPlayerID ChangeAttachmentCharacter);
	bool BrainTalkBt_QuestNpcNearbyCanBeOrdered();
	bool BrainTalkBt_Recovery(const EPlayerID RecoveryTo);
	bool BrainTalkBt_RecoveryAbToPL(const EPlayerID RecoveryFrom);
	bool BrainTalkBt_RecoveryHpToPL(const EPlayerID RecoveryFrom);
	bool BrainTalkBt_RecoveryItemZero();
	bool BrainTalkBt_ReturnToTheAjito();
	bool BrainTalkBt_Revival(const EPlayerID RevivalFrom, const EPlayerID RevivalTo);
	bool BrainTalkBt_SallyTimes(const EPlayerID TargetCharacter, const int32 SallyMinutes, const int32 BeforeBTMinutes);
	bool BrainTalkBt_SasCombo(const int32 ComboNum);
	bool BrainTalkBt_SasContinuity(E_SASKindNative SasEffect, const int32 Num);
	bool BrainTalkBt_SasHoloPossible(const EPlayerID HoloCharacter);
	bool BrainTalkBt_SasHoloPursuit(const EPlayerID HoloCharacter);
	bool BrainTalkBt_SasNoUse(const EPlayerID TargetCharacter, E_SASKindNative SasEffect, const int32 LastSasProgressTime, const int32 LastSasBTProgressTime);
	bool BrainTalkBt_StealthLosePL();
	bool BrainTalkBt_TouchBFWall();
	bool BrainTalkBt_UnopenedTreasure();
	bool BrainTalkBt_WaitingVoice(const EPlayerID WaitCharacter);
	bool BrainTalkBt_WaterEnAtkElectric();
	bool BrainTalkEm_ch0100_01();
	bool BrainTalkEm_ch0100_02();
	bool BrainTalkEm_ch0200_01();
	bool BrainTalkEm_ch0200_02();
	bool BrainTalkEm_ConfusionCharge_ConfusionAttack();
	bool BrainTalkEm_ElectricCharge_ElectricAttack();
	bool BrainTalkEm_ElectricCharge_WaterMember();
	bool BrainTalkEm_em0120_01();
	bool BrainTalkEm_em0210_01();
	bool BrainTalkEm_em0300_01();
	bool BrainTalkEm_em0300_02();
	bool BrainTalkEm_em0300_03();
	bool BrainTalkEm_em0300_04();
	bool BrainTalkEm_em0310_01();
	bool BrainTalkEm_em0310_02();
	bool BrainTalkEm_em0310_03();
	bool BrainTalkEm_em0310_04();
	bool BrainTalkEm_em0320_01();
	bool BrainTalkEm_em0320_02();
	bool BrainTalkEm_em0330_01();
	bool BrainTalkEm_em0330_02();
	bool BrainTalkEm_em0330_03();
	bool BrainTalkEm_em0500_01();
	bool BrainTalkEm_em0510_01();
	bool BrainTalkEm_em0510_02();
	bool BrainTalkEm_em0510_03();
	bool BrainTalkEm_em0620_01();
	bool BrainTalkEm_em0630_01();
	bool BrainTalkEm_em0630_02();
	bool BrainTalkEm_em0630_03();
	bool BrainTalkEm_em0630_04();
	bool BrainTalkEm_em0630_05();
	bool BrainTalkEm_em0630_06();
	bool BrainTalkEm_em0700_01();
	bool BrainTalkEm_em0800_01();
	bool BrainTalkEm_em0820_01();
	bool BrainTalkEm_em0830_01();
	bool BrainTalkEm_em0920_01();
	bool BrainTalkEm_em0920_02();
	bool BrainTalkEm_em0920_03();
	bool BrainTalkEm_em0920_04();
	bool BrainTalkEm_em0920_05();
	bool BrainTalkEm_em0920_06();
	bool BrainTalkEm_em1010_01();
	bool BrainTalkEm_em1020_01();
	bool BrainTalkEm_em1100_01();
	bool BrainTalkEm_em1120_01();
	bool BrainTalkEm_em1130_01();
	bool BrainTalkEm_em1130_02();
	bool BrainTalkEm_em1130_03();
	bool BrainTalkEm_em1130_04();
	bool BrainTalkEm_em1130_05();
	bool BrainTalkEm_em1200_01();
	bool BrainTalkEm_em1200_02();
	bool BrainTalkEm_em1200_03();
	bool BrainTalkEm_em1210_01();
	bool BrainTalkEm_em1210_02();
	bool BrainTalkEm_em1210_03();
	bool BrainTalkEm_em1210_04();
	bool BrainTalkEm_em1210_05();
	bool BrainTalkEm_em1300_01();
	bool BrainTalkEm_em1300_02();
	bool BrainTalkEm_em1300_03();
	bool BrainTalkEm_em1400_01();
	bool BrainTalkEm_em1410_01();
	bool BrainTalkEm_em1410_02();
	bool BrainTalkEm_em1410_03();
	bool BrainTalkEm_em1410_04();
	bool BrainTalkEm_em1410_05();
	bool BrainTalkEm_em1420_01();
	bool BrainTalkEm_em1420_02();
	bool BrainTalkEm_em1420_03();
	bool BrainTalkEm_em1420_04();
	bool BrainTalkEm_em1430_01();
	bool BrainTalkEm_em1430_02();
	bool BrainTalkEm_em8000_01();
	bool BrainTalkEm_em8000_02();
	bool BrainTalkEm_em8000_03();
	bool BrainTalkEm_em8000_04();
	bool BrainTalkEm_em8000_05();
	bool BrainTalkEm_em8000_06();
	bool BrainTalkEm_em8200_01();
	bool BrainTalkEm_em8200_02();
	bool BrainTalkEm_em8200_03();
	bool BrainTalkEm_em8200_04();
	bool BrainTalkEm_em8200_05();
	bool BrainTalkEm_em8200_07();
	bool BrainTalkEm_em8200_08();
	bool BrainTalkEm_em8220_01();
	bool BrainTalkEm_em8220_02();
	bool BrainTalkEm_em8220_05();
	bool BrainTalkEm_em8220_06();
	bool BrainTalkEm_em8220_08();
	bool BrainTalkEm_em8220_09();
	bool BrainTalkEm_em8300_01();
	bool BrainTalkEm_em8300_02();
	bool BrainTalkEm_em8300_03();
	bool BrainTalkEm_em8300_04();
	bool BrainTalkEm_em8300_05();
	bool BrainTalkEm_em8300_06();
	bool BrainTalkEm_FlameCharge_FlameAttack();
	bool BrainTalkEm_FlameCharge_OilMember();
	bool BrainTalkEm_np1100_01();
	bool BrainTalkEm_np1100_02();
	bool BrainTalkEm_np1100_03();
	bool BrainTalkEm_np1100_04();
	bool BrainTalkEm_np1100_05();
	bool BrainTalkEm_np1100_06();
	bool BrainTalkEm_OilCharge_OilAttack();
	bool BrainTalkEm_WaterCharge_WaterAttack();
	void BrainTalkLoadWork();
	bool BrainTalkMapGimmick(EBrainTalkGimmickCondition Type, const class FString& ConditionLabel);
	bool BrainTalkTuto_tutorial_f_F();
	bool BrainTalkTuto_tutorial_f_G();
	bool BrainTalkTuto_tutorial_f_H();
	bool BrainTalkTuto_tutorial_f_I();
	bool BrainTalkTuto_tutorial_f_J();
	bool BrainTalkTuto_tutorial_m_F();
	bool BrainTalkTuto_tutorial_m_G();
	bool BrainTalkTuto_tutorial_m_H();
	bool BrainTalkTuto_tutorial_m_I();
	bool BrainTalkTuto_tutorial_m_J();
	void CallbackFinishBrainTalk();
	bool CheckBrainTalkBt_BattleSim_BattleStart();
	bool CheckEquipChangeBrainTalk();
	void ClearBrainTalkMasterDataQueList();
	void CloseBrainTalkUI();
	void DoBrainTalk_QuestNpcNearbyCanBeOrdered();
	void DoKillEnemy(const bool IsBoss);
	int32 GetBrainTalkBt_GiveItemsFromFriendsWithAjito_EnemyNumMax();
	int32 GetBrainTalkBt_GiveItemsFromFriendsWithField_ScoreNumMax();
	int32 GetBrainTalkBt_ReturnToTheAjito_EnemyNumMax();
	int32 GetBrainTalkMapGimmickWaitTime(EBrainTalkGimmickCondition Type, const class FString& ConditionLabel);
	TArray<struct FBrainTalkMasterData> GetBrainTalkMasterDataQueList();
	struct FMessageDataCell GetBrainTalkMessage(const class FString& MessageID);
	bool GetBrainTalkParam(class FName BrainTalkID, EBrainTalkCategory Category, float* OccurRate, bool* IsOnce);
	class UDataTable* GetCategoryDataTable(EBrainTalkCategory Category);
	bool GetCategoryDataTableRow(EBrainTalkCategory Category, class FName BrainTalkID, struct FBrainTalkMasterData* RowData);
	class UDataTable* GetDataTable();
	bool GetDebugBTGiveItemsFromFriendsWithAjitoLogFlag();
	bool GetDebugBTGiveItemsFromFriendsWithFieldForceEnable();
	bool GetDebugBTGiveItemsFromFriendsWithFieldLogFlag();
	bool GetDebugDispBrainTalkLogFlag();
	float GetMassageWaitTime();
	EBrainTalkPriority GetPriority();
	EBrainTalkPriorityCheckResult GetPriorityCheck(EBrainTalkPriority PlayReqPriority);
	int32 GetReferenceIndex();
	void InitializeStrongestWeaponIdList();
	bool IsCanSASUse(EPlayerID PlayerId);
	bool IsDoEventCheck();
	bool IsEnableBrainTalk_QuestNpcNearbyCanBeOrdered();
	bool IsEnableBrainTalk_ReturnToTheAjito();
	bool IsEnableCheck(const bool IsPlaySuppressionCheck, const bool IsPlayerHPCheck, const bool IsCheckVisionSimulatorResultBTLockFlag);
	bool IsFindBrainTalkOnceCheck_LoadReset(const EBrainTalkCategory _Category, const class FName _ID);
	bool IsFinishBrainTalk();
	bool IsFinishLoad();
	bool IsGameOverCheck();
	bool IsLowerPriority();
	bool IsNoStopBrainTalk();
	bool IsStartTalkEventKeepPlayingBT();
	bool IsStartTalkEventPauseBT();
	bool IsSysInvalidProgressIDCheck(EBrainTalkBtGroup Group);
	bool IsTimingEnableCheck();
	bool IsVisionSimulatorResultBTLockFlag();
	void LoadBrainTalkDatatable(const struct FBrainTalkMasterData& BrainTalkData);
	void OpenBrainTalkUI(const int32 CharacterId, const int32 ExpressionID, const class FString& MessageID, const float DrawSecond);
	void PauseBrainTalk(const bool IsPause);
	void PlaySystemBrainTalk(EBrainTalkSystemType Type, const int32 Param_Index, EPlayerID Player1);
	void PreStartBrainTalk(const struct FBrainTalk_CategoryDatatable& CategoryDatatable);
	void ResetBrainTalkBt_PlayReqList();
	void ResetVisionSimulatorMissionStart();
	void SetDebbugBrainTalkAllInvalidFlag(const bool Flag);
	void SetDebbugBrainTalkBTInvalidFlag(const bool Flag);
	void SetDebugBTGiveItemsFromFriendsWithAjitoLogFlag(const bool Flag);
	void SetDebugBTGiveItemsFromFriendsWithFieldForceEnable(const bool Flag);
	void SetDebugBTGiveItemsFromFriendsWithFieldLogFlag(const bool Flag);
	void SetDebugDispBrainTalkLogFlag(const bool Flag);
	void SetIsEnableBrainTalk_QuestNpcNearbyCanBeOrdered(const bool Flag);
	void SetIsEnableBrainTalk_QuestNpcNearbyCanBeOrdered_ManualAreaChange(const bool Flag);
	void SetIsEnableBrainTalk_ReturnToTheAjito(const bool Flag);
	void SetIsFinishBrainTalk(const bool Flag);
	void SetIsNoStopBrainTalk(const bool Flag);
	void SetIsStartTalkEventKeepPlayingBT(const bool Flag);
	void SetIsStartTalkEventPauseBT(const bool Flag);
	void SetMassageWaitTime(const float Sec);
	void SetNewRowBrainTalk(const float WaitTime);
	void SetOpenMenuWindowEquipWeaponIdList();
	void SetReferenceIndex(const int32 Num);
	void SetStrongestWeaponId(EPlayerID Player, int32 ID);
	void SetVisionSimulatorResultBTLockFlag(const bool Flag);
	void StartBrainTalk();
	void StartBrainTalk_FromNative(const struct FBrainTalkMasterData& BrainTalkData, const struct FBrainTalk_CategoryDatatable& CategoryDatatable);
	void StartBrainTalk_FromNative2(class FName BrainTalkID, EBrainTalkCategory Category);
	void StartBrainTalk_FromNative2_2(const struct FBrainTalkBt_PlayInfo& Info, const bool IsEventCallEnable, const bool IsGameOverCheck);
	void StopBrainTalk();
	void StopBrainTalk_BPFL_FromNative();
	void StopBrainTalkVoice();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrainTalkManager">();
	}
	static class ABrainTalkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrainTalkManager>();
	}
};
static_assert(alignof(ABrainTalkManager) == 0x000008, "Wrong alignment on ABrainTalkManager");
static_assert(sizeof(ABrainTalkManager) == 0x0002E0, "Wrong size on ABrainTalkManager");
static_assert(offsetof(ABrainTalkManager, _gameInstance) == 0x000238, "Member 'ABrainTalkManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_pBrainTalkBattleManager) == 0x000250, "Member 'ABrainTalkManager::M_pBrainTalkBattleManager' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_BrainTalkMasterDataQueCategoryDatatableList) == 0x000258, "Member 'ABrainTalkManager::M_BrainTalkMasterDataQueCategoryDatatableList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_BrainTalkMasterDataQueList) == 0x000268, "Member 'ABrainTalkManager::M_BrainTalkMasterDataQueList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_StrongestWeaponIdList) == 0x000280, "Member 'ABrainTalkManager::M_StrongestWeaponIdList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isUpdateEquipIdList) == 0x000290, "Member 'ABrainTalkManager::M_isUpdateEquipIdList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_OpenMenuWindowEquipIdList) == 0x000298, "Member 'ABrainTalkManager::M_OpenMenuWindowEquipIdList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isEnableBrainTalk_ReturnToTheAjito) == 0x0002A8, "Member 'ABrainTalkManager::M_isEnableBrainTalk_ReturnToTheAjito' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isEnableBrainTalk_QuestNpcNearbyCanBeOrdered) == 0x0002A9, "Member 'ABrainTalkManager::M_isEnableBrainTalk_QuestNpcNearbyCanBeOrdered' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isEnableBrainTalk_QuestNpcNearbyCanBeOrdered_ManualAreaChange) == 0x0002AA, "Member 'ABrainTalkManager::M_isEnableBrainTalk_QuestNpcNearbyCanBeOrdered_ManualAreaChange' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_BrainTalkBt_BattleSim_BattleStart_BattleStartFlag) == 0x0002AB, "Member 'ABrainTalkManager::M_BrainTalkBt_BattleSim_BattleStart_BattleStartFlag' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_VisionSimulatorResultBTLockFlag) == 0x0002AC, "Member 'ABrainTalkManager::M_VisionSimulatorResultBTLockFlag' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_dataTable) == 0x0002B0, "Member 'ABrainTalkManager::M_dataTable' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_Priority) == 0x0002B8, "Member 'ABrainTalkManager::M_Priority' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_ReferenceIndex) == 0x0002BC, "Member 'ABrainTalkManager::M_ReferenceIndex' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_massageWaitTime) == 0x0002C0, "Member 'ABrainTalkManager::M_massageWaitTime' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isPauseBrainTalk) == 0x0002C4, "Member 'ABrainTalkManager::M_isPauseBrainTalk' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isFinishBrainTalk) == 0x0002C5, "Member 'ABrainTalkManager::M_isFinishBrainTalk' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isNoStopBrainTalk) == 0x0002C6, "Member 'ABrainTalkManager::M_isNoStopBrainTalk' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_BrainTalkBt_PlayReqList) == 0x0002C8, "Member 'ABrainTalkManager::M_BrainTalkBt_PlayReqList' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isStartTalkEventPauseBT) == 0x0002D8, "Member 'ABrainTalkManager::M_isStartTalkEventPauseBT' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_isStartTalkEventKeepPlayingBT) == 0x0002D9, "Member 'ABrainTalkManager::M_isStartTalkEventKeepPlayingBT' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_DebbugBrainTalkAllInvalidFlag) == 0x0002DA, "Member 'ABrainTalkManager::M_DebbugBrainTalkAllInvalidFlag' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_DebbugBrainTalkBTInvalidFlag) == 0x0002DB, "Member 'ABrainTalkManager::M_DebbugBrainTalkBTInvalidFlag' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_DebugDispBrainTalkLogFlag) == 0x0002DC, "Member 'ABrainTalkManager::M_DebugDispBrainTalkLogFlag' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_DebugBTGiveItemsFromFriendsWithAjitoLogFlag) == 0x0002DD, "Member 'ABrainTalkManager::M_DebugBTGiveItemsFromFriendsWithAjitoLogFlag' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_DebugBTGiveItemsFromFriendsWithFieldForceEnable) == 0x0002DE, "Member 'ABrainTalkManager::M_DebugBTGiveItemsFromFriendsWithFieldForceEnable' has a wrong offset!");
static_assert(offsetof(ABrainTalkManager, M_DebugBTGiveItemsFromFriendsWithFieldLogFlag) == 0x0002DF, "Member 'ABrainTalkManager::M_DebugBTGiveItemsFromFriendsWithFieldLogFlag' has a wrong offset!");

// Class BattlePrototype.RSActorBackgroundBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorBackgroundBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorBackgroundBase">();
	}
	static class ARSActorBackgroundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorBackgroundBase>();
	}
};
static_assert(alignof(ARSActorBackgroundBase) == 0x000008, "Wrong alignment on ARSActorBackgroundBase");
static_assert(sizeof(ARSActorBackgroundBase) == 0x000230, "Wrong size on ARSActorBackgroundBase");

// Class BattlePrototype.GimmickHorrorBase
// 0x0010 (0x0240 - 0x0230)
class AGimmickHorrorBase final : public ARSActorBackgroundBase
{
public:
	EGimmickHorrorType                            Type;                                              // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB6[0x3];                                     // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerRadius;                                     // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasActioned;                                       // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDrawDebug;                                       // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB7[0x6];                                     // 0x023A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickHorrorBase">();
	}
	static class AGimmickHorrorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickHorrorBase>();
	}
};
static_assert(alignof(AGimmickHorrorBase) == 0x000008, "Wrong alignment on AGimmickHorrorBase");
static_assert(sizeof(AGimmickHorrorBase) == 0x000240, "Wrong size on AGimmickHorrorBase");
static_assert(offsetof(AGimmickHorrorBase, Type) == 0x000230, "Member 'AGimmickHorrorBase::Type' has a wrong offset!");
static_assert(offsetof(AGimmickHorrorBase, TriggerRadius) == 0x000234, "Member 'AGimmickHorrorBase::TriggerRadius' has a wrong offset!");
static_assert(offsetof(AGimmickHorrorBase, HasActioned) == 0x000238, "Member 'AGimmickHorrorBase::HasActioned' has a wrong offset!");
static_assert(offsetof(AGimmickHorrorBase, IsDrawDebug) == 0x000239, "Member 'AGimmickHorrorBase::IsDrawDebug' has a wrong offset!");

// Class BattlePrototype.BSPBlockBase
// 0x0008 (0x0238 - 0x0230)
class ABSPBlockBase final : public ARSActorSystemBase
{
public:
	class UBrushComponent*                        BrushComponent;                                    // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSPBlockBase">();
	}
	static class ABSPBlockBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABSPBlockBase>();
	}
};
static_assert(alignof(ABSPBlockBase) == 0x000008, "Wrong alignment on ABSPBlockBase");
static_assert(sizeof(ABSPBlockBase) == 0x000238, "Wrong size on ABSPBlockBase");
static_assert(offsetof(ABSPBlockBase, BrushComponent) == 0x000230, "Member 'ABSPBlockBase::BrushComponent' has a wrong offset!");

// Class BattlePrototype.BSPBlockVolume
// 0x0058 (0x0310 - 0x02B8)
class ABSPBlockVolume final : public AAudioVolume
{
public:
	FMulticastInlineDelegateProperty_             OnBSPVolumeBeginOverlap;                           // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBSPVolumeEndOverlap;                             // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBSPVolumeHit;                                    // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class ABSPPortalBase*>                 Portals;                                           // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurSoundAttenuationRate;                           // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSoundAttenuationRate;                        // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundSettingInterporateSpeed;                      // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDistanceFromPlayer;                           // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpdateID;                                          // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB8[0x4];                                     // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorHitFunc(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void PrepareUpdateSoundAttenuation();
	void ResetAttenuation();
	void SetDistanceFromPlayer(float Distance);
	void UpdateSoundAttenuation(float DeltaSeconds);

	bool IsInVolume(const struct FVector& Point, float SphereRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSPBlockVolume">();
	}
	static class ABSPBlockVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABSPBlockVolume>();
	}
};
static_assert(alignof(ABSPBlockVolume) == 0x000008, "Wrong alignment on ABSPBlockVolume");
static_assert(sizeof(ABSPBlockVolume) == 0x000310, "Wrong size on ABSPBlockVolume");
static_assert(offsetof(ABSPBlockVolume, OnBSPVolumeBeginOverlap) == 0x0002B8, "Member 'ABSPBlockVolume::OnBSPVolumeBeginOverlap' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, OnBSPVolumeEndOverlap) == 0x0002C8, "Member 'ABSPBlockVolume::OnBSPVolumeEndOverlap' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, OnBSPVolumeHit) == 0x0002D8, "Member 'ABSPBlockVolume::OnBSPVolumeHit' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, Portals) == 0x0002E8, "Member 'ABSPBlockVolume::Portals' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, CurSoundAttenuationRate) == 0x0002F8, "Member 'ABSPBlockVolume::CurSoundAttenuationRate' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, TargetSoundAttenuationRate) == 0x0002FC, "Member 'ABSPBlockVolume::TargetSoundAttenuationRate' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, SoundSettingInterporateSpeed) == 0x000300, "Member 'ABSPBlockVolume::SoundSettingInterporateSpeed' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, TotalDistanceFromPlayer) == 0x000304, "Member 'ABSPBlockVolume::TotalDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(ABSPBlockVolume, UpdateID) == 0x000308, "Member 'ABSPBlockVolume::UpdateID' has a wrong offset!");

// Class BattlePrototype.FallFloorAnimInstanceInterface
// 0x0000 (0x0028 - 0x0028)
class IFallFloorAnimInstanceInterface final : public IInterface
{
public:
	bool AppearBlock(int32 BlockNo);
	bool RemoveBlock(int32 BlockNo);
	bool SetLaserDamage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallFloorAnimInstanceInterface">();
	}
	static class IFallFloorAnimInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFallFloorAnimInstanceInterface>();
	}
};
static_assert(alignof(IFallFloorAnimInstanceInterface) == 0x000008, "Wrong alignment on IFallFloorAnimInstanceInterface");
static_assert(sizeof(IFallFloorAnimInstanceInterface) == 0x000028, "Wrong size on IFallFloorAnimInstanceInterface");

// Class BattlePrototype.UIEnemyDropItem
// 0x0010 (0x0398 - 0x0388)
class UUIEnemyDropItem : public UUIBase
{
public:
	uint8                                         Pad_1FBD[0x10];                                    // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UImage* ImageIcon, class UTextBlock* TextName);
	void SetInfoBP(int32 ItemIconId, EItemRarity ItemRariy);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEnemyDropItem">();
	}
	static class UUIEnemyDropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEnemyDropItem>();
	}
};
static_assert(alignof(UUIEnemyDropItem) == 0x000008, "Wrong alignment on UUIEnemyDropItem");
static_assert(sizeof(UUIEnemyDropItem) == 0x000398, "Wrong size on UUIEnemyDropItem");

// Class BattlePrototype.BSPManager
// 0x0038 (0x0268 - 0x0230)
class ABSPManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_1FBF[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBlockBeginOverlap;                               // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlockEndOverlap;                                 // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlockHit;                                        // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CalcBSPAttenuationFirstFromPlayer_Native(class ABSPBlockVolume* PFromBSPVolume, const TArray<class ABSPPortalBase*>& Portals, const struct FVector& BasePos, const int32 BlockUpdateID, const float MaxSoundDistance);
	void GetSoundAttenuationRate_Call(const struct FVector& Pos, float* AttenuationRate);
	void GetSoundAttenuationRate_Native(const TArray<class ABSPBlockVolume*>& AreaBlocks, const struct FVector& Pos, bool IsPlayerInBlock, float* AttenuationRate, class ABSPBlockVolume** bLock);
	class ABSPBlockVolume* IsPosInAnyBlock_Native(const TArray<class ABSPBlockVolume*>& AreaBlocks, const struct FVector& Pos);
	void OnBlockBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnBlockEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnBlockHitFunc(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void UpdateAllAtomBSPAttenuation_Native();
	void UpdateBSPAttenuation_Native(const float DeltaSeconds, const bool IsPlayerInBlock, const TArray<class ABSPBlockVolume*>& AreaBlocks, const TArray<class ABSPBlockVolume*>& BlockWithPlayer, const int32 BlockUpdateID, const float MaxSoundDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSPManager">();
	}
	static class ABSPManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABSPManager>();
	}
};
static_assert(alignof(ABSPManager) == 0x000008, "Wrong alignment on ABSPManager");
static_assert(sizeof(ABSPManager) == 0x000268, "Wrong size on ABSPManager");
static_assert(offsetof(ABSPManager, OnBlockBeginOverlap) == 0x000238, "Member 'ABSPManager::OnBlockBeginOverlap' has a wrong offset!");
static_assert(offsetof(ABSPManager, OnBlockEndOverlap) == 0x000248, "Member 'ABSPManager::OnBlockEndOverlap' has a wrong offset!");
static_assert(offsetof(ABSPManager, OnBlockHit) == 0x000258, "Member 'ABSPManager::OnBlockHit' has a wrong offset!");

// Class BattlePrototype.DamageResponseComponent
// 0x0060 (0x0120 - 0x00C0)
class UDamageResponseComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             SpawnGuardEffect;                                  // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SpawnHitEffect;                                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDamaging;                                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SpawnDamageHitEffect;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC6[0x20];                                    // 0x0100(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 OnDamageActorHit(const struct FHCHitResult& HitResult, bool IsGuard, bool IsForceCritical, bool IsArmor, bool IsRatio, bool IsAccumurateRatio, bool IsFixCalcCrash);
	void OnDamageAfter();
	int32 OnDamageDirectAttack(bool bUseFixDamage, int32 FixDamage, const struct FHCHitResult& HitResult, bool IsForceCritical);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageResponseComponent">();
	}
	static class UDamageResponseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageResponseComponent>();
	}
};
static_assert(alignof(UDamageResponseComponent) == 0x000008, "Wrong alignment on UDamageResponseComponent");
static_assert(sizeof(UDamageResponseComponent) == 0x000120, "Wrong size on UDamageResponseComponent");
static_assert(offsetof(UDamageResponseComponent, SpawnGuardEffect) == 0x0000C0, "Member 'UDamageResponseComponent::SpawnGuardEffect' has a wrong offset!");
static_assert(offsetof(UDamageResponseComponent, SpawnHitEffect) == 0x0000D0, "Member 'UDamageResponseComponent::SpawnHitEffect' has a wrong offset!");
static_assert(offsetof(UDamageResponseComponent, OnDamaging) == 0x0000E0, "Member 'UDamageResponseComponent::OnDamaging' has a wrong offset!");
static_assert(offsetof(UDamageResponseComponent, SpawnDamageHitEffect) == 0x0000F0, "Member 'UDamageResponseComponent::SpawnDamageHitEffect' has a wrong offset!");

// Class BattlePrototype.BSPPortalBase
// 0x0028 (0x0258 - 0x0230)
class ABSPPortalBase : public ARSActorSystemBase
{
public:
	TArray<class ABSPBlockVolume*>                NearVolumes;                                       // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationBaseRate;                               // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceAttenuationRate;                           // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDistanceFromPlayer;                           // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenRate;                                          // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpdateID;                                          // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCB[0x4];                                     // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNearVolume(class ABSPBlockVolume* BlockVolume);
	void CheckAndSetUpdateID(int32 ID, bool* IsFirstTime);
	void SetDistanceFromPlayer(float Distance);

	float GetTotalAttenuationRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BSPPortalBase">();
	}
	static class ABSPPortalBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABSPPortalBase>();
	}
};
static_assert(alignof(ABSPPortalBase) == 0x000008, "Wrong alignment on ABSPPortalBase");
static_assert(sizeof(ABSPPortalBase) == 0x000258, "Wrong size on ABSPPortalBase");
static_assert(offsetof(ABSPPortalBase, NearVolumes) == 0x000230, "Member 'ABSPPortalBase::NearVolumes' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, AttenuationBaseRate) == 0x000240, "Member 'ABSPPortalBase::AttenuationBaseRate' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, DistanceAttenuationRate) == 0x000244, "Member 'ABSPPortalBase::DistanceAttenuationRate' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, TotalDistanceFromPlayer) == 0x000248, "Member 'ABSPPortalBase::TotalDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, OpenRate) == 0x00024C, "Member 'ABSPPortalBase::OpenRate' has a wrong offset!");
static_assert(offsetof(ABSPPortalBase, UpdateID) == 0x000250, "Member 'ABSPPortalBase::UpdateID' has a wrong offset!");

// Class BattlePrototype.UIPkObjectTimer
// 0x0040 (0x03C8 - 0x0388)
class UUIPkObjectTimer : public UUIBase
{
public:
	uint8                                         Pad_1FCD[0x38];                                    // 0x0388(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Offset;                                            // 0x03C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UREDTextBlock* TextTimer, class UImage* ImageTimer, class UImage* ImageTimerAdd);
	bool SetupOffset();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPkObjectTimer">();
	}
	static class UUIPkObjectTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPkObjectTimer>();
	}
};
static_assert(alignof(UUIPkObjectTimer) == 0x000008, "Wrong alignment on UUIPkObjectTimer");
static_assert(sizeof(UUIPkObjectTimer) == 0x0003C8, "Wrong size on UUIPkObjectTimer");
static_assert(offsetof(UUIPkObjectTimer, Offset) == 0x0003C0, "Member 'UUIPkObjectTimer::Offset' has a wrong offset!");

// Class BattlePrototype.BTDecoratorEnemyBase
// 0x0040 (0x00A8 - 0x0068)
class UBTDecoratorEnemyBase : public UBTDecorator
{
public:
	class AAIController*                          _AIOwner;                                          // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _ActorOwner;                                       // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnemyScriptComponent*                  _EnemyScript;                                      // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ObservedKeyNames;                                  // 0x0080(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FCE[0x10];                                    // 0x0090(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCheckConditionOnlyBlackBoardChanges : 1;          // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsObservingBB : 1;                                // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1FCF[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecoratorEnemyBase">();
	}
	static class UBTDecoratorEnemyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecoratorEnemyBase>();
	}
};
static_assert(alignof(UBTDecoratorEnemyBase) == 0x000008, "Wrong alignment on UBTDecoratorEnemyBase");
static_assert(sizeof(UBTDecoratorEnemyBase) == 0x0000A8, "Wrong size on UBTDecoratorEnemyBase");
static_assert(offsetof(UBTDecoratorEnemyBase, _AIOwner) == 0x000068, "Member 'UBTDecoratorEnemyBase::_AIOwner' has a wrong offset!");
static_assert(offsetof(UBTDecoratorEnemyBase, _ActorOwner) == 0x000070, "Member 'UBTDecoratorEnemyBase::_ActorOwner' has a wrong offset!");
static_assert(offsetof(UBTDecoratorEnemyBase, _EnemyScript) == 0x000078, "Member 'UBTDecoratorEnemyBase::_EnemyScript' has a wrong offset!");
static_assert(offsetof(UBTDecoratorEnemyBase, ObservedKeyNames) == 0x000080, "Member 'UBTDecoratorEnemyBase::ObservedKeyNames' has a wrong offset!");

// Class BattlePrototype.BTD_DistanceAngleCheck_Native
// 0x0030 (0x00D8 - 0x00A8)
class UBTD_DistanceAngleCheck_Native final : public UBTDecoratorEnemyBase
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x00A8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_DistanceAngleCheck_Native">();
	}
	static class UBTD_DistanceAngleCheck_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_DistanceAngleCheck_Native>();
	}
};
static_assert(alignof(UBTD_DistanceAngleCheck_Native) == 0x000008, "Wrong alignment on UBTD_DistanceAngleCheck_Native");
static_assert(sizeof(UBTD_DistanceAngleCheck_Native) == 0x0000D8, "Wrong size on UBTD_DistanceAngleCheck_Native");
static_assert(offsetof(UBTD_DistanceAngleCheck_Native, Target) == 0x0000A8, "Member 'UBTD_DistanceAngleCheck_Native::Target' has a wrong offset!");
static_assert(offsetof(UBTD_DistanceAngleCheck_Native, Distance) == 0x0000D0, "Member 'UBTD_DistanceAngleCheck_Native::Distance' has a wrong offset!");
static_assert(offsetof(UBTD_DistanceAngleCheck_Native, Angle) == 0x0000D4, "Member 'UBTD_DistanceAngleCheck_Native::Angle' has a wrong offset!");

// Class BattlePrototype.CharacterPhysicalSurfaceActionEffectResource
// 0x0018 (0x0040 - 0x0028)
class UCharacterPhysicalSurfaceActionEffectResource final : public UObject
{
public:
	TArray<struct FCharacterPhysicalSurfaceActionEffectResourceArray> ResourceList;                                      // 0x0028(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD0[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UParticleSystem* GetResource(EGamePhysicalSurfaceType SurfaceType, ECharacterPhysicalActionType ActionType);
	bool IsLoaded();
	bool LoadAsset(const struct FCharacterPhysicalSurfaceActionEffect& ActionEffect);
	bool UnloadAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPhysicalSurfaceActionEffectResource">();
	}
	static class UCharacterPhysicalSurfaceActionEffectResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPhysicalSurfaceActionEffectResource>();
	}
};
static_assert(alignof(UCharacterPhysicalSurfaceActionEffectResource) == 0x000008, "Wrong alignment on UCharacterPhysicalSurfaceActionEffectResource");
static_assert(sizeof(UCharacterPhysicalSurfaceActionEffectResource) == 0x000040, "Wrong size on UCharacterPhysicalSurfaceActionEffectResource");
static_assert(offsetof(UCharacterPhysicalSurfaceActionEffectResource, ResourceList) == 0x000028, "Member 'UCharacterPhysicalSurfaceActionEffectResource::ResourceList' has a wrong offset!");

// Class BattlePrototype.TickManageComponent
// 0x0030 (0x00F0 - 0x00C0)
class UTickManageComponent final : public UActorComponent
{
public:
	TArray<TWeakObjectPtr<class AActor>>          _ManageActorList;                                  // 0x00C0(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UTickManageComponent>> _TickManageComponentList;                          // 0x00D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UActorComponent>> _ComponentList;                                    // 0x00E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RegisterManageActor(class AActor* Actor);
	void RegisterManageComponent(const TArray<class UActorComponent*>& ComponentList);
	void SetManageTickEnable(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickManageComponent">();
	}
	static class UTickManageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickManageComponent>();
	}
};
static_assert(alignof(UTickManageComponent) == 0x000008, "Wrong alignment on UTickManageComponent");
static_assert(sizeof(UTickManageComponent) == 0x0000F0, "Wrong size on UTickManageComponent");
static_assert(offsetof(UTickManageComponent, _ManageActorList) == 0x0000C0, "Member 'UTickManageComponent::_ManageActorList' has a wrong offset!");
static_assert(offsetof(UTickManageComponent, _TickManageComponentList) == 0x0000D0, "Member 'UTickManageComponent::_TickManageComponentList' has a wrong offset!");
static_assert(offsetof(UTickManageComponent, _ComponentList) == 0x0000E0, "Member 'UTickManageComponent::_ComponentList' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_EnableActionTimer_Native
// 0x0028 (0x00D0 - 0x00A8)
class UBTD_Enemy_EnableActionTimer_Native final : public UBTDecoratorEnemyBase
{
public:
	struct FBlackboardKeySelector                 ActionTimerKey;                                    // 0x00A8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_EnableActionTimer_Native">();
	}
	static class UBTD_Enemy_EnableActionTimer_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_EnableActionTimer_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_EnableActionTimer_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_EnableActionTimer_Native");
static_assert(sizeof(UBTD_Enemy_EnableActionTimer_Native) == 0x0000D0, "Wrong size on UBTD_Enemy_EnableActionTimer_Native");
static_assert(offsetof(UBTD_Enemy_EnableActionTimer_Native, ActionTimerKey) == 0x0000A8, "Member 'UBTD_Enemy_EnableActionTimer_Native::ActionTimerKey' has a wrong offset!");

// Class BattlePrototype.DebuggingItemFloat
// 0x0038 (0x0300 - 0x02C8)
class ADebuggingItemFloat final : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSliderSettingChanged;                            // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Max;                                               // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Step;                                              // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Value;                                             // 0x02F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD3[0x8];                                     // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeyLeftFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void OnKeyRightFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void SetSliderSettings(float InMin, float InMax, float InStep);
	void SetValue(float InValue);

	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemFloat">();
	}
	static class ADebuggingItemFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemFloat>();
	}
};
static_assert(alignof(ADebuggingItemFloat) == 0x000008, "Wrong alignment on ADebuggingItemFloat");
static_assert(sizeof(ADebuggingItemFloat) == 0x000300, "Wrong size on ADebuggingItemFloat");
static_assert(offsetof(ADebuggingItemFloat, OnChanged) == 0x0002C8, "Member 'ADebuggingItemFloat::OnChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, OnSliderSettingChanged) == 0x0002D8, "Member 'ADebuggingItemFloat::OnSliderSettingChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, Min) == 0x0002E8, "Member 'ADebuggingItemFloat::Min' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, Max) == 0x0002EC, "Member 'ADebuggingItemFloat::Max' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, Step) == 0x0002F0, "Member 'ADebuggingItemFloat::Step' has a wrong offset!");
static_assert(offsetof(ADebuggingItemFloat, Value) == 0x0002F4, "Member 'ADebuggingItemFloat::Value' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_EnableLostAction_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_EnableLostAction_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_EnableLostAction_Native">();
	}
	static class UBTD_Enemy_EnableLostAction_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_EnableLostAction_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_EnableLostAction_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_EnableLostAction_Native");
static_assert(sizeof(UBTD_Enemy_EnableLostAction_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_EnableLostAction_Native");

// Class BattlePrototype.UIEnemyListIndex
// 0x0040 (0x03C8 - 0x0388)
class UUIEnemyListIndex : public UUIBase
{
public:
	uint8                                         Pad_1FD6[0x40];                                    // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UImage* ImageNewIcon, class UTextBlock* TextName);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEnemyListIndex">();
	}
	static class UUIEnemyListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEnemyListIndex>();
	}
};
static_assert(alignof(UUIEnemyListIndex) == 0x000008, "Wrong alignment on UUIEnemyListIndex");
static_assert(sizeof(UUIEnemyListIndex) == 0x0003C8, "Wrong size on UUIEnemyListIndex");

// Class BattlePrototype.BTD_Enemy_FormType_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_FormType_Native final : public UBTDecoratorEnemyBase
{
public:
	EEnemyFormType                                FormType;                                          // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD7[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_FormType_Native">();
	}
	static class UBTD_Enemy_FormType_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_FormType_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_FormType_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_FormType_Native");
static_assert(sizeof(UBTD_Enemy_FormType_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_FormType_Native");
static_assert(offsetof(UBTD_Enemy_FormType_Native, FormType) == 0x0000A8, "Member 'UBTD_Enemy_FormType_Native::FormType' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsAlive_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_IsAlive_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyAliveAnimKind                            EnemyAliveAnimKind;                                // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD8[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsAlive_Native">();
	}
	static class UBTD_Enemy_IsAlive_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsAlive_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsAlive_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsAlive_Native");
static_assert(sizeof(UBTD_Enemy_IsAlive_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_IsAlive_Native");
static_assert(offsetof(UBTD_Enemy_IsAlive_Native, EnemyAliveAnimKind) == 0x0000A8, "Member 'UBTD_Enemy_IsAlive_Native::EnemyAliveAnimKind' has a wrong offset!");

// Class BattlePrototype.DamagePartCollisionComponent
// 0x0040 (0x0470 - 0x0430)
class UDamagePartCollisionComponent final : public UCapsuleComponent
{
public:
	int32                                         MParameterNo;                                      // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHPartNo                                      MPartNo;                                           // 0x042C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsWeakPoint;                                      // 0x042D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHDamageEffectType                            MDamageEffectType;                                 // 0x042E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD9[0x1];                                     // 0x042F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MDamagePriority;                                   // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MHitRotator;                                       // 0x0434(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MHitAngle;                                         // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MOffset;                                           // 0x0444(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsBoneEnable;                                     // 0x0450(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDA[0x3];                                     // 0x0451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MBoneBase;                                         // 0x0454(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MBoneDir;                                          // 0x045C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsNoDamage;                                       // 0x0464(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsNoCrash;                                        // 0x0465(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsNoReaction;                                     // 0x0466(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsNoBadStatus;                                    // 0x0467(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDB[0x8];                                     // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCalcDamageInfo(bool bNoDamage, bool bNoCrash, bool bNoReaction, bool bNoBadStatus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamagePartCollisionComponent">();
	}
	static class UDamagePartCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamagePartCollisionComponent>();
	}
};
static_assert(alignof(UDamagePartCollisionComponent) == 0x000010, "Wrong alignment on UDamagePartCollisionComponent");
static_assert(sizeof(UDamagePartCollisionComponent) == 0x000470, "Wrong size on UDamagePartCollisionComponent");
static_assert(offsetof(UDamagePartCollisionComponent, MParameterNo) == 0x000428, "Member 'UDamagePartCollisionComponent::MParameterNo' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MPartNo) == 0x00042C, "Member 'UDamagePartCollisionComponent::MPartNo' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsWeakPoint) == 0x00042D, "Member 'UDamagePartCollisionComponent::MIsWeakPoint' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MDamageEffectType) == 0x00042E, "Member 'UDamagePartCollisionComponent::MDamageEffectType' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MDamagePriority) == 0x000430, "Member 'UDamagePartCollisionComponent::MDamagePriority' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MHitRotator) == 0x000434, "Member 'UDamagePartCollisionComponent::MHitRotator' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MHitAngle) == 0x000440, "Member 'UDamagePartCollisionComponent::MHitAngle' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MOffset) == 0x000444, "Member 'UDamagePartCollisionComponent::MOffset' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsBoneEnable) == 0x000450, "Member 'UDamagePartCollisionComponent::MIsBoneEnable' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MBoneBase) == 0x000454, "Member 'UDamagePartCollisionComponent::MBoneBase' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MBoneDir) == 0x00045C, "Member 'UDamagePartCollisionComponent::MBoneDir' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsNoDamage) == 0x000464, "Member 'UDamagePartCollisionComponent::MIsNoDamage' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsNoCrash) == 0x000465, "Member 'UDamagePartCollisionComponent::MIsNoCrash' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsNoReaction) == 0x000466, "Member 'UDamagePartCollisionComponent::MIsNoReaction' has a wrong offset!");
static_assert(offsetof(UDamagePartCollisionComponent, MIsNoBadStatus) == 0x000467, "Member 'UDamagePartCollisionComponent::MIsNoBadStatus' has a wrong offset!");

// Class BattlePrototype.UIPhotoModeParts
// 0x0068 (0x03F0 - 0x0388)
class UUIPhotoModeParts : public UUIBase
{
public:
	uint8                                         Pad_1FDC[0x68];                                    // 0x0388(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeFinderList(const TArray<class UImage*>& ImageFinderList);
	void InitializeThis(const TArray<class UWidgetAnimation*>& AnimLogos, class UTextBlock* TextCopyright);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPhotoModeParts">();
	}
	static class UUIPhotoModeParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPhotoModeParts>();
	}
};
static_assert(alignof(UUIPhotoModeParts) == 0x000008, "Wrong alignment on UUIPhotoModeParts");
static_assert(sizeof(UUIPhotoModeParts) == 0x0003F0, "Wrong size on UUIPhotoModeParts");

// Class BattlePrototype.BTD_Enemy_IsBadStatus_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_IsBadStatus_Native final : public UBTDecoratorEnemyBase
{
public:
	EHCBadState                                   BadStatus;                                         // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FDD[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsBadStatus_Native">();
	}
	static class UBTD_Enemy_IsBadStatus_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsBadStatus_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsBadStatus_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsBadStatus_Native");
static_assert(sizeof(UBTD_Enemy_IsBadStatus_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_IsBadStatus_Native");
static_assert(offsetof(UBTD_Enemy_IsBadStatus_Native, BadStatus) == 0x0000A8, "Member 'UBTD_Enemy_IsBadStatus_Native::BadStatus' has a wrong offset!");

// Class BattlePrototype.DataTableTest
// 0x0020 (0x0250 - 0x0230)
class ADataTableTest final : public AActor
{
public:
	class UDataTable*                             _datatable;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDataTableRowTest>              _dataContents;                                     // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTableExtends*                      _datatableExtends;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitDataContents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableTest">();
	}
	static class ADataTableTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADataTableTest>();
	}
};
static_assert(alignof(ADataTableTest) == 0x000008, "Wrong alignment on ADataTableTest");
static_assert(sizeof(ADataTableTest) == 0x000250, "Wrong size on ADataTableTest");
static_assert(offsetof(ADataTableTest, _datatable) == 0x000230, "Member 'ADataTableTest::_datatable' has a wrong offset!");
static_assert(offsetof(ADataTableTest, _dataContents) == 0x000238, "Member 'ADataTableTest::_dataContents' has a wrong offset!");
static_assert(offsetof(ADataTableTest, _datatableExtends) == 0x000248, "Member 'ADataTableTest::_datatableExtends' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsBattle_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsBattle_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsBattle_Native">();
	}
	static class UBTD_Enemy_IsBattle_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsBattle_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsBattle_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsBattle_Native");
static_assert(sizeof(UBTD_Enemy_IsBattle_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsBattle_Native");

// Class BattlePrototype.UIDiscover
// 0x00B0 (0x0438 - 0x0388)
class UUIDiscover : public UUIBase
{
public:
	class AActor*                                 M_EmActor;                                         // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_EmPosData;                                       // 0x0390(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FDE[0x9C];                                    // 0x039C(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceClose();
	void ForceCloseDead();
	void ForceVisible(bool Flag);
	int32 GetDiscoverIndex();
	void InitializeAnime(class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_discover, class UWidgetAnimation* In_discover, class UWidgetAnimation* Out_discover, class UWidgetAnimation* Default_undiscover, class UWidgetAnimation* In_undiscover, class UWidgetAnimation* Out_undiscover, class UWidgetAnimation* Default_undiscoverOver, class UWidgetAnimation* Out_undiscoverOver);
	void InitializeData(class UOverlay* FrameData);
	void SetDiscoverIcon(EDiscoverIconType Type);
	void SetDiscoverIndex(int32 Param_Index);
	void SetMaxTimer(float Timer);
	void Start(EDiscoverType Type, class AActor* EmActor);
	void UpdatePosDiscover();
	void UpdateStateDiscover(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDiscover">();
	}
	static class UUIDiscover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDiscover>();
	}
};
static_assert(alignof(UUIDiscover) == 0x000008, "Wrong alignment on UUIDiscover");
static_assert(sizeof(UUIDiscover) == 0x000438, "Wrong size on UUIDiscover");
static_assert(offsetof(UUIDiscover, M_EmActor) == 0x000388, "Member 'UUIDiscover::M_EmActor' has a wrong offset!");
static_assert(offsetof(UUIDiscover, M_EmPosData) == 0x000390, "Member 'UUIDiscover::M_EmPosData' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsCanFlyModeChange_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsCanFlyModeChange_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsCanFlyModeChange_Native">();
	}
	static class UBTD_Enemy_IsCanFlyModeChange_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsCanFlyModeChange_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsCanFlyModeChange_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsCanFlyModeChange_Native");
static_assert(sizeof(UBTD_Enemy_IsCanFlyModeChange_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsCanFlyModeChange_Native");

// Class BattlePrototype.BTD_Enemy_IsDead_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsDead_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsDead_Native">();
	}
	static class UBTD_Enemy_IsDead_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsDead_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsDead_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsDead_Native");
static_assert(sizeof(UBTD_Enemy_IsDead_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsDead_Native");

// Class BattlePrototype.EffectBackground
// 0x0058 (0x0288 - 0x0230)
class AEffectBackground : public ARSActorBackgroundBase
{
public:
	class URSParticleSystemComponentBase*         ParticleComponent;                                 // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PlayEventName_;                                    // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         StopEventName_;                                    // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE0[0x10];                                    // 0x0258(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseCameraDither_;                                 // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE1[0x3];                                     // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DitherDistance_;                                   // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DitherSpeed_;                                      // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE2[0x4];                                     // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraComp_;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FE3[0x8];                                     // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayParticleImplements();
	void ProtectedAttachParticle(class AActor* Parent);
	void ProtectedDetachParticle();
	bool SetDitherValue(float Value);
	void SetupUseAttachment();
	void StopAndHideParticleImplements();
	void StopParticleImplements();

	bool IsEffectAttachUse() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectBackground">();
	}
	static class AEffectBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectBackground>();
	}
};
static_assert(alignof(AEffectBackground) == 0x000008, "Wrong alignment on AEffectBackground");
static_assert(sizeof(AEffectBackground) == 0x000288, "Wrong size on AEffectBackground");
static_assert(offsetof(AEffectBackground, ParticleComponent) == 0x000230, "Member 'AEffectBackground::ParticleComponent' has a wrong offset!");
static_assert(offsetof(AEffectBackground, PlayEventName_) == 0x000238, "Member 'AEffectBackground::PlayEventName_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, StopEventName_) == 0x000248, "Member 'AEffectBackground::StopEventName_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, bUseCameraDither_) == 0x000268, "Member 'AEffectBackground::bUseCameraDither_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, DitherDistance_) == 0x00026C, "Member 'AEffectBackground::DitherDistance_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, DitherSpeed_) == 0x000270, "Member 'AEffectBackground::DitherSpeed_' has a wrong offset!");
static_assert(offsetof(AEffectBackground, CameraComp_) == 0x000278, "Member 'AEffectBackground::CameraComp_' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsEnableWander_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsEnableWander_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsEnableWander_Native">();
	}
	static class UBTD_Enemy_IsEnableWander_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsEnableWander_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsEnableWander_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsEnableWander_Native");
static_assert(sizeof(UBTD_Enemy_IsEnableWander_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsEnableWander_Native");

// Class BattlePrototype.OnlineTestCreateSession
// 0x0078 (0x00A8 - 0x0030)
class UOnlineTestCreateSession final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE5[0x58];                                    // 0x0050(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOnlineTestCreateSession* OnlineTestCreateSession(class UObject* WorldContextObject, class APlayerController* PlayerController, int32 PubblicConections, bool UseLAN, const class FString& LevelName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestCreateSession">();
	}
	static class UOnlineTestCreateSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineTestCreateSession>();
	}
};
static_assert(alignof(UOnlineTestCreateSession) == 0x000008, "Wrong alignment on UOnlineTestCreateSession");
static_assert(sizeof(UOnlineTestCreateSession) == 0x0000A8, "Wrong size on UOnlineTestCreateSession");
static_assert(offsetof(UOnlineTestCreateSession, OnSuccess) == 0x000030, "Member 'UOnlineTestCreateSession::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOnlineTestCreateSession, OnFailure) == 0x000040, "Member 'UOnlineTestCreateSession::OnFailure' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsForceBreak_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsForceBreak_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsForceBreak_Native">();
	}
	static class UBTD_Enemy_IsForceBreak_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsForceBreak_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsForceBreak_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsForceBreak_Native");
static_assert(sizeof(UBTD_Enemy_IsForceBreak_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsForceBreak_Native");

// Class BattlePrototype.PlayerInterface
// 0x0000 (0x0028 - 0x0028)
class IPlayerInterface final : public IInterface
{
public:
	bool AimEndAI_CallFromCPP();
	bool AimStartAI_CallFromCPP();
	float BeforeTakeDamage(float DamageValue, const struct FHCHitResult& HitResult);
	void BeginControlPsychicObject(class AActor** TargetActor);
	bool CanBattleAction_CallFromCPP(EPlayerAIBattleThinkTypeCPP ThinkType);
	bool CheckAIPsychicObject_CallFromCPP(bool bCapture, bool bAttack);
	bool CheckAutoCounter_CallFromCPP();
	bool CheckEventMovePos_CallFromCPP();
	bool CheckFriendCoverDamage(float DamageValue);
	void CheckHologramAttack(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	bool CheckJumpCount();
	bool CheckRareArrangeItemBySAS();
	bool ClearBattleParticle(class FName ClaimantName, bool bForceClear);
	bool CloseBrainField(bool bCrash);
	void EndControlPsychicObject(class AActor** TargetActor);
	bool EndEventWait_CallFromCPP();
	void EquipAccessory(EPlayerAccessory Param_Index, int32 AccessoryId);
	void EquipAttachment(EPlayerAttachment Param_Index, int32 AttachmentId);
	void EquipCostume(int32 CostumeId);
	void EquipWeapon(int32 WeaponId, int32 SkinID);
	bool ForceEndSAS_Telepo();
	bool ForceWarp_CallFromCPP(const struct FTransform& Transform, float IdleRestoreDelay);
	class AActor* GetBattleTargetActor_CallFromCPP();
	EPlayerBrainFieldDanger GetBrainFieldDangerLV();
	EPlayerActionKind GetCurrentActionStateInterface();
	void GetCurrentSASGaugeRate(E_SASButton SASButton, float* SASGaugeRate);
	void GetEventMovePosActor_CallFromCPP(class AActor** OutActor, float* OutRadius);
	float GetManualAssaultVisionSasGaugeRate();
	float GetMaxSpeedScale_CallFromCPP();
	void GetSAS_MaxActiveSeconds(E_SASKindNative SasKind, float* ActivationSeconds);
	void GetSASActiveSeconds(E_SASButton SASButton, float* RemainingSec);
	bool GetSASEffectFixParam(E_SASKindNative InKind, TArray<struct F_SASParamNative>* OutFixParam);
	void GetSASRecastAndActiveGaugeRate(E_SASButton SASButton, float* SASGaugeRate, bool* IsActive);
	bool InputAI_Attack_CallFromCPP(bool bPressed);
	bool InputAI_Dodge_CallFromCPP(bool bPressed);
	bool InputAI_Jump_CallFromCPP(bool bPressed);
	bool InputAI_LeftStick_CallFromCPP(float X, float Y);
	bool InputAI_Psychic_CallFromCPP(bool bPressed);
	bool InputAI_UseItem_CallFromCPP(bool bPressed);
	bool IsAbleOverwriteENPCBrainField();
	bool IsActionStatusAI_CallFromCPP(EPlayerActionStatus Status);
	bool IsActiveSAS_Accelerator();
	bool IsActiveSAS_Copy();
	bool IsActiveSAS_Electric();
	bool IsActiveSAS_Fire();
	bool IsActiveSAS_Metal();
	bool IsActiveSAS_Psychic();
	bool IsActiveSAS_SeeThrough();
	bool IsActiveSAS_Stealth();
	bool IsActiveSAS_Telepo();
	bool IsAIMoveMode_CallFromCPP(EPlayerAIMoveModeCPP MoveModeCPP);
	bool IsAIPlayer();
	bool IsBattleActionStartAI_CallFromCPP();
	bool IsBattleThink_CallFromCPP(EPlayerAIBattleThinkTypeCPP Type);
	bool IsBattleThinkParam_CallFromCPP(EPlayerAIBattleThinkParamCPP Param);
	bool IsDriveMode_CallFromCPP();
	bool IsEnableActionCounter_CallFromCPP();
	bool IsEnableBackStepAttack();
	bool IsEnableCheckActionIcon();
	bool IsEnableSASCoverDamageFromPlayerID(EPlayerID CoverPlayerID);
	bool IsEnableSASEffectHologram(EPlayerID PlayerId);
	bool IsEnableSASHologramAttack(ESASHologramAttackTiming Timing);
	bool IsEnableSasInterface();
	bool IsEnableSasSelectSlow();
	bool IsEnemyPlayer_CallFromCPP();
	bool IsIgnoreStealthVelocity();
	bool IsInputAI_Psychic_CallFromCPP();
	bool IsInputAI_UseItem_CallFromCPP();
	bool IsInputOverwriteENPCBrainField();
	bool IsManualHologramAttack();
	bool IsPlayerStatusAI_CallFromCPP(EPlayerCommonStatus Status);
	bool IsPsychicAble_CallFromCPP();
	bool IsReactionChance_CallFromCPP();
	bool IsSelfRecovery_CallFromCPP();
	bool IsSpecialDown_CallFromCPP(float* OutSpDownWince);
	bool IsUniqueConditionTransition_CallFromCPP(int32 UniqueNo);
	bool IsUniqueEffectiveSas_CallFromCPP(class AActor* InAttackActor, float* OutWinceRate, float* OutKnockbackRate, float* OutDownRate, float* OutCrashRate);
	bool IsUseAbleCombinationVision(E_SASKindNative InKind);
	bool IsUseAbleSASRecastGauge(E_SASKindNative SasKind);
	bool IsUseItemThink_CallFromCPP();
	bool NextBattleThink_CallFromCPP();
	bool NotifyResetBehaviorTree_CallFromCPP();
	bool OnAnimNotifyEnableAction();
	bool OnAnimNotifyEnableAttack();
	bool OnAnimNotifyEnablePsychic();
	void OnBattleSimulatorMissionEnd(bool bMissionCancel);
	bool OnChangeBattleThink_CallFromCPP(EPlayerAIBattleThinkTypeCPP Next, EPlayerAIBattleThinkTypeCPP Prev);
	bool OpenBrainField();
	ERSAttackInputKind OverwriteAttackInputKindAI_CallFromCPP(EPlayerAIBattleThinkTypeCPP Think, ERSAttackInputKind Kind);
	bool ResetAnimLeftStickPower();
	bool ResetBattleThink_CallFromCPP();
	bool ResetCoverDamagePlayer_CallFromCPP();
	bool RestartBattleAI_CallFromCPP();
	bool RestoreMaxSpeed_CallFromCPP(const class FName& ClaimantName);
	bool ScaleMaxSpeed_CallFromCPP(float Scale, class FName ClaimantName);
	bool SearchAIPsychicObject_CallFromCPP();
	bool SetAIMoveStick_CallFromCPP(bool bMoveStick);
	void SetAIOrder(EPlayerAIOrder Plan);
	bool SetBattleParticleType(EPlayerBattleParticleType Type);
	bool SetEnableInputStick_CallFromCPP(bool bEnable);
	bool SetEventEndDown(bool bFront);
	bool SetEventMove_CallFromCPP(const TArray<struct FVector>& Pos_list_in, const TArray<float>& Radius_list_in, bool Walk, bool bAfterWait);
	bool SetEventWait_CallFromCPP();
	void SetEyeControlEnable(bool bEnable, class FName ClaimantName);
	void SetEyeControlParameter(float Horizontal, float Vertical);
	bool SetForceLockTargetSelf_CallFromCPP();
	bool SetMaterialScalarParameterOther(class FName ParamName, float Value);
	bool SetMoveMode_CallFromCPP(EPlayerAIMoveModeCPP MoveModeCPP);
	bool SetMoveStickBack_CallFromCPP(bool bBack);
	ERSPartyPlayerKind SetPartyPlayerKind(ERSPartyPlayerKind Kind);
	bool SetPlayerCamera(class ACameraActor* PCameraActor, bool bPitch, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	bool SetPlayerInputRestriction_CallFromCPP(EPlayerInputRestrictionType Type, bool bRistriction);
	bool SetReserveCoverDamage_CallFromCPP(bool Flag);
	bool SetSasMetalVisible_CallFromCPP(bool Metal_on_in, const struct FGameTimer& Gametimer_in, struct FGameTimer* Gametimer_out);
	bool SetSasStealth_CallFromCPP(bool Stealth_on_in, bool Hero_order_in, bool Check_delay, bool Check_ignore, bool No_sas_cancel_in);
	bool SetSasStealthVisible_CallFromCPP(bool Stealth_on_in, const struct FPlayerStealthDelayParam& DelayParam_in, struct FPlayerStealthDelayParam* DelayParam_out);
	bool SetStealthReactionInterval_CallFromCPP();
	bool SpawnBattleParticle(class FName ClaimantName);
	struct FPlayerInfo UpdateMenuParameter(const struct FPlayerInfo& CurrentParameter);
	void UpdateParameter(const struct FCharactersParameterTable& Table);

	int32 GetAttackCountAI_CallFromCPP() const;
	struct FVector GetControlPlayerDist_CallFromCPP() const;
	EPlayerID GetCoverDamagePlayerID_CallFromCPP() const;
	void GetCurrentTargetActorInterface(class AActor** TargetActor) const;
	class AActor* GetMovePosActor_CallFromCPP() const;
	ERSPartyPlayerKind GetPartyPlayerKind() const;
	void GetPlayerAccessoryEffect_CallFromCPP(EEffecacyType EffectType, bool* bOutEquip, float* OutParam) const;
	EPlayerID GetPlayerID() const;
	void GetSASKindforButton(E_SASButton SASButton, E_SASKindNative* SasKind) const;
	void GetTargetBossInterface(class AActor** LockBoss) const;
	void IsActiveSAS_ForButton(E_SASButton SASButton, bool* IsSAS) const;
	bool IsAttackAble_CallFromCPP() const;
	void IsCanSAS_Use(E_SASButton SASButton, bool* IsSASUse) const;
	bool IsControlAI_CallFromCPP() const;
	bool IsDamageCollisionInvincible_CallFromCPP() const;
	bool IsDodgeAble_CallFromCPP() const;
	bool IsDying_CallFromCPP() const;
	bool IsEnableActionDodge_CallFromCPP() const;
	bool IsEnableActionJump_CallFromCPP() const;
	bool IsEnableBrainCrash_Native() const;
	void IsEnableSASEffectInterface(E_SASKindNative Kind, ESASEffect Effect, bool* OutEnable, float* OutParam0, float* OutParam1, float* OutParam2, float* OutParam3) const;
	bool IsEnemyForceWait_CallFromCPP() const;
	bool IsEventMove_CallFromCPP() const;
	bool IsEventMoveEnd_CallFromCPP() const;
	bool IsEventWait_CallFromCPP() const;
	bool IsInputAI_Attack_CallFromCPP() const;
	bool IsInputAI_Dodge_CallFromCPP() const;
	bool IsInputAI_Jump_CallFromCPP() const;
	void IsInputSAS(E_SASButton SASButton, bool* Param_IsInputSAS) const;
	bool IsJumpAble_CallFromCPP() const;
	void IsLockTargetInterface(bool* IsLockTarget) const;
	bool IsLockTargetLostInterface() const;
	bool IsMetalMode_CallFromCPP() const;
	bool IsMoveAble_CallFromCPP() const;
	bool IsOnReadySAS() const;
	bool IsPlayerSuperArmor_CallFromCPP() const;
	bool IsResetBehaviorTree_CallFromCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInterface">();
	}
	static class IPlayerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerInterface>();
	}
};
static_assert(alignof(IPlayerInterface) == 0x000008, "Wrong alignment on IPlayerInterface");
static_assert(sizeof(IPlayerInterface) == 0x000028, "Wrong size on IPlayerInterface");

// Class BattlePrototype.BTD_Enemy_IsNotWallHit_Native
// 0x0010 (0x00B8 - 0x00A8)
class UBTD_Enemy_IsNotWallHit_Native final : public UBTDecoratorEnemyBase
{
public:
	float                                         _tmpDistance;                                      // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             _tmpGameTimer;                                     // 0x00AC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsNotWallHit_Native">();
	}
	static class UBTD_Enemy_IsNotWallHit_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsNotWallHit_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsNotWallHit_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsNotWallHit_Native");
static_assert(sizeof(UBTD_Enemy_IsNotWallHit_Native) == 0x0000B8, "Wrong size on UBTD_Enemy_IsNotWallHit_Native");
static_assert(offsetof(UBTD_Enemy_IsNotWallHit_Native, _tmpDistance) == 0x0000A8, "Member 'UBTD_Enemy_IsNotWallHit_Native::_tmpDistance' has a wrong offset!");
static_assert(offsetof(UBTD_Enemy_IsNotWallHit_Native, _tmpGameTimer) == 0x0000AC, "Member 'UBTD_Enemy_IsNotWallHit_Native::_tmpGameTimer' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsRandom_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_IsRandom_Native final : public UBTDecoratorEnemyBase
{
public:
	int32                                         Num;                                               // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200A[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsRandom_Native">();
	}
	static class UBTD_Enemy_IsRandom_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsRandom_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsRandom_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsRandom_Native");
static_assert(sizeof(UBTD_Enemy_IsRandom_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_IsRandom_Native");
static_assert(offsetof(UBTD_Enemy_IsRandom_Native, Num) == 0x0000A8, "Member 'UBTD_Enemy_IsRandom_Native::Num' has a wrong offset!");

// Class BattlePrototype.UICrushBonus
// 0x0030 (0x03B8 - 0x0388)
class UUICrushBonus final : public UUIBase
{
public:
	uint8                                         Pad_200B[0x30];                                    // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextNumber);
	void SetBonus(int32 bonus);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICrushBonus">();
	}
	static class UUICrushBonus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICrushBonus>();
	}
};
static_assert(alignof(UUICrushBonus) == 0x000008, "Wrong alignment on UUICrushBonus");
static_assert(sizeof(UUICrushBonus) == 0x0003B8, "Wrong size on UUICrushBonus");

// Class BattlePrototype.BTD_Enemy_IsSpawnNow_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsSpawnNow_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsSpawnNow_Native">();
	}
	static class UBTD_Enemy_IsSpawnNow_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsSpawnNow_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsSpawnNow_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsSpawnNow_Native");
static_assert(sizeof(UBTD_Enemy_IsSpawnNow_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsSpawnNow_Native");

// Class BattlePrototype.DebuggingItemStringArray
// 0x0040 (0x0308 - 0x02C8)
class ADebuggingItemStringArray : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComboBoxSettingChanged;                          // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FText>                           StringArray;                                       // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Index_DebuggingItemStringArray;                    // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200C[0xC];                                     // 0x02FC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeyLeftFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void OnKeyRightFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void SetComboBoxSetting(const TArray<class FText>& InStringArray);
	void SetStringIndex(int32 InIndex);

	int32 GetIndexByString(const class FText& SearchString) const;
	const class FText GetString() const;
	int32 GetStringIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemStringArray">();
	}
	static class ADebuggingItemStringArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemStringArray>();
	}
};
static_assert(alignof(ADebuggingItemStringArray) == 0x000008, "Wrong alignment on ADebuggingItemStringArray");
static_assert(sizeof(ADebuggingItemStringArray) == 0x000308, "Wrong size on ADebuggingItemStringArray");
static_assert(offsetof(ADebuggingItemStringArray, OnChanged) == 0x0002C8, "Member 'ADebuggingItemStringArray::OnChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemStringArray, OnComboBoxSettingChanged) == 0x0002D8, "Member 'ADebuggingItemStringArray::OnComboBoxSettingChanged' has a wrong offset!");
static_assert(offsetof(ADebuggingItemStringArray, StringArray) == 0x0002E8, "Member 'ADebuggingItemStringArray::StringArray' has a wrong offset!");
static_assert(offsetof(ADebuggingItemStringArray, Index_DebuggingItemStringArray) == 0x0002F8, "Member 'ADebuggingItemStringArray::Index_DebuggingItemStringArray' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsSpawnState_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_Enemy_IsSpawnState_Native final : public UBTDecoratorEnemyBase
{
public:
	Enum_EnemySpawnStateNative                    State;                                             // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2010[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsSpawnState_Native">();
	}
	static class UBTD_Enemy_IsSpawnState_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsSpawnState_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsSpawnState_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsSpawnState_Native");
static_assert(sizeof(UBTD_Enemy_IsSpawnState_Native) == 0x0000B0, "Wrong size on UBTD_Enemy_IsSpawnState_Native");
static_assert(offsetof(UBTD_Enemy_IsSpawnState_Native, State) == 0x0000A8, "Member 'UBTD_Enemy_IsSpawnState_Native::State' has a wrong offset!");

// Class BattlePrototype.UIGameOver
// 0x00D0 (0x0458 - 0x0388)
class UUIGameOver : public UUIBase
{
public:
	int32                                         DefaultIndex;                                      // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2011[0xCC];                                    // 0x038C(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetTargetBossID();
	void InitializeIndex(int32 Param_Index, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimDecision);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOutRetry, class UWidgetAnimation* AnimOutTitle, class UTextBlock* TextGameOver, class UTextBlock* TextDescription, class UTextBlock* TextRetry, class UTextBlock* TextReturnToTitle, class UUIGuide* ChildKeyGuide, class UUserWidget* ChildWidget, class UWidgetAnimation* AnimChildDefault, class UWidgetAnimation* AnimChildIn, class UWidgetAnimation* AnimChildOutRetry, class UWidgetAnimation* AnimChildOutTitle);
	void StartGameOver();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	EGameOverResult GetResult() const;
	bool IsEnd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGameOver">();
	}
	static class UUIGameOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGameOver>();
	}
};
static_assert(alignof(UUIGameOver) == 0x000008, "Wrong alignment on UUIGameOver");
static_assert(sizeof(UUIGameOver) == 0x000458, "Wrong size on UUIGameOver");
static_assert(offsetof(UUIGameOver, DefaultIndex) == 0x000388, "Member 'UUIGameOver::DefaultIndex' has a wrong offset!");

// Class BattlePrototype.BTD_Enemy_IsTickEnable_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsTickEnable_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsTickEnable_Native">();
	}
	static class UBTD_Enemy_IsTickEnable_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsTickEnable_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsTickEnable_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsTickEnable_Native");
static_assert(sizeof(UBTD_Enemy_IsTickEnable_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsTickEnable_Native");

// Class BattlePrototype.BTD_Enemy_IsWander_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_Enemy_IsWander_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_Enemy_IsWander_Native">();
	}
	static class UBTD_Enemy_IsWander_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_Enemy_IsWander_Native>();
	}
};
static_assert(alignof(UBTD_Enemy_IsWander_Native) == 0x000008, "Wrong alignment on UBTD_Enemy_IsWander_Native");
static_assert(sizeof(UBTD_Enemy_IsWander_Native) == 0x0000A8, "Wrong size on UBTD_Enemy_IsWander_Native");

// Class BattlePrototype.BTD_IsEnemyBattleStart_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsEnemyBattleStart_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyBattleStart_Native">();
	}
	static class UBTD_IsEnemyBattleStart_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyBattleStart_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyBattleStart_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyBattleStart_Native");
static_assert(sizeof(UBTD_IsEnemyBattleStart_Native) == 0x0000A8, "Wrong size on UBTD_IsEnemyBattleStart_Native");

// Class BattlePrototype.OptimizeSwitchMaterialComponent
// 0x01D0 (0x0290 - 0x00C0)
class UOptimizeSwitchMaterialComponent : public UActorComponent
{
public:
	uint8                                         Pad_2013[0x98];                                    // 0x00C0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOptimizeMaterialSettingMesh>   MeshBaseSettings;                                  // 0x0158(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2014[0x110];                                   // 0x0168(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOptimizeMaterialSetting>       Settings;                                          // 0x0278(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRuntime;                                        // 0x0288(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2015[0x7];                                     // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddMesh(class UMeshComponent* InTargetMesh);
	int32 AddSwitchSetting2(const TArray<struct FOptimizeMaterialMultiCondition>& MultiConditions, const TMap<class FString, struct FOptimizeMaterialOverrideSetting>& SlotMaterials, const struct FOptimizeMaterialOverrideSetting& OtherSlotMaterial);
	void ChangeMeshLayer(class UMeshComponent* InTargetMesh, int32 MeshLayerID);
	int32 CheckNowParameters();
	int32 CheckScalarArrayParameter(const TArray<class FName>& ParameterName, const TArray<float>& ParameterValue);
	int32 CheckScalarParameter(class FName ParameterName, float ParameterValue);
	void Reset();
	void RevertBaseMaterial();
	void SetMesh(class UMeshComponent* InTargetMesh);
	void SetSwitchActivate(bool Active);

	bool IsSwitchActivate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimizeSwitchMaterialComponent">();
	}
	static class UOptimizeSwitchMaterialComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimizeSwitchMaterialComponent>();
	}
};
static_assert(alignof(UOptimizeSwitchMaterialComponent) == 0x000008, "Wrong alignment on UOptimizeSwitchMaterialComponent");
static_assert(sizeof(UOptimizeSwitchMaterialComponent) == 0x000290, "Wrong size on UOptimizeSwitchMaterialComponent");
static_assert(offsetof(UOptimizeSwitchMaterialComponent, MeshBaseSettings) == 0x000158, "Member 'UOptimizeSwitchMaterialComponent::MeshBaseSettings' has a wrong offset!");
static_assert(offsetof(UOptimizeSwitchMaterialComponent, Settings) == 0x000278, "Member 'UOptimizeSwitchMaterialComponent::Settings' has a wrong offset!");
static_assert(offsetof(UOptimizeSwitchMaterialComponent, bIsRuntime) == 0x000288, "Member 'UOptimizeSwitchMaterialComponent::bIsRuntime' has a wrong offset!");

// Class BattlePrototype.DebugPresetFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDebugPresetFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void InitalizePreset(class UObject* WorldContextObject, class FName Param_Name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugPresetFunctionLibrary">();
	}
	static class UDebugPresetFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugPresetFunctionLibrary>();
	}
};
static_assert(alignof(UDebugPresetFunctionLibrary) == 0x000008, "Wrong alignment on UDebugPresetFunctionLibrary");
static_assert(sizeof(UDebugPresetFunctionLibrary) == 0x000028, "Wrong size on UDebugPresetFunctionLibrary");

// Class BattlePrototype.BTD_IsEnemyDamageAnimKind_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsEnemyDamageAnimKind_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyDamageAnimKind                           DamageKind;                                        // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201A[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyDamageAnimKind_Native">();
	}
	static class UBTD_IsEnemyDamageAnimKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyDamageAnimKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyDamageAnimKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyDamageAnimKind_Native");
static_assert(sizeof(UBTD_IsEnemyDamageAnimKind_Native) == 0x0000B0, "Wrong size on UBTD_IsEnemyDamageAnimKind_Native");
static_assert(offsetof(UBTD_IsEnemyDamageAnimKind_Native, DamageKind) == 0x0000A8, "Member 'UBTD_IsEnemyDamageAnimKind_Native::DamageKind' has a wrong offset!");

// Class BattlePrototype.NexusDriveComponent
// 0x04C8 (0x0588 - 0x00C0)
class UNexusDriveComponent : public UActorComponent
{
public:
	TArray<E_SASKindNative>                       ActiveSasList;                                     // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<E_SASKindNative>                       ActiveNpcDriveList;                                // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<E_SASKindNative>                       DelayDriveEndCheckList;                            // 0x00E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<E_SASKindNative>                       DelayDriveEndList;                                 // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_201B[0x30];                                    // 0x0100(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchNexusDriveActivate;                        // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchNexusDriveBegin;                           // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchNexusDriveEnd;                             // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         SeeThroughParam_JustDodgeAcceptTime;               // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeeThroughParam_HealRate;                          // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeeThroughParam_NpcHealRate;                       // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeeThroughParam_AddSasGaugeRate;                   // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeeThroughParam_AddDriveGaugeRate;                 // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeeThroughParam_JustDodgeCheckScale;               // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthParam_AssasinAttack_CrashRate;              // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthParam_AssasinAttack_Cost;                   // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthParam_AssasinAttack_Knockback;              // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StealthParam_AssasinAttack_Down;                   // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetalParam_WeaponAttackRate;                       // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetalParam_DamageRemindSasTimeRate;                // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_ch0100;                     // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Fire_ch0100;                // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Electric_ch0100;            // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_ch0100;              // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_ch0100_LV2;          // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_ch0100_LV3;          // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_Fire_ch0100;         // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_Fire_ch0100_LV2;     // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_Fire_ch0100_LV3;     // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_Electric_ch0100;     // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_Electric_ch0100_LV2; // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_Electric_ch0100_LV3; // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge2_Electric_ch0100;    // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge2_Electric_ch0100_LV2; // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge2_Electric_ch0100_LV3; // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Assassin_ch0100;            // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_ch0200;                     // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Fire_ch0200;                // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Electric_ch0200;            // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_ch0200;              // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_Fire_ch0200;         // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge2_Fire_ch0200;        // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Charge_Electric_ch0200;     // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DamageRate_Assassin_ch0200;            // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_ch0100;                      // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Fire_ch0100;                 // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Electric_ch0100;             // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_ch0100;               // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_ch0100_LV2;           // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_ch0100_LV3;           // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Fire_ch0100;          // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Fire_ch0100_LV2;      // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Fire_ch0100_LV3;      // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Electric_ch0100;      // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Electric_ch0100_LV2;  // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Electric_ch0100_LV3;  // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge2_Electric_ch0100;     // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge2_Electric_ch0100_LV2; // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge2_Electric_ch0100_LV3; // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Assassin_ch0100;             // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_ch0200;                      // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Fire_ch0200;                 // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Electric_ch0200;             // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_ch0200;               // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Fire_ch0200;          // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge2_Fire_ch0200;         // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Electric_ch0200;      // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Assassin_ch0200;             // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_ch0100;                      // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Fire_ch0100;                 // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Electric_ch0100;             // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_ch0100;               // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_ch0100_LV2;           // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_ch0100_LV3;           // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Fire_ch0100;          // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Fire_ch0100_LV2;      // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Fire_ch0100_LV3;      // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Electric_ch0100;      // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Electric_ch0100_LV2;  // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Electric_ch0100_LV3;  // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge2_Electric_ch0100;     // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge2_Electric_ch0100_LV2; // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge2_Electric_ch0100_LV3; // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Assassin_ch0100;             // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_ch0200;                      // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Fire_ch0200;                 // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Electric_ch0200;             // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_ch0200;               // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Fire_ch0200;          // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge2_Fire_ch0200;         // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Electric_ch0200;      // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Assassin_ch0200;             // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_ch0100;                  // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Fire_ch0100;             // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Electric_ch0100;         // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_ch0100;           // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_ch0100_LV2;       // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_ch0100_LV3;       // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Fire_ch0100;      // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV2;  // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV3;  // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Electric_ch0100;  // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV2; // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV3; // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge2_Electric_ch0100; // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV2; // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV3; // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Assassin_ch0100;         // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_ch0200;                  // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Fire_ch0200;             // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Electric_ch0200;         // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_ch0200;           // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Fire_ch0200;      // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge2_Fire_ch0200;     // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Electric_ch0200;  // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Assassin_ch0200;         // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_ch0100;                       // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Fire_ch0100;                  // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Electric_ch0100;              // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_ch0100;                // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_ch0100_LV2;            // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_ch0100_LV3;            // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Fire_ch0100;           // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Fire_ch0100_LV2;       // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Fire_ch0100_LV3;       // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Electric_ch0100;       // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Electric_ch0100_LV2;   // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Electric_ch0100_LV3;   // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge2_Electric_ch0100;      // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge2_Electric_ch0100_LV2;  // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge2_Electric_ch0100_LV3;  // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Assassin_ch0100;              // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_ch0200;                       // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Fire_ch0200;                  // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Electric_ch0200;              // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_ch0200;                // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Fire_ch0200;           // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge2_Fire_ch0200;          // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Electric_ch0200;       // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Assassin_ch0200;              // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_ch0100_JewelPool;            // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Fire_ch0100_JewelPool;       // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Electric_ch0100_JewelPool;   // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_ch0100_JewelPool;     // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_ch0100_LV2_JewelPool; // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_ch0100_LV3_JewelPool; // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Fire_ch0100_JewelPool; // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Fire_ch0100_LV2_JewelPool; // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Fire_ch0100_LV3_JewelPool; // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Electric_ch0100_JewelPool; // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Electric_ch0100_LV2_JewelPool; // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Electric_ch0100_LV3_JewelPool; // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge2_Electric_ch0100_JewelPool; // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge2_Electric_ch0100_LV2_JewelPool; // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge2_Electric_ch0100_LV3_JewelPool; // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Assassin_ch0100_JewelPool;   // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_ch0200_JewelPool;            // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Fire_ch0200_JewelPool;       // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Electric_ch0200_JewelPool;   // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_ch0200_JewelPool;     // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Fire_ch0200_JewelPool; // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge2_Fire_ch0200_JewelPool; // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Charge_Electric_ch0200_JewelPool; // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_CrashRate_Assassin_ch0200_JewelPool;   // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_ch0100_JewelPool;            // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Fire_ch0100_JewelPool;       // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Electric_ch0100_JewelPool;   // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_ch0100_JewelPool;     // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_ch0100_LV2_JewelPool; // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_ch0100_LV3_JewelPool; // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Fire_ch0100_JewelPool; // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Fire_ch0100_LV2_JewelPool; // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Fire_ch0100_LV3_JewelPool; // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Electric_ch0100_JewelPool; // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Electric_ch0100_LV2_JewelPool; // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Electric_ch0100_LV3_JewelPool; // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge2_Electric_ch0100_JewelPool; // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge2_Electric_ch0100_LV2_JewelPool; // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge2_Electric_ch0100_LV3_JewelPool; // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Assassin_ch0100_JewelPool;   // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_ch0200_JewelPool;            // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Fire_ch0200_JewelPool;       // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Electric_ch0200_JewelPool;   // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_ch0200_JewelPool;     // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Fire_ch0200_JewelPool; // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge2_Fire_ch0200_JewelPool; // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Charge_Electric_ch0200_JewelPool; // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_WinceRate_Assassin_ch0200_JewelPool;   // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_ch0100_JewelPool;        // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Fire_ch0100_JewelPool;   // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Electric_ch0100_JewelPool; // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_ch0100_JewelPool; // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_ch0100_LV2_JewelPool; // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_ch0100_LV3_JewelPool; // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Fire_ch0100_JewelPool; // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV2_JewelPool; // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV3_JewelPool; // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Electric_ch0100_JewelPool; // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV2_JewelPool; // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV3_JewelPool; // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge2_Electric_ch0100_JewelPool; // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV2_JewelPool; // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV3_JewelPool; // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Assassin_ch0100_JewelPool; // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_ch0200_JewelPool;        // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Fire_ch0200_JewelPool;   // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Electric_ch0200_JewelPool; // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_ch0200_JewelPool; // 0x047C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Fire_ch0200_JewelPool; // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge2_Fire_ch0200_JewelPool; // 0x0484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Charge_Electric_ch0200_JewelPool; // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_KnockbackRate_Assassin_ch0200_JewelPool; // 0x048C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_ch0100_JewelPool;             // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Fire_ch0100_JewelPool;        // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Electric_ch0100_JewelPool;    // 0x0498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_ch0100_JewelPool;      // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_ch0100_LV2_JewelPool;  // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_ch0100_LV3_JewelPool;  // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Fire_ch0100_JewelPool; // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Fire_ch0100_LV2_JewelPool; // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Fire_ch0100_LV3_JewelPool; // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Electric_ch0100_JewelPool; // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Electric_ch0100_LV2_JewelPool; // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Electric_ch0100_LV3_JewelPool; // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge2_Electric_ch0100_JewelPool; // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge2_Electric_ch0100_LV2_JewelPool; // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge2_Electric_ch0100_LV3_JewelPool; // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Assassin_ch0100_JewelPool;    // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_ch0200_JewelPool;             // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Fire_ch0200_JewelPool;        // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Electric_ch0200_JewelPool;    // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_ch0200_JewelPool;      // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Fire_ch0200_JewelPool; // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge2_Fire_ch0200_JewelPool; // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Charge_Electric_ch0200_JewelPool; // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TelepoParam_DownRate_Assassin_ch0200_JewelPool;    // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceleratorParam_WeaponDamageRate;                 // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceleratorParam_ExtendSasTime;                    // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceleratorParam_ExtendSasTimeLimit;               // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychicParam_PsychicFieldCostRate;                 // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychicParam_PsychicField_Down;                    // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSec_Psychic;                             // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSecWith_Psychic;                         // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSec_Fire;                                // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSecWith_Fire;                            // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSec_Metal;                               // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSecWith_Metal;                           // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSec_SeeThrough;                          // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSecWith_SeeThrough;                      // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSec_Telepo;                              // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSecWith_Telepo;                          // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSec_Stealth;                             // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSecWith_Stealth;                         // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSec_Electric;                            // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSecWith_Electric;                        // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSec_Copy;                                // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSecWith_Copy;                            // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSec_Accelarator;                         // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationSecWith_Accelarator;                     // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealHPRate_Weapon_ch0100;                          // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealHPRate_Psychic_ch0100;                         // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealHPRate_Weapon_ch0200;                          // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealHPRate_Psychic_ch0200;                         // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost;                             // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch0100;                      // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch0200;                      // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch0300;                      // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch0400;                      // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch0500;                      // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch0600;                      // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch0700;                      // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch0800;                      // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch0900;                      // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CombinationVisionCost_ch1000;                      // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetAcceleratorExtendTime(float ElapsedTime);
	float GetAttackHitHealRate(const struct FHCHitResult& HitResult);
	float GetCombinationVisionCostRate(E_SASKindNative SasKind);
	bool GetNexusDriveTelepoParam(float* OutDamageRate, float* OutCrashRate, float* OutWinceRate, float* OutKnockbackRate, float* OutDownRate, const struct FHCSkillCommonInfo& InSkill, bool bInJewelPool);
	void GetSasActivationSec(bool* bEanble, float* OutActivationSec, E_SASKindNative SasKind, bool bBattleMember);
	bool IsEnableNexusDriveSas(E_SASKindNative SasKind);
	bool IsEnableNexusDriveSasAny();
	bool IsRegisterActiveDriveNpc(EPlayerID PlayerId);
	bool IsRegisterActiveSasKind(E_SASKindNative SasKind);
	bool IsRegisterActiveSasKindAny();
	void RegisterActiveDriveNpc(EPlayerID PlayerId);
	void RegisterActiveSasKind(E_SASKindNative SasKind);
	void RegisterDelayDriveEnd(EPlayerID PlayerId);
	void ResetAcceleratorExtendTime();
	void SetAttackComboData(int32 InChargeSkillLevel, bool bInChargeAttackSasChange);
	void SetChargeAttackLevel(int32 InChargeAttackLevel);
	void UnregisterActiveDriveNpc(EPlayerID PlayerId);
	void UnregisterActiveSasKind(E_SASKindNative SasKind);
	void UnregisterDelayDriveEnd(EPlayerID PlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NexusDriveComponent">();
	}
	static class UNexusDriveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNexusDriveComponent>();
	}
};
static_assert(alignof(UNexusDriveComponent) == 0x000008, "Wrong alignment on UNexusDriveComponent");
static_assert(sizeof(UNexusDriveComponent) == 0x000588, "Wrong size on UNexusDriveComponent");
static_assert(offsetof(UNexusDriveComponent, ActiveSasList) == 0x0000C0, "Member 'UNexusDriveComponent::ActiveSasList' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActiveNpcDriveList) == 0x0000D0, "Member 'UNexusDriveComponent::ActiveNpcDriveList' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, DelayDriveEndCheckList) == 0x0000E0, "Member 'UNexusDriveComponent::DelayDriveEndCheckList' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, DelayDriveEndList) == 0x0000F0, "Member 'UNexusDriveComponent::DelayDriveEndList' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, DispatchNexusDriveActivate) == 0x000130, "Member 'UNexusDriveComponent::DispatchNexusDriveActivate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, DispatchNexusDriveBegin) == 0x000140, "Member 'UNexusDriveComponent::DispatchNexusDriveBegin' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, DispatchNexusDriveEnd) == 0x000150, "Member 'UNexusDriveComponent::DispatchNexusDriveEnd' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, SeeThroughParam_JustDodgeAcceptTime) == 0x000160, "Member 'UNexusDriveComponent::SeeThroughParam_JustDodgeAcceptTime' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, SeeThroughParam_HealRate) == 0x000164, "Member 'UNexusDriveComponent::SeeThroughParam_HealRate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, SeeThroughParam_NpcHealRate) == 0x000168, "Member 'UNexusDriveComponent::SeeThroughParam_NpcHealRate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, SeeThroughParam_AddSasGaugeRate) == 0x00016C, "Member 'UNexusDriveComponent::SeeThroughParam_AddSasGaugeRate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, SeeThroughParam_AddDriveGaugeRate) == 0x000170, "Member 'UNexusDriveComponent::SeeThroughParam_AddDriveGaugeRate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, SeeThroughParam_JustDodgeCheckScale) == 0x000174, "Member 'UNexusDriveComponent::SeeThroughParam_JustDodgeCheckScale' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, StealthParam_AssasinAttack_CrashRate) == 0x000178, "Member 'UNexusDriveComponent::StealthParam_AssasinAttack_CrashRate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, StealthParam_AssasinAttack_Cost) == 0x00017C, "Member 'UNexusDriveComponent::StealthParam_AssasinAttack_Cost' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, StealthParam_AssasinAttack_Knockback) == 0x000180, "Member 'UNexusDriveComponent::StealthParam_AssasinAttack_Knockback' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, StealthParam_AssasinAttack_Down) == 0x000184, "Member 'UNexusDriveComponent::StealthParam_AssasinAttack_Down' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, MetalParam_WeaponAttackRate) == 0x000188, "Member 'UNexusDriveComponent::MetalParam_WeaponAttackRate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, MetalParam_DamageRemindSasTimeRate) == 0x00018C, "Member 'UNexusDriveComponent::MetalParam_DamageRemindSasTimeRate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_ch0100) == 0x000190, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Fire_ch0100) == 0x000194, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Electric_ch0100) == 0x000198, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_ch0100) == 0x00019C, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_ch0100_LV2) == 0x0001A0, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_ch0100_LV3) == 0x0001A4, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_Fire_ch0100) == 0x0001A8, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_Fire_ch0100_LV2) == 0x0001AC, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_Fire_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_Fire_ch0100_LV3) == 0x0001B0, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_Fire_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_Electric_ch0100) == 0x0001B4, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_Electric_ch0100_LV2) == 0x0001B8, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_Electric_ch0100_LV3) == 0x0001BC, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge2_Electric_ch0100) == 0x0001C0, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge2_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge2_Electric_ch0100_LV2) == 0x0001C4, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge2_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge2_Electric_ch0100_LV3) == 0x0001C8, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge2_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Assassin_ch0100) == 0x0001CC, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Assassin_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_ch0200) == 0x0001D0, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Fire_ch0200) == 0x0001D4, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Electric_ch0200) == 0x0001D8, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_ch0200) == 0x0001DC, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_Fire_ch0200) == 0x0001E0, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge2_Fire_ch0200) == 0x0001E4, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge2_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Charge_Electric_ch0200) == 0x0001E8, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Charge_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DamageRate_Assassin_ch0200) == 0x0001EC, "Member 'UNexusDriveComponent::TelepoParam_DamageRate_Assassin_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_ch0100) == 0x0001F0, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Fire_ch0100) == 0x0001F4, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Electric_ch0100) == 0x0001F8, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_ch0100) == 0x0001FC, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_ch0100_LV2) == 0x000200, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_ch0100_LV3) == 0x000204, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Fire_ch0100) == 0x000208, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Fire_ch0100_LV2) == 0x00020C, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Fire_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Fire_ch0100_LV3) == 0x000210, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Fire_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Electric_ch0100) == 0x000214, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Electric_ch0100_LV2) == 0x000218, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Electric_ch0100_LV3) == 0x00021C, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge2_Electric_ch0100) == 0x000220, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge2_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge2_Electric_ch0100_LV2) == 0x000224, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge2_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge2_Electric_ch0100_LV3) == 0x000228, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge2_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Assassin_ch0100) == 0x00022C, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Assassin_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_ch0200) == 0x000230, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Fire_ch0200) == 0x000234, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Electric_ch0200) == 0x000238, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_ch0200) == 0x00023C, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Fire_ch0200) == 0x000240, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge2_Fire_ch0200) == 0x000244, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge2_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Electric_ch0200) == 0x000248, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Assassin_ch0200) == 0x00024C, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Assassin_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_ch0100) == 0x000250, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Fire_ch0100) == 0x000254, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Electric_ch0100) == 0x000258, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_ch0100) == 0x00025C, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_ch0100_LV2) == 0x000260, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_ch0100_LV3) == 0x000264, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Fire_ch0100) == 0x000268, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Fire_ch0100_LV2) == 0x00026C, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Fire_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Fire_ch0100_LV3) == 0x000270, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Fire_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Electric_ch0100) == 0x000274, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Electric_ch0100_LV2) == 0x000278, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Electric_ch0100_LV3) == 0x00027C, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge2_Electric_ch0100) == 0x000280, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge2_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge2_Electric_ch0100_LV2) == 0x000284, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge2_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge2_Electric_ch0100_LV3) == 0x000288, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge2_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Assassin_ch0100) == 0x00028C, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Assassin_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_ch0200) == 0x000290, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Fire_ch0200) == 0x000294, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Electric_ch0200) == 0x000298, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_ch0200) == 0x00029C, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Fire_ch0200) == 0x0002A0, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge2_Fire_ch0200) == 0x0002A4, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge2_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Electric_ch0200) == 0x0002A8, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Assassin_ch0200) == 0x0002AC, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Assassin_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_ch0100) == 0x0002B0, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Fire_ch0100) == 0x0002B4, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Electric_ch0100) == 0x0002B8, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_ch0100) == 0x0002BC, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_ch0100_LV2) == 0x0002C0, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_ch0100_LV3) == 0x0002C4, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Fire_ch0100) == 0x0002C8, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV2) == 0x0002CC, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV3) == 0x0002D0, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Electric_ch0100) == 0x0002D4, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV2) == 0x0002D8, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV3) == 0x0002DC, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge2_Electric_ch0100) == 0x0002E0, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge2_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV2) == 0x0002E4, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV3) == 0x0002E8, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Assassin_ch0100) == 0x0002EC, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Assassin_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_ch0200) == 0x0002F0, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Fire_ch0200) == 0x0002F4, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Electric_ch0200) == 0x0002F8, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_ch0200) == 0x0002FC, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Fire_ch0200) == 0x000300, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge2_Fire_ch0200) == 0x000304, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge2_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Electric_ch0200) == 0x000308, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Assassin_ch0200) == 0x00030C, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Assassin_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_ch0100) == 0x000310, "Member 'UNexusDriveComponent::TelepoParam_DownRate_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Fire_ch0100) == 0x000314, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Electric_ch0100) == 0x000318, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_ch0100) == 0x00031C, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_ch0100_LV2) == 0x000320, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_ch0100_LV3) == 0x000324, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Fire_ch0100) == 0x000328, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Fire_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Fire_ch0100_LV2) == 0x00032C, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Fire_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Fire_ch0100_LV3) == 0x000330, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Fire_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Electric_ch0100) == 0x000334, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Electric_ch0100_LV2) == 0x000338, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Electric_ch0100_LV3) == 0x00033C, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge2_Electric_ch0100) == 0x000340, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge2_Electric_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge2_Electric_ch0100_LV2) == 0x000344, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge2_Electric_ch0100_LV2' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge2_Electric_ch0100_LV3) == 0x000348, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge2_Electric_ch0100_LV3' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Assassin_ch0100) == 0x00034C, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Assassin_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_ch0200) == 0x000350, "Member 'UNexusDriveComponent::TelepoParam_DownRate_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Fire_ch0200) == 0x000354, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Electric_ch0200) == 0x000358, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_ch0200) == 0x00035C, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Fire_ch0200) == 0x000360, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge2_Fire_ch0200) == 0x000364, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge2_Fire_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Electric_ch0200) == 0x000368, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Electric_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Assassin_ch0200) == 0x00036C, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Assassin_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_ch0100_JewelPool) == 0x000370, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Fire_ch0100_JewelPool) == 0x000374, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Fire_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Electric_ch0100_JewelPool) == 0x000378, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_ch0100_JewelPool) == 0x00037C, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_ch0100_LV2_JewelPool) == 0x000380, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_ch0100_LV3_JewelPool) == 0x000384, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Fire_ch0100_JewelPool) == 0x000388, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Fire_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Fire_ch0100_LV2_JewelPool) == 0x00038C, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Fire_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Fire_ch0100_LV3_JewelPool) == 0x000390, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Fire_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Electric_ch0100_JewelPool) == 0x000394, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Electric_ch0100_LV2_JewelPool) == 0x000398, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Electric_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Electric_ch0100_LV3_JewelPool) == 0x00039C, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Electric_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge2_Electric_ch0100_JewelPool) == 0x0003A0, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge2_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge2_Electric_ch0100_LV2_JewelPool) == 0x0003A4, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge2_Electric_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge2_Electric_ch0100_LV3_JewelPool) == 0x0003A8, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge2_Electric_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Assassin_ch0100_JewelPool) == 0x0003AC, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Assassin_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_ch0200_JewelPool) == 0x0003B0, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Fire_ch0200_JewelPool) == 0x0003B4, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Electric_ch0200_JewelPool) == 0x0003B8, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Electric_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_ch0200_JewelPool) == 0x0003BC, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Fire_ch0200_JewelPool) == 0x0003C0, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge2_Fire_ch0200_JewelPool) == 0x0003C4, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge2_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Charge_Electric_ch0200_JewelPool) == 0x0003C8, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Charge_Electric_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_CrashRate_Assassin_ch0200_JewelPool) == 0x0003CC, "Member 'UNexusDriveComponent::TelepoParam_CrashRate_Assassin_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_ch0100_JewelPool) == 0x0003D0, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Fire_ch0100_JewelPool) == 0x0003D4, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Fire_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Electric_ch0100_JewelPool) == 0x0003D8, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_ch0100_JewelPool) == 0x0003DC, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_ch0100_LV2_JewelPool) == 0x0003E0, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_ch0100_LV3_JewelPool) == 0x0003E4, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Fire_ch0100_JewelPool) == 0x0003E8, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Fire_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Fire_ch0100_LV2_JewelPool) == 0x0003EC, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Fire_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Fire_ch0100_LV3_JewelPool) == 0x0003F0, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Fire_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Electric_ch0100_JewelPool) == 0x0003F4, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Electric_ch0100_LV2_JewelPool) == 0x0003F8, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Electric_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Electric_ch0100_LV3_JewelPool) == 0x0003FC, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Electric_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge2_Electric_ch0100_JewelPool) == 0x000400, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge2_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge2_Electric_ch0100_LV2_JewelPool) == 0x000404, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge2_Electric_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge2_Electric_ch0100_LV3_JewelPool) == 0x000408, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge2_Electric_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Assassin_ch0100_JewelPool) == 0x00040C, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Assassin_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_ch0200_JewelPool) == 0x000410, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Fire_ch0200_JewelPool) == 0x000414, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Electric_ch0200_JewelPool) == 0x000418, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Electric_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_ch0200_JewelPool) == 0x00041C, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Fire_ch0200_JewelPool) == 0x000420, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge2_Fire_ch0200_JewelPool) == 0x000424, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge2_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Charge_Electric_ch0200_JewelPool) == 0x000428, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Charge_Electric_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_WinceRate_Assassin_ch0200_JewelPool) == 0x00042C, "Member 'UNexusDriveComponent::TelepoParam_WinceRate_Assassin_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_ch0100_JewelPool) == 0x000430, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Fire_ch0100_JewelPool) == 0x000434, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Fire_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Electric_ch0100_JewelPool) == 0x000438, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_ch0100_JewelPool) == 0x00043C, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_ch0100_LV2_JewelPool) == 0x000440, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_ch0100_LV3_JewelPool) == 0x000444, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Fire_ch0100_JewelPool) == 0x000448, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Fire_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV2_JewelPool) == 0x00044C, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV3_JewelPool) == 0x000450, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Fire_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Electric_ch0100_JewelPool) == 0x000454, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV2_JewelPool) == 0x000458, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV3_JewelPool) == 0x00045C, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Electric_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge2_Electric_ch0100_JewelPool) == 0x000460, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge2_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV2_JewelPool) == 0x000464, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV3_JewelPool) == 0x000468, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge2_Electric_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Assassin_ch0100_JewelPool) == 0x00046C, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Assassin_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_ch0200_JewelPool) == 0x000470, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Fire_ch0200_JewelPool) == 0x000474, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Electric_ch0200_JewelPool) == 0x000478, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Electric_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_ch0200_JewelPool) == 0x00047C, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Fire_ch0200_JewelPool) == 0x000480, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge2_Fire_ch0200_JewelPool) == 0x000484, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge2_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Charge_Electric_ch0200_JewelPool) == 0x000488, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Charge_Electric_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_KnockbackRate_Assassin_ch0200_JewelPool) == 0x00048C, "Member 'UNexusDriveComponent::TelepoParam_KnockbackRate_Assassin_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_ch0100_JewelPool) == 0x000490, "Member 'UNexusDriveComponent::TelepoParam_DownRate_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Fire_ch0100_JewelPool) == 0x000494, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Fire_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Electric_ch0100_JewelPool) == 0x000498, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_ch0100_JewelPool) == 0x00049C, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_ch0100_LV2_JewelPool) == 0x0004A0, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_ch0100_LV3_JewelPool) == 0x0004A4, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Fire_ch0100_JewelPool) == 0x0004A8, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Fire_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Fire_ch0100_LV2_JewelPool) == 0x0004AC, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Fire_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Fire_ch0100_LV3_JewelPool) == 0x0004B0, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Fire_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Electric_ch0100_JewelPool) == 0x0004B4, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Electric_ch0100_LV2_JewelPool) == 0x0004B8, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Electric_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Electric_ch0100_LV3_JewelPool) == 0x0004BC, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Electric_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge2_Electric_ch0100_JewelPool) == 0x0004C0, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge2_Electric_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge2_Electric_ch0100_LV2_JewelPool) == 0x0004C4, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge2_Electric_ch0100_LV2_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge2_Electric_ch0100_LV3_JewelPool) == 0x0004C8, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge2_Electric_ch0100_LV3_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Assassin_ch0100_JewelPool) == 0x0004CC, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Assassin_ch0100_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_ch0200_JewelPool) == 0x0004D0, "Member 'UNexusDriveComponent::TelepoParam_DownRate_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Fire_ch0200_JewelPool) == 0x0004D4, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Electric_ch0200_JewelPool) == 0x0004D8, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Electric_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_ch0200_JewelPool) == 0x0004DC, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Fire_ch0200_JewelPool) == 0x0004E0, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge2_Fire_ch0200_JewelPool) == 0x0004E4, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge2_Fire_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Charge_Electric_ch0200_JewelPool) == 0x0004E8, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Charge_Electric_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, TelepoParam_DownRate_Assassin_ch0200_JewelPool) == 0x0004EC, "Member 'UNexusDriveComponent::TelepoParam_DownRate_Assassin_ch0200_JewelPool' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, AcceleratorParam_WeaponDamageRate) == 0x0004F0, "Member 'UNexusDriveComponent::AcceleratorParam_WeaponDamageRate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, AcceleratorParam_ExtendSasTime) == 0x0004F4, "Member 'UNexusDriveComponent::AcceleratorParam_ExtendSasTime' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, AcceleratorParam_ExtendSasTimeLimit) == 0x0004F8, "Member 'UNexusDriveComponent::AcceleratorParam_ExtendSasTimeLimit' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, PsychicParam_PsychicFieldCostRate) == 0x0004FC, "Member 'UNexusDriveComponent::PsychicParam_PsychicFieldCostRate' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, PsychicParam_PsychicField_Down) == 0x000500, "Member 'UNexusDriveComponent::PsychicParam_PsychicField_Down' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSec_Psychic) == 0x000504, "Member 'UNexusDriveComponent::ActivationSec_Psychic' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSecWith_Psychic) == 0x000508, "Member 'UNexusDriveComponent::ActivationSecWith_Psychic' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSec_Fire) == 0x00050C, "Member 'UNexusDriveComponent::ActivationSec_Fire' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSecWith_Fire) == 0x000510, "Member 'UNexusDriveComponent::ActivationSecWith_Fire' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSec_Metal) == 0x000514, "Member 'UNexusDriveComponent::ActivationSec_Metal' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSecWith_Metal) == 0x000518, "Member 'UNexusDriveComponent::ActivationSecWith_Metal' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSec_SeeThrough) == 0x00051C, "Member 'UNexusDriveComponent::ActivationSec_SeeThrough' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSecWith_SeeThrough) == 0x000520, "Member 'UNexusDriveComponent::ActivationSecWith_SeeThrough' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSec_Telepo) == 0x000524, "Member 'UNexusDriveComponent::ActivationSec_Telepo' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSecWith_Telepo) == 0x000528, "Member 'UNexusDriveComponent::ActivationSecWith_Telepo' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSec_Stealth) == 0x00052C, "Member 'UNexusDriveComponent::ActivationSec_Stealth' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSecWith_Stealth) == 0x000530, "Member 'UNexusDriveComponent::ActivationSecWith_Stealth' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSec_Electric) == 0x000534, "Member 'UNexusDriveComponent::ActivationSec_Electric' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSecWith_Electric) == 0x000538, "Member 'UNexusDriveComponent::ActivationSecWith_Electric' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSec_Copy) == 0x00053C, "Member 'UNexusDriveComponent::ActivationSec_Copy' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSecWith_Copy) == 0x000540, "Member 'UNexusDriveComponent::ActivationSecWith_Copy' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSec_Accelarator) == 0x000544, "Member 'UNexusDriveComponent::ActivationSec_Accelarator' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, ActivationSecWith_Accelarator) == 0x000548, "Member 'UNexusDriveComponent::ActivationSecWith_Accelarator' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, HealHPRate_Weapon_ch0100) == 0x00054C, "Member 'UNexusDriveComponent::HealHPRate_Weapon_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, HealHPRate_Psychic_ch0100) == 0x000550, "Member 'UNexusDriveComponent::HealHPRate_Psychic_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, HealHPRate_Weapon_ch0200) == 0x000554, "Member 'UNexusDriveComponent::HealHPRate_Weapon_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, HealHPRate_Psychic_ch0200) == 0x000558, "Member 'UNexusDriveComponent::HealHPRate_Psychic_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost) == 0x00055C, "Member 'UNexusDriveComponent::CombinationVisionCost' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch0100) == 0x000560, "Member 'UNexusDriveComponent::CombinationVisionCost_ch0100' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch0200) == 0x000564, "Member 'UNexusDriveComponent::CombinationVisionCost_ch0200' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch0300) == 0x000568, "Member 'UNexusDriveComponent::CombinationVisionCost_ch0300' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch0400) == 0x00056C, "Member 'UNexusDriveComponent::CombinationVisionCost_ch0400' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch0500) == 0x000570, "Member 'UNexusDriveComponent::CombinationVisionCost_ch0500' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch0600) == 0x000574, "Member 'UNexusDriveComponent::CombinationVisionCost_ch0600' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch0700) == 0x000578, "Member 'UNexusDriveComponent::CombinationVisionCost_ch0700' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch0800) == 0x00057C, "Member 'UNexusDriveComponent::CombinationVisionCost_ch0800' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch0900) == 0x000580, "Member 'UNexusDriveComponent::CombinationVisionCost_ch0900' has a wrong offset!");
static_assert(offsetof(UNexusDriveComponent, CombinationVisionCost_ch1000) == 0x000584, "Member 'UNexusDriveComponent::CombinationVisionCost_ch1000' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyDamageDownAnimKind_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsEnemyDamageDownAnimKind_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyDamageDownAnimKind                       DamageDownKind;                                    // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2023[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyDamageDownAnimKind_Native">();
	}
	static class UBTD_IsEnemyDamageDownAnimKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyDamageDownAnimKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyDamageDownAnimKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyDamageDownAnimKind_Native");
static_assert(sizeof(UBTD_IsEnemyDamageDownAnimKind_Native) == 0x0000B0, "Wrong size on UBTD_IsEnemyDamageDownAnimKind_Native");
static_assert(offsetof(UBTD_IsEnemyDamageDownAnimKind_Native, DamageDownKind) == 0x0000A8, "Member 'UBTD_IsEnemyDamageDownAnimKind_Native::DamageDownKind' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyDamageStopAnimKind_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsEnemyDamageStopAnimKind_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyDamageStopAnimKind_Native">();
	}
	static class UBTD_IsEnemyDamageStopAnimKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyDamageStopAnimKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyDamageStopAnimKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyDamageStopAnimKind_Native");
static_assert(sizeof(UBTD_IsEnemyDamageStopAnimKind_Native) == 0x0000A8, "Wrong size on UBTD_IsEnemyDamageStopAnimKind_Native");

// Class BattlePrototype.UIEquipParts5
// 0x0010 (0x0398 - 0x0388)
class UUIEquipParts5 : public UUIBase
{
public:
	class UFlagManager*                           FlagManager;                                       // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2024[0x8];                                     // 0x0390(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ClearCurrentNewFlagNative(int32 Param_Index);
	void InitializeList(class UREDScrollBox* ScrollBox);
	bool IsUpdateEquipListMouseFocus(int32* CursorIndex);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);

	int32 StringCompare(const class FString& String1, const class FString& String2) const;
	int32 TextCompare(const class FText& Text1, const class FText& Text2) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEquipParts5">();
	}
	static class UUIEquipParts5* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEquipParts5>();
	}
};
static_assert(alignof(UUIEquipParts5) == 0x000008, "Wrong alignment on UUIEquipParts5");
static_assert(sizeof(UUIEquipParts5) == 0x000398, "Wrong size on UUIEquipParts5");
static_assert(offsetof(UUIEquipParts5, FlagManager) == 0x000388, "Member 'UUIEquipParts5::FlagManager' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyKind_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsEnemyKind_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyKind                                     _EnemyKind;                                        // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2029[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyKind_Native">();
	}
	static class UBTD_IsEnemyKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyKind_Native");
static_assert(sizeof(UBTD_IsEnemyKind_Native) == 0x0000B0, "Wrong size on UBTD_IsEnemyKind_Native");
static_assert(offsetof(UBTD_IsEnemyKind_Native, _EnemyKind) == 0x0000A8, "Member 'UBTD_IsEnemyKind_Native::_EnemyKind' has a wrong offset!");

// Class BattlePrototype.DebuggingStatsManager
// 0x0030 (0x0058 - 0x0028)
class UDebuggingStatsManager final : public UObject
{
public:
	uint8                                         Pad_202A[0x30];                                    // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingStatsManager">();
	}
	static class UDebuggingStatsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebuggingStatsManager>();
	}
};
static_assert(alignof(UDebuggingStatsManager) == 0x000008, "Wrong alignment on UDebuggingStatsManager");
static_assert(sizeof(UDebuggingStatsManager) == 0x000058, "Wrong size on UDebuggingStatsManager");

// Class BattlePrototype.BTD_IsEnemyStopAnimKind_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsEnemyStopAnimKind_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyStopAnimKind_Native">();
	}
	static class UBTD_IsEnemyStopAnimKind_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyStopAnimKind_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyStopAnimKind_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyStopAnimKind_Native");
static_assert(sizeof(UBTD_IsEnemyStopAnimKind_Native) == 0x0000A8, "Wrong size on UBTD_IsEnemyStopAnimKind_Native");

// Class BattlePrototype.TriggerEffectManager
// 0x0120 (0x0350 - 0x0230)
class ATriggerEffectManager : public AActor
{
public:
	uint8                                         Pad_202B[0x90];                                    // 0x0230(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_directShotPsyObj;                                // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_202C[0x88];                                    // 0x02C8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePanRatioOfPadEffect(float PadPanRatio);
	void ClearTriggerEffect();
	void EraseDirectShotPsyObj();
	void EraseTargetMeshComponent();
	void IgnoreCompatibleVibration(bool Flag);
	void IncorporateOffModeIntoTriggerEffect(bool IsOffMode);
	bool IsPadEffectPlaying();
	bool IsTriggerEffectOff(int32 Lr);
	bool IsTriggerEffectStopped(int32 Lr);
	bool IsTriggerInputStatus(int32 Lr);
	void Load(const class FString& GroupName, const class FString& Filename, EVibSndPrio Prio);
	void LoadHDB(const class FString& GroupName, const class FString& Filename);
	void PausePadEffect();
	void PlayEmulateCompatibleVibration(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused);
	void PlayHaptics(const class FString& Filename, EVibSndMode Svmode, class AActor* Sndowner);
	void PlayPadEffect(const class FString& Filename, float Wavvol, float Vibvol, bool RoopFlag, EVibSndPrio Svprio, EVibSndMode Svmode, class AActor* Sndowner, class UMeshComponent* SndownerMesh, class FName SndownerMeshSocketName, bool IsDistanceAttenuation);
	void PlayPadEffectV01(const class FString& Filename, float Wavvol, float Vibvol, bool RoopFlag, EVibSndPrio Svprio, EVibSndMode Svmode, class AActor* Sndowner, class UMeshComponent* SndownerMesh, class FName SndownerMeshSocketName, bool IsDistanceAttenuation);
	void RegistDirectShotPsyObj(class AActor* Actor);
	void RegistTargetMeshComponent(class UMeshComponent* Mesh, class FName TargetSocketName);
	void ResumePadEffect();
	void SetCompatibleVibrationMode(bool IsCompatibleVibMode);
	void SetIsCompatibleMode2Enabled(bool IsEnable);
	void SetPadEffectBrainCrashVolume(float Vol);
	void SetPadEffectBrainFieldVolume(float Vol);
	void SetPadEffectCompatibleMode2LargeVibAfterglow(float FrameNum);
	void SetPadEffectCompatibleMode2LargeVolume(float Vol);
	void SetPadEffectCompatibleMode2MaxRotRateOfLarge(float Vol);
	void SetPadEffectCompatibleMode2MaxRotRateOfSmall(float Vol);
	void SetPadEffectCompatibleMode2MinRotRateOfLarge(float Vol);
	void SetPadEffectCompatibleMode2MinRotRateOfSmall(float Vol);
	void SetPadEffectCompatibleMode2SmallVibAfterglow(float FrameNum);
	void SetPadEffectCompatibleMode2SmallVolume(float Vol);
	void SetPadEffectCompatibleMode2Volume(float Vol);
	void SetPadEffectCompatibleModeLargeVolume(float Vol);
	void SetPadEffectCompatibleModeMasterVolume(float Vol);
	void SetPadEffectCompatibleModeSmallVolume(float Vol);
	void SetPadEffectCompatibleVolume(float Vol);
	void SetPadEffectDirectShotVolume(float Vol);
	void SetPadEffectLocationVolume(float Vol);
	void SetPadEffectMapGimmickVolume(float Vol);
	void SetPadEffectMasterVolume(float Vol);
	void SetPadEffectOuterVibrationMagnification(float Mag);
	void SetPadEffectStrengthVolume(float Vol);
	void SetPadEffectVolume(float Wavvol, float Vibvol, float Sec);
	void SetPadEffectVolumeName(const class FString& Filename, float Wavvol, float Vibvol, float Sec);
	void SetRandomFrequencyVibration(int32 Lr, uint8 Pos, uint8 Amp, uint8 MinFre, uint8 MaxFre, bool IsReleaseEnhancements);
	void SetTriggerEffect(const struct FTrgEffParam& L, const struct FTrgEffParam& R, bool LeftInitFlag, bool RightInitFlag);
	void SetTriggerEffect2(ETrgEffMode M0, uint8 V00, uint8 V01, uint8 V02, ETrgEffMode M1, uint8 V10, uint8 V11, uint8 V12);
	void SetTriggerEffectOff(int32 Lr);
	void StopEmulateCompatibleVibration(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag);
	void StopPadEffect(float Sec);
	void StopPadEffectName(const class FString& Filename, float Sec);
	void StopTriggerEffect(int32 Lr, float LingeringTime);
	void Unload(const class FString& GroupName);
	void UnloadHDB(const class FString& GroupName);
	void UpdateTriggerEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerEffectManager">();
	}
	static class ATriggerEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATriggerEffectManager>();
	}
};
static_assert(alignof(ATriggerEffectManager) == 0x000008, "Wrong alignment on ATriggerEffectManager");
static_assert(sizeof(ATriggerEffectManager) == 0x000350, "Wrong size on ATriggerEffectManager");
static_assert(offsetof(ATriggerEffectManager, M_directShotPsyObj) == 0x0002C0, "Member 'ATriggerEffectManager::M_directShotPsyObj' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyTargetNearRange_Native
// 0x0030 (0x00D8 - 0x00A8)
class UBTD_IsEnemyTargetNearRange_Native final : public UBTDecoratorEnemyBase
{
public:
	uint8                                         Pad_203B[0x28];                                    // 0x00A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearRange;                                         // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInRange;                                         // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_203C[0x3];                                     // 0x00D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyTargetNearRange_Native">();
	}
	static class UBTD_IsEnemyTargetNearRange_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyTargetNearRange_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyTargetNearRange_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyTargetNearRange_Native");
static_assert(sizeof(UBTD_IsEnemyTargetNearRange_Native) == 0x0000D8, "Wrong size on UBTD_IsEnemyTargetNearRange_Native");
static_assert(offsetof(UBTD_IsEnemyTargetNearRange_Native, NearRange) == 0x0000D0, "Member 'UBTD_IsEnemyTargetNearRange_Native::NearRange' has a wrong offset!");
static_assert(offsetof(UBTD_IsEnemyTargetNearRange_Native, IsInRange) == 0x0000D4, "Member 'UBTD_IsEnemyTargetNearRange_Native::IsInRange' has a wrong offset!");

// Class BattlePrototype.BTD_IsEnemyWait_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsEnemyWait_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsEnemyWait_Native">();
	}
	static class UBTD_IsEnemyWait_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsEnemyWait_Native>();
	}
};
static_assert(alignof(UBTD_IsEnemyWait_Native) == 0x000008, "Wrong alignment on UBTD_IsEnemyWait_Native");
static_assert(sizeof(UBTD_IsEnemyWait_Native) == 0x0000A8, "Wrong size on UBTD_IsEnemyWait_Native");

// Class BattlePrototype.DamageArrayComponent
// 0x0008 (0x00C8 - 0x00C0)
class UDamageArrayComponent final : public UActorComponent
{
public:
	uint8                                         Pad_203D[0x8];                                     // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<struct FHCHitResult> HitResultDamageSort(const TArray<struct FHCHitResult>& HitResult, bool IsDes) const;
	struct FHCHitResult HitResultMaxDamage(const TArray<struct FHCHitResult>& HitResult) const;
	TArray<struct FHCHitResult> HitResultMaxDamageMultiActor(const TArray<struct FHCHitResult>& HitResult) const;
	TArray<struct FHCHitResult> HitResultMaxDamagePriorityMultiActor(const TArray<struct FHCHitResult>& HitResult, bool* IsPartsInvinsible) const;
	bool IsRangeCheck(const struct FVector& VecStart, const struct FVector& VecEnd, const struct FVector& VecForward, float Range) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageArrayComponent">();
	}
	static class UDamageArrayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageArrayComponent>();
	}
};
static_assert(alignof(UDamageArrayComponent) == 0x000008, "Wrong alignment on UDamageArrayComponent");
static_assert(sizeof(UDamageArrayComponent) == 0x0000C8, "Wrong size on UDamageArrayComponent");

// Class BattlePrototype.BTD_IsFlyEnemy_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsFlyEnemy_Native final : public UBTDecoratorEnemyBase
{
public:
	bool                                          bIsFlying;                                         // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2041[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsFlyEnemy_Native">();
	}
	static class UBTD_IsFlyEnemy_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsFlyEnemy_Native>();
	}
};
static_assert(alignof(UBTD_IsFlyEnemy_Native) == 0x000008, "Wrong alignment on UBTD_IsFlyEnemy_Native");
static_assert(sizeof(UBTD_IsFlyEnemy_Native) == 0x0000B0, "Wrong size on UBTD_IsFlyEnemy_Native");
static_assert(offsetof(UBTD_IsFlyEnemy_Native, bIsFlying) == 0x0000A8, "Member 'UBTD_IsFlyEnemy_Native::bIsFlying' has a wrong offset!");

// Class BattlePrototype.DelegatableActor
// 0x0000 (0x0230 - 0x0230)
class ADelegatableActor final : public AActor
{
public:
	void OnPostEditChange();
	void OnPostEditMove();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelegatableActor">();
	}
	static class ADelegatableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADelegatableActor>();
	}
};
static_assert(alignof(ADelegatableActor) == 0x000008, "Wrong alignment on ADelegatableActor");
static_assert(sizeof(ADelegatableActor) == 0x000230, "Wrong size on ADelegatableActor");

// Class BattlePrototype.BTD_IsFlyType_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsFlyType_Native final : public UBTDecoratorEnemyBase
{
public:
	bool                                          bIsFlying;                                         // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2042[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsFlyType_Native">();
	}
	static class UBTD_IsFlyType_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsFlyType_Native>();
	}
};
static_assert(alignof(UBTD_IsFlyType_Native) == 0x000008, "Wrong alignment on UBTD_IsFlyType_Native");
static_assert(sizeof(UBTD_IsFlyType_Native) == 0x0000B0, "Wrong size on UBTD_IsFlyType_Native");
static_assert(offsetof(UBTD_IsFlyType_Native, bIsFlying) == 0x0000A8, "Member 'UBTD_IsFlyType_Native::bIsFlying' has a wrong offset!");

// Class BattlePrototype.NpcCommonInterface
// 0x0000 (0x0028 - 0x0028)
class INpcCommonInterface final : public IInterface
{
public:
	void ChangeAnimation(ENpcAnimationKind AnimKind);
	bool GetChangePeopleDataHidden();
	ETextGender GetNpcMeshGenderType();
	bool SetDrawMessageFacial(const class FString& MessageLabel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcCommonInterface">();
	}
	static class INpcCommonInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INpcCommonInterface>();
	}
};
static_assert(alignof(INpcCommonInterface) == 0x000008, "Wrong alignment on INpcCommonInterface");
static_assert(sizeof(INpcCommonInterface) == 0x000028, "Wrong size on INpcCommonInterface");

// Class BattlePrototype.BTD_IsInitLayout_Native
// 0x0000 (0x00A8 - 0x00A8)
class UBTD_IsInitLayout_Native final : public UBTDecoratorEnemyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsInitLayout_Native">();
	}
	static class UBTD_IsInitLayout_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsInitLayout_Native>();
	}
};
static_assert(alignof(UBTD_IsInitLayout_Native) == 0x000008, "Wrong alignment on UBTD_IsInitLayout_Native");
static_assert(sizeof(UBTD_IsInitLayout_Native) == 0x0000A8, "Wrong size on UBTD_IsInitLayout_Native");

// Class BattlePrototype.BTD_IsMoveAnim_Native
// 0x0008 (0x00B0 - 0x00A8)
class UBTD_IsMoveAnim_Native final : public UBTDecoratorEnemyBase
{
public:
	EnemyMoveAnimKind                             _MoveAnimKind;                                     // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2044[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_IsMoveAnim_Native">();
	}
	static class UBTD_IsMoveAnim_Native* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_IsMoveAnim_Native>();
	}
};
static_assert(alignof(UBTD_IsMoveAnim_Native) == 0x000008, "Wrong alignment on UBTD_IsMoveAnim_Native");
static_assert(sizeof(UBTD_IsMoveAnim_Native) == 0x0000B0, "Wrong size on UBTD_IsMoveAnim_Native");
static_assert(offsetof(UBTD_IsMoveAnim_Native, _MoveAnimKind) == 0x0000A8, "Member 'UBTD_IsMoveAnim_Native::_MoveAnimKind' has a wrong offset!");

// Class BattlePrototype.TreasureItem
// 0x0010 (0x0350 - 0x0340)
class ATreasureItem final : public AArrangeItemParticle
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent_;                            // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInitialize_;                                     // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsGetThisItem_;                                    // 0x0349(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2045[0x6];                                     // 0x034A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessAfterGetAnimFinished();
	void ProcessBeforeGetAnimBegin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TreasureItem">();
	}
	static class ATreasureItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATreasureItem>();
	}
};
static_assert(alignof(ATreasureItem) == 0x000008, "Wrong alignment on ATreasureItem");
static_assert(sizeof(ATreasureItem) == 0x000350, "Wrong size on ATreasureItem");
static_assert(offsetof(ATreasureItem, SkeletalMeshComponent_) == 0x000340, "Member 'ATreasureItem::SkeletalMeshComponent_' has a wrong offset!");
static_assert(offsetof(ATreasureItem, IsInitialize_) == 0x000348, "Member 'ATreasureItem::IsInitialize_' has a wrong offset!");
static_assert(offsetof(ATreasureItem, IsGetThisItem_) == 0x000349, "Member 'ATreasureItem::IsGetThisItem_' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerBase
// 0x0038 (0x00A0 - 0x0068)
class UBTDecorator_RSPlayerBase : public UBTDecorator
{
public:
	class AAIController*                          _AIOwner;                                          // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerScriptComponent*                 _PlayerScript;                                     // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ObservedKeyNames;                                  // 0x0078(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2046[0x10];                                    // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCheckConditionOnlyBlackBoardChanges : 1;          // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsObservingBB : 1;                                // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2047[0x7];                                     // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerBase">();
	}
	static class UBTDecorator_RSPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerBase>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerBase) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerBase");
static_assert(sizeof(UBTDecorator_RSPlayerBase) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerBase");
static_assert(offsetof(UBTDecorator_RSPlayerBase, _AIOwner) == 0x000068, "Member 'UBTDecorator_RSPlayerBase::_AIOwner' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RSPlayerBase, _PlayerScript) == 0x000070, "Member 'UBTDecorator_RSPlayerBase::_PlayerScript' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RSPlayerBase, ObservedKeyNames) == 0x000078, "Member 'UBTDecorator_RSPlayerBase::ObservedKeyNames' has a wrong offset!");

// Class BattlePrototype.FinishMoveActorManager
// 0x0050 (0x0280 - 0x0230)
class AFinishMoveActorManager : public AActor
{
public:
	uint8                                         Pad_2048[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FmActor_;                                          // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCallingEffectFinish_;                            // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2049[0xF];                                     // 0x0241(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSLevelSequenceActor*                  RsLevelSequencer_;                                 // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_204A[0x18];                                    // 0x0258(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SequencePath_;                                     // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void FinishMoveBegin();
	void FinishMoveEnd();
	void FinishMoveUpdate();
	float GetSequenceRate();
	bool PauseFinishMove();
	void PauseFinishMoveSequence();
	bool RestartFinishMove();
	void RestartFinishMoveSequence();
	void RotateCameraYawAfterEvent(float RotYaw);
	void SetSequencePlayRate(float NewRate);
	void SpawnAndSwapFinishMoveActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinishMoveActorManager">();
	}
	static class AFinishMoveActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFinishMoveActorManager>();
	}
};
static_assert(alignof(AFinishMoveActorManager) == 0x000008, "Wrong alignment on AFinishMoveActorManager");
static_assert(sizeof(AFinishMoveActorManager) == 0x000280, "Wrong size on AFinishMoveActorManager");
static_assert(offsetof(AFinishMoveActorManager, FmActor_) == 0x000238, "Member 'AFinishMoveActorManager::FmActor_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActorManager, IsCallingEffectFinish_) == 0x000240, "Member 'AFinishMoveActorManager::IsCallingEffectFinish_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActorManager, RsLevelSequencer_) == 0x000250, "Member 'AFinishMoveActorManager::RsLevelSequencer_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActorManager, SequencePath_) == 0x000270, "Member 'AFinishMoveActorManager::SequencePath_' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerCheckDistanceToPlayer
// 0x0008 (0x00A8 - 0x00A0)
class UBTDecorator_RSPlayerCheckDistanceToPlayer final : public UBTDecorator_RSPlayerBase
{
public:
	float                                         Distance;                                          // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204B[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerCheckDistanceToPlayer">();
	}
	static class UBTDecorator_RSPlayerCheckDistanceToPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerCheckDistanceToPlayer>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerCheckDistanceToPlayer) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerCheckDistanceToPlayer");
static_assert(sizeof(UBTDecorator_RSPlayerCheckDistanceToPlayer) == 0x0000A8, "Wrong size on UBTDecorator_RSPlayerCheckDistanceToPlayer");
static_assert(offsetof(UBTDecorator_RSPlayerCheckDistanceToPlayer, Distance) == 0x0000A0, "Member 'UBTDecorator_RSPlayerCheckDistanceToPlayer::Distance' has a wrong offset!");

// Class BattlePrototype.UIAutoSaving
// 0x0008 (0x0390 - 0x0388)
class UUIAutoSaving : public UUIBase
{
public:
	float                                         M_SaveTimer;                                       // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204C[0x4];                                     // 0x038C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenAutoSave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAutoSaving">();
	}
	static class UUIAutoSaving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAutoSaving>();
	}
};
static_assert(alignof(UUIAutoSaving) == 0x000008, "Wrong alignment on UUIAutoSaving");
static_assert(sizeof(UUIAutoSaving) == 0x000390, "Wrong size on UUIAutoSaving");
static_assert(offsetof(UUIAutoSaving, M_SaveTimer) == 0x000388, "Member 'UUIAutoSaving::M_SaveTimer' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsAssist
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsAssist final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsAssist">();
	}
	static class UBTDecorator_RSPlayerIsAssist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsAssist>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsAssist) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsAssist");
static_assert(sizeof(UBTDecorator_RSPlayerIsAssist) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsAssist");

// Class BattlePrototype.BTDecorator_RSPlayerIsAttackAble
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsAttackAble final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsAttackAble">();
	}
	static class UBTDecorator_RSPlayerIsAttackAble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsAttackAble>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsAttackAble) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsAttackAble");
static_assert(sizeof(UBTDecorator_RSPlayerIsAttackAble) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsAttackAble");

// Class BattlePrototype.UICode
// 0x0078 (0x0400 - 0x0388)
class UUICode : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204D[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204E[0x60];                                    // 0x03A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UREDScrollBox* ScrollBox, class UTextBlock* TextTitle);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void Start();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICode">();
	}
	static class UUICode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICode>();
	}
};
static_assert(alignof(UUICode) == 0x000008, "Wrong alignment on UUICode");
static_assert(sizeof(UUICode) == 0x000400, "Wrong size on UUICode");
static_assert(offsetof(UUICode, ListElementSize) == 0x000388, "Member 'UUICode::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUICode, ListOffsetSize) == 0x000390, "Member 'UUICode::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUICode, ListIndexClass) == 0x000398, "Member 'UUICode::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsBattleMode
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsBattleMode final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsBattleMode">();
	}
	static class UBTDecorator_RSPlayerIsBattleMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsBattleMode>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsBattleMode) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsBattleMode");
static_assert(sizeof(UBTDecorator_RSPlayerIsBattleMode) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsBattleMode");

// Class BattlePrototype.EasyNavNode
// 0x0008 (0x0238 - 0x0230)
class AEasyNavNode final : public AActor
{
public:
	class UBoxComponent*                          BoxComponent;                                      // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EasyNavNode">();
	}
	static class AEasyNavNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEasyNavNode>();
	}
};
static_assert(alignof(AEasyNavNode) == 0x000008, "Wrong alignment on AEasyNavNode");
static_assert(sizeof(AEasyNavNode) == 0x000238, "Wrong size on AEasyNavNode");
static_assert(offsetof(AEasyNavNode, BoxComponent) == 0x000230, "Member 'AEasyNavNode::BoxComponent' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsBattleThink
// 0x0008 (0x00A8 - 0x00A0)
class UBTDecorator_RSPlayerIsBattleThink final : public UBTDecorator_RSPlayerBase
{
public:
	EPlayerAIBattleThinkTypeCPP                   ThinkTypeCPP;                                      // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2050[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsBattleThink">();
	}
	static class UBTDecorator_RSPlayerIsBattleThink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsBattleThink>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsBattleThink) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsBattleThink");
static_assert(sizeof(UBTDecorator_RSPlayerIsBattleThink) == 0x0000A8, "Wrong size on UBTDecorator_RSPlayerIsBattleThink");
static_assert(offsetof(UBTDecorator_RSPlayerIsBattleThink, ThinkTypeCPP) == 0x0000A0, "Member 'UBTDecorator_RSPlayerIsBattleThink::ThinkTypeCPP' has a wrong offset!");

// Class BattlePrototype.NpcTownPeopleCrowd
// 0x0060 (0x0410 - 0x03B0)
class ANpcTownPeopleCrowd : public ANpcTownPeopleBase
{
public:
	class UFixPoseActorComponent*                 FixPoseActorComponent;                             // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNpcHomingMoveComponent*                NpcHomingMoveComponent;                            // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineMovePath;                                    // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurMoveVec;                                        // 0x03C8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x03D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurMoveRot;                                        // 0x03D8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotSpeed;                                          // 0x03E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowAnimationDistance;                              // 0x03E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCollisionOffByDistance;                          // 0x03EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2051[0x3];                                     // 0x03ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoCollisionDistance;                               // 0x03F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowAnimationTickValue;                             // 0x03F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraNearDistance;                                // 0x03F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedTransparent;                                   // 0x03FC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2052[0x3];                                     // 0x03FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransparentRate;                                   // 0x0400(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransparentSpeed;                                  // 0x0404(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerNearDistance;                                // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFadingAsMovement;                                // 0x040C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2053[0x3];                                     // 0x040D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSpline(class USplineComponent* Spline);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTownPeopleCrowd">();
	}
	static class ANpcTownPeopleCrowd* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTownPeopleCrowd>();
	}
};
static_assert(alignof(ANpcTownPeopleCrowd) == 0x000010, "Wrong alignment on ANpcTownPeopleCrowd");
static_assert(sizeof(ANpcTownPeopleCrowd) == 0x000410, "Wrong size on ANpcTownPeopleCrowd");
static_assert(offsetof(ANpcTownPeopleCrowd, FixPoseActorComponent) == 0x0003B0, "Member 'ANpcTownPeopleCrowd::FixPoseActorComponent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, NpcHomingMoveComponent) == 0x0003B8, "Member 'ANpcTownPeopleCrowd::NpcHomingMoveComponent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, SplineMovePath) == 0x0003C0, "Member 'ANpcTownPeopleCrowd::SplineMovePath' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, CurMoveVec) == 0x0003C8, "Member 'ANpcTownPeopleCrowd::CurMoveVec' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, MoveSpeed) == 0x0003D4, "Member 'ANpcTownPeopleCrowd::MoveSpeed' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, CurMoveRot) == 0x0003D8, "Member 'ANpcTownPeopleCrowd::CurMoveRot' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, RotSpeed) == 0x0003E4, "Member 'ANpcTownPeopleCrowd::RotSpeed' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, LowAnimationDistance) == 0x0003E8, "Member 'ANpcTownPeopleCrowd::LowAnimationDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, IsCollisionOffByDistance) == 0x0003EC, "Member 'ANpcTownPeopleCrowd::IsCollisionOffByDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, NoCollisionDistance) == 0x0003F0, "Member 'ANpcTownPeopleCrowd::NoCollisionDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, LowAnimationTickValue) == 0x0003F4, "Member 'ANpcTownPeopleCrowd::LowAnimationTickValue' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, CameraNearDistance) == 0x0003F8, "Member 'ANpcTownPeopleCrowd::CameraNearDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, NeedTransparent) == 0x0003FC, "Member 'ANpcTownPeopleCrowd::NeedTransparent' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, TransparentRate) == 0x000400, "Member 'ANpcTownPeopleCrowd::TransparentRate' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, TransparentSpeed) == 0x000404, "Member 'ANpcTownPeopleCrowd::TransparentSpeed' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, PlayerNearDistance) == 0x000408, "Member 'ANpcTownPeopleCrowd::PlayerNearDistance' has a wrong offset!");
static_assert(offsetof(ANpcTownPeopleCrowd, IsFadingAsMovement) == 0x00040C, "Member 'ANpcTownPeopleCrowd::IsFadingAsMovement' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsBattleThinkParam
// 0x0008 (0x00A8 - 0x00A0)
class UBTDecorator_RSPlayerIsBattleThinkParam final : public UBTDecorator_RSPlayerBase
{
public:
	EPlayerAIBattleThinkParamCPP                  ThinkParamCPP;                                     // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2054[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsBattleThinkParam">();
	}
	static class UBTDecorator_RSPlayerIsBattleThinkParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsBattleThinkParam>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsBattleThinkParam) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsBattleThinkParam");
static_assert(sizeof(UBTDecorator_RSPlayerIsBattleThinkParam) == 0x0000A8, "Wrong size on UBTDecorator_RSPlayerIsBattleThinkParam");
static_assert(offsetof(UBTDecorator_RSPlayerIsBattleThinkParam, ThinkParamCPP) == 0x0000A0, "Member 'UBTDecorator_RSPlayerIsBattleThinkParam::ThinkParamCPP' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsBrainField
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsBrainField final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsBrainField">();
	}
	static class UBTDecorator_RSPlayerIsBrainField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsBrainField>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsBrainField) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsBrainField");
static_assert(sizeof(UBTDecorator_RSPlayerIsBrainField) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsBrainField");

// Class BattlePrototype.DecoyComponent
// 0x0008 (0x00C8 - 0x00C0)
class UDecoyComponent final : public UActorComponent
{
public:
	TSubclassOf<class ARSCharacterBase>           _targetClass;                                      // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static TArray<class AActor*> Decoy_SortByDistance(const TArray<class AActor*>& Actors, const class AActor* OriginActor);
	static class UDecoyComponent* GetDecoyComponentFromActor(class AActor* Actor);

	bool IsDecoyTarget(const class AActor* TargetActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecoyComponent">();
	}
	static class UDecoyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecoyComponent>();
	}
};
static_assert(alignof(UDecoyComponent) == 0x000008, "Wrong alignment on UDecoyComponent");
static_assert(sizeof(UDecoyComponent) == 0x0000C8, "Wrong size on UDecoyComponent");
static_assert(offsetof(UDecoyComponent, _targetClass) == 0x0000C0, "Member 'UDecoyComponent::_targetClass' has a wrong offset!");

// Class BattlePrototype.UIAreaHere
// 0x0028 (0x03B0 - 0x0388)
class UUIAreaHere : public UUIBase
{
public:
	float                                         DrawSeconds;                                       // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2056[0x24];                                    // 0x038C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextAreaHere);
	void Start(int32 LocationId, int32 AreaId, int32 PortalID);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAreaHere">();
	}
	static class UUIAreaHere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAreaHere>();
	}
};
static_assert(alignof(UUIAreaHere) == 0x000008, "Wrong alignment on UUIAreaHere");
static_assert(sizeof(UUIAreaHere) == 0x0003B0, "Wrong size on UUIAreaHere");
static_assert(offsetof(UUIAreaHere, DrawSeconds) == 0x000388, "Member 'UUIAreaHere::DrawSeconds' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsDamage
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsDamage final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsDamage">();
	}
	static class UBTDecorator_RSPlayerIsDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsDamage>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsDamage) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsDamage");
static_assert(sizeof(UBTDecorator_RSPlayerIsDamage) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsDamage");

// Class BattlePrototype.BTDecorator_RSPlayerIsDead
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsDead final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsDead">();
	}
	static class UBTDecorator_RSPlayerIsDead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsDead>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsDead) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsDead");
static_assert(sizeof(UBTDecorator_RSPlayerIsDead) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsDead");

// Class BattlePrototype.REDLocalizeOverlay
// 0x0000 (0x0130 - 0x0130)
class UREDLocalizeOverlay final : public UOverlay
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDLocalizeOverlay">();
	}
	static class UREDLocalizeOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDLocalizeOverlay>();
	}
};
static_assert(alignof(UREDLocalizeOverlay) == 0x000008, "Wrong alignment on UREDLocalizeOverlay");
static_assert(sizeof(UREDLocalizeOverlay) == 0x000130, "Wrong size on UREDLocalizeOverlay");

// Class BattlePrototype.MapGimmickAnimInstance
// 0x0010 (0x0280 - 0x0270)
class UMapGimmickAnimInstance final : public UAnimInstance
{
public:
	bool                                          IsOpen;                                            // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2057[0xF];                                     // 0x0271(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapGimmickAnimInstance">();
	}
	static class UMapGimmickAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapGimmickAnimInstance>();
	}
};
static_assert(alignof(UMapGimmickAnimInstance) == 0x000010, "Wrong alignment on UMapGimmickAnimInstance");
static_assert(sizeof(UMapGimmickAnimInstance) == 0x000280, "Wrong size on UMapGimmickAnimInstance");
static_assert(offsetof(UMapGimmickAnimInstance, IsOpen) == 0x000270, "Member 'UMapGimmickAnimInstance::IsOpen' has a wrong offset!");

// Class BattlePrototype.UIMainContentsSubTab
// 0x0050 (0x03D8 - 0x0388)
class UUIMainContentsSubTab : public UUIBase
{
public:
	uint8                                         Pad_2058[0x50];                                    // 0x0388(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimUnselect, class UREDTextBlock* TextCategory);
	void SetSelect(bool IsSelect);
	void SetTitle(const class FText& Text);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainContentsSubTab">();
	}
	static class UUIMainContentsSubTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainContentsSubTab>();
	}
};
static_assert(alignof(UUIMainContentsSubTab) == 0x000008, "Wrong alignment on UUIMainContentsSubTab");
static_assert(sizeof(UUIMainContentsSubTab) == 0x0003D8, "Wrong size on UUIMainContentsSubTab");

// Class BattlePrototype.BTDecorator_RSPlayerIsDodgeAble
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsDodgeAble final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsDodgeAble">();
	}
	static class UBTDecorator_RSPlayerIsDodgeAble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsDodgeAble>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsDodgeAble) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsDodgeAble");
static_assert(sizeof(UBTDecorator_RSPlayerIsDodgeAble) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsDodgeAble");

// Class BattlePrototype.BTDecorator_RSPlayerIsDown
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsDown final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsDown">();
	}
	static class UBTDecorator_RSPlayerIsDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsDown>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsDown) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsDown");
static_assert(sizeof(UBTDecorator_RSPlayerIsDown) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsDown");

// Class BattlePrototype.EventCelLookLightBase
// 0x0000 (0x0230 - 0x0230)
class AEventCelLookLightBase final : public AActor
{
public:
	bool IsEditorTimelineSetup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCelLookLightBase">();
	}
	static class AEventCelLookLightBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventCelLookLightBase>();
	}
};
static_assert(alignof(AEventCelLookLightBase) == 0x000008, "Wrong alignment on AEventCelLookLightBase");
static_assert(sizeof(AEventCelLookLightBase) == 0x000230, "Wrong size on AEventCelLookLightBase");

// Class BattlePrototype.UIPartyListIndex
// 0x0008 (0x0390 - 0x0388)
class UUIPartyListIndex : public UUIBase
{
public:
	bool                                          IsEnable;                                          // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsEnableChange;                                    // 0x0389(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSelect;                                          // 0x038A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDecide;                                          // 0x038B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLock;                                            // 0x038C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLockBack;                                        // 0x038D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsStart;                                           // 0x038E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsResetSelect;                                     // 0x038F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyListIndex">();
	}
	static class UUIPartyListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyListIndex>();
	}
};
static_assert(alignof(UUIPartyListIndex) == 0x000008, "Wrong alignment on UUIPartyListIndex");
static_assert(sizeof(UUIPartyListIndex) == 0x000390, "Wrong size on UUIPartyListIndex");
static_assert(offsetof(UUIPartyListIndex, IsEnable) == 0x000388, "Member 'UUIPartyListIndex::IsEnable' has a wrong offset!");
static_assert(offsetof(UUIPartyListIndex, IsEnableChange) == 0x000389, "Member 'UUIPartyListIndex::IsEnableChange' has a wrong offset!");
static_assert(offsetof(UUIPartyListIndex, IsSelect) == 0x00038A, "Member 'UUIPartyListIndex::IsSelect' has a wrong offset!");
static_assert(offsetof(UUIPartyListIndex, IsDecide) == 0x00038B, "Member 'UUIPartyListIndex::IsDecide' has a wrong offset!");
static_assert(offsetof(UUIPartyListIndex, IsLock) == 0x00038C, "Member 'UUIPartyListIndex::IsLock' has a wrong offset!");
static_assert(offsetof(UUIPartyListIndex, IsLockBack) == 0x00038D, "Member 'UUIPartyListIndex::IsLockBack' has a wrong offset!");
static_assert(offsetof(UUIPartyListIndex, IsStart) == 0x00038E, "Member 'UUIPartyListIndex::IsStart' has a wrong offset!");
static_assert(offsetof(UUIPartyListIndex, IsResetSelect) == 0x00038F, "Member 'UUIPartyListIndex::IsResetSelect' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsEvent
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsEvent final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsEvent">();
	}
	static class UBTDecorator_RSPlayerIsEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsEvent>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsEvent) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsEvent");
static_assert(sizeof(UBTDecorator_RSPlayerIsEvent) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsEvent");

// Class BattlePrototype.GameTimerFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameTimerFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float AddElapsedTime(struct FGameTimer& GameTimer, float AddTime);
	static void EndTimer(struct FGameTimer& GameTimer);
	static float GetElapsedTime(const struct FGameTimer& GameTimer);
	static float GetEndTime(const struct FGameTimer& GameTimer);
	static float GetRate(const struct FGameTimer& GameTimer);
	static float GetRemainingTime(const struct FGameTimer& GameTimer);
	static bool IsEnable(const struct FGameTimer& GameTimer);
	static bool IsOver(const struct FGameTimer& GameTimer);
	static bool IsPause(const struct FGameTimer& GameTimer);
	static void SetPause(struct FGameTimer& GameTimer, bool bPause);
	static void SetTimer(struct FGameTimer& GameTimer, float Time);
	static void UpdateTimer(struct FGameTimer& GameTimer, float Delta);
	static void UpdateTimerByActor(struct FGameTimer& GameTimer, class AActor* Actor);
	static void UpdateTimerByWorld(struct FGameTimer& GameTimer, class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameTimerFunctionLibrary">();
	}
	static class UGameTimerFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameTimerFunctionLibrary>();
	}
};
static_assert(alignof(UGameTimerFunctionLibrary) == 0x000008, "Wrong alignment on UGameTimerFunctionLibrary");
static_assert(sizeof(UGameTimerFunctionLibrary) == 0x000028, "Wrong size on UGameTimerFunctionLibrary");

// Class BattlePrototype.BTDecorator_RSPlayerIsEventMove
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsEventMove final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsEventMove">();
	}
	static class UBTDecorator_RSPlayerIsEventMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsEventMove>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsEventMove) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsEventMove");
static_assert(sizeof(UBTDecorator_RSPlayerIsEventMove) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsEventMove");

// Class BattlePrototype.UINoticeMessage
// 0x00D0 (0x0458 - 0x0388)
class UUINoticeMessage : public UUIBase
{
public:
	float                                         DispTimerMax;                                      // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_205F[0xCC];                                    // 0x038C(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddEvent(EUINoticeMessageCallType Type, class FName ID);
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeNoticeMessage(class UTextBlock* TextName, class UTextBlock* TextDetails, class UImage* NoticeImage, class UImage* KizunaImage, class UImage* ClearImage, class UImage* Frame1Image, class UImage* Frame2Image, class UImage* Frame3Image, class UImage* NoiseImage, class UOverlay* bmguide);
	bool RemoveBrainMessageEvent(class FName ThreadID);
	bool RemoveEvent(EUINoticeMessageCallType Type, class FName ID);
	bool RemoveEventClearGetter();
	bool RemoveEventSubQuest();
	void SetNoticeIcon(int32 Type);
	void UpdateStateNoticeMessage(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINoticeMessage">();
	}
	static class UUINoticeMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINoticeMessage>();
	}
};
static_assert(alignof(UUINoticeMessage) == 0x000008, "Wrong alignment on UUINoticeMessage");
static_assert(sizeof(UUINoticeMessage) == 0x000458, "Wrong size on UUINoticeMessage");
static_assert(offsetof(UUINoticeMessage, DispTimerMax) == 0x000388, "Member 'UUINoticeMessage::DispTimerMax' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsEventWait
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsEventWait final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsEventWait">();
	}
	static class UBTDecorator_RSPlayerIsEventWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsEventWait>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsEventWait) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsEventWait");
static_assert(sizeof(UBTDecorator_RSPlayerIsEventWait) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsEventWait");

// Class BattlePrototype.BTDecorator_RSPlayerIsJump
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsJump final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsJump">();
	}
	static class UBTDecorator_RSPlayerIsJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsJump>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsJump) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsJump");
static_assert(sizeof(UBTDecorator_RSPlayerIsJump) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsJump");

// Class BattlePrototype.FootStepUtility
// 0x0000 (0x0028 - 0x0028)
class UFootStepUtility final : public UBlueprintFunctionLibrary
{
public:
	static EGamePhysicalSurfaceType ConvertPhysicalSurfaceToGamePhysicalSurface(const EPhysicalSurface SurfaceType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootStepUtility">();
	}
	static class UFootStepUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootStepUtility>();
	}
};
static_assert(alignof(UFootStepUtility) == 0x000008, "Wrong alignment on UFootStepUtility");
static_assert(sizeof(UFootStepUtility) == 0x000028, "Wrong size on UFootStepUtility");

// Class BattlePrototype.UIMain3DManager
// 0x0080 (0x02B0 - 0x0230)
class AUIMain3DManager : public AActor
{
public:
	class UDataTable*                             SceneDataTable;                                    // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PlayerDataTable;                                   // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PlayerEquipGeneralDataTable;                       // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             BGCameraDataTable;                                 // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2064[0x10];                                    // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      TextureStreamingWaitLimit;                         // 0x0260(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	bool GetBGCameraSetting(struct FUIMain3DBGCameraSetting* Setting);
	bool GetEquipSetting(class UDataTable* DataTable, EUIMain3DEquipCameraID CameraID, struct FUIMain3DCharacterEquipSetting* Setting);
	bool GetPlayerSetting(int32 PlayerUniqueID, struct FUIMain3DCharacterPlayerSetting* Setting);
	bool GetSceneSetting(EUIMain3DCharacterSceneID SceneID, struct FUIMain3DCharacterSceneSetting* Setting);
	bool IsTexturesThatUsedAtMeshLoaded(class UMeshComponent* MeshComp);
	void LoadTextureRelationEquip(class UMeshComponent* MeshComp);
	void ResetTextureStreamingWaitLimit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMain3DManager">();
	}
	static class AUIMain3DManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIMain3DManager>();
	}
};
static_assert(alignof(AUIMain3DManager) == 0x000008, "Wrong alignment on AUIMain3DManager");
static_assert(sizeof(AUIMain3DManager) == 0x0002B0, "Wrong size on AUIMain3DManager");
static_assert(offsetof(AUIMain3DManager, SceneDataTable) == 0x000230, "Member 'AUIMain3DManager::SceneDataTable' has a wrong offset!");
static_assert(offsetof(AUIMain3DManager, PlayerDataTable) == 0x000238, "Member 'AUIMain3DManager::PlayerDataTable' has a wrong offset!");
static_assert(offsetof(AUIMain3DManager, PlayerEquipGeneralDataTable) == 0x000240, "Member 'AUIMain3DManager::PlayerEquipGeneralDataTable' has a wrong offset!");
static_assert(offsetof(AUIMain3DManager, BGCameraDataTable) == 0x000248, "Member 'AUIMain3DManager::BGCameraDataTable' has a wrong offset!");
static_assert(offsetof(AUIMain3DManager, TextureStreamingWaitLimit) == 0x000260, "Member 'AUIMain3DManager::TextureStreamingWaitLimit' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsMoveAble
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsMoveAble final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsMoveAble">();
	}
	static class UBTDecorator_RSPlayerIsMoveAble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsMoveAble>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsMoveAble) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsMoveAble");
static_assert(sizeof(UBTDecorator_RSPlayerIsMoveAble) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsMoveAble");

// Class BattlePrototype.BTDecorator_RSPlayerIsNoThink
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsNoThink final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsNoThink">();
	}
	static class UBTDecorator_RSPlayerIsNoThink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsNoThink>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsNoThink) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsNoThink");
static_assert(sizeof(UBTDecorator_RSPlayerIsNoThink) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsNoThink");

// Class BattlePrototype.REDScrollBoxSimple
// 0x0020 (0x08A0 - 0x0880)
class UREDScrollBoxSimple final : public UScrollBox
{
public:
	bool                                          DebugMouseHitDisp;                                 // 0x0880(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitBarDisp;                              // 0x0881(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_206D[0xE];                                     // 0x0882(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UREDebugLines*                          M_DebugDraw;                                       // 0x0890(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugbarDraw;                                    // 0x0898(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* CreateAndAddChildEx(class UClass* ClassInfo);
	bool IsMouseON();
	void ResetScrollOffset();
	bool ScrollDown();
	bool ScrollUp();
	void SetAutoScroll(float Offset);
	void SetScrollSpeed(float Speed);
	void UpdateAutoScroll(float DeltaTime);
	bool UpdateMouse();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDScrollBoxSimple">();
	}
	static class UREDScrollBoxSimple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDScrollBoxSimple>();
	}
};
static_assert(alignof(UREDScrollBoxSimple) == 0x000008, "Wrong alignment on UREDScrollBoxSimple");
static_assert(sizeof(UREDScrollBoxSimple) == 0x0008A0, "Wrong size on UREDScrollBoxSimple");
static_assert(offsetof(UREDScrollBoxSimple, DebugMouseHitDisp) == 0x000880, "Member 'UREDScrollBoxSimple::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDScrollBoxSimple, DebugMouseHitBarDisp) == 0x000881, "Member 'UREDScrollBoxSimple::DebugMouseHitBarDisp' has a wrong offset!");
static_assert(offsetof(UREDScrollBoxSimple, M_DebugDraw) == 0x000890, "Member 'UREDScrollBoxSimple::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UREDScrollBoxSimple, M_DebugbarDraw) == 0x000898, "Member 'UREDScrollBoxSimple::M_DebugbarDraw' has a wrong offset!");

// Class BattlePrototype.MessageData
// 0x0060 (0x0088 - 0x0028)
class UMessageData final : public UObject
{
public:
	TArray<class UDataTable*>                     RefDataTableList;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UObject*>           M_PreLoadVoiceMap;                                 // 0x0038(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	bool GetMessage(struct FMessageDataCell* MessageDataCell, class FName ID);
	bool GetMessageFromIndex(struct FMessageDataCell* MessageDataCell, int32 _index);
	bool LoadDataTable(const class FString& _path);
	void RegisterDataTable(class UDataTable* _datatable, const class FString& _path);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageData">();
	}
	static class UMessageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageData>();
	}
};
static_assert(alignof(UMessageData) == 0x000008, "Wrong alignment on UMessageData");
static_assert(sizeof(UMessageData) == 0x000088, "Wrong size on UMessageData");
static_assert(offsetof(UMessageData, RefDataTableList) == 0x000028, "Member 'UMessageData::RefDataTableList' has a wrong offset!");
static_assert(offsetof(UMessageData, M_PreLoadVoiceMap) == 0x000038, "Member 'UMessageData::M_PreLoadVoiceMap' has a wrong offset!");

// Class BattlePrototype.UIMiniTips
// 0x0000 (0x0388 - 0x0388)
class UUIMiniTips : public UUIBase
{
public:
	void UpdateSpacerMiniTips();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniTips">();
	}
	static class UUIMiniTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniTips>();
	}
};
static_assert(alignof(UUIMiniTips) == 0x000008, "Wrong alignment on UUIMiniTips");
static_assert(sizeof(UUIMiniTips) == 0x000388, "Wrong size on UUIMiniTips");

// Class BattlePrototype.BTDecorator_RSPlayerIsPlayerRevive
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsPlayerRevive final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsPlayerRevive">();
	}
	static class UBTDecorator_RSPlayerIsPlayerRevive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsPlayerRevive>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsPlayerRevive) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsPlayerRevive");
static_assert(sizeof(UBTDecorator_RSPlayerIsPlayerRevive) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsPlayerRevive");

// Class BattlePrototype.BTDecorator_RSPlayerIsPsychicAble
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsPsychicAble final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsPsychicAble">();
	}
	static class UBTDecorator_RSPlayerIsPsychicAble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsPsychicAble>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsPsychicAble) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsPsychicAble");
static_assert(sizeof(UBTDecorator_RSPlayerIsPsychicAble) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsPsychicAble");

// Class BattlePrototype.EventSplineMovePoint
// 0x0008 (0x0238 - 0x0230)
class AEventSplineMovePoint : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSplineMovePoint">();
	}
	static class AEventSplineMovePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSplineMovePoint>();
	}
};
static_assert(alignof(AEventSplineMovePoint) == 0x000008, "Wrong alignment on AEventSplineMovePoint");
static_assert(sizeof(AEventSplineMovePoint) == 0x000238, "Wrong size on AEventSplineMovePoint");
static_assert(offsetof(AEventSplineMovePoint, SplineComponent) == 0x000230, "Member 'AEventSplineMovePoint::SplineComponent' has a wrong offset!");

// Class BattlePrototype.UIPresentNext
// 0x0008 (0x0390 - 0x0388)
class UUIPresentNext : public UUIBase
{
public:
	class FName                                   M_ItemID;                                          // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetItemID(class FName ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPresentNext">();
	}
	static class UUIPresentNext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPresentNext>();
	}
};
static_assert(alignof(UUIPresentNext) == 0x000008, "Wrong alignment on UUIPresentNext");
static_assert(sizeof(UUIPresentNext) == 0x000390, "Wrong size on UUIPresentNext");
static_assert(offsetof(UUIPresentNext, M_ItemID) == 0x000388, "Member 'UUIPresentNext::M_ItemID' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsResetBehaviorTree
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsResetBehaviorTree final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsResetBehaviorTree">();
	}
	static class UBTDecorator_RSPlayerIsResetBehaviorTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsResetBehaviorTree>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsResetBehaviorTree) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsResetBehaviorTree");
static_assert(sizeof(UBTDecorator_RSPlayerIsResetBehaviorTree) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsResetBehaviorTree");

// Class BattlePrototype.EnemyDefineFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UEnemyDefineFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool EnemyGrade_LockOnIsGreater(EEnemyGrade MyPri, EEnemyGrade OtherPri);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDefineFunctionLibrary">();
	}
	static class UEnemyDefineFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDefineFunctionLibrary>();
	}
};
static_assert(alignof(UEnemyDefineFunctionLibrary) == 0x000008, "Wrong alignment on UEnemyDefineFunctionLibrary");
static_assert(sizeof(UEnemyDefineFunctionLibrary) == 0x000028, "Wrong size on UEnemyDefineFunctionLibrary");

// Class BattlePrototype.BTDecorator_RSPlayerIsReviveNpc
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsReviveNpc final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsReviveNpc">();
	}
	static class UBTDecorator_RSPlayerIsReviveNpc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsReviveNpc>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsReviveNpc) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsReviveNpc");
static_assert(sizeof(UBTDecorator_RSPlayerIsReviveNpc) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsReviveNpc");

// Class BattlePrototype.UIPhotoModeIndex
// 0x00C0 (0x0448 - 0x0388)
class UUIPhotoModeIndex : public UUIBase
{
public:
	uint8                                         Pad_2071[0xC0];                                    // 0x0388(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimDefaultLock, class UWidgetAnimation* AnimSelectLock, class UWidgetAnimation* AnimSelectInLock, class UTextBlock* TextTitle, class UTextBlock* TextParam);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPhotoModeIndex">();
	}
	static class UUIPhotoModeIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPhotoModeIndex>();
	}
};
static_assert(alignof(UUIPhotoModeIndex) == 0x000008, "Wrong alignment on UUIPhotoModeIndex");
static_assert(sizeof(UUIPhotoModeIndex) == 0x000448, "Wrong size on UUIPhotoModeIndex");

// Class BattlePrototype.BTDecorator_RSPlayerIsUseCppFunc
// 0x0008 (0x00A8 - 0x00A0)
class UBTDecorator_RSPlayerIsUseCppFunc final : public UBTDecorator_RSPlayerBase
{
public:
	bool                                          bEnable;                                           // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2073[0x7];                                     // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsUseCppFunc">();
	}
	static class UBTDecorator_RSPlayerIsUseCppFunc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsUseCppFunc>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsUseCppFunc) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsUseCppFunc");
static_assert(sizeof(UBTDecorator_RSPlayerIsUseCppFunc) == 0x0000A8, "Wrong size on UBTDecorator_RSPlayerIsUseCppFunc");
static_assert(offsetof(UBTDecorator_RSPlayerIsUseCppFunc, bEnable) == 0x0000A0, "Member 'UBTDecorator_RSPlayerIsUseCppFunc::bEnable' has a wrong offset!");

// Class BattlePrototype.BTDecorator_RSPlayerIsUseItem
// 0x0000 (0x00A0 - 0x00A0)
class UBTDecorator_RSPlayerIsUseItem final : public UBTDecorator_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RSPlayerIsUseItem">();
	}
	static class UBTDecorator_RSPlayerIsUseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RSPlayerIsUseItem>();
	}
};
static_assert(alignof(UBTDecorator_RSPlayerIsUseItem) == 0x000008, "Wrong alignment on UBTDecorator_RSPlayerIsUseItem");
static_assert(sizeof(UBTDecorator_RSPlayerIsUseItem) == 0x0000A0, "Wrong size on UBTDecorator_RSPlayerIsUseItem");

// Class BattlePrototype.GameMainManager
// 0x00A0 (0x02D0 - 0x0230)
class alignas(0x10) AGameMainManager : public AActor
{
public:
	uint8                                         Pad_2074[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             M_pSaveDataCapturePicture;                         // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadScreenParamManager*            M_pAutoSaveLoadScreenParamManager;                 // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_AutoSaveIntervalTime;                            // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                M_AutoSavePlayerLocation;                          // 0x0254(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isAutoSaveEnable;                                // 0x0260(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isAsyncAutoSaveRequest;                          // 0x0261(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2075[0x6];                                     // 0x0262(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGame*                            M_AsyncAutoSaveClass;                              // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2076[0x58];                                    // 0x0270(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_isForceAutoSaveEnable;                           // 0x02C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isForceAutoSaveDisable;                          // 0x02C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2077[0x6];                                     // 0x02CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AsyncAutoSaveExec();
	bool AutoSaveExec();
	class UTexture2D* ConvertTextureRenderTarget2DtoTexture2D(class UTextureRenderTarget2D* PSrcRenderTex);
	bool DoSaveDataCapture();
	class UTextureRenderTarget2D* GetSaveDataCapture();
	class UTexture2D* GetSaveDataCapturePicture();
	bool IsAutoSaveEnable();
	bool IsForceAutoSaveDisable();
	bool IsForceAutoSaveEnable();
	bool LoadRetryBattleSimulatorDataExec();
	bool LoadRetryDataExec();
	bool SaveRetryDataExec();
	void SetIsAutoSaveEnable(const bool Flag);
	void SetIsForceAutoSaveDisable(const bool Flag);
	void SetIsForceAutoSaveEnable(const bool Flag);
	void SetSaveDataCapturePicture(class UTexture2D* PCapturePic);
	void StartGameoverFlow(EGameOverResult ResultType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMainManager">();
	}
	static class AGameMainManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameMainManager>();
	}
};
static_assert(alignof(AGameMainManager) == 0x000010, "Wrong alignment on AGameMainManager");
static_assert(sizeof(AGameMainManager) == 0x0002D0, "Wrong size on AGameMainManager");
static_assert(offsetof(AGameMainManager, M_pSaveDataCapturePicture) == 0x000240, "Member 'AGameMainManager::M_pSaveDataCapturePicture' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_pAutoSaveLoadScreenParamManager) == 0x000248, "Member 'AGameMainManager::M_pAutoSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_AutoSaveIntervalTime) == 0x000250, "Member 'AGameMainManager::M_AutoSaveIntervalTime' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_AutoSavePlayerLocation) == 0x000254, "Member 'AGameMainManager::M_AutoSavePlayerLocation' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_isAutoSaveEnable) == 0x000260, "Member 'AGameMainManager::M_isAutoSaveEnable' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_isAsyncAutoSaveRequest) == 0x000261, "Member 'AGameMainManager::M_isAsyncAutoSaveRequest' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_AsyncAutoSaveClass) == 0x000268, "Member 'AGameMainManager::M_AsyncAutoSaveClass' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_isForceAutoSaveEnable) == 0x0002C8, "Member 'AGameMainManager::M_isForceAutoSaveEnable' has a wrong offset!");
static_assert(offsetof(AGameMainManager, M_isForceAutoSaveDisable) == 0x0002C9, "Member 'AGameMainManager::M_isForceAutoSaveDisable' has a wrong offset!");

// Class BattlePrototype.BTTask_RSNativeBase
// 0x0030 (0x00A0 - 0x0070)
class UBTTask_RSNativeBase : public UBTTaskNode
{
public:
	class AAIController*                          _AIOwner;                                          // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntervalCountdown                     TickInterval;                                      // 0x0078(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2078[0x18];                                    // 0x0080(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ReceiveTickImplementations : 1;                    // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2079[0x7];                                     // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSNativeBase">();
	}
	static class UBTTask_RSNativeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSNativeBase>();
	}
};
static_assert(alignof(UBTTask_RSNativeBase) == 0x000008, "Wrong alignment on UBTTask_RSNativeBase");
static_assert(sizeof(UBTTask_RSNativeBase) == 0x0000A0, "Wrong size on UBTTask_RSNativeBase");
static_assert(offsetof(UBTTask_RSNativeBase, _AIOwner) == 0x000070, "Member 'UBTTask_RSNativeBase::_AIOwner' has a wrong offset!");
static_assert(offsetof(UBTTask_RSNativeBase, TickInterval) == 0x000078, "Member 'UBTTask_RSNativeBase::TickInterval' has a wrong offset!");

// Class BattlePrototype.RenderingManager
// 0x0008 (0x0238 - 0x0230)
class ARenderingManager final : public AActor
{
public:
	class URenderingManagerCoreComponent*         CoreComponent;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderingManager">();
	}
	static class ARenderingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARenderingManager>();
	}
};
static_assert(alignof(ARenderingManager) == 0x000008, "Wrong alignment on ARenderingManager");
static_assert(sizeof(ARenderingManager) == 0x000238, "Wrong size on ARenderingManager");
static_assert(offsetof(ARenderingManager, CoreComponent) == 0x000230, "Member 'ARenderingManager::CoreComponent' has a wrong offset!");

// Class BattlePrototype.MovementUtilityFunctions
// 0x0000 (0x0028 - 0x0028)
class UMovementUtilityFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void MoveAndSlideUpdatedComponent(class UMovementComponent* Target, const struct FVector& DesiredMovementThisFrame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementUtilityFunctions">();
	}
	static class UMovementUtilityFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementUtilityFunctions>();
	}
};
static_assert(alignof(UMovementUtilityFunctions) == 0x000008, "Wrong alignment on UMovementUtilityFunctions");
static_assert(sizeof(UMovementUtilityFunctions) == 0x000028, "Wrong size on UMovementUtilityFunctions");

// Class BattlePrototype.UITitleMenu
// 0x0158 (0x04E0 - 0x0388)
class UUITitleMenu final : public UUIBase
{
public:
	TDelegate<void(ETitleFlow Cursor)>            M_OnEventCursorSelectStart;                        // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UUIGamerTag*                            TitleUserTag;                                      // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_207B[0x20];                                    // 0x03A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserParamManager*                      UserParamManager;                                  // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatabaseManager*                       DatabaseManager;                                   // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSTitleManager*                        M_pTitleManager;                                   // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMessageHudManager*                     MessageHudManager;                                 // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_207C[0x80];                                    // 0x03E0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      M_pPlayerController;                               // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSHUDBase*                             M_pHudBase;                                        // 0x0468(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_207D[0x70];                                    // 0x0470(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetMoviePlayFlag();
	void InitializeAnime(class UWidgetAnimation* _press_start_out_first, class UWidgetAnimation* _press_start_in_first, class UWidgetAnimation* _press_start_default_first, class UWidgetAnimation* _press_start_out, class UWidgetAnimation* _press_start_in, class UWidgetAnimation* _press_start_default_none, class UWidgetAnimation* _press_start_default_, class UWidgetAnimation* _start_menu_in, class UWidgetAnimation* _start_menu_default, class UWidgetAnimation* _start_menu_decision, class UWidgetAnimation* _change_press_start, class UWidgetAnimation* _start_menu_select_in);
	void InitializeText(class UTextBlock* Pressstart, class UTextBlock* Titlever, class UTextBlock* Titlecopyright);
	void InitializeTitleLogo(class UImage* Titlelogoimage);
	void InitializeTitleParts(int32 Param_Index, class UUITitleMenuParts* Titleparts);
	void InitializeXboxOne(class UTextBlock* UserName);
	bool IsFirstDecideCheck();
	void OpenFirstPressMenu();
	void OpenLogoBP();
	void OpenSelectMenu();
	void SetTitleLogoWidget(class UUIScarletLogo* Titlelogowidget);
	void SetTitleManager(class ARSTitleManager* Ptitlemanager);
	void Start(bool IsStartMenu);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleMenu">();
	}
	static class UUITitleMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleMenu>();
	}
};
static_assert(alignof(UUITitleMenu) == 0x000008, "Wrong alignment on UUITitleMenu");
static_assert(sizeof(UUITitleMenu) == 0x0004E0, "Wrong size on UUITitleMenu");
static_assert(offsetof(UUITitleMenu, M_OnEventCursorSelectStart) == 0x000388, "Member 'UUITitleMenu::M_OnEventCursorSelectStart' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, TitleUserTag) == 0x000398, "Member 'UUITitleMenu::TitleUserTag' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, UserParamManager) == 0x0003C0, "Member 'UUITitleMenu::UserParamManager' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, DatabaseManager) == 0x0003C8, "Member 'UUITitleMenu::DatabaseManager' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, M_pTitleManager) == 0x0003D0, "Member 'UUITitleMenu::M_pTitleManager' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, MessageHudManager) == 0x0003D8, "Member 'UUITitleMenu::MessageHudManager' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, M_pPlayerController) == 0x000460, "Member 'UUITitleMenu::M_pPlayerController' has a wrong offset!");
static_assert(offsetof(UUITitleMenu, M_pHudBase) == 0x000468, "Member 'UUITitleMenu::M_pHudBase' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerBase
// 0x0008 (0x00A8 - 0x00A0)
class UBTTask_RSPlayerBase : public UBTTask_RSNativeBase
{
public:
	class UPlayerScriptComponent*                 _PlayerScript;                                     // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerBase">();
	}
	static class UBTTask_RSPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerBase>();
	}
};
static_assert(alignof(UBTTask_RSPlayerBase) == 0x000008, "Wrong alignment on UBTTask_RSPlayerBase");
static_assert(sizeof(UBTTask_RSPlayerBase) == 0x0000A8, "Wrong size on UBTTask_RSPlayerBase");
static_assert(offsetof(UBTTask_RSPlayerBase, _PlayerScript) == 0x0000A0, "Member 'UBTTask_RSPlayerBase::_PlayerScript' has a wrong offset!");

// Class BattlePrototype.REDLocalizeOverlaySlot
// 0x0000 (0x0058 - 0x0058)
class UREDLocalizeOverlaySlot final : public UOverlaySlot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDLocalizeOverlaySlot">();
	}
	static class UREDLocalizeOverlaySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDLocalizeOverlaySlot>();
	}
};
static_assert(alignof(UREDLocalizeOverlaySlot) == 0x000008, "Wrong alignment on UREDLocalizeOverlaySlot");
static_assert(sizeof(UREDLocalizeOverlaySlot) == 0x000058, "Wrong size on UREDLocalizeOverlaySlot");

// Class BattlePrototype.BTTask_RSPlayerBattleStart
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerBattleStart final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerBattleStart">();
	}
	static class UBTTask_RSPlayerBattleStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerBattleStart>();
	}
};
static_assert(alignof(UBTTask_RSPlayerBattleStart) == 0x000008, "Wrong alignment on UBTTask_RSPlayerBattleStart");
static_assert(sizeof(UBTTask_RSPlayerBattleStart) == 0x0000A8, "Wrong size on UBTTask_RSPlayerBattleStart");

// Class BattlePrototype.LibraryEnemyDBAsset
// 0x0050 (0x0078 - 0x0028)
class ULibraryEnemyDBAsset final : public UObject
{
public:
	TMap<class FName, struct FLibraryEnemyDBCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryEnemyDBAsset">();
	}
	static class ULibraryEnemyDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryEnemyDBAsset>();
	}
};
static_assert(alignof(ULibraryEnemyDBAsset) == 0x000008, "Wrong alignment on ULibraryEnemyDBAsset");
static_assert(sizeof(ULibraryEnemyDBAsset) == 0x000078, "Wrong size on ULibraryEnemyDBAsset");
static_assert(offsetof(ULibraryEnemyDBAsset, DBMap) == 0x000028, "Member 'ULibraryEnemyDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.UIQuestMenu
// 0x0E58 (0x11E0 - 0x0388)
class UUIQuestMenu : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_207F[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2080[0xE40];                                   // 0x03A0(0x0E40)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeCategory(int32 Category, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimUnselect, class UTextBlock* TextCategory);
	void InitializeCommonParts(class UUIMainContents* UIMainContents, class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimInfoWindow, class UWidgetAnimation* AnimInfoWindowIn, class UWidgetAnimation* AnimInfoWindowOut, class UBorder* borderAllColor, class UREDScrollBox* ScrollBox, class UUIQuestListIndex* UiListIndexBase, class UUIQuestChoice* ChildQuestPopup, class UUIBase* ChildErrorPopup, class UUIQuestDetailsMain* ChildDetailsMain, class UUIQuestDetailsSub* ChildDetailsSub, class UUIQuestDetailsBonds* ChildDetailsBounds);
	bool IsEndErrorPopup();
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void SetContentsChange(bool IsChange);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsEndMenu() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestMenu">();
	}
	static class UUIQuestMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestMenu>();
	}
};
static_assert(alignof(UUIQuestMenu) == 0x000008, "Wrong alignment on UUIQuestMenu");
static_assert(sizeof(UUIQuestMenu) == 0x0011E0, "Wrong size on UUIQuestMenu");
static_assert(offsetof(UUIQuestMenu, ListElementSize) == 0x000388, "Member 'UUIQuestMenu::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIQuestMenu, ListOffsetSize) == 0x000390, "Member 'UUIQuestMenu::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIQuestMenu, ListIndexClass) == 0x000398, "Member 'UUIQuestMenu::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerBrainField
// 0x0010 (0x00B8 - 0x00A8)
class UBTTask_RSPlayerBrainField final : public UBTTask_RSPlayerBase
{
public:
	struct FGameTimer                             Timer;                                             // 0x00A8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2084[0x4];                                     // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerBrainField">();
	}
	static class UBTTask_RSPlayerBrainField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerBrainField>();
	}
};
static_assert(alignof(UBTTask_RSPlayerBrainField) == 0x000008, "Wrong alignment on UBTTask_RSPlayerBrainField");
static_assert(sizeof(UBTTask_RSPlayerBrainField) == 0x0000B8, "Wrong size on UBTTask_RSPlayerBrainField");
static_assert(offsetof(UBTTask_RSPlayerBrainField, Timer) == 0x0000A8, "Member 'UBTTask_RSPlayerBrainField::Timer' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerDamage
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerDamage final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerDamage">();
	}
	static class UBTTask_RSPlayerDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerDamage>();
	}
};
static_assert(alignof(UBTTask_RSPlayerDamage) == 0x000008, "Wrong alignment on UBTTask_RSPlayerDamage");
static_assert(sizeof(UBTTask_RSPlayerDamage) == 0x0000A8, "Wrong size on UBTTask_RSPlayerDamage");

// Class BattlePrototype.UIQuestChoice
// 0x0138 (0x04C0 - 0x0388)
class UUIQuestChoice : public UUIBase
{
public:
	uint8                                         Pad_2085[0x138];                                   // 0x0388(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Param_Index, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeReward(int32 Param_Index, class UOverlay* Overlay, class UImage* ItemIconFrame, class UImage* IconCategory);
	void InitializeThis(class UTextBlock* TextWindowTitle, class UOverlay* OverlayMainGatherItem, class USpacer* SpacerMain, class UOverlay* OverlayMainOther, class UTextBlock* TextMain, class UVerticalBox* VerticalBoxChoice, class UVerticalBox* VerticalBoxChoice2, class UOverlay* OverlayReward, class UTextBlock* TextRewardTitle, class UHorizontalBox* HorizontalBoxGuide);
	void SetItemIcon(class FName ItemId, class UImage* ImageCategory, class UImage* ImageItemIconFrame);
	void SetItemIconNone(class UImage* ImageCategory, class UImage* ImageItemIconFrame);
	void SetKinsuIcon(class UImage* ImageCategory, class UImage* ImageItemIconFrame);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestChoice">();
	}
	static class UUIQuestChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestChoice>();
	}
};
static_assert(alignof(UUIQuestChoice) == 0x000008, "Wrong alignment on UUIQuestChoice");
static_assert(sizeof(UUIQuestChoice) == 0x0004C0, "Wrong size on UUIQuestChoice");

// Class BattlePrototype.BTTask_RSPlayerDead
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerDead final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerDead">();
	}
	static class UBTTask_RSPlayerDead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerDead>();
	}
};
static_assert(alignof(UBTTask_RSPlayerDead) == 0x000008, "Wrong alignment on UBTTask_RSPlayerDead");
static_assert(sizeof(UBTTask_RSPlayerDead) == 0x0000A8, "Wrong size on UBTTask_RSPlayerDead");

// Class BattlePrototype.BTTask_RSPlayerDown
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerDown final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerDown">();
	}
	static class UBTTask_RSPlayerDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerDown>();
	}
};
static_assert(alignof(UBTTask_RSPlayerDown) == 0x000008, "Wrong alignment on UBTTask_RSPlayerDown");
static_assert(sizeof(UBTTask_RSPlayerDown) == 0x0000A8, "Wrong size on UBTTask_RSPlayerDown");

// Class BattlePrototype.GimmickTriggerVolume
// 0x0028 (0x0290 - 0x0268)
class AGimmickTriggerVolume : public AVolume
{
public:
	class AMapGimmickObject*                      TargetMapGimmick;                                  // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMapGimmickManager*                     MapGimmickManager;                                 // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapGimmickPlayerPlace                        PositionToGimmick;                                 // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverlapAllPlayer;                                // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverlapPartner;                                  // 0x027A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapGimmickFinishDir                          FinishAnimationDir;                                // 0x027B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateIconOnly;                                    // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUseLimitIcon;                                    // 0x027D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2088[0x2];                                     // 0x027E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           _TimerHandle;                                      // 0x0280(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2089[0x8];                                     // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelayCollisionOn();
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorHitFunc(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

	bool IsInPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTriggerVolume">();
	}
	static class AGimmickTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTriggerVolume>();
	}
};
static_assert(alignof(AGimmickTriggerVolume) == 0x000008, "Wrong alignment on AGimmickTriggerVolume");
static_assert(sizeof(AGimmickTriggerVolume) == 0x000290, "Wrong size on AGimmickTriggerVolume");
static_assert(offsetof(AGimmickTriggerVolume, TargetMapGimmick) == 0x000268, "Member 'AGimmickTriggerVolume::TargetMapGimmick' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, MapGimmickManager) == 0x000270, "Member 'AGimmickTriggerVolume::MapGimmickManager' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, PositionToGimmick) == 0x000278, "Member 'AGimmickTriggerVolume::PositionToGimmick' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, IsOverlapAllPlayer) == 0x000279, "Member 'AGimmickTriggerVolume::IsOverlapAllPlayer' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, IsOverlapPartner) == 0x00027A, "Member 'AGimmickTriggerVolume::IsOverlapPartner' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, FinishAnimationDir) == 0x00027B, "Member 'AGimmickTriggerVolume::FinishAnimationDir' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, UpdateIconOnly) == 0x00027C, "Member 'AGimmickTriggerVolume::UpdateIconOnly' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, IsUseLimitIcon) == 0x00027D, "Member 'AGimmickTriggerVolume::IsUseLimitIcon' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerVolume, _TimerHandle) == 0x000280, "Member 'AGimmickTriggerVolume::_TimerHandle' has a wrong offset!");

// Class BattlePrototype.GimmickLimitTriggerVolume
// 0x0000 (0x0290 - 0x0290)
class AGimmickLimitTriggerVolume final : public AGimmickTriggerVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickLimitTriggerVolume">();
	}
	static class AGimmickLimitTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickLimitTriggerVolume>();
	}
};
static_assert(alignof(AGimmickLimitTriggerVolume) == 0x000008, "Wrong alignment on AGimmickLimitTriggerVolume");
static_assert(sizeof(AGimmickLimitTriggerVolume) == 0x000290, "Wrong size on AGimmickLimitTriggerVolume");

// Class BattlePrototype.UITitleLicense
// 0x0040 (0x03C8 - 0x0388)
class UUITitleLicense final : public UUIBase
{
public:
	uint8                                         Pad_208B[0x40];                                    // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextTitle, class UREDTextBlock* TextHelp, class UREDScrollBoxSimple* ScrollBox, class UUIGuide* UIGuide);
	void Start();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleLicense">();
	}
	static class UUITitleLicense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleLicense>();
	}
};
static_assert(alignof(UUITitleLicense) == 0x000008, "Wrong alignment on UUITitleLicense");
static_assert(sizeof(UUITitleLicense) == 0x0003C8, "Wrong size on UUITitleLicense");

// Class BattlePrototype.BTTask_RSPlayerEvent
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerEvent final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerEvent">();
	}
	static class UBTTask_RSPlayerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerEvent>();
	}
};
static_assert(alignof(UBTTask_RSPlayerEvent) == 0x000008, "Wrong alignment on UBTTask_RSPlayerEvent");
static_assert(sizeof(UBTTask_RSPlayerEvent) == 0x0000A8, "Wrong size on UBTTask_RSPlayerEvent");

// Class BattlePrototype.RegisterEffectInterface
// 0x0000 (0x0028 - 0x0028)
class IRegisterEffectInterface final : public IInterface
{
public:
	void RegisterEffectInterface(class URSParticleSystemComponentBase* Particle);
	void RegisterInterruptTelepoEffectInterface(class URSParticleSystemComponentBase* Particle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegisterEffectInterface">();
	}
	static class IRegisterEffectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRegisterEffectInterface>();
	}
};
static_assert(alignof(IRegisterEffectInterface) == 0x000008, "Wrong alignment on IRegisterEffectInterface");
static_assert(sizeof(IRegisterEffectInterface) == 0x000028, "Wrong size on IRegisterEffectInterface");

// Class BattlePrototype.BTTask_RSPlayerEventWait
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerEventWait final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerEventWait">();
	}
	static class UBTTask_RSPlayerEventWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerEventWait>();
	}
};
static_assert(alignof(UBTTask_RSPlayerEventWait) == 0x000008, "Wrong alignment on UBTTask_RSPlayerEventWait");
static_assert(sizeof(UBTTask_RSPlayerEventWait) == 0x0000A8, "Wrong size on UBTTask_RSPlayerEventWait");

// Class BattlePrototype.RSActorEnemyBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorEnemyBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorEnemyBase">();
	}
	static class ARSActorEnemyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorEnemyBase>();
	}
};
static_assert(alignof(ARSActorEnemyBase) == 0x000008, "Wrong alignment on ARSActorEnemyBase");
static_assert(sizeof(ARSActorEnemyBase) == 0x000230, "Wrong size on ARSActorEnemyBase");

// Class BattlePrototype.HelpTutorialDBAsset
// 0x00F0 (0x0118 - 0x0028)
class UHelpTutorialDBAsset final : public UObject
{
public:
	TMap<EHelpTutorial, struct FHelpDBDataCell>   HelpDBMap_;                                        // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<EHelpTutorial, struct FMiniHelpRowDataCell> MiniHelpDBMap_;                                    // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTutorialDBDataCell> TutorialDBMap_;                                    // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpTutorialDBAsset">();
	}
	static class UHelpTutorialDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpTutorialDBAsset>();
	}
};
static_assert(alignof(UHelpTutorialDBAsset) == 0x000008, "Wrong alignment on UHelpTutorialDBAsset");
static_assert(sizeof(UHelpTutorialDBAsset) == 0x000118, "Wrong size on UHelpTutorialDBAsset");
static_assert(offsetof(UHelpTutorialDBAsset, HelpDBMap_) == 0x000028, "Member 'UHelpTutorialDBAsset::HelpDBMap_' has a wrong offset!");
static_assert(offsetof(UHelpTutorialDBAsset, MiniHelpDBMap_) == 0x000078, "Member 'UHelpTutorialDBAsset::MiniHelpDBMap_' has a wrong offset!");
static_assert(offsetof(UHelpTutorialDBAsset, TutorialDBMap_) == 0x0000C8, "Member 'UHelpTutorialDBAsset::TutorialDBMap_' has a wrong offset!");

// Class BattlePrototype.UIVisionSimulatorResult
// 0x0008 (0x0390 - 0x0388)
class UUIVisionSimulatorResult : public UUIBase
{
public:
	bool                                          M_isOpend;                                         // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208C[0x7];                                     // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFontColor(class UTextBlock* PTextBlock, const struct FSlateColor& Color, const struct FLinearColor& OutlineColor);
	bool Share();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVisionSimulatorResult">();
	}
	static class UUIVisionSimulatorResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVisionSimulatorResult>();
	}
};
static_assert(alignof(UUIVisionSimulatorResult) == 0x000008, "Wrong alignment on UUIVisionSimulatorResult");
static_assert(sizeof(UUIVisionSimulatorResult) == 0x000390, "Wrong size on UUIVisionSimulatorResult");
static_assert(offsetof(UUIVisionSimulatorResult, M_isOpend) == 0x000388, "Member 'UUIVisionSimulatorResult::M_isOpend' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerJump
// 0x0010 (0x00B8 - 0x00A8)
class UBTTask_RSPlayerJump final : public UBTTask_RSPlayerBase
{
public:
	bool                                          bPress;                                            // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208D[0x3];                                     // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             Timer;                                             // 0x00AC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerJump">();
	}
	static class UBTTask_RSPlayerJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerJump>();
	}
};
static_assert(alignof(UBTTask_RSPlayerJump) == 0x000008, "Wrong alignment on UBTTask_RSPlayerJump");
static_assert(sizeof(UBTTask_RSPlayerJump) == 0x0000B8, "Wrong size on UBTTask_RSPlayerJump");
static_assert(offsetof(UBTTask_RSPlayerJump, bPress) == 0x0000A8, "Member 'UBTTask_RSPlayerJump::bPress' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerJump, Timer) == 0x0000AC, "Member 'UBTTask_RSPlayerJump::Timer' has a wrong offset!");

// Class BattlePrototype.REDScrollBox
// 0x0108 (0x0988 - 0x0880)
class UREDScrollBox final : public UScrollBox
{
public:
	bool                                          DebugMouseHitDisp;                                 // 0x0880(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitBarDisp;                              // 0x0881(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208E[0x6];                                     // 0x0882(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pElementClass;                                   // 0x0888(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208F[0x10];                                    // 0x0890(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UREDScrollBoxElement*>           M_elementList;                                     // 0x08A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2090[0x8];                                     // 0x08B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRedScrollBoxWork>              M_elementWork;                                     // 0x08B8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2091[0x8];                                     // 0x08C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_elementClass;                                    // 0x08D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2092[0x40];                                    // 0x08D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_updateElement;                                   // 0x0918(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_focus;                                           // 0x0928(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_unFocus;                                         // 0x0938(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_FocusMouse;                                      // 0x0948(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_unFocusMouse;                                    // 0x0958(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             M_LeftDownMouse;                                   // 0x0968(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugDraw;                                       // 0x0978(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugbarDraw;                                    // 0x0980(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddElement();
	void CleanUpList();
	void CloseDrawAreaWidget();
	void CorrectCursorDrawArea(bool IsScroll, bool InitcursorTop);
	void DecrementWorkWeightAll();
	class UUserWidget* GetCurrentWidget();
	class UUserWidget* GetSimpleCurrentWidget();
	class UUserWidget* GetWorkWidget(int32 Param_Index, bool IsSetFreeWork, bool NotupdateElement);
	void IncrementWorkWeight(int32 CursorPosition);
	bool IsScrollAnimation();
	void ReleaseList();
	void ResetList();
	void SetCursorPosition(int32 Param_Index, bool Mouseflag, bool MouseScrollflag);
	void SetDebugDraw(bool IsDraw);
	void SetDrawTop(int32 Pos);
	void SetMouseControlInputLevel(bool IsControl);
	void SetMouseDisable(bool Flag, ESlateVisibility Lockvisibility);
	void SetMouseInputDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);
	void SetScrollOffsetRED(float Offset);
	void SetScrollSpeed(float Speed);
	void SetupList(class UClass* ElementClass, int32 ElementNum, const struct FVector2D& ElementSize, float OffsetSize, int32 Initcursor, bool IsCursorTop);
	void UpdateDrawAreaWidget();
	void UpdateList(float DeltaSeconds);

	int32 GetCurrentIndex() const;
	int32 GetDrawTop() const;
	int32 GetDrawTopGoal() const;
	bool GetIsSetUp() const;
	int32 GetMouseBackUpCursor() const;
	bool GetMouseDisable() const;
	bool GetMouseInputDisable() const;
	int32 GetMouseInputLevel() const;
	int32 GetPageDrawNum() const;
	bool IsRedrawScroll() const;
	bool IsScrollBarClicking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDScrollBox">();
	}
	static class UREDScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDScrollBox>();
	}
};
static_assert(alignof(UREDScrollBox) == 0x000008, "Wrong alignment on UREDScrollBox");
static_assert(sizeof(UREDScrollBox) == 0x000988, "Wrong size on UREDScrollBox");
static_assert(offsetof(UREDScrollBox, DebugMouseHitDisp) == 0x000880, "Member 'UREDScrollBox::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, DebugMouseHitBarDisp) == 0x000881, "Member 'UREDScrollBox::DebugMouseHitBarDisp' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_pElementClass) == 0x000888, "Member 'UREDScrollBox::M_pElementClass' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_elementList) == 0x0008A0, "Member 'UREDScrollBox::M_elementList' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_elementWork) == 0x0008B8, "Member 'UREDScrollBox::M_elementWork' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_elementClass) == 0x0008D0, "Member 'UREDScrollBox::M_elementClass' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_updateElement) == 0x000918, "Member 'UREDScrollBox::M_updateElement' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_focus) == 0x000928, "Member 'UREDScrollBox::M_focus' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_unFocus) == 0x000938, "Member 'UREDScrollBox::M_unFocus' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_FocusMouse) == 0x000948, "Member 'UREDScrollBox::M_FocusMouse' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_unFocusMouse) == 0x000958, "Member 'UREDScrollBox::M_unFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_LeftDownMouse) == 0x000968, "Member 'UREDScrollBox::M_LeftDownMouse' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_DebugDraw) == 0x000978, "Member 'UREDScrollBox::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UREDScrollBox, M_DebugbarDraw) == 0x000980, "Member 'UREDScrollBox::M_DebugbarDraw' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerMoveToBase
// 0x0038 (0x00E0 - 0x00A8)
class UBTTask_RSPlayerMoveToBase : public UBTTask_RSPlayerBase
{
public:
	float                                         AcceptionRadius;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpCheck;                                        // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWallBackCheck;                                    // 0x00AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExit;                                             // 0x00AE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInputMoveMode;                                    // 0x00AF(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             Timer;                                             // 0x00B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         Step;                                              // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             CheckWallTimer;                                    // 0x00C0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CheckJumpInterval;                                 // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             BackInputTimer;                                    // 0x00D0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EPlayerAIMoveWallCPP                          WallTypeCPP;                                       // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2096[0x3];                                     // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveToBase">();
	}
	static class UBTTask_RSPlayerMoveToBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveToBase>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveToBase) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveToBase");
static_assert(sizeof(UBTTask_RSPlayerMoveToBase) == 0x0000E0, "Wrong size on UBTTask_RSPlayerMoveToBase");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, AcceptionRadius) == 0x0000A8, "Member 'UBTTask_RSPlayerMoveToBase::AcceptionRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, bJumpCheck) == 0x0000AC, "Member 'UBTTask_RSPlayerMoveToBase::bJumpCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, bWallBackCheck) == 0x0000AD, "Member 'UBTTask_RSPlayerMoveToBase::bWallBackCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, bExit) == 0x0000AE, "Member 'UBTTask_RSPlayerMoveToBase::bExit' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, bInputMoveMode) == 0x0000AF, "Member 'UBTTask_RSPlayerMoveToBase::bInputMoveMode' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, Timer) == 0x0000B0, "Member 'UBTTask_RSPlayerMoveToBase::Timer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, Step) == 0x0000BC, "Member 'UBTTask_RSPlayerMoveToBase::Step' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, CheckWallTimer) == 0x0000C0, "Member 'UBTTask_RSPlayerMoveToBase::CheckWallTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, CheckJumpInterval) == 0x0000CC, "Member 'UBTTask_RSPlayerMoveToBase::CheckJumpInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, BackInputTimer) == 0x0000D0, "Member 'UBTTask_RSPlayerMoveToBase::BackInputTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveToBase, WallTypeCPP) == 0x0000DC, "Member 'UBTTask_RSPlayerMoveToBase::WallTypeCPP' has a wrong offset!");

// Class BattlePrototype.MakeEventActor
// 0x01E0 (0x0410 - 0x0230)
class AMakeEventActor : public AActor
{
public:
	TDelegate<void()>                             OnEvent;                                           // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           CharaPresetNameList;                               // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           TextureRowNameList;                                // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MovieTextureRowNameList;                           // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AnimAssetPathList;                                 // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AnimBPPathList;                                    // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EEventPostProcessID>                   EventPostProcessIDList;                            // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBattleSimulatorSystemEvent;                      // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNpcActionButton2Event;                           // 0x02A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkip;                                            // 0x02A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActiveBPEvent;                                   // 0x02A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStaticToInGame;                                   // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoreSequencerInGameTransform;                    // 0x02A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2097[0x2];                                     // 0x02A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkipOPEvent;                                     // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2098[0x7];                                     // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SkipUnableSpaceString;                             // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_InterludeID;                                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2099[0x4];                                     // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          SkipMessageSE;                                     // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_isWait;                                          // 0x02D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEventWaitMode                                M_waitMode;                                        // 0x02D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_209A[0x2];                                     // 0x02DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_waitSecond;                                      // 0x02DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_209B[0x8];                                     // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      M_PlayerController;                                // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsEndMotion;                                     // 0x02F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_209C[0x7];                                     // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_AnimationActor;                                  // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isStartDynamicCutscene;                          // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isCallSkipMessage;                               // 0x0301(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_MessageFlagCheckClose;                           // 0x0302(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_209D[0x5];                                     // 0x0303(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pWaitAnimMontageActor;                           // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           M_pWaitAnimMontageMontage;                         // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEventAsset*                            M_pWaitLoadAsset;                                  // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStoreSeqCapStatus                            M_StoreSeqCapStatus;                               // 0x0320(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESequenceSkipPhase                            M_SequenceSkipPhase;                               // 0x0321(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPhotoModeStatusType                          M_PhotoModeStatusType;                             // 0x0322(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsStopBoadMotion;                                // 0x0323(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsSkipLatentNode;                                // 0x0324(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_bInputOnSkipLatentNode;                          // 0x0325(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_209E[0x2];                                     // 0x0326(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AMainEventLatentActor*                  M_Latenter;                                        // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsKeyDown;                                         // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_209F[0x3];                                     // 0x0331(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeyDownTime;                                       // 0x0334(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsOrWaitInput;                                   // 0x0338(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCurrentStaticEvent;                              // 0x0339(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20A0[0x6];                                     // 0x033A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UAnimationAsset*>     M_PreLoadAnimationMap;                             // 0x0340(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, class UClass*>              M_PreLoadAnimationBPMap;                           // 0x0390(0x0050)(NativeAccessSpecifierPrivate)
	class UCurveFloat*                            M_PreLoadCurveFloat[0x3];                          // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             M_PreLoadPPMList;                                  // 0x03F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20A1[0x8];                                     // 0x0408(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBoardAnimation(int32 CaptureActorIndex, const class FString& BoardAnimNamePath, bool IsLoop);
	void AddBoardBGAnimation(const class FString& BoardAnimNamePath, bool IsLoop);
	void AddBondsLevel(EPlayerID HeroID, EPlayerID PartnerId, int32 AddNum);
	void AddBondsValue(EPlayerID HeroID, EPlayerID PartnerId, float AddNum);
	void BGEffectFringe(class UCurveFloat* Curve, bool IsLoop);
	void BGEffectGlitch(class UCurveFloat* Curve, bool IsLoop);
	void BGEffectNoise(class UCurveFloat* Curve, bool IsLoop);
	void BGEffectScanline(class UCurveFloat* Curve, bool IsLoop);
	void BoardEffectAnimationAlpha(int32 CaptureActorIndex, float Time, float Start, float End, class UCurveFloat* Curve, bool Loop);
	void CaptureScene(int32 CaptureActorIndex);
	void CaptureSceneBG(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void CaptureSceneBGForLevelSequencerAndDelay(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, class ULevelSequence* CaptureSequence, float CaptureSequencePosition);
	void ChangeMainPlayer();
	void ChangePlayerFromClass(ERSPartyPlayerKind PartyPlayerType, TSoftClassPtr<class UClass> CharacterClass);
	void ChangePresetCamera(const struct FCameraTriggerInfo& TriggerInfo, bool bLerp);
	bool CheckBondsLevelUp(EPlayerID PlayerId, EPlayerID TargetID);
	int32 CheckSubQuestRewardResult();
	void CloseForceUITutoOperation();
	void CloseMessage();
	void CloseScarletLogo();
	void CloseUITutoOperation(class FName ClosehelpTutoID);
	void CloseUITutoTips();
	bool DisableEventBattlefieldFence(int32 FenceGroupID);
	int32 DrawChoiceMessage(const class FString& Choice1, const class FString& Choice2, const class FString& Choice3, const class FString& Choice4, const class FString& Choice5, int32 DefaultCursor, float DrawSecond, bool IsWaitMode);
	void DrawGeneralChoice1(ETextType TextType, class FName TextMain, class FName Choice1, bool IsCancelable);
	void DrawGeneralChoice2(ETextType TextType, class FName TextMain, int32 DefaultCursor, class FName Choice1, class FName Choice2, bool IsCancelable);
	void DrawGeneralChoice3(ETextType TextType, class FName TextMain, int32 DefaultCursor, class FName Choice1, class FName Choice2, class FName Choice3, bool IsCancelable);
	void DrawGeneralChoice4(ETextType TextType, class FName TextMain, int32 DefaultCursor, class FName Choice1, class FName Choice2, class FName Choice3, class FName Choice4, bool IsCancelable);
	void DrawMessage(int32 WindowType, const class FString& MessageLabel, class FName RipSyncBoardJointID, bool Skipable, float DrawSecond, bool IsSkipVoiceEnd, bool IsVoiceOnlyMessage, bool IsWaitMode);
	void EffectBokeh(int32 CaptureActorIndex, class UCurveFloat* Curve, bool CurveReverse);
	bool EnableEventBattlefieldFence(int32 FenceGroupID);
	void EndBattlefieldForce(int32 GroupID);
	void EndCutScene(bool IsEndEvent, float PlayerCameraBlendTime, EViewTargetBlendFunction PlayerCameraBlendFunc, float PlayerCameraBlendExp, class FName SkipENPCCamRowName);
	bool EndEventBattlefield(int32 GroupID, bool ForceCloseFence);
	void EndFade(float FadeSeconds, bool IsUnderCaption);
	void EndHighSpeedMode();
	void EndTalkEvent(bool IsRestoreTransform);
	void EventAllManagerEnd(bool RestoreTickEnable, bool RestoreVisibility);
	void EventAllManagerStart(bool TickEnable, bool Visibility);
	void FinishSubQuest(bool NoCheck, bool UiEffectFlag);
	void FinishSubQuestById(class FName SubQuestID, bool NoCheck, bool UiEffectFlag);
	void FinishUIEffectBondsQuest(class FName bondsQuestId);
	void FinishUIEffectSubQuest(class FName SubQuestID);
	float GetBondsFValue(EPlayerID HeroID, EPlayerID PartnerId);
	int32 GetBondsLevel(EPlayerID HeroID, EPlayerID PartnerId);
	int32 GetBondsProgress(EPlayerID HeroID, EPlayerID PartnerId);
	int32 GetBondsValue(EPlayerID HeroID, EPlayerID PartnerId);
	int32 GetChoiceResult(int32 MessageIndex);
	const struct FBattlefieldInfo GetCurrentBattlefieldInfo();
	int32 GetEnemyNumInGroup(int32 GroupID);
	int32 GetEnemyNumInSubGroup(int32 GroupID, int32 SubGroupID);
	int32 GetGeneralChoiceResult();
	int32 GetLastChoiceResult();
	class FString GetMessageForMessageLabel(const class FString& MessageLabel);
	class FName GetResultCode();
	class FString GetResultKeyword();
	class FName GetResultVisionSimulatorSelect();
	bool IsCanceledCode();
	bool IsCanceledVisionSimulatorSelect();
	bool IsCancelKeyword();
	bool IsMainEventWait();
	bool IsPhotoModeFlag();
	bool IsSavedSaveLoadMenu();
	bool IsSavedSaveLoadMenuError();
	bool IsSeamlessStart();
	bool IsSkipUnableFlag();
	bool IsStartBattlefield(int32 GroupID);
	bool IsWaitEndSASCutinCh0400_0600();
	bool IsWaitEndSASCutinCh0500_0700();
	int32 LC21ChangePhase(int32 PhaseNo);
	void LoadMessage(const class FString& MessageDataPath, bool PreLoad);
	void LockInputSubMenu();
	void NPCLookAtPlayer(bool IsLookAt);
	void NPCPlayAnimation(const ENpcAnimationKind AnimKind);
	void NPCTurnToPlayer(float Speed);
	void OffPhotoModeFlag();
	void OffSkipLatentNodeFlag();
	void OffSkipUnableFlag();
	void OnFinishEvent();
	void OnPhotoModeFlag();
	void OnSkipUnableFlag();
	void OnStartEvent();
	void OnStartGameEventNative();
	void OpenEventBrainFieldTuto();
	void OpenScarletLogo();
	void PlayBoardAnimation(int32 CaptureActorIndex, const class FString& BoardAnimNamePath, bool IsLoop, class FName SocketName, TSoftObjectPtr<class UCurveFloat> PlayRateCurveData);
	void PlayBoardBGAnimation(const class FString& BoardAnimNamePath, bool IsLoop);
	void PlayGeneralBoardAnimation(int32 CaptureActorIndex, const class FString& boardAnimationName, int32 AttachCaptureActorIndex, class UAnimMontage* AddAnimMontage, TSoftObjectPtr<class UCurveFloat> PlayRateCurveData);
	void PreLoadAllVoice();
	void RequestChangeScene(int32 LocationId, int32 AreaId, int32 PortalID, class FName StartPortalName, bool NoFade, ELoadingScreenType LoadingScreenType, int32 LoadingScreenParam, bool IsAutoSaveEnable);
	void RestartUpdatingBrainMessage();
	void SaveLoad(EEventSaveLoadType SaveType, EEventSaveLoadExType Mode);
	void SetActionIconType(bool NeedKizunaIcon);
	void SetActiveSubQuest(class FName SubQuestID);
	void SetAnimationActor(class UObject* Object);
	void SetBondsProgress(EPlayerID HeroID, EPlayerID PartnerId, int32 SetValue, bool NotUpdateBrainMes);
	void SetBondsQuestState(class FName bondsQuestId, EQuestProgressState SetState);
	void SetDirectionalLight(class FName LightPresetName);
	void SetEventMovieTextureAndPrepare(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, class UManaTexture* MovieTexture);
	void SetEventPause(bool IsPause);
	void SetIsEndMotion(bool IsEndMotion);
	void SetIsWaitFlag(bool IsWait);
	void SetPlayBattleUI(bool IsVisible);
	void SetPlayerController(class APlayerController* PlayerController);
	void SetStopBoadMotionFlag(bool IsStop);
	void SetSubQuestState(class FName SubQuestID, EQuestProgressState SetState);
	void SettingCapture(int32 CaptureActorIndex, int32 BoardMeshIndex, class FName CapturePresetName, class FName CharaBodyAnimationSectionName, class FName CharaFaceAnimationSectionName, int32 NpcMeshTableID, int32 NpcMaterialTableID, class FName LightPresetName, class ULevelSequence* CaptureSequnece, float CaptureSequnecePositon, class FName TextureRowName, EStaticPlType StaticPlType, class FName MovieTextureRowName, bool IsUseSaveTexture, bool IsSeamlessInGameCapture, bool IsHiddenPlFrameEffect, class FName CharaEyePresetName, float EyeXAxisThreshold, float EyeYAxisThreshold, const class FString& CharaPartsMontagePath);
	void SetTransformCaptureBG(const struct FTransform& Transform);
	void SetTransformCaptureBGCamera(const struct FTransform& Transform);
	void Shop(EEventShopType ShopType, int32 ShopParam, int32 TradeShopParam);
	void SkipEvent();
	void SkipMessage(bool NoPlaySE);
	void SpawnEnemiesByGroup(int32 GroupID);
	void SpawnEnemiesBySubGroup(int32 GroupID, int32 SubGroupID);
	void StartAutoBoardAnimation(int32 CaptureActorIndex, const class FString& BoardAnimNamePath, class UAnimMontage* AddAnimMontage, EStaticPlType StaticPlType, TSoftObjectPtr<class UCurveFloat> PlayRateCurveData);
	bool StartBattlefield(EBattlefieldEventType Type, int32 GroupID, int32 SubGroupID, const TArray<struct FBattlefieldTutorialInfo>& AdditionalTutorialInfo, TSubclassOf<class AMakeEventActor> MakeEventActorClass, int32 TutorialGroupID, int32 TutorialSubGroupID, float FenceBattleRate, const class FString& SeedString, bool IsOnceBattle);
	void StartBondsQuestById(class FName bondsQuestId, bool NoCheck, bool UiEffectFlag);
	void StartCode();
	void StartDynamicCutscene(class ULevelSequence* Sequence, bool IsSeamlessInGame, class FName OwnerShipExternalActorTag);
	void StartEvent();
	bool StartEventBattlefield(int32 GroupID, int32 SubGroupID);
	void StartFade(float FadeSeconds, float ColorR, float ColorG, float ColorB, float ColorA, bool IsUnderCaption);
	void StartFadeIn(float FadeSeconds, float ColorR, float ColorG, float ColorB, float ColorA, bool IsUnderCaption);
	void StartFadeOut(float FadeSeconds, float ColorR, float ColorG, float ColorB, float ColorA, bool IsUnderCaption);
	void StartHighSpeedMode();
	void StartKeyword();
	void StartSubQuest(bool NoCheck, bool UiEffectFlag);
	void StartSubQuestById(class FName SubQuestID, bool NoCheck, bool UiEffectFlag);
	void StartTalkEvent(bool IsAutoInput);
	void StartUIEffectBondsQuest(class FName bondsQuestId);
	void StartUIEffectSubQuest(class FName SubQuestID);
	void StartUIRewardSubQuest(class FName SubQuestID);
	void StartUITutoOperation(class FName HelpTutoID);
	void StartUITutoTips(class FName HelpTutoID);
	void StartUITutoTipsByID(EHelpTutorial HelpTutoID, bool NotPauseControll, bool NotCloseOfPause);
	void StartupCutscene(bool IsPartyPlayerBattleReady, bool IsENPCBattleReady, bool PreLoad);
	void StartVisionSimulatorSelect();
	void StaticEventEnd(bool IsRestoreTransform);
	void StaticEventStart();
	void StoreSequencerInGameTransform(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, class ULevelSequence* Sequnece, float SequencePosition);
	void UnloadMessage();
	void UnLockInputSubMenu();
	bool UpdateBondsLevel(EPlayerID PlayerId, EPlayerID TargetID, bool IsSingleLvUp);
	void UpdateBondsLevelAllMembers(EPlayerID PlayerId, TArray<EPlayerID>* LevelupMembers, bool IsSingleLvUp);
	void UpdateTownPeopleSubQuestState();
	void WaitBoardAnimation(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, int32 CaptureActorIndex);
	void WaitBoardBGAnimation(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitBrainField(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitBrainFieldButton(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitBrainFieldDangerLV(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, EPlayerBrainFieldDanger DangerLvType);
	void WaitCharacterEventMoveEnd(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitCloseSystemMessage(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitDelayOrInput(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, float Duration, bool OnSkipLatentNodeFlag);
	void WaitDynamicCutscene(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndBrainTalk(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndCode(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndCreditEvent(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndKeyword(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndSubMenu(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEndVisionSimulatorSelect(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEventBrainFieldTuto(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitEventTips(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitFade(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitGeneralChoice(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitInput(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitLoadAssetAll(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitLoadChangeScene(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitLoadingInterlude(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, const TDelegate<void(class AMainEventLatentActor* Latenter)> OnEventDispatcher, int32 ID);
	void WaitLoadMakeEventAsset(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitLogMessage(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitMainEvent(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, const TDelegate<void(class AMainEventLatentActor* Latenter)> OnEventDispatcher);
	void WaitMessage(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, bool FlagCheckClose);
	void WaitMipLoadReady(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, float TimeLimitSeconds);
	void WaitMipLoadReadyMesh(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, class FName MeshName, float TimeLimitSeconds);
	void WaitNewStaticInGeneralAnimation(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitPhaseAnimation(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_, bool IsOrWaitInput, bool OnSkipLatentNodeFlag);
	void WaitPostProcessSequencer(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitPresentSequencer(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSASCutinCh0400_0600(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSASCutinCh0500_0700(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSASCutinExtra(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSasWindow(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSaveLoad(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitShop(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitSubQuestReward(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);
	void WaitTutoTips(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);

	const EQuestProgressState GetBondsQuestProgressById(class FName bondsQuestId) const;
	const EQuestProgressState GetSubQuestProgress() const;
	const EQuestProgressState GetSubQuestProgressById(class FName SubQuestID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MakeEventActor">();
	}
	static class AMakeEventActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMakeEventActor>();
	}
};
static_assert(alignof(AMakeEventActor) == 0x000008, "Wrong alignment on AMakeEventActor");
static_assert(sizeof(AMakeEventActor) == 0x000410, "Wrong size on AMakeEventActor");
static_assert(offsetof(AMakeEventActor, OnEvent) == 0x000230, "Member 'AMakeEventActor::OnEvent' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, CharaPresetNameList) == 0x000240, "Member 'AMakeEventActor::CharaPresetNameList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, TextureRowNameList) == 0x000250, "Member 'AMakeEventActor::TextureRowNameList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, MovieTextureRowNameList) == 0x000260, "Member 'AMakeEventActor::MovieTextureRowNameList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, AnimAssetPathList) == 0x000270, "Member 'AMakeEventActor::AnimAssetPathList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, AnimBPPathList) == 0x000280, "Member 'AMakeEventActor::AnimBPPathList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, EventPostProcessIDList) == 0x000290, "Member 'AMakeEventActor::EventPostProcessIDList' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsBattleSimulatorSystemEvent) == 0x0002A0, "Member 'AMakeEventActor::IsBattleSimulatorSystemEvent' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsNpcActionButton2Event) == 0x0002A1, "Member 'AMakeEventActor::IsNpcActionButton2Event' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsSkip) == 0x0002A2, "Member 'AMakeEventActor::IsSkip' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsActiveBPEvent) == 0x0002A3, "Member 'AMakeEventActor::IsActiveBPEvent' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, bStaticToInGame) == 0x0002A4, "Member 'AMakeEventActor::bStaticToInGame' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, bStoreSequencerInGameTransform) == 0x0002A5, "Member 'AMakeEventActor::bStoreSequencerInGameTransform' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, OwnerActor) == 0x0002A8, "Member 'AMakeEventActor::OwnerActor' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsSkipOPEvent) == 0x0002B0, "Member 'AMakeEventActor::IsSkipOPEvent' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, SkipUnableSpaceString) == 0x0002B8, "Member 'AMakeEventActor::SkipUnableSpaceString' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_InterludeID) == 0x0002C8, "Member 'AMakeEventActor::M_InterludeID' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, SkipMessageSE) == 0x0002D0, "Member 'AMakeEventActor::SkipMessageSE' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_isWait) == 0x0002D8, "Member 'AMakeEventActor::M_isWait' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_waitMode) == 0x0002D9, "Member 'AMakeEventActor::M_waitMode' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_waitSecond) == 0x0002DC, "Member 'AMakeEventActor::M_waitSecond' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PlayerController) == 0x0002E8, "Member 'AMakeEventActor::M_PlayerController' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_IsEndMotion) == 0x0002F0, "Member 'AMakeEventActor::M_IsEndMotion' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_AnimationActor) == 0x0002F8, "Member 'AMakeEventActor::M_AnimationActor' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_isStartDynamicCutscene) == 0x000300, "Member 'AMakeEventActor::M_isStartDynamicCutscene' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_isCallSkipMessage) == 0x000301, "Member 'AMakeEventActor::M_isCallSkipMessage' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_MessageFlagCheckClose) == 0x000302, "Member 'AMakeEventActor::M_MessageFlagCheckClose' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_pWaitAnimMontageActor) == 0x000308, "Member 'AMakeEventActor::M_pWaitAnimMontageActor' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_pWaitAnimMontageMontage) == 0x000310, "Member 'AMakeEventActor::M_pWaitAnimMontageMontage' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_pWaitLoadAsset) == 0x000318, "Member 'AMakeEventActor::M_pWaitLoadAsset' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_StoreSeqCapStatus) == 0x000320, "Member 'AMakeEventActor::M_StoreSeqCapStatus' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_SequenceSkipPhase) == 0x000321, "Member 'AMakeEventActor::M_SequenceSkipPhase' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PhotoModeStatusType) == 0x000322, "Member 'AMakeEventActor::M_PhotoModeStatusType' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_IsStopBoadMotion) == 0x000323, "Member 'AMakeEventActor::M_IsStopBoadMotion' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_IsSkipLatentNode) == 0x000324, "Member 'AMakeEventActor::M_IsSkipLatentNode' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_bInputOnSkipLatentNode) == 0x000325, "Member 'AMakeEventActor::M_bInputOnSkipLatentNode' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_Latenter) == 0x000328, "Member 'AMakeEventActor::M_Latenter' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsKeyDown) == 0x000330, "Member 'AMakeEventActor::IsKeyDown' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, KeyDownTime) == 0x000334, "Member 'AMakeEventActor::KeyDownTime' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_IsOrWaitInput) == 0x000338, "Member 'AMakeEventActor::M_IsOrWaitInput' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, IsCurrentStaticEvent) == 0x000339, "Member 'AMakeEventActor::IsCurrentStaticEvent' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PreLoadAnimationMap) == 0x000340, "Member 'AMakeEventActor::M_PreLoadAnimationMap' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PreLoadAnimationBPMap) == 0x000390, "Member 'AMakeEventActor::M_PreLoadAnimationBPMap' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PreLoadCurveFloat) == 0x0003E0, "Member 'AMakeEventActor::M_PreLoadCurveFloat' has a wrong offset!");
static_assert(offsetof(AMakeEventActor, M_PreLoadPPMList) == 0x0003F8, "Member 'AMakeEventActor::M_PreLoadPPMList' has a wrong offset!");

// Class BattlePrototype.UIGeneralChoice
// 0x01A0 (0x0528 - 0x0388)
class UUIGeneralChoice : public UUIBase
{
public:
	uint8                                         Pad_20F5[0x1A0];                                   // 0x0388(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Param_Index, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextMain, class UVerticalBox* IndexListParent, class UImage* ImageGhost, class UImage* ImagepgBlack);
	void Notice_start1(const class FString& TextMain, const class FString& TextIndex);
	void Notice_start2(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2);
	void Start1(const class FString& TextMain, const class FString& TextIndex, bool Cancelable, int32 CancelIndex, bool IsFade);
	void Start2(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, bool Cancelable, int32 CancelIndex, bool IsFade);
	void Start3(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, const class FString& TextIndex3, bool Cancelable, int32 CancelIndex, bool IsFade);
	void Start4(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, const class FString& TextIndex3, const class FString& TextIndex4, bool Cancelable, int32 CancelIndex, bool IsFade);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	int32 GetResult() const;
	bool IsCancel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGeneralChoice">();
	}
	static class UUIGeneralChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGeneralChoice>();
	}
};
static_assert(alignof(UUIGeneralChoice) == 0x000008, "Wrong alignment on UUIGeneralChoice");
static_assert(sizeof(UUIGeneralChoice) == 0x000528, "Wrong size on UUIGeneralChoice");

// Class BattlePrototype.BTTask_RSPlayerMoveRoute
// 0x0000 (0x00E0 - 0x00E0)
class UBTTask_RSPlayerMoveRoute final : public UBTTask_RSPlayerMoveToBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveRoute">();
	}
	static class UBTTask_RSPlayerMoveRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveRoute>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveRoute) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveRoute");
static_assert(sizeof(UBTTask_RSPlayerMoveRoute) == 0x0000E0, "Wrong size on UBTTask_RSPlayerMoveRoute");

// Class BattlePrototype.UIResurrectionGauge
// 0x0098 (0x0420 - 0x0388)
class UUIResurrectionGauge : public UUIBase
{
public:
	struct FVector2D                              baseOffset;                                        // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2103[0x8];                                     // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2104[0x80];                                    // 0x03A0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimOut2, class UImage* ImageIcon, class USpacer* Spacer);
	void SetGauge(float Guage);
	void SetMode(EResurrectionIconMode Mode);
	void SetOwnerActor(class AActor* Param_OwnerActor);
	void SetWorldOffset(const struct FVector& WorldOffset);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIResurrectionGauge">();
	}
	static class UUIResurrectionGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIResurrectionGauge>();
	}
};
static_assert(alignof(UUIResurrectionGauge) == 0x000008, "Wrong alignment on UUIResurrectionGauge");
static_assert(sizeof(UUIResurrectionGauge) == 0x000420, "Wrong size on UUIResurrectionGauge");
static_assert(offsetof(UUIResurrectionGauge, baseOffset) == 0x000388, "Member 'UUIResurrectionGauge::baseOffset' has a wrong offset!");
static_assert(offsetof(UUIResurrectionGauge, OwnerActor) == 0x000398, "Member 'UUIResurrectionGauge::OwnerActor' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerMoveTo_BlueprintBase
// 0x00C8 (0x0170 - 0x00A8)
class UBTTask_RSPlayerMoveTo_BlueprintBase : public UBTTask_BlueprintBase
{
public:
	class ARSCharacterBase*                       OwnerCharacter;                                    // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerScriptComponent*                 OwnerPlayerScript;                                 // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerAIBaseComponent*                 OwnerPlayerAIComponent;                            // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AcceptionRadius;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AcceptionHeight;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExit;                                             // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInputMoveMode;                                    // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2105[0x2];                                     // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             ResetAIMoveToTimer;                                // 0x00CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         Step;                                              // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpCheck;                                        // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsJumpCheckCurrent;                            // 0x00DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2106[0x2];                                     // 0x00DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpCheckMoveSpeedRatioThreshold;                  // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             CheckWallTimer;                                    // 0x00E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CheckJumpInterval;                                 // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameTimer                             BackInputTimer;                                    // 0x00F4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameTimer                             DetourInputTimer;                                  // 0x0100(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DetourInputDuration;                               // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputBeginYawAngle;                          // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputDurationShort;                          // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputBeginYawAngleShort;                     // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputDurationRateWalk;                       // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputDurationRateRun;                        // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputDurationRateSprint;                     // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputRotateDirection;                        // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetourInputBeginYawAngleCurrent;                   // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAIMoveWallCPP                          WallTypeCPP;                                       // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWallBackCheck;                                    // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2107[0x2];                                     // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceWallBackNotMovedTime;                         // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWallDetourCheck;                                  // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAIMoving;                                         // 0x0139(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnemyCheck;                                       // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWarpCheck;                                        // 0x013B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MovedDistanceCurrent;                              // 0x013C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MovedDistancePrevLocation;                         // 0x0144(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovedDistanceCheckTimer;                           // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovedDistanceCheckInterval;                        // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovedDistanceThreshold;                            // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NotMovedElapsedTime;                               // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceWarpThresholdTime;                            // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceWarpRequest;                                 // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeWalkOrRun;                                  // 0x0161(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2108[0x2];                                     // 0x0162(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkingDistanceMax;                                // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunningDistanceMin;                                // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWalking;                                          // 0x016C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2109[0x3];                                     // 0x016D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckAvoidWallOrWarpCPP();
	void CheckMovedDistance_InitializeCPP();
	void CheckMovedDistance_TickCPP(float DeltaSeconds);
	bool CheckMoveDistance_IsEndCPP();
	void CheckWallCPP();
	void Exit_CallFromCPP(class AAIController* OwnerController, class APawn* ControlledPawn);
	void ExitCPP();
	void ForceWarpCPP();
	void SetAIMoveTo_CallFromCPP(class AAIController* OwnerController, class APawn* ControlledPawn);
	void StopAIMoveToCPP(bool bRechargeResetAIMoveTimer);
	void TickMoveCPP();

	bool CheckArrivedGoalCPP() const;
	bool CheckDistanceXY_CPP(const struct FVector& Location1, const struct FVector& Location2, float DistanceXY) const;
	bool CheckDistanceXY_Z_CPP(const struct FVector& Location1, const struct FVector& Location2, float DistanceXY, float DistanceZ) const;
	bool CheckPlayerIsRun(class ARSCharacterBase* Character) const;
	bool CheckStickMoveEndCPP() const;
	class ARSCharacterBase* GetOwnerCharacter() const;
	class UPlayerAIBaseComponent* GetOwnerPlayerAI() const;
	class UPlayerScriptComponent* GetOwnerPlayerScript() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveTo_BlueprintBase">();
	}
	static class UBTTask_RSPlayerMoveTo_BlueprintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveTo_BlueprintBase>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveTo_BlueprintBase) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveTo_BlueprintBase");
static_assert(sizeof(UBTTask_RSPlayerMoveTo_BlueprintBase) == 0x000170, "Wrong size on UBTTask_RSPlayerMoveTo_BlueprintBase");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, OwnerCharacter) == 0x0000A8, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, OwnerPlayerScript) == 0x0000B0, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::OwnerPlayerScript' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, OwnerPlayerAIComponent) == 0x0000B8, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::OwnerPlayerAIComponent' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, AcceptionRadius) == 0x0000C0, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::AcceptionRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, AcceptionHeight) == 0x0000C4, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::AcceptionHeight' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bExit) == 0x0000C8, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bExit' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bInputMoveMode) == 0x0000C9, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bInputMoveMode' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, ResetAIMoveToTimer) == 0x0000CC, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::ResetAIMoveToTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, Step) == 0x0000D8, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::Step' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bJumpCheck) == 0x0000DC, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bJumpCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bNeedsJumpCheckCurrent) == 0x0000DD, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bNeedsJumpCheckCurrent' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, JumpCheckMoveSpeedRatioThreshold) == 0x0000E0, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::JumpCheckMoveSpeedRatioThreshold' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, CheckWallTimer) == 0x0000E4, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::CheckWallTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, CheckJumpInterval) == 0x0000F0, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::CheckJumpInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, BackInputTimer) == 0x0000F4, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::BackInputTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputTimer) == 0x000100, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDuration) == 0x00010C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputBeginYawAngle) == 0x000110, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputBeginYawAngle' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDurationShort) == 0x000114, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDurationShort' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputBeginYawAngleShort) == 0x000118, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputBeginYawAngleShort' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDurationRateWalk) == 0x00011C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDurationRateWalk' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDurationRateRun) == 0x000120, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDurationRateRun' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputDurationRateSprint) == 0x000124, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputDurationRateSprint' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputRotateDirection) == 0x000128, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputRotateDirection' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, DetourInputBeginYawAngleCurrent) == 0x00012C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::DetourInputBeginYawAngleCurrent' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, WallTypeCPP) == 0x000130, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::WallTypeCPP' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bWallBackCheck) == 0x000131, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bWallBackCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, ForceWallBackNotMovedTime) == 0x000134, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::ForceWallBackNotMovedTime' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bWallDetourCheck) == 0x000138, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bWallDetourCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bAIMoving) == 0x000139, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bAIMoving' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bEnemyCheck) == 0x00013A, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bEnemyCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bWarpCheck) == 0x00013B, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bWarpCheck' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistanceCurrent) == 0x00013C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistanceCurrent' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistancePrevLocation) == 0x000144, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistancePrevLocation' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistanceCheckTimer) == 0x00014C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistanceCheckTimer' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistanceCheckInterval) == 0x000150, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistanceCheckInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, MovedDistanceThreshold) == 0x000154, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::MovedDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, NotMovedElapsedTime) == 0x000158, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::NotMovedElapsedTime' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, ForceWarpThresholdTime) == 0x00015C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::ForceWarpThresholdTime' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bForceWarpRequest) == 0x000160, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bForceWarpRequest' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bChangeWalkOrRun) == 0x000161, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bChangeWalkOrRun' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, WalkingDistanceMax) == 0x000164, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::WalkingDistanceMax' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, RunningDistanceMin) == 0x000168, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::RunningDistanceMin' has a wrong offset!");
static_assert(offsetof(UBTTask_RSPlayerMoveTo_BlueprintBase, bWalking) == 0x00016C, "Member 'UBTTask_RSPlayerMoveTo_BlueprintBase::bWalking' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerMoveToHero
// 0x0000 (0x00E0 - 0x00E0)
class UBTTask_RSPlayerMoveToHero final : public UBTTask_RSPlayerMoveToBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveToHero">();
	}
	static class UBTTask_RSPlayerMoveToHero* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveToHero>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveToHero) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveToHero");
static_assert(sizeof(UBTTask_RSPlayerMoveToHero) == 0x0000E0, "Wrong size on UBTTask_RSPlayerMoveToHero");

// Class BattlePrototype.EnemyLookCheckComponent
// 0x00A0 (0x0170 - 0x00D0)
class UEnemyLookCheckComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_210D[0xA0];                                    // 0x00D0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginLookCheck();
	void EndLookCheck();
	bool GetFailedLook();
	void SetRayPos(const struct FVector& Start, const struct FVector& End);
	void SetRayPos2(const struct FVector& MainStart, const struct FVector& MainEnd, const struct FVector& TargetStart, const struct FVector& TargetEnd);

	bool IsLookMain() const;
	bool IsLookTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyLookCheckComponent">();
	}
	static class UEnemyLookCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyLookCheckComponent>();
	}
};
static_assert(alignof(UEnemyLookCheckComponent) == 0x000008, "Wrong alignment on UEnemyLookCheckComponent");
static_assert(sizeof(UEnemyLookCheckComponent) == 0x000170, "Wrong size on UEnemyLookCheckComponent");

// Class BattlePrototype.UIVisionSimulator
// 0x0458 (0x07E0 - 0x0388)
class UUIVisionSimulator : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210E[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210F[0x3B0];                                   // 0x03A0(0x03B0)(Fixing Size After Last Property [ Dumper-7 ])
	class ABattleSimulatorManager*                M_pBattleSimulatorManager;                         // 0x0750(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2110[0x88];                                    // 0x0758(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(int32 Param_Index, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeCategory(int32 Param_Index, class UUIBase* Widget, class UImage* ImageSeparator, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UTextBlock* TextName);
	void InitializeHighScore(int32 Param_Index, class UImage* ImageFace, class UTextBlock* TextDifficultyTitle, class UTextBlock* TextDifficultyDetail, class UTextBlock* TextTotalScoreTitle, class UTextBlock* TextTotalScoreNum, class UTextBlock* TextTotalScorePiont, class UTextBlock* TextRankTitle, class UImage* ImageRank, class UTextBlock* TextRankNone, class UTextBlock* TextDate, class UTextBlock* TextTimehh, class UTextBlock* TextTimeColon, class UTextBlock* TextTimemm);
	void InitializeMainItems(int32 Param_Index, class UOverlay* TextSet, class UImage* ImageItemRarity, class UImage* ImageItemCategory);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimChange1, class UWidgetAnimation* AnimChange2, class UREDScrollBox* ScrollBoxMain, class UUIGuide* ChildGuide, class UTextBlock* TextScreenTitle, class UImage* ImageIconDifficulty, class UImage* ImageIconDifficulty2, class UTextBlock* TextMissionTitle, class UTextBlock* TextMissionNumber, class UREDScrollBoxSimple* ScrollBoxSub, class UTextBlock* TextOrderTitle, class UBorder* borderOrder, class UTextBlock* TextOrderDetail, class UTextBlock* TextLocationTitle, class UTextBlock* TextLocationDetail, class UTextBlock* TextMissionEnemyTitle, class UTextBlock* TextMissionEnemy0, class UTextBlock* TextMissionEnemy1, class UTextBlock* TextMissionEnemy2, class UTextBlock* TextMissionEnemy3, class UTextBlock* TextMissionEnemy4, class UTextBlock* TextMissionItem, class UTextBlock* TextOverviewTitle, class USpacer* SpaceOverview);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void SetItemIcon(class UImage* ImageCategory, EItemIcon Category);
	void SetItemRarity(class UImage* ImageRarity, EItemRarity Rarity);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVisionSimulator">();
	}
	static class UUIVisionSimulator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVisionSimulator>();
	}
};
static_assert(alignof(UUIVisionSimulator) == 0x000008, "Wrong alignment on UUIVisionSimulator");
static_assert(sizeof(UUIVisionSimulator) == 0x0007E0, "Wrong size on UUIVisionSimulator");
static_assert(offsetof(UUIVisionSimulator, ListElementSize) == 0x000388, "Member 'UUIVisionSimulator::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIVisionSimulator, ListOffsetSize) == 0x000390, "Member 'UUIVisionSimulator::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIVisionSimulator, ListIndexClass) == 0x000398, "Member 'UUIVisionSimulator::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUIVisionSimulator, M_pBattleSimulatorManager) == 0x000750, "Member 'UUIVisionSimulator::M_pBattleSimulatorManager' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerMoveToRevive
// 0x0000 (0x00E0 - 0x00E0)
class UBTTask_RSPlayerMoveToRevive final : public UBTTask_RSPlayerMoveToBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerMoveToRevive">();
	}
	static class UBTTask_RSPlayerMoveToRevive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerMoveToRevive>();
	}
};
static_assert(alignof(UBTTask_RSPlayerMoveToRevive) == 0x000008, "Wrong alignment on UBTTask_RSPlayerMoveToRevive");
static_assert(sizeof(UBTTask_RSPlayerMoveToRevive) == 0x0000E0, "Wrong size on UBTTask_RSPlayerMoveToRevive");

// Class BattlePrototype.RSActorPlayerBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorPlayerBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorPlayerBase">();
	}
	static class ARSActorPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorPlayerBase>();
	}
};
static_assert(alignof(ARSActorPlayerBase) == 0x000008, "Wrong alignment on ARSActorPlayerBase");
static_assert(sizeof(ARSActorPlayerBase) == 0x000230, "Wrong size on ARSActorPlayerBase");

// Class BattlePrototype.EnemyScrollCheckComponent
// 0x0048 (0x0118 - 0x00D0)
class UEnemyScrollCheckComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_2118[0x48];                                    // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginScrollCheck();
	void EndScrollCheck();
	void SetCheckPos(const struct FVector& StartPos, const struct FVector& EndPos);
	void SetFloorAngle(float NewFloorAngle);
	void SetIntervalTime(float NewIntervalTime);

	bool IsHitFloorOrCeiling() const;
	bool IsHitScroll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyScrollCheckComponent">();
	}
	static class UEnemyScrollCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyScrollCheckComponent>();
	}
};
static_assert(alignof(UEnemyScrollCheckComponent) == 0x000008, "Wrong alignment on UEnemyScrollCheckComponent");
static_assert(sizeof(UEnemyScrollCheckComponent) == 0x000118, "Wrong size on UEnemyScrollCheckComponent");

// Class BattlePrototype.BTTask_RSPlayerNextBattleThink
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerNextBattleThink final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerNextBattleThink">();
	}
	static class UBTTask_RSPlayerNextBattleThink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerNextBattleThink>();
	}
};
static_assert(alignof(UBTTask_RSPlayerNextBattleThink) == 0x000008, "Wrong alignment on UBTTask_RSPlayerNextBattleThink");
static_assert(sizeof(UBTTask_RSPlayerNextBattleThink) == 0x0000A8, "Wrong size on UBTTask_RSPlayerNextBattleThink");

// Class BattlePrototype.UIQuestIcon
// 0x0040 (0x03C8 - 0x0388)
class UUIQuestIcon : public UUIBase
{
public:
	uint8                                         Pad_2119[0x40];                                    // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault3, class UWidgetAnimation* AnimDefault4, class UWidgetAnimation* AnimDefault5, class UWidgetAnimation* AnimDefault6, class UTextBlock* TextName);
	void SetProgress(int32 Progress);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestIcon">();
	}
	static class UUIQuestIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestIcon>();
	}
};
static_assert(alignof(UUIQuestIcon) == 0x000008, "Wrong alignment on UUIQuestIcon");
static_assert(sizeof(UUIQuestIcon) == 0x0003C8, "Wrong size on UUIQuestIcon");

// Class BattlePrototype.BTTask_RSPlayerPlayerRevive
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerPlayerRevive final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerPlayerRevive">();
	}
	static class UBTTask_RSPlayerPlayerRevive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerPlayerRevive>();
	}
};
static_assert(alignof(UBTTask_RSPlayerPlayerRevive) == 0x000008, "Wrong alignment on UBTTask_RSPlayerPlayerRevive");
static_assert(sizeof(UBTTask_RSPlayerPlayerRevive) == 0x0000A8, "Wrong size on UBTTask_RSPlayerPlayerRevive");

// Class BattlePrototype.BTTask_RSPlayerResetBehaviorTree
// 0x0000 (0x00A8 - 0x00A8)
class UBTTask_RSPlayerResetBehaviorTree final : public UBTTask_RSPlayerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerResetBehaviorTree">();
	}
	static class UBTTask_RSPlayerResetBehaviorTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerResetBehaviorTree>();
	}
};
static_assert(alignof(UBTTask_RSPlayerResetBehaviorTree) == 0x000008, "Wrong alignment on UBTTask_RSPlayerResetBehaviorTree");
static_assert(sizeof(UBTTask_RSPlayerResetBehaviorTree) == 0x0000A8, "Wrong size on UBTTask_RSPlayerResetBehaviorTree");

// Class BattlePrototype.FreeCameraSpectatorPawn
// 0x0020 (0x02D8 - 0x02B8)
class AFreeCameraSpectatorPawn final : public ASpectatorPawn
{
public:
	class UCameraComponent*                       CameraComponent;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedScale;                                        // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialMaxSpeed;                                   // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialAccel;                                      // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialDecel;                                      // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211A[0x8];                                     // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeCameraSpectatorPawn">();
	}
	static class AFreeCameraSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFreeCameraSpectatorPawn>();
	}
};
static_assert(alignof(AFreeCameraSpectatorPawn) == 0x000008, "Wrong alignment on AFreeCameraSpectatorPawn");
static_assert(sizeof(AFreeCameraSpectatorPawn) == 0x0002D8, "Wrong size on AFreeCameraSpectatorPawn");
static_assert(offsetof(AFreeCameraSpectatorPawn, CameraComponent) == 0x0002B8, "Member 'AFreeCameraSpectatorPawn::CameraComponent' has a wrong offset!");
static_assert(offsetof(AFreeCameraSpectatorPawn, SpeedScale) == 0x0002C0, "Member 'AFreeCameraSpectatorPawn::SpeedScale' has a wrong offset!");
static_assert(offsetof(AFreeCameraSpectatorPawn, InitialMaxSpeed) == 0x0002C4, "Member 'AFreeCameraSpectatorPawn::InitialMaxSpeed' has a wrong offset!");
static_assert(offsetof(AFreeCameraSpectatorPawn, InitialAccel) == 0x0002C8, "Member 'AFreeCameraSpectatorPawn::InitialAccel' has a wrong offset!");
static_assert(offsetof(AFreeCameraSpectatorPawn, InitialDecel) == 0x0002CC, "Member 'AFreeCameraSpectatorPawn::InitialDecel' has a wrong offset!");

// Class BattlePrototype.TutorialData
// 0x0008 (0x0030 - 0x0028)
class UTutorialData final : public UObject
{
public:
	class UHelpTutorialDBAsset*                   HelpDataAsset_;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialData">();
	}
	static class UTutorialData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialData>();
	}
};
static_assert(alignof(UTutorialData) == 0x000008, "Wrong alignment on UTutorialData");
static_assert(sizeof(UTutorialData) == 0x000030, "Wrong size on UTutorialData");
static_assert(offsetof(UTutorialData, HelpDataAsset_) == 0x000028, "Member 'UTutorialData::HelpDataAsset_' has a wrong offset!");

// Class BattlePrototype.BTTask_RSPlayerUseItem
// 0x0008 (0x00B0 - 0x00A8)
class UBTTask_RSPlayerUseItem final : public UBTTask_RSPlayerBase
{
public:
	int32                                         Step;                                              // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211B[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RSPlayerUseItem">();
	}
	static class UBTTask_RSPlayerUseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RSPlayerUseItem>();
	}
};
static_assert(alignof(UBTTask_RSPlayerUseItem) == 0x000008, "Wrong alignment on UBTTask_RSPlayerUseItem");
static_assert(sizeof(UBTTask_RSPlayerUseItem) == 0x0000B0, "Wrong size on UBTTask_RSPlayerUseItem");
static_assert(offsetof(UBTTask_RSPlayerUseItem, Step) == 0x0000A8, "Member 'UBTTask_RSPlayerUseItem::Step' has a wrong offset!");

// Class BattlePrototype.DebuggingItemEvent
// 0x0018 (0x02E0 - 0x02C8)
class ADebuggingItemEvent : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnEvent;                                           // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_211C[0x8];                                     // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallEvent();
	void OnKeySelectFunc(const class ADebuggingItemBase* InItem, bool IsRepeat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemEvent">();
	}
	static class ADebuggingItemEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemEvent>();
	}
};
static_assert(alignof(ADebuggingItemEvent) == 0x000008, "Wrong alignment on ADebuggingItemEvent");
static_assert(sizeof(ADebuggingItemEvent) == 0x0002E0, "Wrong size on ADebuggingItemEvent");
static_assert(offsetof(ADebuggingItemEvent, OnEvent) == 0x0002C8, "Member 'ADebuggingItemEvent::OnEvent' has a wrong offset!");

// Class BattlePrototype.DebuggingItemScrApply
// 0x0010 (0x02F0 - 0x02E0)
class ADebuggingItemScrApply final : public ADebuggingItemEvent
{
public:
	uint8                                         Pad_211E[0x10];                                    // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyEvent(const class ADebuggingItemEvent* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrApply">();
	}
	static class ADebuggingItemScrApply* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrApply>();
	}
};
static_assert(alignof(ADebuggingItemScrApply) == 0x000008, "Wrong alignment on ADebuggingItemScrApply");
static_assert(sizeof(ADebuggingItemScrApply) == 0x0002F0, "Wrong size on ADebuggingItemScrApply");

// Class BattlePrototype.CalcMemoryManager
// 0x0080 (0x00A8 - 0x0028)
class UCalcMemoryManager final : public UObject
{
public:
	uint8                                         Pad_211F[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECalcMode                                     CurCalcMode;                                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2120[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ListIndex;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStartCalcMemory;                                  // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcPlayer;                                       // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcEnemy;                                        // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcNPC;                                          // 0x003B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcObject;                                       // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCalcLevel;                                        // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCancel;                                           // 0x003E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRequestLevel;                                     // 0x003F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2121[0x8];                                     // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAssetMemoryData*>               AssetInfos;                                        // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnyObjectCreator*                      CreateObject;                                      // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAssetMemoryData*>               LevelInfos;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentIndex;                                      // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaitTimer;                                         // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFinishedCurrentAsset;                             // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bExecLevel;                                        // 0x0079(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2122[0x2];                                     // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentLevelIndex;                                 // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECalcProcess                                  MyProcess;                                         // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2123[0x7];                                     // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        PreUsedPhysical;                                   // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        PreUsedVirtual;                                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        PostUsedPhysical;                                  // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint64                                        PostUsedVirtual;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CalcMemory();
	void CancelLevel();
	ECalcTarget DecrementCalcTarget();
	ECalcMode GetCalcMode();
	class FName GetCurrentLevelName();
	ECalcTarget IncrementCalcTarget();
	void IncrementLevel();
	void PostMeasureLevel();
	void PreMeasureLevel();
	void PrintLevelInfo();
	void ReadyNextAsset();
	void RefleshSelectAsset();
	void ResetCalcMemory();
	void ResetStartCalcMemory();
	void SelectNextAsset(int32 AddValue);
	void SelectNextPageAsset();
	void SelectPrevAsset(int32 SubValue);
	void SelectPrevPageAsset();
	void SetCancel();
	void StartCalcLevel();
	void StartCalcMemory();
	void StartCurrentAsset();
	ECalcMode SwitchCalcMode(bool IsLevel);
	void SwitchCalcTargetEnemy();
	void SwitchCalcTargetLevel();
	void SwitchCalcTargetNPC();
	void SwitchCalcTargetObject();
	void SwitchCalcTargetPlayer();

	class FString GetIndividualStatusText() const;
	class FString GetLevelStatusText() const;
	class FString GetStatusText() const;
	bool IsCalcTargetEnemy() const;
	bool IsCalcTargetLevel() const;
	bool IsCalcTargetNPC() const;
	bool IsCalcTargetObject() const;
	bool IsCalcTargetPlayer() const;
	bool IsCancel() const;
	bool IsExec() const;
	bool IsExecLevel() const;
	bool IsFinished() const;
	bool IsFinishedCurrentAsset() const;
	bool IsReadyCurrentAsset() const;
	bool IsRequestLevel() const;
	bool IsStartCalcMemory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalcMemoryManager">();
	}
	static class UCalcMemoryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalcMemoryManager>();
	}
};
static_assert(alignof(UCalcMemoryManager) == 0x000008, "Wrong alignment on UCalcMemoryManager");
static_assert(sizeof(UCalcMemoryManager) == 0x0000A8, "Wrong size on UCalcMemoryManager");
static_assert(offsetof(UCalcMemoryManager, CurCalcMode) == 0x000030, "Member 'UCalcMemoryManager::CurCalcMode' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, ListIndex) == 0x000034, "Member 'UCalcMemoryManager::ListIndex' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bStartCalcMemory) == 0x000038, "Member 'UCalcMemoryManager::bStartCalcMemory' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcPlayer) == 0x000039, "Member 'UCalcMemoryManager::bCalcPlayer' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcEnemy) == 0x00003A, "Member 'UCalcMemoryManager::bCalcEnemy' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcNPC) == 0x00003B, "Member 'UCalcMemoryManager::bCalcNPC' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcObject) == 0x00003C, "Member 'UCalcMemoryManager::bCalcObject' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCalcLevel) == 0x00003D, "Member 'UCalcMemoryManager::bCalcLevel' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bCancel) == 0x00003E, "Member 'UCalcMemoryManager::bCancel' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bRequestLevel) == 0x00003F, "Member 'UCalcMemoryManager::bRequestLevel' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, AssetInfos) == 0x000048, "Member 'UCalcMemoryManager::AssetInfos' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, CreateObject) == 0x000058, "Member 'UCalcMemoryManager::CreateObject' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, LevelInfos) == 0x000060, "Member 'UCalcMemoryManager::LevelInfos' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, CurrentIndex) == 0x000070, "Member 'UCalcMemoryManager::CurrentIndex' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, WaitTimer) == 0x000074, "Member 'UCalcMemoryManager::WaitTimer' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bFinishedCurrentAsset) == 0x000078, "Member 'UCalcMemoryManager::bFinishedCurrentAsset' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, bExecLevel) == 0x000079, "Member 'UCalcMemoryManager::bExecLevel' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, CurrentLevelIndex) == 0x00007C, "Member 'UCalcMemoryManager::CurrentLevelIndex' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, MyProcess) == 0x000080, "Member 'UCalcMemoryManager::MyProcess' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, PreUsedPhysical) == 0x000088, "Member 'UCalcMemoryManager::PreUsedPhysical' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, PreUsedVirtual) == 0x000090, "Member 'UCalcMemoryManager::PreUsedVirtual' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, PostUsedPhysical) == 0x000098, "Member 'UCalcMemoryManager::PostUsedPhysical' has a wrong offset!");
static_assert(offsetof(UCalcMemoryManager, PostUsedVirtual) == 0x0000A0, "Member 'UCalcMemoryManager::PostUsedVirtual' has a wrong offset!");

// Class BattlePrototype.TownPeopleManager
// 0x0010 (0x0240 - 0x0230)
class ATownPeopleManager final : public AActor
{
public:
	class UNpcManager*                            PNpcManager;                                       // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2124[0x8];                                     // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TownPeopleManager">();
	}
	static class ATownPeopleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATownPeopleManager>();
	}
};
static_assert(alignof(ATownPeopleManager) == 0x000008, "Wrong alignment on ATownPeopleManager");
static_assert(sizeof(ATownPeopleManager) == 0x000240, "Wrong size on ATownPeopleManager");
static_assert(offsetof(ATownPeopleManager, PNpcManager) == 0x000230, "Member 'ATownPeopleManager::PNpcManager' has a wrong offset!");

// Class BattlePrototype.CameraInterface
// 0x0000 (0x0028 - 0x0028)
class ICameraInterface final : public IInterface
{
public:
	struct FVector GetCameraLookAtPos();
	struct FVector GetPlayerCameraDirection();
	float GetPlayerCameraFieldOfView();
	struct FVector GetPlayerCameraLocation();
	EPlayerCameraMode GetPlayerCameraMode();
	struct FRotator GetPlayerCameraRotation();
	struct FVector GetRemoteActorLocation();
	struct FRotator GetRemoteActorRotation();
	bool SetPlayerCameraDirection(const struct FVector& Pos);
	bool SetPlayerCameraFieldOfView(float FOV);
	bool SetPlayerCameraLocation(const struct FVector& Pos);
	bool SetPlayerCameraMode(EPlayerCameraMode Mode);
	bool SetPlayerCameraRotation(const struct FRotator& Rot);
	bool SetPlayerCameraViewTarget(float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraInterface">();
	}
	static class ICameraInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICameraInterface>();
	}
};
static_assert(alignof(ICameraInterface) == 0x000008, "Wrong alignment on ICameraInterface");
static_assert(sizeof(ICameraInterface) == 0x000028, "Wrong size on ICameraInterface");

// Class BattlePrototype.CameraPropertyMediatorComponent
// 0x0090 (0x0150 - 0x00C0)
class UCameraPropertyMediatorComponent final : public UActorComponent
{
public:
	float                                         PitchNoMove;                                       // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_212B[0x8C];                                    // 0x00C4(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCameraPropertyMediatorComponent* GetCameraPropertyMediatorComponentFromActor(class AActor* Actor);

	void ClearTargetArmLengthPitchByName(class FName Param_Name);
	void ClearTargetArmLengthPitchByObject(const class UObject* Object);
	void SetControlledCameraByOwner();
	void SetTargetArmLengthPitchByName(class FName Param_Name, float Length, float Pitch, float KeepSec, float InterpSec, EEasingFunc InterpType);
	void SetTargetArmLengthPitchByObject(const class UObject* Object, float Length, float Pitch, float KeepSec, float InterpSec, EEasingFunc InterpType);

	bool IsRestoreCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraPropertyMediatorComponent">();
	}
	static class UCameraPropertyMediatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraPropertyMediatorComponent>();
	}
};
static_assert(alignof(UCameraPropertyMediatorComponent) == 0x000008, "Wrong alignment on UCameraPropertyMediatorComponent");
static_assert(sizeof(UCameraPropertyMediatorComponent) == 0x000150, "Wrong size on UCameraPropertyMediatorComponent");
static_assert(offsetof(UCameraPropertyMediatorComponent, PitchNoMove) == 0x0000C0, "Member 'UCameraPropertyMediatorComponent::PitchNoMove' has a wrong offset!");

// Class BattlePrototype.DebuggingGameActivityManager
// 0x0028 (0x0258 - 0x0230)
class ADebuggingGameActivityManager final : public AActor
{
public:
	uint8                                         Pad_212E[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayString;                                     // 0x0238(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           TextColor;                                         // 0x0248(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsDisplayFlag();
	void SetDisplayFlag(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingGameActivityManager">();
	}
	static class ADebuggingGameActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingGameActivityManager>();
	}
};
static_assert(alignof(ADebuggingGameActivityManager) == 0x000008, "Wrong alignment on ADebuggingGameActivityManager");
static_assert(sizeof(ADebuggingGameActivityManager) == 0x000258, "Wrong size on ADebuggingGameActivityManager");
static_assert(offsetof(ADebuggingGameActivityManager, DisplayString) == 0x000238, "Member 'ADebuggingGameActivityManager::DisplayString' has a wrong offset!");
static_assert(offsetof(ADebuggingGameActivityManager, TextColor) == 0x000248, "Member 'ADebuggingGameActivityManager::TextColor' has a wrong offset!");

// Class BattlePrototype.UIQuestDetailsMain
// 0x0060 (0x03E8 - 0x0388)
class UUIQuestDetailsMain : public UUIBase
{
public:
	uint8                                         Pad_212F[0x60];                                    // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UTextBlock* TextTitle, class UREDScrollBoxSimple* ScrollBox, class UImage* Image1, class UImage* Image2, class UImage* Image3, class UImage* Image4, class UImage* Image5, class UUIQuestIcon* UIQuestIcon, class UUIQuestNamePlate* UIQuestNamePlate, class UCanvasPanel* QuestPanel, class UOverlay* OverlayImage1Set, class UOverlay* OverlayImage2Set, class UOverlay* OverlayImage3Set, class UOverlay* OverlayImage4Set, class UOverlay* OverlayImage5Set, class UOverlay* OverlayText1Set, class UOverlay* OverlayText2Set, class UOverlay* OverlayText3Set, class UOverlay* OverlayText4Set, class UOverlay* OverlayText5Set, class UOverlay* OverlayText6Set);
	void SetProgressIcon(int32 ProgressIndex);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestDetailsMain">();
	}
	static class UUIQuestDetailsMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestDetailsMain>();
	}
};
static_assert(alignof(UUIQuestDetailsMain) == 0x000008, "Wrong alignment on UUIQuestDetailsMain");
static_assert(sizeof(UUIQuestDetailsMain) == 0x0003E8, "Wrong size on UUIQuestDetailsMain");

// Class BattlePrototype.ChangeMinimapStateComponent
// 0x0010 (0x00D0 - 0x00C0)
class UChangeMinimapStateComponent final : public UActorComponent
{
public:
	bool                                          IsAccessed;                                        // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2130[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SquareDistance;                                    // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeightDifference;                                  // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2131[0x4];                                     // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeParam(bool IsAlreadyAccessed, float CheckDistance, float Param_HeightDifference);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeMinimapStateComponent">();
	}
	static class UChangeMinimapStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeMinimapStateComponent>();
	}
};
static_assert(alignof(UChangeMinimapStateComponent) == 0x000008, "Wrong alignment on UChangeMinimapStateComponent");
static_assert(sizeof(UChangeMinimapStateComponent) == 0x0000D0, "Wrong size on UChangeMinimapStateComponent");
static_assert(offsetof(UChangeMinimapStateComponent, IsAccessed) == 0x0000C0, "Member 'UChangeMinimapStateComponent::IsAccessed' has a wrong offset!");
static_assert(offsetof(UChangeMinimapStateComponent, SquareDistance) == 0x0000C4, "Member 'UChangeMinimapStateComponent::SquareDistance' has a wrong offset!");
static_assert(offsetof(UChangeMinimapStateComponent, HeightDifference) == 0x0000C8, "Member 'UChangeMinimapStateComponent::HeightDifference' has a wrong offset!");

// Class BattlePrototype.EventInterface
// 0x0000 (0x0028 - 0x0028)
class IEventInterface final : public IInterface
{
public:
	bool BattleSequencerEnd(bool IsRestoreTransform, bool IsSetEnemyEvent, bool bDriveSequence);
	bool BattleSequencerStart(bool IsSetEnemyEvent, bool bDriveSequence);
	bool DynamicEventBeforeBindCharacter();
	bool DynamicEventEnd(bool IsRestoreTransform);
	bool DynamicEventStart();
	bool EventEnd();
	bool EventInputRestrictNative(bool Restrict);
	void EventPhysicsIdling(float IdlingSec, float IdleRestoreDelay);
	bool EventStart();
	bool IsEndEventAnimMontage(class UAnimMontage* AnimMontage);
	bool PlayEventAnimMontage(class UAnimMontage* AnimMontage, class FName Section, float InPlayRate);
	bool ResetShadowOffset();
	bool SetEventVisible(bool Visible);
	bool SetHoodVisible(bool Visible);
	bool SetShadowOffsetMapID(EMaterialShadowOffsetID ShadowOffsetID);
	bool SetShadowOffsetTexture(class UTexture2D* Texture);
	bool StaticEventEnd(bool IsRestoreTransform);
	bool StaticEventStart();
	bool StopEventAnimMontage(class UAnimMontage* AnimMontage);
	bool TalkEventEnd(bool IsRestoreTransform);
	bool TalkEventStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventInterface">();
	}
	static class IEventInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventInterface>();
	}
};
static_assert(alignof(IEventInterface) == 0x000008, "Wrong alignment on IEventInterface");
static_assert(sizeof(IEventInterface) == 0x000028, "Wrong size on IEventInterface");

// Class BattlePrototype.ChangeMinimapStateInterface
// 0x0000 (0x0028 - 0x0028)
class IChangeMinimapStateInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeMinimapStateInterface">();
	}
	static class IChangeMinimapStateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChangeMinimapStateInterface>();
	}
};
static_assert(alignof(IChangeMinimapStateInterface) == 0x000008, "Wrong alignment on IChangeMinimapStateInterface");
static_assert(sizeof(IChangeMinimapStateInterface) == 0x000028, "Wrong size on IChangeMinimapStateInterface");

// Class BattlePrototype.UISASFrame
// 0x00F0 (0x0478 - 0x0388)
class UUISASFrame : public UUIBase
{
public:
	uint8                                         Pad_2137[0xB0];                                    // 0x0388(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_buttonIndex;                                     // 0x0438(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2138[0x3C];                                    // 0x043C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimGauge_Full, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimGauge_FullIn, class UWidgetAnimation* AnimGauge_Useing, class UWidgetAnimation* AnimGauge_Full_Out, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimChange1, class UWidgetAnimation* AnimChange2, class UOverlay* OverlaySasSet, class UImage* ImageIcon01, class UImage* ImageIcon01Add, class UImage* ImageObjectNone, class UImage* ImageBaseEffect, class UImage* ImageSasGaugeUse, class UImage* ImageSasGaugeUseAdd, class UUISASFrame2* UISASFrame2);
	bool IsEnable();
	void SetActive(bool IsActiveSAS, bool IsActiveCv);
	void SetActiveWidgetFlag(bool IsAcitveWidget);
	void SetButtonIndex(int32 Param_Index);
	void SetCombinationVision(bool IsCv);
	void SetIconScale(const struct FVector2D& Scale);
	void SetIconVisible(bool Param_IsVisible);
	void SetObject(class UUISASFrame2* FrameObject, class UImage* NoneObject, class UUINexusDriveSAS* NexusDriveSas, class UImage* ImageNexusDriveBase, class UImage* ImageNexusDriveCorner, class UImage* ImageNexusDriveCenter);
	void SetSasGaugeR(class UImage* Image, int32 Param_Index);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool CheckCombinationVisionCost(E_SASKindNative Sas) const;
	bool IsDecide() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASFrame">();
	}
	static class UUISASFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASFrame>();
	}
};
static_assert(alignof(UUISASFrame) == 0x000008, "Wrong alignment on UUISASFrame");
static_assert(sizeof(UUISASFrame) == 0x000478, "Wrong size on UUISASFrame");
static_assert(offsetof(UUISASFrame, M_buttonIndex) == 0x000438, "Member 'UUISASFrame::M_buttonIndex' has a wrong offset!");

// Class BattlePrototype.ChangeWeakStateComponentBase
// 0x0128 (0x01E8 - 0x00C0)
class UChangeWeakStateComponentBase : public UActorComponent
{
public:
	float                                         MWeakFullInactiveTime;                             // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MElapsedWeakFullInactiveTime;                      // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MFullInactiveWeak;                                 // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_213A[0x3];                                     // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MFullInactiveColorMapValueMin;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFullInactiveColorMapValueMax;                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFullInactiveFrenelColorPowerMin;                  // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFullInactiveFrenelColorPowerMax;                  // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MForceEnableWeak;                                  // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_213B[0x3];                                     // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MForceEnableWeakTime;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MElapsedForceEnableWeakTime;                       // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MStartWeakEmissive;                                // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_213C[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MWeakMaterialEmissiveCurve;                        // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEnemyWeakMaterialData>         MWeakMaterialList;                                 // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MWeakEmissiveTime;                                 // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_213D[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEnemyWeakMaterialData>         MDisableWeakMaterialList;                          // 0x0110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDisableWeakEmissiveTime;                          // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MWeakExtendTime;                                   // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbWeakExtendTime;                                  // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_213E[0x3];                                     // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MCurrentWeakExtendTime;                            // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 MDisableWeakNumList;                               // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MEnableWeakExtendTime;                             // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_213F[0x3];                                     // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MMaxExtendTime;                                    // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAddFirstExtendTime;                               // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAddPconExtendTime;                                // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MChangeWeakState;                                  // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2140[0x7];                                     // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEnemyEnableWeakData>           MEnableWeakDataList;                               // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MBeforeWeakStateList;                              // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 MCurrentTimeList;                                  // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MEnableWeakList;                                   // 0x0188(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MChangeWeakMaterial;                               // 0x0198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MFullInactivateList;                               // 0x01A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  MChangeFullInactiveList;                           // 0x01B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MWeakMaterialRateCurveData;                        // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2141[0x18];                                    // 0x01D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddWeakExtendTime_Native();
	void ClearChangeWeakMaterial_Native();
	void EnableAllWeak_Native(bool bEnable);
	void EnableWeak_Native(bool bEnable, int32 WeakListNum, bool bNotChangeCollision);
	void EndForceEnableWeak_Native();
	void EndFullInactiveWeak_Native();
	void EndWeakExtendTime_Native();
	void ForceDisableAllWeak_Native();
	TArray<bool> GetFullInactiveList_Native();
	void Initialize_Native(bool IsChangeWeakState);
	bool IsAllWeakFullInactive_Native();
	bool IsEnableWeakExtendTime_Native();
	bool IsForceEnableWeak_Native();
	bool IsWeakExtendTime_Native();
	bool IsWeakFullInactive_Native(int32 WeakListNum);
	void RestoreWeakState_Native();
	void SetAllWeakFullInactive_Native(bool bFullInactive);
	void SetChangeWeakMaterial_Native(bool bChange, int32 WeakListNum);
	void SetEnableWeakExtendTime_Native(bool EnableExtend);
	void SetFullInactiveWeak_Native(bool FullInactive, int32 WeakListNum);
	void StartForceEnableWeak_Native();
	void StartFullInactiveWeak_Native();
	void StoreWeakState_Native();
	void Update_Native(float DeltaSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeWeakStateComponentBase">();
	}
	static class UChangeWeakStateComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeWeakStateComponentBase>();
	}
};
static_assert(alignof(UChangeWeakStateComponentBase) == 0x000008, "Wrong alignment on UChangeWeakStateComponentBase");
static_assert(sizeof(UChangeWeakStateComponentBase) == 0x0001E8, "Wrong size on UChangeWeakStateComponentBase");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakFullInactiveTime) == 0x0000C0, "Member 'UChangeWeakStateComponentBase::MWeakFullInactiveTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MElapsedWeakFullInactiveTime) == 0x0000C4, "Member 'UChangeWeakStateComponentBase::MElapsedWeakFullInactiveTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveWeak) == 0x0000C8, "Member 'UChangeWeakStateComponentBase::MFullInactiveWeak' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveColorMapValueMin) == 0x0000CC, "Member 'UChangeWeakStateComponentBase::MFullInactiveColorMapValueMin' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveColorMapValueMax) == 0x0000D0, "Member 'UChangeWeakStateComponentBase::MFullInactiveColorMapValueMax' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveFrenelColorPowerMin) == 0x0000D4, "Member 'UChangeWeakStateComponentBase::MFullInactiveFrenelColorPowerMin' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactiveFrenelColorPowerMax) == 0x0000D8, "Member 'UChangeWeakStateComponentBase::MFullInactiveFrenelColorPowerMax' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MForceEnableWeak) == 0x0000DC, "Member 'UChangeWeakStateComponentBase::MForceEnableWeak' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MForceEnableWeakTime) == 0x0000E0, "Member 'UChangeWeakStateComponentBase::MForceEnableWeakTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MElapsedForceEnableWeakTime) == 0x0000E4, "Member 'UChangeWeakStateComponentBase::MElapsedForceEnableWeakTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MStartWeakEmissive) == 0x0000E8, "Member 'UChangeWeakStateComponentBase::MStartWeakEmissive' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakMaterialEmissiveCurve) == 0x0000F0, "Member 'UChangeWeakStateComponentBase::MWeakMaterialEmissiveCurve' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakMaterialList) == 0x0000F8, "Member 'UChangeWeakStateComponentBase::MWeakMaterialList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakEmissiveTime) == 0x000108, "Member 'UChangeWeakStateComponentBase::MWeakEmissiveTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MDisableWeakMaterialList) == 0x000110, "Member 'UChangeWeakStateComponentBase::MDisableWeakMaterialList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MDisableWeakEmissiveTime) == 0x000120, "Member 'UChangeWeakStateComponentBase::MDisableWeakEmissiveTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakExtendTime) == 0x000124, "Member 'UChangeWeakStateComponentBase::MWeakExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MbWeakExtendTime) == 0x000128, "Member 'UChangeWeakStateComponentBase::MbWeakExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MCurrentWeakExtendTime) == 0x00012C, "Member 'UChangeWeakStateComponentBase::MCurrentWeakExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MDisableWeakNumList) == 0x000130, "Member 'UChangeWeakStateComponentBase::MDisableWeakNumList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MEnableWeakExtendTime) == 0x000140, "Member 'UChangeWeakStateComponentBase::MEnableWeakExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MMaxExtendTime) == 0x000144, "Member 'UChangeWeakStateComponentBase::MMaxExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MAddFirstExtendTime) == 0x000148, "Member 'UChangeWeakStateComponentBase::MAddFirstExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MAddPconExtendTime) == 0x00014C, "Member 'UChangeWeakStateComponentBase::MAddPconExtendTime' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MChangeWeakState) == 0x000150, "Member 'UChangeWeakStateComponentBase::MChangeWeakState' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MEnableWeakDataList) == 0x000158, "Member 'UChangeWeakStateComponentBase::MEnableWeakDataList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MBeforeWeakStateList) == 0x000168, "Member 'UChangeWeakStateComponentBase::MBeforeWeakStateList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MCurrentTimeList) == 0x000178, "Member 'UChangeWeakStateComponentBase::MCurrentTimeList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MEnableWeakList) == 0x000188, "Member 'UChangeWeakStateComponentBase::MEnableWeakList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MChangeWeakMaterial) == 0x000198, "Member 'UChangeWeakStateComponentBase::MChangeWeakMaterial' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MFullInactivateList) == 0x0001A8, "Member 'UChangeWeakStateComponentBase::MFullInactivateList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MChangeFullInactiveList) == 0x0001B8, "Member 'UChangeWeakStateComponentBase::MChangeFullInactiveList' has a wrong offset!");
static_assert(offsetof(UChangeWeakStateComponentBase, MWeakMaterialRateCurveData) == 0x0001C8, "Member 'UChangeWeakStateComponentBase::MWeakMaterialRateCurveData' has a wrong offset!");

// Class BattlePrototype.CharacterDatatableAccessorComponent
// 0x0010 (0x00D0 - 0x00C0)
class UCharacterDatatableAccessorComponent : public UActorComponent
{
public:
	struct FAttackCalcInfo                        _attackCalcInfo;                                   // 0x00C0(0x0010)(Edit, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UCharacterDatatableAccessorComponent* GetCharacterDatatableAccessorComponent(class AActor* Actor);
	static void InheritAttackCalcInfo(class AActor* Parent, class AActor* Child);

	void SetAttackCalcInfo(const struct FAttackCalcInfo& AttackCalcInfo);

	struct FAttackCalcInfo GetAttackCalcInfo() const;
	struct FDamageCalcInfo GetDamageCalcInfo() const;
	struct FCharactersParameterBasic GetParamBasic() const;
	struct FCharactersParameterTable GetParamTable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDatatableAccessorComponent">();
	}
	static class UCharacterDatatableAccessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDatatableAccessorComponent>();
	}
};
static_assert(alignof(UCharacterDatatableAccessorComponent) == 0x000008, "Wrong alignment on UCharacterDatatableAccessorComponent");
static_assert(sizeof(UCharacterDatatableAccessorComponent) == 0x0000D0, "Wrong size on UCharacterDatatableAccessorComponent");
static_assert(offsetof(UCharacterDatatableAccessorComponent, _attackCalcInfo) == 0x0000C0, "Member 'UCharacterDatatableAccessorComponent::_attackCalcInfo' has a wrong offset!");

// Class BattlePrototype.GimmickAttackAreaVolume
// 0x0008 (0x0270 - 0x0268)
class AGimmickAttackAreaVolume final : public AVolume
{
public:
	uint8                                         Pad_2147[0x8];                                     // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEnemyInArea();
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickAttackAreaVolume">();
	}
	static class AGimmickAttackAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickAttackAreaVolume>();
	}
};
static_assert(alignof(AGimmickAttackAreaVolume) == 0x000008, "Wrong alignment on AGimmickAttackAreaVolume");
static_assert(sizeof(AGimmickAttackAreaVolume) == 0x000270, "Wrong size on AGimmickAttackAreaVolume");

// Class BattlePrototype.UIBossName
// 0x0180 (0x0508 - 0x0388)
class UUIBossName : public UUIBase
{
public:
	float                                         PreShuffleSeconds;                                 // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffuleSeconds;                                   // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffuleIntervalSeconds;                           // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FixedDrawSecond;                                   // 0x0394(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2148[0x170];                                   // 0x0398(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextBossName);
	void Start(const class FString& bossId, EBossNameMode Mode, float FreeFixedDrawSecond);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBossName">();
	}
	static class UUIBossName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBossName>();
	}
};
static_assert(alignof(UUIBossName) == 0x000008, "Wrong alignment on UUIBossName");
static_assert(sizeof(UUIBossName) == 0x000508, "Wrong size on UUIBossName");
static_assert(offsetof(UUIBossName, PreShuffleSeconds) == 0x000388, "Member 'UUIBossName::PreShuffleSeconds' has a wrong offset!");
static_assert(offsetof(UUIBossName, ShuffuleSeconds) == 0x00038C, "Member 'UUIBossName::ShuffuleSeconds' has a wrong offset!");
static_assert(offsetof(UUIBossName, ShuffuleIntervalSeconds) == 0x000390, "Member 'UUIBossName::ShuffuleIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UUIBossName, FixedDrawSecond) == 0x000394, "Member 'UUIBossName::FixedDrawSecond' has a wrong offset!");

// Class BattlePrototype.CharacterDitherDataAsset
// 0x0008 (0x0038 - 0x0030)
class UCharacterDitherDataAsset final : public UDataAsset
{
public:
	float                                         DitherSpeed;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214A[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDitherDataAsset">();
	}
	static class UCharacterDitherDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDitherDataAsset>();
	}
};
static_assert(alignof(UCharacterDitherDataAsset) == 0x000008, "Wrong alignment on UCharacterDitherDataAsset");
static_assert(sizeof(UCharacterDitherDataAsset) == 0x000038, "Wrong size on UCharacterDitherDataAsset");
static_assert(offsetof(UCharacterDitherDataAsset, DitherSpeed) == 0x000030, "Member 'UCharacterDitherDataAsset::DitherSpeed' has a wrong offset!");

// Class BattlePrototype.ConditionComponent
// 0x00A0 (0x0160 - 0x00C0)
class alignas(0x10) UConditionComponent : public UActorComponent
{
public:
	float                                         _accumulationLimit;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _accumulationAddedScale;                           // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _cureAccumulation;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _conditionAutoEndSec;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _intervalSec;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214B[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             _dispatchInterval;                                 // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _dispatchBeginCondition;                           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _dispatchEndCondition;                             // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_214C[0x58];                                    // 0x0108(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Accumulate(float Value, bool IsGuard);
	void ClearAccumulation();
	void FinishCondition();
	void OnBeginCondition();
	void OnEndCondition();
	void OnInterval();
	void SetFreeze(bool Flag);

	EConditionExclusionKind CheckExclusion(const class UConditionComponent* Other) const;
	EConditionKind GetConditionKind() const;
	bool IsActiveCondition() const;
	bool IsStateCondition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionComponent">();
	}
	static class UConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionComponent>();
	}
};
static_assert(alignof(UConditionComponent) == 0x000010, "Wrong alignment on UConditionComponent");
static_assert(sizeof(UConditionComponent) == 0x000160, "Wrong size on UConditionComponent");
static_assert(offsetof(UConditionComponent, _accumulationLimit) == 0x0000C0, "Member 'UConditionComponent::_accumulationLimit' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _accumulationAddedScale) == 0x0000C4, "Member 'UConditionComponent::_accumulationAddedScale' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _cureAccumulation) == 0x0000C8, "Member 'UConditionComponent::_cureAccumulation' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _conditionAutoEndSec) == 0x0000CC, "Member 'UConditionComponent::_conditionAutoEndSec' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _intervalSec) == 0x0000D0, "Member 'UConditionComponent::_intervalSec' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _dispatchInterval) == 0x0000D8, "Member 'UConditionComponent::_dispatchInterval' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _dispatchBeginCondition) == 0x0000E8, "Member 'UConditionComponent::_dispatchBeginCondition' has a wrong offset!");
static_assert(offsetof(UConditionComponent, _dispatchEndCondition) == 0x0000F8, "Member 'UConditionComponent::_dispatchEndCondition' has a wrong offset!");

// Class BattlePrototype.FaintConditionComponent
// 0x0030 (0x0190 - 0x0160)
class UFaintConditionComponent final : public UConditionComponent
{
public:
	float                                         _faintSec;                                         // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214F[0x4];                                     // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _pFaintEffect;                                     // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _pEffectComp;                                      // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2150[0x18];                                    // 0x0178(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaintConditionComponent">();
	}
	static class UFaintConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFaintConditionComponent>();
	}
};
static_assert(alignof(UFaintConditionComponent) == 0x000010, "Wrong alignment on UFaintConditionComponent");
static_assert(sizeof(UFaintConditionComponent) == 0x000190, "Wrong size on UFaintConditionComponent");
static_assert(offsetof(UFaintConditionComponent, _faintSec) == 0x000160, "Member 'UFaintConditionComponent::_faintSec' has a wrong offset!");
static_assert(offsetof(UFaintConditionComponent, _pFaintEffect) == 0x000168, "Member 'UFaintConditionComponent::_pFaintEffect' has a wrong offset!");
static_assert(offsetof(UFaintConditionComponent, _pEffectComp) == 0x000170, "Member 'UFaintConditionComponent::_pEffectComp' has a wrong offset!");

// Class BattlePrototype.CharacterHitCheckComponent
// 0x0018 (0x00D8 - 0x00C0)
class UCharacterHitCheckComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2151[0x18];                                    // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterHitCheck(class UCapsuleComponent* Capsule0, class UCapsuleComponent* Capsule1);
	void SetEnable(bool bEnable);
	void UnregisterHitCheck(class UCapsuleComponent* Capsule0, class UCapsuleComponent* Capsule1);

	int32 GetRegisteredCount() const;
	class ARSCharacterBase* GetRegisteredHitCharacter(int32 Param_Index) const;
	bool IsRegisteredAny() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHitCheckComponent">();
	}
	static class UCharacterHitCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHitCheckComponent>();
	}
};
static_assert(alignof(UCharacterHitCheckComponent) == 0x000008, "Wrong alignment on UCharacterHitCheckComponent");
static_assert(sizeof(UCharacterHitCheckComponent) == 0x0000D8, "Wrong size on UCharacterHitCheckComponent");

// Class BattlePrototype.CharacterMaterialLightFunction
// 0x0000 (0x0028 - 0x0028)
class UCharacterMaterialLightFunction final : public UBlueprintFunctionLibrary
{
public:
	static void SetupCharacterMaterialLight(class UMeshComponent* MeshComponent, const struct FCharacterMaterialLightSetting& LightSetting, const TMap<class FName, struct FArrayOfFloat>& DefaultScalars, const TMap<class FName, struct FArrayOfLinearColor>& DefaultVectors, float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMaterialLightFunction">();
	}
	static class UCharacterMaterialLightFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMaterialLightFunction>();
	}
};
static_assert(alignof(UCharacterMaterialLightFunction) == 0x000008, "Wrong alignment on UCharacterMaterialLightFunction");
static_assert(sizeof(UCharacterMaterialLightFunction) == 0x000028, "Wrong size on UCharacterMaterialLightFunction");

// Class BattlePrototype.CharactersParameterComponent
// 0x05A0 (0x0660 - 0x00C0)
class UCharactersParameterComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             HpEvent;                                           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BadStateOnEvent;                                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BadStateOffEvent;                                  // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BrainCrashAccessOnEvent;                           // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             BrainCrashAccessOffEvent;                          // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          MIsUseTick;                                        // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2154[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharactersParameterTable              MParamTable;                                       // 0x0118(0x01F8)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FCharactersParameterBasic              MParamBasic;                                       // 0x0310(0x0068)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FCharactersParameterTable              MParamInitTable;                                   // 0x0378(0x01F8)(Edit, EditConst, NativeAccessSpecifierPrivate)
	bool                                          MIsBrainCrashLock;                                 // 0x0570(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MIsNotUseBrainCrashTimer;                          // 0x0571(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2155[0x2];                                     // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MBrainCrashTimer;                                  // 0x0574(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MIsPauseBrainCrashTimer;                           // 0x0578(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2156[0x7];                                     // 0x0579(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFinishActor;                                     // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnDead;                                            // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	bool                                          MIsElectricTimer;                                  // 0x05A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2157[0x2F];                                    // 0x05A1(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MBrainCrashTime;                                   // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MBrainCrashMissAccumulationScale;                  // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MFrameBaseTime;                                    // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MElectricBaseTime;                                 // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MElectricAddTime;                                  // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MFloodedBaseTime;                                  // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOilBaseTime;                                      // 0x05E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MConfusionBaseTime;                                // 0x05EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MAddFrameBaseTime;                                 // 0x05F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MAddElectricBaseTime;                              // 0x05F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOilDownScale;                                     // 0x05F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MFloodedMoveScale;                                 // 0x05FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MFlameScaleByOil;                                  // 0x0600(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MElectricScaleByFlooded;                           // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MEndlessFlame;                                     // 0x0608(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MEndlessFlooded;                                   // 0x0609(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MEndlessOil;                                       // 0x060A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsBeforeEndlessFlooded;                           // 0x060B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsBeforeEndlessOil;                               // 0x060C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsUpdateCrashOldFrame;                            // 0x060D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2158[0x2];                                     // 0x060E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MUpdateCrashOldFrameCnt;                           // 0x0610(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2159[0x4];                                     // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlameUpdateTimeRate;                               // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElectricUpdateTimeRate;                            // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloodedUpdateTimeRate;                             // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OilUpdateTimeRate;                                 // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionUpdateTimeRate;                           // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215A[0x30];                                    // 0x062C(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MIgnoreDamageFlag;                                 // 0x065C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UCharactersParameterComponent* GetCharactersParameterComponentFromActor(class AActor* Actor);

	void AddBrainCrashExtraTime(float ExtraTime);
	void AddHp(int32 HP);
	void AddHpArray(const TArray<int32>& HP);
	void AddParameterBasic(const struct FCharactersParameterBasic& Param, class AActor* Attacker, bool IsEnemy);
	void DebugSetEnemyCrashCrashResistance(int32 DebugCrashResistance);
	void DisableCharacterIgnoreDamage(ECharacterIgnoreDamage SetFlag);
	void DisableCharacterIgnoreDamageAll();
	void DisableCharacterIgnoreDamageFromType(ECharacterIgnoreDamageType IgnoreType);
	void EnableCharacterIgnoreDamage(ECharacterIgnoreDamage SetFlag);
	void EnableCharacterIgnoreDamageAll();
	void EnableCharacterIgnoreDamageFromType(ECharacterIgnoreDamageType IgnoreType);
	void EndLimitCrashAccumulation();
	float GetBrainCrashMissAccumulationScale();
	float GetCrashResistance(int32 Part);
	float GetCrashResistanceMax();
	float GetElectricScaleByFlooded();
	float GetFloodedMoveScale();
	float GetWeakPointRate(int32 Part);
	float GetWeakPointRateOldFrame(int32 Part);
	bool IsBadStateEndless();
	bool IsBrainCrashAccess();
	bool IsBrainCrashLock();
	bool IsDead();
	bool IsDelayDeath();
	bool IsLimitCrashAccumulation();
	void ModifyParameterTable_Attack(int32 NewValue);
	void OutBreakCable(class AActor* Attacker);
	void OutBreakConfusion(class AActor* Attacker, float Time);
	void OutBreakElectric(class AActor* Attacker, float Time);
	void OutBreakFlame(class AActor* Attacker, float Time, bool bEndless);
	void OutBreakFlooded(class AActor* Attacker, float Time, bool bEndless);
	void OutBreakOil(class AActor* Attacker, float Time, bool bEndless);
	void ParameterBasicCopy(const struct FCharactersParameterBasic& Param);
	void ReleaseAllBadStatus(bool bRsetAccumulation);
	void ReleaseCable();
	void ReleaseConfusion(bool bRsetAccumulation);
	void ReleaseElectric(bool bRsetAccumulation);
	void ReleaseFlame(bool bRsetAccumulation);
	void ReleaseFlooded(bool bRsetAccumulation);
	void ReleaseOil(bool bRsetAccumulation);
	void ResetAttenuation(bool bResetCrash);
	void ResetBadStatusAttenuation();
	void ResetCrash();
	void ResetDelayDeath();
	void ResetHpDownLimit();
	void ResetPauseUpdate();
	void SetAddElectricBaseTime(float Num);
	void SetAddFrameBaseTime(float Num);
	void SetArmorHp(int32 HP);
	void SetAttenuation(const struct FCharactersParameterBasic& Param);
	void SetBadStatusAttenuation(const struct FCharactersParameterBasic& Param);
	void SetBrainCrashEnableTime(float Num);
	void SetBrainCrashLock(bool Lock);
	void SetBrainCrashMiss();
	void SetBrainCrashMissAccumulationScale(float Num);
	void SetBrainCrashTimeSeconds(float Seconds);
	void SetCharacterIgnoreDamageFlag(int32 Param_Flags);
	void SetConfusionAttenuationCoefficient(float Coefficient);
	void SetConfusionBaseTime(float Num);
	void SetConfusionTimeCoefficient(float Coefficient);
	void SetCrashMax();
	void SetElectricAddTime(float Num);
	void SetElectricAttenuationCoefficient(float Coefficient);
	void SetElectricBaseTime(float Num);
	void SetElectricTimeCoefficient(float Coefficient);
	void SetElectricTimerOn(bool On);
	void SetEnableBadStatusTimeRate(bool bEnable);
	void SetEndlessFlame(bool bEndless);
	void SetEndlessFlooded(bool bEndless);
	void SetEndlessOil(bool bEndless);
	void SetFlameAttenuationCoefficient(float Coefficient);
	void SetFlameTimeCoefficient(float Coefficient);
	void SetFloodedAttenuationCoefficient(float Coefficient);
	void SetFloodedBaseTime(float Num);
	void SetFloodedMoveScale(float Num);
	void SetFloodedTimeCoefficient(float Coefficient);
	void SetFrameBaseTime(float Num);
	void SetHp(const TArray<int32>& HP);
	void SetHpDownLimit(EHpDownLimitType LimitType, float LimitValue);
	void SetHpPart(int32 No, int32 HP);
	void SetHpWithoutEvent(int32 HP);
	void SetLevelTable(float HP, float Attack, float brain, float Defense, float Exp);
	void SetNoReleaseBadState(bool bNoRelease);
	void SetNotUseBrainCrashTimer(bool bNotUse);
	void SetOilAttenuationCoefficient(float Coefficient);
	void SetOilBaseTime(float Num);
	void SetOilDownScale(float Num);
	void SetOilTimeCoefficient(float Coefficient);
	void SetParameterAll(const struct FCharactersParameterTable& Param);
	void SetParameterBasic(const struct FCharactersParameterTable& Param);
	void SetParameterInitTable(const struct FCharactersParameterTable& Param);
	void SetParameterTable(const struct FCharactersParameterTable& Param);
	void SetPauseBrainCrashTimer(bool bPause);
	void SetPauseUpdate();
	void StartDamageReactionAccumulationStopTimer();
	void StartLimitCrashAccumulation();
	int32 SufferDamage(int32 Damage, bool IsEnemy, bool IsNoDead, bool IsDelayDeath, bool IsGuts, class AActor* Attacker);
	void SufferPartDamage(int32 Part, int32 Damage);

	int32 GetAllHp() const;
	float GetAllHPPercent() const;
	int32 GetArmorHp() const;
	float GetArmorHPPercent() const;
	float GetBrainCrashTimer() const;
	float GetCaptureArea() const;
	int32 GetCharacterIgnoreDamageFlag() const;
	int32 GetCharacterIgnoreDamageFlagFromType(ECharacterIgnoreDamageType IgnoreType) const;
	int32 GetHp() const;
	TArray<int32> GetHpArray() const;
	int32 GetHpDownLimit() const;
	int32 GetHpPart(int32 No) const;
	float GetHPPercent() const;
	int32 GetMaxArmorHp() const;
	int32 GetMaxHp() const;
	int32 GetMaxHpPart(int32 No) const;
	float GetMoveArea() const;
	struct FCharactersParameterBasic GetParameterBasic() const;
	struct FCharactersParameterTable GetParameterInitTable() const;
	struct FCharactersParameterTable GetParameterTable() const;
	float GetSearchAngle() const;
	float GetSearchRange() const;
	float GetSensingArea() const;
	bool IsAnyBadStatus() const;
	bool IsCharacterIgnoreDamage(ECharacterIgnoreDamage CheckFlag) const;
	bool IsConfusion() const;
	bool IsElectric() const;
	bool IsElectricTimer() const;
	bool IsEndlessFlame() const;
	bool IsEndlessFlooded() const;
	bool IsEndlessOil() const;
	bool IsFlame() const;
	bool IsFlooded() const;
	bool IsHpDownLimit() const;
	bool IsOil() const;
	bool IsPauseUpdate() const;
	bool IsReinfoceFlame() const;
	bool NeedsStatusAssist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharactersParameterComponent">();
	}
	static class UCharactersParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharactersParameterComponent>();
	}
};
static_assert(alignof(UCharactersParameterComponent) == 0x000008, "Wrong alignment on UCharactersParameterComponent");
static_assert(sizeof(UCharactersParameterComponent) == 0x000660, "Wrong size on UCharactersParameterComponent");
static_assert(offsetof(UCharactersParameterComponent, HpEvent) == 0x0000C0, "Member 'UCharactersParameterComponent::HpEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, BadStateOnEvent) == 0x0000D0, "Member 'UCharactersParameterComponent::BadStateOnEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, BadStateOffEvent) == 0x0000E0, "Member 'UCharactersParameterComponent::BadStateOffEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, BrainCrashAccessOnEvent) == 0x0000F0, "Member 'UCharactersParameterComponent::BrainCrashAccessOnEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, BrainCrashAccessOffEvent) == 0x000100, "Member 'UCharactersParameterComponent::BrainCrashAccessOffEvent' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsUseTick) == 0x000110, "Member 'UCharactersParameterComponent::MIsUseTick' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MParamTable) == 0x000118, "Member 'UCharactersParameterComponent::MParamTable' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MParamBasic) == 0x000310, "Member 'UCharactersParameterComponent::MParamBasic' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MParamInitTable) == 0x000378, "Member 'UCharactersParameterComponent::MParamInitTable' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsBrainCrashLock) == 0x000570, "Member 'UCharactersParameterComponent::MIsBrainCrashLock' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsNotUseBrainCrashTimer) == 0x000571, "Member 'UCharactersParameterComponent::MIsNotUseBrainCrashTimer' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MBrainCrashTimer) == 0x000574, "Member 'UCharactersParameterComponent::MBrainCrashTimer' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsPauseBrainCrashTimer) == 0x000578, "Member 'UCharactersParameterComponent::MIsPauseBrainCrashTimer' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, OnFinishActor) == 0x000580, "Member 'UCharactersParameterComponent::OnFinishActor' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, OnDead) == 0x000590, "Member 'UCharactersParameterComponent::OnDead' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsElectricTimer) == 0x0005A0, "Member 'UCharactersParameterComponent::MIsElectricTimer' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MBrainCrashTime) == 0x0005D0, "Member 'UCharactersParameterComponent::MBrainCrashTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MBrainCrashMissAccumulationScale) == 0x0005D4, "Member 'UCharactersParameterComponent::MBrainCrashMissAccumulationScale' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MFrameBaseTime) == 0x0005D8, "Member 'UCharactersParameterComponent::MFrameBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MElectricBaseTime) == 0x0005DC, "Member 'UCharactersParameterComponent::MElectricBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MElectricAddTime) == 0x0005E0, "Member 'UCharactersParameterComponent::MElectricAddTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MFloodedBaseTime) == 0x0005E4, "Member 'UCharactersParameterComponent::MFloodedBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MOilBaseTime) == 0x0005E8, "Member 'UCharactersParameterComponent::MOilBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MConfusionBaseTime) == 0x0005EC, "Member 'UCharactersParameterComponent::MConfusionBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MAddFrameBaseTime) == 0x0005F0, "Member 'UCharactersParameterComponent::MAddFrameBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MAddElectricBaseTime) == 0x0005F4, "Member 'UCharactersParameterComponent::MAddElectricBaseTime' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MOilDownScale) == 0x0005F8, "Member 'UCharactersParameterComponent::MOilDownScale' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MFloodedMoveScale) == 0x0005FC, "Member 'UCharactersParameterComponent::MFloodedMoveScale' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MFlameScaleByOil) == 0x000600, "Member 'UCharactersParameterComponent::MFlameScaleByOil' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MElectricScaleByFlooded) == 0x000604, "Member 'UCharactersParameterComponent::MElectricScaleByFlooded' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MEndlessFlame) == 0x000608, "Member 'UCharactersParameterComponent::MEndlessFlame' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MEndlessFlooded) == 0x000609, "Member 'UCharactersParameterComponent::MEndlessFlooded' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MEndlessOil) == 0x00060A, "Member 'UCharactersParameterComponent::MEndlessOil' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsBeforeEndlessFlooded) == 0x00060B, "Member 'UCharactersParameterComponent::MIsBeforeEndlessFlooded' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsBeforeEndlessOil) == 0x00060C, "Member 'UCharactersParameterComponent::MIsBeforeEndlessOil' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIsUpdateCrashOldFrame) == 0x00060D, "Member 'UCharactersParameterComponent::MIsUpdateCrashOldFrame' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MUpdateCrashOldFrameCnt) == 0x000610, "Member 'UCharactersParameterComponent::MUpdateCrashOldFrameCnt' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, FlameUpdateTimeRate) == 0x000618, "Member 'UCharactersParameterComponent::FlameUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, ElectricUpdateTimeRate) == 0x00061C, "Member 'UCharactersParameterComponent::ElectricUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, FloodedUpdateTimeRate) == 0x000620, "Member 'UCharactersParameterComponent::FloodedUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, OilUpdateTimeRate) == 0x000624, "Member 'UCharactersParameterComponent::OilUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, ConfusionUpdateTimeRate) == 0x000628, "Member 'UCharactersParameterComponent::ConfusionUpdateTimeRate' has a wrong offset!");
static_assert(offsetof(UCharactersParameterComponent, MIgnoreDamageFlag) == 0x00065C, "Member 'UCharactersParameterComponent::MIgnoreDamageFlag' has a wrong offset!");

// Class BattlePrototype.DebuggingItemScrSetting
// 0x0008 (0x0310 - 0x0308)
class ADebuggingItemScrSetting : public ADebuggingItemStringArray
{
public:
	uint8                                         Pad_2164[0x8];                                     // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrSetting">();
	}
	static class ADebuggingItemScrSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrSetting>();
	}
};
static_assert(alignof(ADebuggingItemScrSetting) == 0x000008, "Wrong alignment on ADebuggingItemScrSetting");
static_assert(sizeof(ADebuggingItemScrSetting) == 0x000310, "Wrong size on ADebuggingItemScrSetting");

// Class BattlePrototype.DebuggingItemScrResOutputChange
// 0x0000 (0x0310 - 0x0310)
class ADebuggingItemScrResOutputChange final : public ADebuggingItemScrSetting
{
public:
	void OnChangeValue(const class ADebuggingItemStringArray* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrResOutputChange">();
	}
	static class ADebuggingItemScrResOutputChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrResOutputChange>();
	}
};
static_assert(alignof(ADebuggingItemScrResOutputChange) == 0x000008, "Wrong alignment on ADebuggingItemScrResOutputChange");
static_assert(sizeof(ADebuggingItemScrResOutputChange) == 0x000310, "Wrong size on ADebuggingItemScrResOutputChange");

// Class BattlePrototype.UISASButton2
// 0x0018 (0x03A0 - 0x0388)
class UUISASButton2 : public UUIBase
{
public:
	uint8                                         Pad_2165[0x18];                                    // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Decide();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimChangeSas1, class UWidgetAnimation* AnimDefaultSas, class UWidgetAnimation* AnimChangeSas2, class UWidgetAnimation* AnimDecisionSas, class UWidgetAnimation* AnimChangePage1, class UWidgetAnimation* AnimDefaultPage, class UWidgetAnimation* AnimChangePage2, class UWidgetAnimation* AnimDecisionPage, class UImage* ImageSasIconFont, class UImage* ImageSasButton);
	void SetPageFlag(bool IsPage);
	void SetReadyFlag(bool IsReady);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASButton2">();
	}
	static class UUISASButton2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASButton2>();
	}
};
static_assert(alignof(UUISASButton2) == 0x000008, "Wrong alignment on UUISASButton2");
static_assert(sizeof(UUISASButton2) == 0x0003A0, "Wrong size on UUISASButton2");

// Class BattlePrototype.CharactersParameterManager
// 0x0010 (0x0038 - 0x0028)
class UCharactersParameterManager final : public UObject
{
public:
	TArray<struct FCharacterInfo>                 M_characterInfoList;                               // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateCharacterInfo(const class AActor* Actor, const struct FCharactersParameterBasic& CharaParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharactersParameterManager">();
	}
	static class UCharactersParameterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharactersParameterManager>();
	}
};
static_assert(alignof(UCharactersParameterManager) == 0x000008, "Wrong alignment on UCharactersParameterManager");
static_assert(sizeof(UCharactersParameterManager) == 0x000038, "Wrong size on UCharactersParameterManager");
static_assert(offsetof(UCharactersParameterManager, M_characterInfoList) == 0x000028, "Member 'UCharactersParameterManager::M_characterInfoList' has a wrong offset!");

// Class BattlePrototype.ExporterBase
// 0x0010 (0x0240 - 0x0230)
class AExporterBase final : public AActor
{
public:
	EExporterType                                 ExporterType;                                      // 0x0230(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2166[0xF];                                     // 0x0231(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndExportInternal();
	void EndExportShowDestination();
	void ExecExportInternal(int32 LocationId, int32 AreaId);
	void LoopExportShowDestination(int32 LocationId, int32 AreaId);
	void StartExportInternal();
	void StartExportShowDestination();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExporterBase">();
	}
	static class AExporterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExporterBase>();
	}
};
static_assert(alignof(AExporterBase) == 0x000008, "Wrong alignment on AExporterBase");
static_assert(sizeof(AExporterBase) == 0x000240, "Wrong size on AExporterBase");
static_assert(offsetof(AExporterBase, ExporterType) == 0x000230, "Member 'AExporterBase::ExporterType' has a wrong offset!");

// Class BattlePrototype.CheatCommandListenerComponent
// 0x0010 (0x00D0 - 0x00C0)
class UCheatCommandListenerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCheatCommand;                                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UCheatCommandListenerComponent* GetCheatCommandListenerComponentFromActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatCommandListenerComponent">();
	}
	static class UCheatCommandListenerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatCommandListenerComponent>();
	}
};
static_assert(alignof(UCheatCommandListenerComponent) == 0x000008, "Wrong alignment on UCheatCommandListenerComponent");
static_assert(sizeof(UCheatCommandListenerComponent) == 0x0000D0, "Wrong size on UCheatCommandListenerComponent");
static_assert(offsetof(UCheatCommandListenerComponent, OnCheatCommand) == 0x0000C0, "Member 'UCheatCommandListenerComponent::OnCheatCommand' has a wrong offset!");

// Class BattlePrototype.UIInfoWindow
// 0x0058 (0x03E0 - 0x0388)
class UUIInfoWindow : public UUIBase
{
public:
	bool                                          IsWarning;                                         // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2167[0x47];                                    // 0x0389(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	class URSAtomComponentBase*                   PlayingSE;                                         // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2168[0x8];                                     // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextMain, class USpacer* Spacer, class UOverlay* GuideOverlay, class UImage* ImageGuideLine, class UImage* ImageFade);
	void SetMessage(const class FString& Message);
	void SetStyleNormal();
	void SetStyleWarning();
	void SetVisibleGuide(bool Flag);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInfoWindow">();
	}
	static class UUIInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInfoWindow>();
	}
};
static_assert(alignof(UUIInfoWindow) == 0x000008, "Wrong alignment on UUIInfoWindow");
static_assert(sizeof(UUIInfoWindow) == 0x0003E0, "Wrong size on UUIInfoWindow");
static_assert(offsetof(UUIInfoWindow, IsWarning) == 0x000388, "Member 'UUIInfoWindow::IsWarning' has a wrong offset!");
static_assert(offsetof(UUIInfoWindow, PlayingSE) == 0x0003D0, "Member 'UUIInfoWindow::PlayingSE' has a wrong offset!");

// Class BattlePrototype.ClearGetterData
// 0x0028 (0x0050 - 0x0028)
class UClearGetterData final : public UObject
{
public:
	TArray<class FName>                           ClearGetterIDs;                                    // 0x0028(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RefClearGetterTable;                               // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2169[0x10];                                    // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool LoadDataTable(const class FString& ClearGetterTablePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearGetterData">();
	}
	static class UClearGetterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearGetterData>();
	}
};
static_assert(alignof(UClearGetterData) == 0x000008, "Wrong alignment on UClearGetterData");
static_assert(sizeof(UClearGetterData) == 0x000050, "Wrong size on UClearGetterData");
static_assert(offsetof(UClearGetterData, ClearGetterIDs) == 0x000028, "Member 'UClearGetterData::ClearGetterIDs' has a wrong offset!");
static_assert(offsetof(UClearGetterData, RefClearGetterTable) == 0x000038, "Member 'UClearGetterData::RefClearGetterTable' has a wrong offset!");

// Class BattlePrototype.DebuggingItemClearGetterGroup
// 0x0018 (0x02E8 - 0x02D0)
class ADebuggingItemClearGetterGroup final : public ADebuggingItemGroup
{
public:
	TWeakObjectPtr<class ADebuggingItemBool>      DebugDispBool;                                     // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecParamChange;                                   // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UClearGetterManager>     Manager;                                           // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DisplayDebugParam(float X, float Y, const struct FLinearColor& Color, const struct FVector2D& Scale);
	void OnExecuteParameterChange(const class ADebuggingItemEvent* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemClearGetterGroup">();
	}
	static class ADebuggingItemClearGetterGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemClearGetterGroup>();
	}
};
static_assert(alignof(ADebuggingItemClearGetterGroup) == 0x000008, "Wrong alignment on ADebuggingItemClearGetterGroup");
static_assert(sizeof(ADebuggingItemClearGetterGroup) == 0x0002E8, "Wrong size on ADebuggingItemClearGetterGroup");
static_assert(offsetof(ADebuggingItemClearGetterGroup, DebugDispBool) == 0x0002D0, "Member 'ADebuggingItemClearGetterGroup::DebugDispBool' has a wrong offset!");
static_assert(offsetof(ADebuggingItemClearGetterGroup, ExecParamChange) == 0x0002D8, "Member 'ADebuggingItemClearGetterGroup::ExecParamChange' has a wrong offset!");
static_assert(offsetof(ADebuggingItemClearGetterGroup, Manager) == 0x0002E0, "Member 'ADebuggingItemClearGetterGroup::Manager' has a wrong offset!");

// Class BattlePrototype.EnemyDropDataUtility
// 0x0000 (0x0028 - 0x0028)
class UEnemyDropDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static void DebugDropItemLotteryParam(class FName EnemyId, int32 TableNo, float Rate, float Randnum);
	static bool GetCoreDropItemID(const struct FEnemyDropDataCell& RCell, const bool IsRare, class FName* ItemId, int32* ItemNum, bool KillByBrainCrash, class FName EnemyId, int32 TableNo, float Rate, float Randnum);
	static bool GetDataDropItemID(const struct FEnemyDropDataCell& RCell, const bool IsRare, class FName* ItemId, int32* ItemNum, bool KillByBrainCrash, class FName EnemyId, int32 TableNo, float Rate, float Randnum);
	static class FString GetDebugLotteryParamString(int32 Param_Index);
	static int32 GetDropExperience(const struct FEnemyDropDataCell& RCell);
	static float GetDropItemProbability(const struct FEnemyDropDataCell& RCell);
	static int32 GetDropMoney(const struct FEnemyDropDataCell& RCell);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDropDataUtility">();
	}
	static class UEnemyDropDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDropDataUtility>();
	}
};
static_assert(alignof(UEnemyDropDataUtility) == 0x000008, "Wrong alignment on UEnemyDropDataUtility");
static_assert(sizeof(UEnemyDropDataUtility) == 0x000028, "Wrong size on UEnemyDropDataUtility");

// Class BattlePrototype.UICharaInfoWindow
// 0x0100 (0x0488 - 0x0388)
class UUICharaInfoWindow : public UUIBase
{
public:
	uint8                                         Pad_2175[0x100];                                   // 0x0388(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault1, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault1_2, class UWidgetAnimation* AnimDefault2_1, class UTextBlock* TextCharaName, class UTextBlock* TextCategoryName, class UTextBlock* TextCharaInfo, class UTextBlock* TextCharaDetails, class UImage* CharaImage, class UREDScrollBoxSimple* ScrollBox1, class UREDScrollBoxSimple* ScrollBox2, class UREDOverlay* Mousehitthubnail);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaInfoWindow">();
	}
	static class UUICharaInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaInfoWindow>();
	}
};
static_assert(alignof(UUICharaInfoWindow) == 0x000008, "Wrong alignment on UUICharaInfoWindow");
static_assert(sizeof(UUICharaInfoWindow) == 0x000488, "Wrong size on UUICharaInfoWindow");

// Class BattlePrototype.ClearGetterManager
// 0x0250 (0x0278 - 0x0028)
class UClearGetterManager final : public UObject
{
public:
	uint8                                         Pad_2176[0x178];                                   // 0x0028(0x0178)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ClearMissionDelegate;                              // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2177[0xC8];                                    // 0x01B0(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItemUseCount(int32 Num);
	void CheckAllClearGetterMission();
	void CheckAssaultVision(int32 Num);
	void CheckBattleSimulatorClear(class FName MissionName, const struct FBattleSimulatorResult& Result);
	void CheckBrainCrash(int32 Num);
	void CheckBrainField(int32 Num);
	void CheckClearGetterMission();
	void CheckCombinationVisionCombo(int32 Num);
	void CheckCombinationVisionDamage(int32 Damage);
	void CheckCrashVisionCombo(int32 Num);
	void CheckDLCBondsEpisode(class FName BondsEPName);
	void CheckEnableNexusDrive();
	void CheckEnemyDefeated(const struct FHCHitResult& HitResult, bool bBrainField);
	void CheckExistItem();
	void CheckGameClear();
	void CheckGetAnyItem(const class FName& WeaponId);
	void CheckKarenEpisode(class FName KarenEPName);
	void CheckMoney();
	void CheckNexusDrive(int32 Num);
	void CheckNpcDrive(int32 Num);
	void CheckPhaseClear();
	void CheckPlayerDrive(int32 Num);
	void CheckPlayerLevel();
	void CheckPlayerParameter(const struct FPlayerInfo& PlayerInfo);
	void CheckPresent(int32 Num);
	void CheckPresentUnique();
	void CheckProtectVision(int32 Num);
	void CheckQuestClear(int32 Num);
	void CheckReleaseMission(EClearGetterReleaseType Type, int32 Param1, class FName Param2);
	void CheckReviveNpc(int32 Num);
	void CheckTeamBonds();
	void CheckThrowPsychicObject(int32 Num);
	void CheckTotalExp(int32 AddExp);
	void CheckTotalNexusDriveTime(float Time);
	void CheckTotalPlayTime();
	void CheckUniquePsychicObjectSuccess(int32 Num);
	void ClearParameter(bool bExNewGame);
	void CreateTitleString(class FString* Output, EClearGetterType Type);
	bool GetProgressValue(float* CurrentValue, float* MaximumValue, EClearGetterType Type);
	bool GetProgressWithBestValue(float* CurrentValue, float* MaximumValue, float* bestValue, EClearGetterType Type);
	void SetIsClearGetterInfo(EClearGetterInfoType Type, bool IsOn);

	bool CheckIsClearGetterInfo(EClearGetterInfoType Type) const;
	bool GetClearGetterData(struct FClearGetterCell* ClearGetterData, EClearGetterType ClearGetterType) const;
	int32 GetClearGetterDataNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearGetterManager">();
	}
	static class UClearGetterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearGetterManager>();
	}
};
static_assert(alignof(UClearGetterManager) == 0x000008, "Wrong alignment on UClearGetterManager");
static_assert(sizeof(UClearGetterManager) == 0x000278, "Wrong size on UClearGetterManager");
static_assert(offsetof(UClearGetterManager, ClearMissionDelegate) == 0x0001A0, "Member 'UClearGetterManager::ClearMissionDelegate' has a wrong offset!");

// Class BattlePrototype.DebuggingItemFlagManagerGroup
// 0x0030 (0x0300 - 0x02D0)
class ADebuggingItemFlagManagerGroup final : public ADebuggingItemGroup
{
public:
	uint8                                         Pad_217E[0x20];                                    // 0x02D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ADebuggingItemBool2>> FlagBool;                                          // 0x02F0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangeFlagBool(const class ADebuggingItemBool* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemFlagManagerGroup">();
	}
	static class ADebuggingItemFlagManagerGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemFlagManagerGroup>();
	}
};
static_assert(alignof(ADebuggingItemFlagManagerGroup) == 0x000008, "Wrong alignment on ADebuggingItemFlagManagerGroup");
static_assert(sizeof(ADebuggingItemFlagManagerGroup) == 0x000300, "Wrong size on ADebuggingItemFlagManagerGroup");
static_assert(offsetof(ADebuggingItemFlagManagerGroup, FlagBool) == 0x0002F0, "Member 'ADebuggingItemFlagManagerGroup::FlagBool' has a wrong offset!");

// Class BattlePrototype.PostProcessSettingsDataAsset
// 0x0780 (0x07B0 - 0x0030)
class UPostProcessSettingsDataAsset final : public UDataAsset
{
public:
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0030(0x0780)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessSettingsDataAsset">();
	}
	static class UPostProcessSettingsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessSettingsDataAsset>();
	}
};
static_assert(alignof(UPostProcessSettingsDataAsset) == 0x000010, "Wrong alignment on UPostProcessSettingsDataAsset");
static_assert(sizeof(UPostProcessSettingsDataAsset) == 0x0007B0, "Wrong size on UPostProcessSettingsDataAsset");
static_assert(offsetof(UPostProcessSettingsDataAsset, PostProcessSettings) == 0x000030, "Member 'UPostProcessSettingsDataAsset::PostProcessSettings' has a wrong offset!");

// Class BattlePrototype.UIBrainGaugeEN
// 0x0010 (0x0398 - 0x0388)
class UUIBrainGaugeEN : public UUIBase
{
public:
	float                                         M_Percent;                                         // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_Time;                                            // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagPercentUpdate;                               // 0x0390(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagGaugeMax;                                    // 0x0391(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagBrainField;                                  // 0x0392(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_217F[0x5];                                     // 0x0393(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndBrainField();
	void SetGaugeMax(bool IsFull);
	void SetGaugePercent(float Percent, float Time);
	void StartBrainField();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainGaugeEN">();
	}
	static class UUIBrainGaugeEN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainGaugeEN>();
	}
};
static_assert(alignof(UUIBrainGaugeEN) == 0x000008, "Wrong alignment on UUIBrainGaugeEN");
static_assert(sizeof(UUIBrainGaugeEN) == 0x000398, "Wrong size on UUIBrainGaugeEN");
static_assert(offsetof(UUIBrainGaugeEN, M_Percent) == 0x000388, "Member 'UUIBrainGaugeEN::M_Percent' has a wrong offset!");
static_assert(offsetof(UUIBrainGaugeEN, M_Time) == 0x00038C, "Member 'UUIBrainGaugeEN::M_Time' has a wrong offset!");
static_assert(offsetof(UUIBrainGaugeEN, M_FlagPercentUpdate) == 0x000390, "Member 'UUIBrainGaugeEN::M_FlagPercentUpdate' has a wrong offset!");
static_assert(offsetof(UUIBrainGaugeEN, M_FlagGaugeMax) == 0x000391, "Member 'UUIBrainGaugeEN::M_FlagGaugeMax' has a wrong offset!");
static_assert(offsetof(UUIBrainGaugeEN, M_FlagBrainField) == 0x000392, "Member 'UUIBrainGaugeEN::M_FlagBrainField' has a wrong offset!");

// Class BattlePrototype.ConditionUtility
// 0x0000 (0x0028 - 0x0028)
class UConditionUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AccumulateCondition(class AActor* Actor, const struct FHCHitResult& HitResult, bool IsGuard);
	static void FinishStateConditionAll(class AActor* Actor);
	static bool IsActiveStateCondition(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConditionUtility">();
	}
	static class UConditionUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConditionUtility>();
	}
};
static_assert(alignof(UConditionUtility) == 0x000008, "Wrong alignment on UConditionUtility");
static_assert(sizeof(UConditionUtility) == 0x000028, "Wrong size on UConditionUtility");

// Class BattlePrototype.DebuggingStartupObject
// 0x0130 (0x0158 - 0x0028)
class UDebuggingStartupObject final : public UObject
{
public:
	int32                                         SaveDataNo;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DebugSaveDataNo;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pDebugSaveLoadScreenParamManager;                // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pDebugAutoSaveLoadScreenParamManager;            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pDebugSystemSaveLoadScreenParamManager;          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pDebugDebugSaveLoadScreenParamManager;           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2182[0x108];                                   // 0x0050(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetDebugSaveDataNo();
	int32 GetSaveDataNo();
	void OnACAccountControllerInfo(const class ADebuggingItemEvent* Item);
	void OnACFirstProfileCheck(const class ADebuggingItemEvent* Item);
	void OnACTickOutputLogOff(const class ADebuggingItemEvent* Item);
	void OnACTickOutputLogOn(const class ADebuggingItemEvent* Item);
	void OnAllCharaLibrary(const class ADebuggingItemBool* Item);
	void OnAllCharaLibraryDLC(const class ADebuggingItemBool* Item);
	void OnAllClearGetters(const class ADebuggingItemBool* Item);
	void OnAllEnemyLibrary(const class ADebuggingItemEvent* Item);
	void OnAllGetContents(const class ADebuggingItemBool* Item);
	void OnAllPresentList(const class ADebuggingItemBool* Item);
	void OnAllQuests(const class ADebuggingItemEvent* Item);
	void OnAllShop(const class ADebuggingItemBool* Item);
	void OnAllTutoList(const class ADebuggingItemBool* Item);
	void OnAutoDeleteFileGameData(const class ADebuggingItemEvent* Item);
	void OnAutoDeleteGameData(const class ADebuggingItemEvent* Item);
	void OnAutoLoadGameData(const class ADebuggingItemEvent* Item);
	void OnAutoSaveGameData(const class ADebuggingItemEvent* Item);
	void OnBirthdayBMDay(const class ADebuggingItemInt* Item);
	void OnBirthdayBMMonth(const class ADebuggingItemInt* Item);
	void OnBirthdayBMYear(const class ADebuggingItemStringArray* Item);
	void OnBTResetBeforePlayTime(const class ADebuggingItemEvent* Item);
	void OnBTResetIsOnce(const class ADebuggingItemEvent* Item);
	void OnChangeAnimInterLockingErrorTest(const class ADebuggingItemStringArray* Item);
	void OnChangeAnimInterLockingFailTest(const class ADebuggingItemBool* Item);
	void OnChangeAnimInterLockingQuestRelease(const class ADebuggingItemInt* Item);
	void OnChangeAnimInterLockingSuccessTest(const class ADebuggingItemBool* Item);
	void OnChangeArrangeItemForceRepopTime(const class ADebuggingItemInt* Item);
	void OnChangeArrangeItemForceRepopTimeFlag(const class ADebuggingItemBool* Item);
	void OnChangeArrangeItemGetLog(const class ADebuggingItemBool* Item);
	void OnChangeBoolBrainCrashOpend(const class ADebuggingItemBool* Item);
	void OnChangeBoolDirectPause(const class ADebuggingItemBool* Item);
	void OnChangeBoolParticleSpawnDisable(const class ADebuggingItemBool* Item);
	void OnChangeBoolSample(const class ADebuggingItemBool* Item);
	void OnChangeBoolSoundSpawnDisable(const class ADebuggingItemBool* Item);
	void OnChangeBrainTalkAllInvalidFlag(const class ADebuggingItemBool* Item);
	void OnChangeBrainTalkBTInvalidFlag(const class ADebuggingItemBool* Item);
	void OnChangedDispMessageId(const class ADebuggingItemBool* Item);
	void OnChangeDebugPauseInput(const class ADebuggingItemBool* Item);
	void OnChangeDecideButtonType(const class ADebuggingItemBool* Item);
	void OnChangeDispBrainTalkLogFlag(const class ADebuggingItemBool* Item);
	void OnChangeDispIndexDropItemLotteryParam(const class ADebuggingItemInt* Item);
	void OnChangeDisplayDropItemLotteryParam(const class ADebuggingItemBool* Item);
	void OnChangeDispType_Bonsai11349(const class ADebuggingItemBool* Item);
	void OnChangeDropItemGetRule(const class ADebuggingItemBool* Item);
	void OnChangeGuideDeviceType(const class ADebuggingItemStringArray* Item);
	void OnChangeLastShopID(const class ADebuggingItemInt* Item);
	void OnChangeLastTradeShopID(const class ADebuggingItemInt* Item);
	void OnChangeLoadingTipsID(const class ADebuggingItemStringArray* Item);
	void OnChangeMoney(const class ADebuggingItemInt* Item);
	void OnChangeMouseCameraMove(const class ADebuggingItemBool* Item);
	void OnChangepBTGiveItemsWithAjito_LogFlag(const class ADebuggingItemBool* Item);
	void OnChangepBTGiveItemsWithField_ForceEnable(const class ADebuggingItemBool* Item);
	void OnChangepBTGiveItemsWithField_LogFlag(const class ADebuggingItemBool* Item);
	void OnChangepDeepenTheBondsDebugOutputFlag(const class ADebuggingItemBool* Item);
	void OnChangepDeepenTheBondsResetIntervalTimer(const class ADebuggingItemEvent* Item);
	void OnChangePresentInfo_Bonsai11349(const class ADebuggingItemStringArray* Item);
	void OnChangeScenarioClearF(const class ADebuggingItemBool* Item);
	void OnChangeScenarioClearM(const class ADebuggingItemBool* Item);
	void OnChangeSelectDebugTimeSaveData(const class ADebuggingItemStringArray* Item);
	void OnChangeTransferObject(const class ADebuggingItemStringArray* Item);
	void OnClearGetterDebugMode(const class ADebuggingItemBool* Item);
	void OnConvertTrial2SaveData(const class ADebuggingItemEvent* Item);
	void OnDebugDrawAnimationName(const class ADebuggingItemBool* Item);
	void OnDebugDrawWidgetName(const class ADebuggingItemBool* Item);
	void OnDebugKeyboard(const class ADebuggingItemBool* Item);
	void OnDebugLoadGameData(const class ADebuggingItemEvent* Item);
	void OnDebugSaveGameData(const class ADebuggingItemEvent* Item);
	void OnDebugTimeSaveGameData(const class ADebuggingItemEvent* Item);
	void OnDeleteFileGameData(const class ADebuggingItemEvent* Item);
	void OnDeleteGameData(const class ADebuggingItemEvent* Item);
	void OnDeleteSystemData(const class ADebuggingItemEvent* Item);
	void OnDispMouseRectangle(const class ADebuggingItemBool* Item);
	void OnDrawActionIconProperty(const class ADebuggingItemBool* Item);
	void OnDrawBattleControlProperty(const class ADebuggingItemBool* Item);
	void OnDrawFontAtlasProperty(const class ADebuggingItemBool* Item);
	void OnDrawInactiveUIBaseProperty(const class ADebuggingItemBool* Item);
	void OnDrawNoticeStack(const class ADebuggingItemBool* Item);
	void OnDrawShopTradeProperty(const class ADebuggingItemBool* Item);
	void OnDrawUIBaseProperty(const class ADebuggingItemBool* Item);
	void OnExecExSystemSaveDump(const class ADebuggingItemEvent* Item);
	void OnExecuteAllBaseItems(const class ADebuggingItemEvent* Item);
	void OnExecuteAllBattleItems(const class ADebuggingItemEvent* Item);
	void OnExecuteAllEquipments(const class ADebuggingItemEvent* Item);
	void OnExecuteAllFoods(const class ADebuggingItemEvent* Item);
	void OnExecuteAllKeyItem(const class ADebuggingItemEvent* Item);
	void OnExecuteAllMaterials(const class ADebuggingItemEvent* Item);
	void OnExecuteBondsQuestNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteBrainCrashOpendChange(const class ADebuggingItemEvent* Item);
	void OnExecuteBTEnemyDebugPlay(const class ADebuggingItemEvent* Item);
	void OnExecuteBTEnemyListChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteBTMapGimmickDebugPlay(const class ADebuggingItemEvent* Item);
	void OnExecuteBTMapGimmickListChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteBTSysBattleSimOnChanged(const class ADebuggingItemBool* Item);
	void OnExecuteBTSysDebugPlay(const class ADebuggingItemEvent* Item);
	void OnExecuteBTSysForceWataruHarukaFlagChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteBTSysListChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteBTSysSkipIsOnceCheckChanged(const class ADebuggingItemBool* Item);
	void OnExecuteBTSysSkipProgressIDCheckChanged(const class ADebuggingItemBool* Item);
	void OnExecuteBTTutorialDebugPlay(const class ADebuggingItemEvent* Item);
	void OnExecuteBTTutorialListChanged(const class ADebuggingItemStringArray* Item);
	void OnExecuteCharaLibraryNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteCollectDebugMenuStrings(const class ADebuggingItemEvent* Item);
	void OnExecuteContentsClosedFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteEnemyLibraryNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteItemNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteMainQuestNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteResetDropItemLotteryParam(const class ADebuggingItemEvent* Item);
	void OnExecuteRich(const class ADebuggingItemEvent* Item);
	void OnExecuteShopItemNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteSubQuestNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteTradeItemNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteTutoGetFlag(const class ADebuggingItemStringArray* Item);
	void OnExecuteTutorialNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExecuteWorldMapNewFlagClear(const class ADebuggingItemEvent* Item);
	void OnExitGame(const class ADebuggingItemEvent* Item);
	void OnFlushFontCache(const class ADebuggingItemEvent* Item);
	void OnForceAutoSaveDisable(const class ADebuggingItemBool* Item);
	void OnForceAutoSaveEnable(const class ADebuggingItemBool* Item);
	void OnForceCrcCheckError(const class ADebuggingItemBool* Item);
	void OnForceExecGarbageCollect(const class ADebuggingItemEvent* Item);
	void OnGameResume(const class ADebuggingItemEvent* Item);
	void OnGameSuspend(const class ADebuggingItemEvent* Item);
	void OnIsExistTrial2SaveData(const class ADebuggingItemEvent* Item);
	void OnKeyRightCEBankGroup(const class ADebuggingItemBase* Item, bool IsRepeat, int32 InSpeed);
	void OnLoadAreaSelectLevel(const class ADebuggingItemEvent* Item);
	void OnLoadAutoData(const class ADebuggingItemEvent* Item);
	void OnLoadGameData(const class ADebuggingItemEvent* Item);
	void OnLoadLaunchScreen(const class ADebuggingItemEvent* Item);
	void OnLoadRetryData(const class ADebuggingItemEvent* Item);
	void OnLoadSystemData(const class ADebuggingItemEvent* Item);
	void OnLoadTrial2SaveData(const class ADebuggingItemEvent* Item);
	void OnLoadTrialSaveData(const class ADebuggingItemEvent* Item);
	void OnMinimapCreateMapDisable(const class ADebuggingItemBool* Item);
	void OnMinimapDisp(const class ADebuggingItemBool* Item);
	void OnMinimapIconEnemyTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapIconFootTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapIconNpcTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapIconTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapIconUpdateAdjust(const class ADebuggingItemBool* Item);
	void OnMinimapMaterialTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapMenuSetting(const class ADebuggingItemStringArray* Item);
	void OnMinimapRotate(const class ADebuggingItemBool* Item);
	void OnMinimapScale(const class ADebuggingItemBool* Item);
	void OnMinimapTickDisable(const class ADebuggingItemBool* Item);
	void OnMinimapTraceTickDisable(const class ADebuggingItemBool* Item);
	void OnOpenLoadMenu(const class ADebuggingItemEvent* Item);
	void OnOpenLoginUI(const class ADebuggingItemEvent* Item);
	void OnOpenSaveMenu(const class ADebuggingItemEvent* Item);
	void OnOutputFlagUpdateAlways(const class ADebuggingItemEvent* Item);
	void OnOutputUIBaseAnimationList(const class ADebuggingItemEvent* Item);
	void OnOutputUIBaseList(const class ADebuggingItemEvent* Item);
	void OnPrintScreenFadeCallStack(const class ADebuggingItemBool* Item);
	void OnReloadLevel(const class ADebuggingItemEvent* Item);
	void OnSaveAutoData(const class ADebuggingItemEvent* Item);
	void OnSaveDataCapture(const class ADebuggingItemEvent* Item);
	void OnSaveGameData(const class ADebuggingItemEvent* Item);
	void OnSaveLoadMenuSetting(const class ADebuggingItemStringArray* Item);
	void OnSaveRetryData(const class ADebuggingItemEvent* Item);
	void OnSaveSystemData(const class ADebuggingItemEvent* Item);
	void OnSetDebugSaveIndex(const class ADebuggingItemInt* Item);
	void OnSetSaveIndex(const class ADebuggingItemInt* Item);
	void OnSUDoSharePlat(const class ADebuggingItemEvent* Item);
	void OnSUTestDoShareLaunchURL(const class ADebuggingItemEvent* Item);
	void OnSUTestDoSharePlat(const class ADebuggingItemEvent* Item);
	void OnSUTestDoSharePlat2(const class ADebuggingItemEvent* Item);
	void OnSystemChangeClearFlag(const class ADebuggingItemBool* Item);
	void OnSystemChangeZeroEpClearFlag(const class ADebuggingItemBool* Item);
	void OnSystemLoadGameData(const class ADebuggingItemEvent* Item);
	void OnSystemSaveGameData(const class ADebuggingItemEvent* Item);
	void OnTitleBack(const class ADebuggingItemEvent* Item);
	void OnTrial2AchievementSaveDataCheck(const class ADebuggingItemEvent* Item);
	void OnUseMouseCursor(const class ADebuggingItemBool* Item);
	void OnVisionSimulatorArtCheck(const class ADebuggingItemBool* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingStartupObject">();
	}
	static class UDebuggingStartupObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebuggingStartupObject>();
	}
};
static_assert(alignof(UDebuggingStartupObject) == 0x000008, "Wrong alignment on UDebuggingStartupObject");
static_assert(sizeof(UDebuggingStartupObject) == 0x000158, "Wrong size on UDebuggingStartupObject");
static_assert(offsetof(UDebuggingStartupObject, SaveDataNo) == 0x000028, "Member 'UDebuggingStartupObject::SaveDataNo' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, DebugSaveDataNo) == 0x00002C, "Member 'UDebuggingStartupObject::DebugSaveDataNo' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, M_pDebugSaveLoadScreenParamManager) == 0x000030, "Member 'UDebuggingStartupObject::M_pDebugSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, M_pDebugAutoSaveLoadScreenParamManager) == 0x000038, "Member 'UDebuggingStartupObject::M_pDebugAutoSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, M_pDebugSystemSaveLoadScreenParamManager) == 0x000040, "Member 'UDebuggingStartupObject::M_pDebugSystemSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UDebuggingStartupObject, M_pDebugDebugSaveLoadScreenParamManager) == 0x000048, "Member 'UDebuggingStartupObject::M_pDebugDebugSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.UIHelpParts
// 0x0020 (0x03A8 - 0x0388)
class UUIHelpParts : public UUIBase
{
public:
	uint8                                         Pad_2184[0x20];                                    // 0x0388(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Cursor_select, class UWidgetAnimation* Cursor_default_none, class UWidgetAnimation* Cursor_default);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHelpParts">();
	}
	static class UUIHelpParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHelpParts>();
	}
};
static_assert(alignof(UUIHelpParts) == 0x000008, "Wrong alignment on UUIHelpParts");
static_assert(sizeof(UUIHelpParts) == 0x0003A8, "Wrong size on UUIHelpParts");

// Class BattlePrototype.ContinualMoveComponent
// 0x0020 (0x00E0 - 0x00C0)
class UContinualMoveComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2185[0x20];                                    // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UContinualMoveComponent* GetContinualMoveComponent(class AActor* Actor);

	void ClearMove(const class FName& ClaimantName);
	void ForceClearMove();
	void SetInvalidMove(bool bInvalid);
	void StartMove(const class FName& ClaimantName, const struct FVector& FrontVector, float InitSpeed, float Acceleration, float EndSpeed);
	void UpdateFunction(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContinualMoveComponent">();
	}
	static class UContinualMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContinualMoveComponent>();
	}
};
static_assert(alignof(UContinualMoveComponent) == 0x000008, "Wrong alignment on UContinualMoveComponent");
static_assert(sizeof(UContinualMoveComponent) == 0x0000E0, "Wrong size on UContinualMoveComponent");

// Class BattlePrototype.LibraryEnemyParam
// 0x00E8 (0x0110 - 0x0028)
class ULibraryEnemyParam final : public UObject
{
public:
	TMap<class FName, struct FLibraryEnemyParamData> ParamMapM;                                         // 0x0028(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLibraryEnemyParamData> ParamMapF;                                         // 0x0078(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FFlag                                  LibFlagsM;                                         // 0x00C8(0x0010)(Protected, NativeAccessSpecifierProtected)
	struct FFlag                                  LibFlagsF;                                         // 0x00D8(0x0010)(Protected, NativeAccessSpecifierProtected)
	class URSGameInstance*                        GameInst;                                          // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryEnemyData*                      DataTable;                                         // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2186[0x18];                                    // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetLibraryData(struct FLibraryEnemyDataCell* Data, class FName EnemyId, bool IsPlayerM, int32 ProgressNo, bool IsDebugOpen);
	bool GetLibraryDataFromLibraryID(struct FLibraryEnemyDataCell* Data, class FName LibraryID, bool IsPlayerM, int32 ProgressNo, bool IsDebugOpen);
	void InitData(class URSGameInstance* GameInstance);
	void ResetAll();

	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryEnemyParam">();
	}
	static class ULibraryEnemyParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryEnemyParam>();
	}
};
static_assert(alignof(ULibraryEnemyParam) == 0x000008, "Wrong alignment on ULibraryEnemyParam");
static_assert(sizeof(ULibraryEnemyParam) == 0x000110, "Wrong size on ULibraryEnemyParam");
static_assert(offsetof(ULibraryEnemyParam, ParamMapM) == 0x000028, "Member 'ULibraryEnemyParam::ParamMapM' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, ParamMapF) == 0x000078, "Member 'ULibraryEnemyParam::ParamMapF' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, LibFlagsM) == 0x0000C8, "Member 'ULibraryEnemyParam::LibFlagsM' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, LibFlagsF) == 0x0000D8, "Member 'ULibraryEnemyParam::LibFlagsF' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, GameInst) == 0x0000E8, "Member 'ULibraryEnemyParam::GameInst' has a wrong offset!");
static_assert(offsetof(ULibraryEnemyParam, DataTable) == 0x0000F0, "Member 'ULibraryEnemyParam::DataTable' has a wrong offset!");

// Class BattlePrototype.ControllablePsychicObjectComponent
// 0x0048 (0x0108 - 0x00C0)
class UControllablePsychicObjectComponent final : public UActorComponent
{
public:
	float                                         MaxTurnSpeed;                                      // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationSpeed;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowDownSpeed;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnSlowDown;                                     // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218B[0x3];                                     // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnSlowDownAngleMin;                              // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSlowDownAngleMax;                              // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSlowDownMaxSpeedRate;                          // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218C[0x28];                                    // 0x00E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeginControl(class ARSCharacterBase* InControlOwner, class UPlayerInputBaseComponent* InInputComponent, float InitializeSpeed);
	void EndControl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllablePsychicObjectComponent">();
	}
	static class UControllablePsychicObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllablePsychicObjectComponent>();
	}
};
static_assert(alignof(UControllablePsychicObjectComponent) == 0x000008, "Wrong alignment on UControllablePsychicObjectComponent");
static_assert(sizeof(UControllablePsychicObjectComponent) == 0x000108, "Wrong size on UControllablePsychicObjectComponent");
static_assert(offsetof(UControllablePsychicObjectComponent, MaxTurnSpeed) == 0x0000C0, "Member 'UControllablePsychicObjectComponent::MaxTurnSpeed' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, MaxSpeed) == 0x0000C4, "Member 'UControllablePsychicObjectComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, AccelerationSpeed) == 0x0000C8, "Member 'UControllablePsychicObjectComponent::AccelerationSpeed' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, SlowDownSpeed) == 0x0000CC, "Member 'UControllablePsychicObjectComponent::SlowDownSpeed' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, bTurnSlowDown) == 0x0000D0, "Member 'UControllablePsychicObjectComponent::bTurnSlowDown' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, TurnSlowDownAngleMin) == 0x0000D4, "Member 'UControllablePsychicObjectComponent::TurnSlowDownAngleMin' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, TurnSlowDownAngleMax) == 0x0000D8, "Member 'UControllablePsychicObjectComponent::TurnSlowDownAngleMax' has a wrong offset!");
static_assert(offsetof(UControllablePsychicObjectComponent, TurnSlowDownMaxSpeedRate) == 0x0000DC, "Member 'UControllablePsychicObjectComponent::TurnSlowDownMaxSpeedRate' has a wrong offset!");

// Class BattlePrototype.UIItemTradeMaterialListIndex
// 0x0070 (0x03F8 - 0x0388)
class UUIItemTradeMaterialListIndex : public UUIBase
{
public:
	uint8                                         Pad_218E[0x70];                                    // 0x0388(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectMax, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectInMax, class UWidgetAnimation* AnimDefaultLack, class UWidgetAnimation* AnimSelectLack, class UWidgetAnimation* AnimSelectInLack, class UTextBlock* TextItemName, class UTextBlock* TextNumHave, class UTextBlock* TextNumNeed);
	bool SetItemInfo(const class FName& ItemId, int32 NeedNum, bool IsLackMaterial);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemTradeMaterialListIndex">();
	}
	static class UUIItemTradeMaterialListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemTradeMaterialListIndex>();
	}
};
static_assert(alignof(UUIItemTradeMaterialListIndex) == 0x000008, "Wrong alignment on UUIItemTradeMaterialListIndex");
static_assert(sizeof(UUIItemTradeMaterialListIndex) == 0x0003F8, "Wrong size on UUIItemTradeMaterialListIndex");

// Class BattlePrototype.CopyPlayerAnimInstance
// 0x0090 (0x0300 - 0x0270)
class UCopyPlayerAnimInstance final : public UAnimInstance
{
public:
	TWeakObjectPtr<class USkeletalMeshComponent>  SourceMesh;                                        // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMontage;                                       // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2190[0x3];                                     // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SpineAimRot;                                       // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FootIKBlendRate;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKMaxHeight;                                   // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKOffset_Left;                                 // 0x0290(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKOffset_Right;                                // 0x029C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKJointTargetLocation_Left;                    // 0x02A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKJointTargetLocation_Right;                   // 0x02B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MeshOffset;                                       // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2191[0x3C];                                    // 0x02C4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupFootIK(class URSPlayerAnimInstance* InOriginalAnimInstance, float InFloorAngle, float InCapsuleHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CopyPlayerAnimInstance">();
	}
	static class UCopyPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCopyPlayerAnimInstance>();
	}
};
static_assert(alignof(UCopyPlayerAnimInstance) == 0x000010, "Wrong alignment on UCopyPlayerAnimInstance");
static_assert(sizeof(UCopyPlayerAnimInstance) == 0x000300, "Wrong size on UCopyPlayerAnimInstance");
static_assert(offsetof(UCopyPlayerAnimInstance, SourceMesh) == 0x000270, "Member 'UCopyPlayerAnimInstance::SourceMesh' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, bUseMontage) == 0x000278, "Member 'UCopyPlayerAnimInstance::bUseMontage' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, SpineAimRot) == 0x00027C, "Member 'UCopyPlayerAnimInstance::SpineAimRot' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKBlendRate) == 0x000288, "Member 'UCopyPlayerAnimInstance::FootIKBlendRate' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKMaxHeight) == 0x00028C, "Member 'UCopyPlayerAnimInstance::FootIKMaxHeight' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKOffset_Left) == 0x000290, "Member 'UCopyPlayerAnimInstance::FootIKOffset_Left' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKOffset_Right) == 0x00029C, "Member 'UCopyPlayerAnimInstance::FootIKOffset_Right' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKJointTargetLocation_Left) == 0x0002A8, "Member 'UCopyPlayerAnimInstance::FootIKJointTargetLocation_Left' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, FootIKJointTargetLocation_Right) == 0x0002B4, "Member 'UCopyPlayerAnimInstance::FootIKJointTargetLocation_Right' has a wrong offset!");
static_assert(offsetof(UCopyPlayerAnimInstance, _MeshOffset) == 0x0002C0, "Member 'UCopyPlayerAnimInstance::_MeshOffset' has a wrong offset!");

// Class BattlePrototype.CosmosSaveTest
// 0x0018 (0x0040 - 0x0028)
class UCosmosSaveTest final : public USaveGame
{
public:
	TArray<struct FCosmosSaveImageBuf>            ImageData;                                         // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2192[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddImageData(const TArray<uint8>& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CosmosSaveTest">();
	}
	static class UCosmosSaveTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCosmosSaveTest>();
	}
};
static_assert(alignof(UCosmosSaveTest) == 0x000008, "Wrong alignment on UCosmosSaveTest");
static_assert(sizeof(UCosmosSaveTest) == 0x000040, "Wrong size on UCosmosSaveTest");
static_assert(offsetof(UCosmosSaveTest, ImageData) == 0x000028, "Member 'UCosmosSaveTest::ImageData' has a wrong offset!");

// Class BattlePrototype.EnemyPathAreaCheckComponent
// 0x0050 (0x0120 - 0x00D0)
class UEnemyPathAreaCheckComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_2193[0x50];                                    // 0x00D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAreaCheck();
	void EndAreaCheck();
	void SetCheckPos(const struct FVector& StartPos, const struct FVector& EndPos, class AActor* TargetActor);
	void SetIntervalTime(float NewIntervalTime);

	bool IsAreaOut() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyPathAreaCheckComponent">();
	}
	static class UEnemyPathAreaCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyPathAreaCheckComponent>();
	}
};
static_assert(alignof(UEnemyPathAreaCheckComponent) == 0x000008, "Wrong alignment on UEnemyPathAreaCheckComponent");
static_assert(sizeof(UEnemyPathAreaCheckComponent) == 0x000120, "Wrong size on UEnemyPathAreaCheckComponent");

// Class BattlePrototype.UINexusDrive
// 0x0058 (0x03E0 - 0x0388)
class UUINexusDrive : public UUIBase
{
public:
	uint8                                         Pad_2194[0x58];                                    // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UTextBlock* PTextBlock, class UWidgetAnimation* PAnimDefault1, class UWidgetAnimation* PAnimIn1, class UWidgetAnimation* PAnimOut1, class UWidgetAnimation* PAnimChange1, class UWidgetAnimation* PAnimDefault2, class UWidgetAnimation* PAnimIn2, class UWidgetAnimation* PAnimOut2, class UWidgetAnimation* PAnimChange2);
	void SetupText();
	bool SetUsing(bool IsUsing);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINexusDrive">();
	}
	static class UUINexusDrive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINexusDrive>();
	}
};
static_assert(alignof(UUINexusDrive) == 0x000008, "Wrong alignment on UUINexusDrive");
static_assert(sizeof(UUINexusDrive) == 0x0003E0, "Wrong size on UUINexusDrive");

// Class BattlePrototype.CosmosWebManager
// 0x04B8 (0x06E8 - 0x0230)
class ACosmosWebManager : public AActor
{
public:
	uint8                                         Pad_2195[0x38];                                    // 0x0230(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TitleCd;                                           // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Limitsec;                                          // 0x0270(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOutSec;                                        // 0x0274(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RetryCount;                                        // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResultOK;                                          // 0x027C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResultMaintenance;                                 // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResponseOK;                                        // 0x0284(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SessionNG;                                         // 0x0288(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SessionTimeout;                                    // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResponseNotExistUser;                              // 0x0290(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaMax;                                           // 0x0294(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseYear;                                          // 0x0298(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseMonth;                                         // 0x029C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseDay;                                           // 0x02A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoginSkuType;                                      // 0x02A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankingGetNum;                                     // 0x02A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SealDistnce;                                       // 0x02AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2196[0x10];                                    // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugConnsectTime;                                 // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErrorCodeSuccess;                                  // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimeInterlockingProgressIdYuito;                  // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimeInterlockingProgressIdKasane;                 // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimeInterlockingContentsId;                       // 0x02D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimeInterlockingTssSlotTop;                       // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnvInitialized;                                  // 0x02D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningAuthEvent;                                // 0x02D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningWebEvent;                                 // 0x02DA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningWebLoginEvent;                            // 0x02DB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningWebSubEvent;                              // 0x02DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningWebSealEvent;                             // 0x02DD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningHttpEvet;                                 // 0x02DE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRunningMainEvent;                                // 0x02DF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Platform;                                          // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2197[0x4];                                     // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosResultParam                     ResultParam;                                       // 0x02E8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSysGetEnvResponse               SysGetEnvResponse;                                 // 0x0310(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSysKpiParam                     SysKpiParam;                                       // 0x0328(0x0010)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmsoSysKpiResponse                  SysKpiResponse;                                    // 0x0338(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCosmosSysAgreeKpiParam                SysAgreeKpiParam;                                  // 0x033C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCosmosSysAgreeKpiResponse             SysAgreeKpiResponse;                               // 0x0340(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2198[0x4];                                     // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosUserParam                       UserParam;                                         // 0x0348(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosUserResponse                    UserResponse;                                      // 0x0370(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosUserResponseV2                  UserResponseV2;                                    // 0x0388(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosTusReadParam                    TusReadParam;                                      // 0x03A8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosTusReadResponse                 TusReadResponse;                                   // 0x03C0(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosTusWriteParam                   TusWriteParam;                                     // 0x03D8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosTusWriteResponse                TusWriteResponse;                                  // 0x03F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2199[0x4];                                     // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosRankingGetMasterResponse        RankingGetMasterResponse;                          // 0x03F8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosRankingSetScoreParam            RankingSetScoreParam;                              // 0x0410(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosRankingSetScoreResponse         RankingSetScoreResponse;                           // 0x0438(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_219A[0x4];                                     // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosRankingGetByRangeParam          RankingGetByRangeParam;                            // 0x0440(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosRankingGetByRangeResponse       RankingGetByRangeResponse;                         // 0x0460(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            RankingIDList;                                     // 0x0490(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataUploadParam             SavedataUploadParam;                               // 0x04E0(0x0048)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataUploadResponse          SavedataUploadResponse;                            // 0x0528(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_219B[0x4];                                     // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosSavedataDownloadParam           SavedataDownloadParam;                             // 0x0530(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataDownloadResponse        SavedataDownloadResponse;                          // 0x0548(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataDeleteParam             SavedataDeleteParam;                               // 0x0560(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosSavedataDeleteResponse          SavedataDeleteResponse;                            // 0x0578(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_219C[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URSFrameGrabberComponent*               FrameGrabberComponent;                             // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FCosmosSealInfo>   SealInfoList;                                      // 0x0588(0x0050)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 HttpLastErrorCode;                                 // 0x05D8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCosmosHugeTssReadListParam            HugeTssReadListParam;                              // 0x05E8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_219D[0x4];                                     // 0x05F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCosmosHugeTssReadListResponse         HugeTssReadListResponse;                           // 0x05F8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCosmosGetTrackingNumResponse          GetTrackingNumResponse;                            // 0x0610(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FAnimeInterlockingURL>          PlayableQuestList;                                 // 0x0628(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimeInterlockingAnswer               AnimeInterlockingAnswer;                           // 0x0638(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void(bool bCommunicationSuccess, TArray<class FString>& QuestList)> GetPlayableQuestsDelegate;                         // 0x0658(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(bool bCommunicationSuccess, class FName QuestName, TArray<class FString>& Answers)> GetQuestAnswersDelegate;                           // 0x0668(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(bool bCommunicationSuccess, bool bCorrect)> CheckAnswerDelegate;                               // 0x0678(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EAnimeInterlockingState                       AnimeInterlockingState;                            // 0x0688(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimeInterlockingErrorType                   AnimeInterlockingErrorType;                        // 0x0689(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnimeInterlockingIsGetPlayableQuestListLoaded;     // 0x068A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnimeInterlockingIsAnswerSuccess;                  // 0x068B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AnimeInterlockingIsAnswerLoaded;                   // 0x068C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219E[0x3];                                     // 0x068D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITitleCrossSave_UpdatingWidget*       UITitleCrossSave_UpdatingWidget;                   // 0x0690(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& TrackingNum)> TrackingNumDelegate;                               // 0x0698(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_219F[0x40];                                    // 0x06A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Base64ToBase64Url(const class FString& Base64, class FString* Base64Url);
	void Base64UrlToBase64(const class FString& Base64Url, class FString* Base64);
	bool CallCheckAnswerDelegate(const class FString& QuestName, const class FString& Answer);
	void CallGetPlayableQuestListDelegate(bool bForceFinish);
	void CallGetQuestAnswersDelegate(class FName QuestName);
	void CallGetTrackingNumDelegate();
	bool CheckSealPosition(const struct FVector& Pos);
	void ClearAllSeal(float StartDelay, float Duration);
	void CosmosAddBrainMessage(class UObject* WorldContextObject);
	void CosmosAgreeKpiEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32 AgreeFlag);
	void CosmosAgreeKpiEventInternal();
	void CosmosAgreeKpiEventNoLatent(int32 AgreeFlag);
	bool CosmosAnimeInterlockingGetErrorCode(int32* ErrorCode);
	bool CosmosAnimeInterlockingIsMaintenance();
	void CosmosCheckAnswerEventInternal(const struct FAmieInterlockingCheckAnswer& Param);
	void CosmosCoreAgreeKpiEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosCoreAgreeKpiEventInternal();
	void CosmosCoreGetEnvEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosCoreGetEvnEventInternal();
	void CosmosGetEnvEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosGetEvnEventInternal();
	void CosmosGetPlayableQuestEventInternal(int32 Region, int32 Use, int32 Language, bool IsWait);
	void CosmosGetPlayableQuestList(bool* IsConnectSuccess, TArray<class FString>* QuestList);
	bool CosmosGetQuestAnswers(class FName QuestName, TArray<class FString>* Answers);
	void CosmosGetQuestAnswersEventInternal(class FName QuestName);
	void CosmosHttpEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& QuestName, bool IsCheckAnswer);
	bool CosmosHttpRequest(const class FString& QuestName);
	bool CosmosIsLoadedPlayableQuestList();
	bool CosmosIsQuestAnswerLoaded(const class FString& QuestName);
	bool CosmosRequestCheckAnswer(class FName QuestName, const class FString& Answer);
	bool CosmosRequestGetPlayableQuestList();
	bool CosmosRequestGetPlayableQuestListNoWait();
	bool CosmosRequestGetQuestAnswers(class FName QuestName);
	void CosmosResetAnimeInterlocking();
	void CosmosSetLoading();
	void CosmosUserConvertUserIdEventNoLatent(const TArray<class FString>& PlatformUserIDList);
	void CosmosWebCoreEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, ECosmosWebAPIType Type);
	void CosmosWebCoreEventInternal(ECosmosWebAPIType Type);
	void CosmosWebCoreLoginEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosWebCoreLoginEventInternal();
	void CosmosWebEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, ECosmosWebAPIType Type);
	void CosmosWebEventInternal(ECosmosWebAPIType Type);
	void CosmosWebEventNoLatent(ECosmosWebAPIType Type);
	void CosmosWebGetRankingEventInternal();
	void CosmosWebGetRankingEvnet(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& AreaName, int32 RankingType, int32 StartRank, int32 GetNum);
	void CosmosWebLoginEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void CosmosWebLoginEventInternal();
	void CosmosWebSealEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32 SlotNo, const class FString& TusData, const class FString& AreaName, const class FString& RankingUserData);
	void CosmosWebSealEventInternal();
	void CosmosWebSetRankingEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& AreaName, const class FString& UserData);
	void CosmosWebSetRankingEventInternal();
	void CosmosWebTusReadEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& UserId, int32 SlotNo);
	void CosmosWebTusReadEventInternal();
	void CosmosWebTusWriteEvent(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32 SlotNo, const class FString& TusData);
	void CosmosWebTusWriteEventInternal();
	void CosmsoAddNotificationBrainMessageEventInternal();
	void CreateRankingUserData(class UObject* WorldContextObject, const struct FCosmosRankingUserData& RankingUserData, class FString* UserData);
	void CreateTusData(const struct FVector& Pos, const struct FRotator& Rotate, const TArray<uint8>& Image, class FString* TusData);
	void DebugSetAnswers(const class FString& QuestName);
	void DebugSetOverwriteErrorType(EAnimeInterlockingErrorType ErrorType);
	void DebugSetQuestForceFail(bool bSet);
	void DebugSetQuestForceSuccess(bool bSet);
	void DebugSetQuestList();
	void DebugSetQuestRelease(int32 Param_Index);
	void DebugWriteHttp();
	void DebugWriteParam(ECosmosWebAPIType Type, const class FString& URL, const class FString& UserId, const class FString& SessionID, bool IsSend);
	void DecryptImageData(const TArray<uint8>& TusData, TArray<uint8>* Buff);
	void EnvFinalize();
	int32 EnvInitialize();
	void EnvironmentRebuild();
	bool EnvironmentValidate();
	int32 EnvUpdate();
	bool GetAgreeKpiFlg(const class UObject* WorldContextObject);
	void GetBaseURL(class FName* baseUrl);
	void GetBaseURL_V2(ECosmosWebAPIType Type, class FName* baseUrl);
	void GetBitMap(class UTextureRenderTarget2D* Target, int32 Quality, TArray<uint8>* Buff);
	void GetIssuerID(int32* IssuerID);
	class FString GetLoginTalken();
	class FString GetRankingName(const class FString& Json);
	void GetRankingUserData(class UObject* WorldContextObject, const class FString& UserData, struct FCosmosRankingUserData* RankingUserData);
	int32 GetRegion();
	bool GetTokenAndSignature();
	void GetTrackingNumInternal();
	void GetTusData(class UObject* WorldContextObject, const class FString& Data, struct FCosmosTusData* TusData);
	bool IsCompleteTokenAndSignature();
	bool IsEnvironmentBuildComplete();
	bool IsGetTokenAndSignatureExecuting();
	bool IsRunningCosmosWebAPI();
	void ReceiveErrorResponse(ECosmosWebAPIType Type, int32 RespCode);
	bool RequestAddNotificationBrainMessage();
	bool RequestGetPlayableQuestListInternal(bool IsWait);
	bool SetPlayableQuestList(bool IsTimeOut);
	void SpawnSealByWebData(const class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const class FString& AreaName);
	void UserConvertUserIdResponseEventBroadcast(const struct FCosmosUserConvertUserIdResponseParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CosmosWebManager">();
	}
	static class ACosmosWebManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACosmosWebManager>();
	}
};
static_assert(alignof(ACosmosWebManager) == 0x000008, "Wrong alignment on ACosmosWebManager");
static_assert(sizeof(ACosmosWebManager) == 0x0006E8, "Wrong size on ACosmosWebManager");
static_assert(offsetof(ACosmosWebManager, TitleCd) == 0x000268, "Member 'ACosmosWebManager::TitleCd' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, Limitsec) == 0x000270, "Member 'ACosmosWebManager::Limitsec' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TimeOutSec) == 0x000274, "Member 'ACosmosWebManager::TimeOutSec' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RetryCount) == 0x000278, "Member 'ACosmosWebManager::RetryCount' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResultOK) == 0x00027C, "Member 'ACosmosWebManager::ResultOK' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResultMaintenance) == 0x000280, "Member 'ACosmosWebManager::ResultMaintenance' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResponseOK) == 0x000284, "Member 'ACosmosWebManager::ResponseOK' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SessionNG) == 0x000288, "Member 'ACosmosWebManager::SessionNG' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SessionTimeout) == 0x00028C, "Member 'ACosmosWebManager::SessionTimeout' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResponseNotExistUser) == 0x000290, "Member 'ACosmosWebManager::ResponseNotExistUser' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AreaMax) == 0x000294, "Member 'ACosmosWebManager::AreaMax' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, BaseYear) == 0x000298, "Member 'ACosmosWebManager::BaseYear' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, BaseMonth) == 0x00029C, "Member 'ACosmosWebManager::BaseMonth' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, BaseDay) == 0x0002A0, "Member 'ACosmosWebManager::BaseDay' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, LoginSkuType) == 0x0002A4, "Member 'ACosmosWebManager::LoginSkuType' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingGetNum) == 0x0002A8, "Member 'ACosmosWebManager::RankingGetNum' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SealDistnce) == 0x0002AC, "Member 'ACosmosWebManager::SealDistnce' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, DebugConnsectTime) == 0x0002C0, "Member 'ACosmosWebManager::DebugConnsectTime' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ErrorCodeSuccess) == 0x0002C4, "Member 'ACosmosWebManager::ErrorCodeSuccess' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingProgressIdYuito) == 0x0002C8, "Member 'ACosmosWebManager::AnimeInterlockingProgressIdYuito' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingProgressIdKasane) == 0x0002CC, "Member 'ACosmosWebManager::AnimeInterlockingProgressIdKasane' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingContentsId) == 0x0002D0, "Member 'ACosmosWebManager::AnimeInterlockingContentsId' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingTssSlotTop) == 0x0002D4, "Member 'ACosmosWebManager::AnimeInterlockingTssSlotTop' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsEnvInitialized) == 0x0002D8, "Member 'ACosmosWebManager::IsEnvInitialized' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningAuthEvent) == 0x0002D9, "Member 'ACosmosWebManager::IsRunningAuthEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningWebEvent) == 0x0002DA, "Member 'ACosmosWebManager::IsRunningWebEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningWebLoginEvent) == 0x0002DB, "Member 'ACosmosWebManager::IsRunningWebLoginEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningWebSubEvent) == 0x0002DC, "Member 'ACosmosWebManager::IsRunningWebSubEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningWebSealEvent) == 0x0002DD, "Member 'ACosmosWebManager::IsRunningWebSealEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningHttpEvet) == 0x0002DE, "Member 'ACosmosWebManager::IsRunningHttpEvet' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, IsRunningMainEvent) == 0x0002DF, "Member 'ACosmosWebManager::IsRunningMainEvent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, Platform) == 0x0002E0, "Member 'ACosmosWebManager::Platform' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, ResultParam) == 0x0002E8, "Member 'ACosmosWebManager::ResultParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysGetEnvResponse) == 0x000310, "Member 'ACosmosWebManager::SysGetEnvResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysKpiParam) == 0x000328, "Member 'ACosmosWebManager::SysKpiParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysKpiResponse) == 0x000338, "Member 'ACosmosWebManager::SysKpiResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysAgreeKpiParam) == 0x00033C, "Member 'ACosmosWebManager::SysAgreeKpiParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SysAgreeKpiResponse) == 0x000340, "Member 'ACosmosWebManager::SysAgreeKpiResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, UserParam) == 0x000348, "Member 'ACosmosWebManager::UserParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, UserResponse) == 0x000370, "Member 'ACosmosWebManager::UserResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, UserResponseV2) == 0x000388, "Member 'ACosmosWebManager::UserResponseV2' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TusReadParam) == 0x0003A8, "Member 'ACosmosWebManager::TusReadParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TusReadResponse) == 0x0003C0, "Member 'ACosmosWebManager::TusReadResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TusWriteParam) == 0x0003D8, "Member 'ACosmosWebManager::TusWriteParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TusWriteResponse) == 0x0003F0, "Member 'ACosmosWebManager::TusWriteResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingGetMasterResponse) == 0x0003F8, "Member 'ACosmosWebManager::RankingGetMasterResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingSetScoreParam) == 0x000410, "Member 'ACosmosWebManager::RankingSetScoreParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingSetScoreResponse) == 0x000438, "Member 'ACosmosWebManager::RankingSetScoreResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingGetByRangeParam) == 0x000440, "Member 'ACosmosWebManager::RankingGetByRangeParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingGetByRangeResponse) == 0x000460, "Member 'ACosmosWebManager::RankingGetByRangeResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, RankingIDList) == 0x000490, "Member 'ACosmosWebManager::RankingIDList' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataUploadParam) == 0x0004E0, "Member 'ACosmosWebManager::SavedataUploadParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataUploadResponse) == 0x000528, "Member 'ACosmosWebManager::SavedataUploadResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataDownloadParam) == 0x000530, "Member 'ACosmosWebManager::SavedataDownloadParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataDownloadResponse) == 0x000548, "Member 'ACosmosWebManager::SavedataDownloadResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataDeleteParam) == 0x000560, "Member 'ACosmosWebManager::SavedataDeleteParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SavedataDeleteResponse) == 0x000578, "Member 'ACosmosWebManager::SavedataDeleteResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, FrameGrabberComponent) == 0x000580, "Member 'ACosmosWebManager::FrameGrabberComponent' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, SealInfoList) == 0x000588, "Member 'ACosmosWebManager::SealInfoList' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, HttpLastErrorCode) == 0x0005D8, "Member 'ACosmosWebManager::HttpLastErrorCode' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, HugeTssReadListParam) == 0x0005E8, "Member 'ACosmosWebManager::HugeTssReadListParam' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, HugeTssReadListResponse) == 0x0005F8, "Member 'ACosmosWebManager::HugeTssReadListResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, GetTrackingNumResponse) == 0x000610, "Member 'ACosmosWebManager::GetTrackingNumResponse' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, PlayableQuestList) == 0x000628, "Member 'ACosmosWebManager::PlayableQuestList' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingAnswer) == 0x000638, "Member 'ACosmosWebManager::AnimeInterlockingAnswer' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, GetPlayableQuestsDelegate) == 0x000658, "Member 'ACosmosWebManager::GetPlayableQuestsDelegate' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, GetQuestAnswersDelegate) == 0x000668, "Member 'ACosmosWebManager::GetQuestAnswersDelegate' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, CheckAnswerDelegate) == 0x000678, "Member 'ACosmosWebManager::CheckAnswerDelegate' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingState) == 0x000688, "Member 'ACosmosWebManager::AnimeInterlockingState' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingErrorType) == 0x000689, "Member 'ACosmosWebManager::AnimeInterlockingErrorType' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingIsGetPlayableQuestListLoaded) == 0x00068A, "Member 'ACosmosWebManager::AnimeInterlockingIsGetPlayableQuestListLoaded' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingIsAnswerSuccess) == 0x00068B, "Member 'ACosmosWebManager::AnimeInterlockingIsAnswerSuccess' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, AnimeInterlockingIsAnswerLoaded) == 0x00068C, "Member 'ACosmosWebManager::AnimeInterlockingIsAnswerLoaded' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, UITitleCrossSave_UpdatingWidget) == 0x000690, "Member 'ACosmosWebManager::UITitleCrossSave_UpdatingWidget' has a wrong offset!");
static_assert(offsetof(ACosmosWebManager, TrackingNumDelegate) == 0x000698, "Member 'ACosmosWebManager::TrackingNumDelegate' has a wrong offset!");

// Class BattlePrototype.CosmosWebManagerUtility
// 0x0000 (0x0028 - 0x0028)
class UCosmosWebManagerUtility final : public UBlueprintFunctionLibrary
{
public:
	static void CosmosAddKpiOrg10_ItemsUsed(EConsumeItemID Item_id, int32 Num);
	static void CosmosAddKpiOrg19_PlayedPhases(int32 brainSpaceActivation_cnt);
	static void CosmosAddKpiOrg6_PlayedPhases(EPlayerID Members_id, int32 Num);
	static void CosmosAddKpiOrg7_PlayedPhases(int32 brainCrash_type, int32 Num);
	static void CosmosAddKpiOrg8_PlayedPhases(int32 EnemySubjugation_cnt, int32 EnemySubjugation_brainCrash_0type_cnt, int32 EnemySubjugation_brainCrash_1type_cnt);
	static void CosmosAddKpiOrg9_PlayedPhases(EPlayerID Members_id, int32 SupportType, int32 Num);
	static void CosmosClearParam();
	static void CosmosEndBattle();
	static void CosmosEndBossBattle();
	static void CosmosEndEvent();
	static void CosmosEndIngame();
	static void CosmosEndMenu();
	static void CosmosGetPlatformUserID(class APlayerController* PlayerController, class FString* PlatformUserID, bool* Result);
	static bool CosmosIsSendedAtOnce();
	static void CosmosResetKpiParam();
	static void CosmosResetSendedAtOnce();
	static void CosmosSendedAtOnce();
	static void CosmosSendKpi10_CurrencyCirculation();
	static bool CosmosSendKpi10_IsDirtyCurrencyCirculation();
	static bool CosmosSendKpi14_IsDirtyPlayedPhases();
	static void CosmosSendKpi14_PlayedPhases();
	static bool CosmosSendKpi16_IsDirtyPlayedPhasesSelectedMembers();
	static void CosmosSendKpi16_PlayedPhasesSelectedMembers();
	static void CosmosSendKpi17_Sale(const class UObject* WorldContextObject);
	static void CosmosSendKpi22_GameLanguage();
	static void CosmosSendKpi289_Upgrade();
	static void CosmosSendKpi289_UpgradeVer2();
	static void CosmosSendKpi292_AnimationInterlocking(int32 Episode_id);
	static void CosmosSendKpi293_DLCUpdate();
	static void CosmosSendKpi294_ChallengeClearItem(int32 Challenge_id, int32 Clear_time, int32 Item_count);
	static void CosmosSendKpi294_ChallengeClearNormal(int32 Challenge_id);
	static void CosmosSendKpi294_ChallengeClearTime(int32 Challenge_id, int32 Clear_time, int32 Item_count, bool IsNotItemCount);
	static void CosmosSendKpi295_BirthdayMessage(EPlayerID Members_id);
	static void CosmosSendKpi295_FellowItemReceipt(const class FString& Item_id, EPlayerID Members_id);
	static void CosmosSendKpi295_FellowItemSarchingReceipt(const class FString& Item_id, EPlayerID Members_id);
	static void CosmosSendKpi295_MatchingAttachmentReceipt(class FName Attachment_id);
	static void CosmosSendKpi295_TwoShotPhotoReceipt(EPlayerID Members_id);
	static void CosmosSendKpi296_ExSAS(EPlayerID Members_id, int32 ExSAS_id);
	static void CosmosSendKpi324_AjitoTogether(EPlayerID Members_id);
	static void CosmosSendKpi324_AjitoTogetherSafeHouseCharacter();
	static void CosmosSendKpi324_AjitoTogetherSafeHouseMembers(EPlayerID Members_id);
	static void CosmosSendKpi325_VisionSimulator(int32 MissionId, EBattleSimulatorRank TotalScore, EBattleSimulatorRank GaveDamageScore, EBattleSimulatorRank TakenDamage, EBattleSimulatorRank brainCrashNumScore, EBattleSimulatorRank ItemsusedNumScore, EBattleSimulatorRank CleartimeScore, int32 EnemyKillNum);
	static void CosmosSendKpi338_PhotoMode();
	static bool CosmosSendKpi5_IsDirtyTimePlayed();
	static void CosmosSendKpi5_ResetTimePlayed();
	static void CosmosSendKpi5_TimePlayed();
	static void CosmosSendKpi7_Ending();
	static void CosmosSendKpi7_PlayedPhaseLevel();
	static void CosmosSendKpi7_PlayedQuestLevel(class FName Sub_quest_id);
	static void CosmosSendKpi7_Progress();
	static void CosmosSendKpi7_Quest(class FName Sub_quest_id);
	static void CosmosSendKpiOrg10_Avoidance(int32 Avoidancestate_0type_cnt, int32 Avoidancestate_1type_cnt, int32 Avoidancestate_2type_cnt, int32 Avoidancestate_3type_cnt, int32 Avoidancestate_4type_cnt);
	static void CosmosSendKpiOrg10_GameOver(int32 GameOverState);
	static bool CosmosSendKpiOrg10_IsDirtyItemsUsed();
	static void CosmosSendKpiOrg10_ItemsUsed();
	static void CosmosSendKpiOrg10_Retry();
	static void CosmosSendKpiOrg13_Attachment();
	static void CosmosSendKpiOrg13_BackupAttachment();
	static void CosmosSendKpiOrg13_BackupCostume();
	static void CosmosSendKpiOrg13_Costume();
	static bool CosmosSendKpiOrg13_IsDirtyAttachment();
	static bool CosmosSendKpiOrg13_IsDirtyCostume();
	static void CosmosSendKpiOrg13_Plugin();
	static void CosmosSendKpiOrg13_Weapon();
	static void CosmosSendKpiOrg14_Brightness(float Brightness);
	static void CosmosSendKpiOrg14_Config(EHCGameDifficulty Difficult_id, EAttackAutoLockOn AttackAutoLockOn, ETargetCameraTrace TargetCameraTrace, ECameraAfterMoveType CameraAfterMoveType, EOptionDisplayEnemyDamage DispEnemyDamage, EOptionMinimapDisplay MinimapDisplay, EOptionMinimapRotation MinimapRotation, EOptionMinimapScaling MinimapScaling, EEventMessageAutoPlay MessageAutoPlay, uint8 CameraSpeed, EOptionCameraPitch CameraPitch, EOptionCameraYaw CameraYaw, EOptionControllerVibration Vibration, EAttackDirOrtho AttackDirOrtho, EAttackDirOrthoLockon AttackDirOrthoLockon, ECameraDistance CameraDistance, uint8 CameraTrackingSpeed, ESASCutin SASCutin, bool brainCrash, ELetterSize TextSize, uint8 LockOnCameraSpeed);
	static void CosmosSendKpiOrg14_Controller(ERSGamepadInputName WeaponAttack, ERSGamepadInputName Jump, ERSGamepadInputName StrafeAndDash, ERSGamepadInputName SpecialAttack, ERSGamepadInputName ActivateSASMenu, ERSGamepadInputName EnableComboVisionMenu, ERSGamepadInputName PKAttack, ERSGamepadInputName SpecialObjectAndBrainCrush, ELockonActionType ChangeLockOnTarget, ERSGamepadInputName SusConvinationVision);
	static void CosmosSendKpiOrg14_Graphic(bool IsVerticalSyncOff, EOptionAAQuality AntiAliasingQuality, EGradualQuality TextureQuality, EGradualQuality ShadowQuality, EGradualQuality PostQuality, EWindowMode WindowMode, EFPSType FpsType);
	static void CosmosSendKpiOrg16_PlayedPhases(EPlayerSkill Skill_id);
	static void CosmosSendKpiOrg17_ShopsUsed(int32 Status, class FName Item);
	static void CosmosSendKpiOrg17_ShopVisits();
	static bool CosmosSendKpiOrg19_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg19_PlayedPhases(class FName Location);
	static void CosmosSendKpiOrg1_LapInfo(EPlayerID Character_id);
	static void CosmosSendKpiOrg21_GameVoice(ETextLanguage TextLanguage);
	static void CosmosSendKpiOrg3_KizunaEpisodeInfo(EPlayerID Members_id);
	static void CosmosSendKpiOrg3_TeamKizunaEpisodeInfo(const class FString& Team_kizuna_episode_id);
	static void CosmosSendKpiOrg4_PresentInfo(EPlayerID Members_id, class FName Present_id);
	static void CosmosSendKpiOrg5_KizunaLevel(EPlayerID Members_id);
	static bool CosmosSendKpiOrg6_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg6_PlayedPhases();
	static bool CosmosSendKpiOrg7_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg7_PlayedPhases(class FName Location);
	static bool CosmosSendKpiOrg8_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg8_PlayedPhases(int32 DriveModeActivation_num, int32 DriveModeActivation_time);
	static bool CosmosSendKpiOrg9_IsDirtyPlayedPhases();
	static void CosmosSendKpiOrg9_PlayedPhases(class FName Location);
	static void CosmosSendKpiParam();
	static void CosmosSendKpiParamAfterSave();
	static void CosmosSendKpiParamAtFirst();
	static void CosmosSendKpiParamGameover();
	static void CosmosSendKpiParamMapChange();
	static void CosmosSendKpiParamNextPhase();
	static void CosmosSendKpiParamStartGame(const class UObject* WorldContextObject);
	static void CosmosStartBattle();
	static void CosmosStartBossBattle(const class FString& bossName);
	static void CosmosStartEvent();
	static void CosmosStartIngame();
	static void CosmosStartMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CosmosWebManagerUtility">();
	}
	static class UCosmosWebManagerUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCosmosWebManagerUtility>();
	}
};
static_assert(alignof(UCosmosWebManagerUtility) == 0x000008, "Wrong alignment on UCosmosWebManagerUtility");
static_assert(sizeof(UCosmosWebManagerUtility) == 0x000028, "Wrong size on UCosmosWebManagerUtility");

// Class BattlePrototype.UICharaPresentListIndex
// 0x0030 (0x03B8 - 0x0388)
class UUICharaPresentListIndex : public UUIBase
{
public:
	uint8                                         Pad_21C2[0x30];                                    // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UTextBlock* TextItemName);
	bool SetItemInfo(const class FName& ItemId);
	void UpdateStateThis();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaPresentListIndex">();
	}
	static class UUICharaPresentListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaPresentListIndex>();
	}
};
static_assert(alignof(UUICharaPresentListIndex) == 0x000008, "Wrong alignment on UUICharaPresentListIndex");
static_assert(sizeof(UUICharaPresentListIndex) == 0x0003B8, "Wrong size on UUICharaPresentListIndex");

// Class BattlePrototype.CrashVisionComponent
// 0x00A0 (0x0160 - 0x00C0)
class UCrashVisionComponent : public UActorComponent
{
public:
	int32                                         MAX_CRASH_VISION_COUNT;                            // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PROBABILIRY_NOT_DRIVE_BATTLE_MEMBER_LOT;           // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CrashVisionDataTable;                              // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CRASH_VISION_RANGE;                                // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C4[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CRASH_DAMAGE_RATE_LIST;                            // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CrashVisionDataTable_VS;                           // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CRASH_VISION_RANGE_VS;                             // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C5[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 CRASH_DAMAGE_RATE_LIST_VS;                         // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C6[0x20];                                    // 0x0108(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerID>                             ExecCrashVisionPlayerID;                           // 0x0128(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C7[0x10];                                    // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ARSCharacterBase>> CrashTargetList;                                   // 0x0148(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21C8[0x8];                                     // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugCrashVisionDamageOffset(float Offset);
	void DebugEnableCrashVision(bool bSet);
	void DebugSetCrashVisionRange(float Range);
	void DebugSetForceLotPlayerID(EPlayerID PlayerId);
	void DebugSetIgnoreCrashAccumulate(bool bSet);
	void DebugSetIgnoreSAS(bool bSet);
	void DebugSetProbabilityNotDriveBattleMember(int32 Probability);
	void DebugSetUsePlayerLocation(bool bSet);
	void DebugVisionSimulatorMode(bool bSet);
	void FinishCrashVision();
	TArray<class ARSCharacterBase*> GetCrashTargetList();
	class ARSCharacterBase* GetNextCrashVisionTarget(const TArray<class ARSCharacterBase*>& IgnoreCharacterList);
	struct FVector GetShockWaveLocation();
	bool IsEnableShockWave();
	bool IsExecCrashVisionPlayerID(EPlayerID PlayerId);
	EPlayerID RequestCrashVision(class ARSCharacterBase* TargetCharacter, bool bFirstCrash);
	void SetExecuteCrashVisionPlayer(EPlayerID PlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrashVisionComponent">();
	}
	static class UCrashVisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrashVisionComponent>();
	}
};
static_assert(alignof(UCrashVisionComponent) == 0x000008, "Wrong alignment on UCrashVisionComponent");
static_assert(sizeof(UCrashVisionComponent) == 0x000160, "Wrong size on UCrashVisionComponent");
static_assert(offsetof(UCrashVisionComponent, MAX_CRASH_VISION_COUNT) == 0x0000C0, "Member 'UCrashVisionComponent::MAX_CRASH_VISION_COUNT' has a wrong offset!");
static_assert(offsetof(UCrashVisionComponent, PROBABILIRY_NOT_DRIVE_BATTLE_MEMBER_LOT) == 0x0000C4, "Member 'UCrashVisionComponent::PROBABILIRY_NOT_DRIVE_BATTLE_MEMBER_LOT' has a wrong offset!");
static_assert(offsetof(UCrashVisionComponent, CrashVisionDataTable) == 0x0000C8, "Member 'UCrashVisionComponent::CrashVisionDataTable' has a wrong offset!");
static_assert(offsetof(UCrashVisionComponent, CRASH_VISION_RANGE) == 0x0000D0, "Member 'UCrashVisionComponent::CRASH_VISION_RANGE' has a wrong offset!");
static_assert(offsetof(UCrashVisionComponent, CRASH_DAMAGE_RATE_LIST) == 0x0000D8, "Member 'UCrashVisionComponent::CRASH_DAMAGE_RATE_LIST' has a wrong offset!");
static_assert(offsetof(UCrashVisionComponent, CrashVisionDataTable_VS) == 0x0000E8, "Member 'UCrashVisionComponent::CrashVisionDataTable_VS' has a wrong offset!");
static_assert(offsetof(UCrashVisionComponent, CRASH_VISION_RANGE_VS) == 0x0000F0, "Member 'UCrashVisionComponent::CRASH_VISION_RANGE_VS' has a wrong offset!");
static_assert(offsetof(UCrashVisionComponent, CRASH_DAMAGE_RATE_LIST_VS) == 0x0000F8, "Member 'UCrashVisionComponent::CRASH_DAMAGE_RATE_LIST_VS' has a wrong offset!");
static_assert(offsetof(UCrashVisionComponent, ExecCrashVisionPlayerID) == 0x000128, "Member 'UCrashVisionComponent::ExecCrashVisionPlayerID' has a wrong offset!");
static_assert(offsetof(UCrashVisionComponent, CrashTargetList) == 0x000148, "Member 'UCrashVisionComponent::CrashTargetList' has a wrong offset!");

// Class BattlePrototype.CrashVisionInterface
// 0x0000 (0x0028 - 0x0028)
class ICrashVisionInterface final : public IInterface
{
public:
	bool IsDisableCrashVision();
	bool IsInvincibleCrashVisionDamage();
	bool SetDisableCrashVision(bool bDisable, const class FName ClaimantName);
	bool SetInvincibleCrashVisionDamage(bool bInvincible, const class FName ClaimantName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrashVisionInterface">();
	}
	static class ICrashVisionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICrashVisionInterface>();
	}
};
static_assert(alignof(ICrashVisionInterface) == 0x000008, "Wrong alignment on ICrashVisionInterface");
static_assert(sizeof(ICrashVisionInterface) == 0x000028, "Wrong size on ICrashVisionInterface");

// Class BattlePrototype.FlagManager
// 0x0170 (0x0198 - 0x0028)
class UFlagManager final : public UObject
{
public:
	uint8                                         Pad_21CE[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchContentsOpend;                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchContentsRestricted;                        // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFlag                                  ItemNewFlag;                                       // 0x0058(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  ShopItemNewFlag;                                   // 0x0068(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  TradeItemNewFlag;                                  // 0x0078(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  WorldMapNewFlag;                                   // 0x0088(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  TutorialNewFlag;                                   // 0x0098(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  HelpNewDataFlag;                                   // 0x00A8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  HelpGetDataFlag;                                   // 0x00B8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  HelpDisplayFlag;                                   // 0x00C8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  MainQuestNewFlag;                                  // 0x00D8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  SubQuestNewFlag;                                   // 0x00E8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  BondsQuestNewFlag;                                 // 0x00F8(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  CharaLibraryNewFlag;                               // 0x0108(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  EnemyLibraryNewFlag;                               // 0x0118(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  PresentNewFlag;                                    // 0x0128(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  ContentsOpenedFlag;                                // 0x0138(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  OperationRestrictionFlag;                          // 0x0148(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  BrainmapOpenInfoFlag;                              // 0x0158(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  AddContentsNewFlag;                                // 0x0168(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  SystemSaveDataCommonFlag;                          // 0x0178(0x0010)(NativeAccessSpecifierPrivate)
	struct FFlag                                  ShopTradeAddContentsPopupFlag;                     // 0x0188(0x0010)(NativeAccessSpecifierPrivate)

public:
	void AddContentsNewFlagOff(int32 FlagIdx);
	void AddContentsNewFlagOn(int32 FlagIdx);
	void BrainmapOpenInfoFlagOff(int32 FlagIdx);
	void BrainmapOpenInfoFlagOn(int32 FlagIdx);
	void HelpDisplayFlagOff(EHelpTutorial HelpID);
	void HelpDisplayFlagOn(EHelpTutorial HelpID);
	void HelpGetFlagClear();
	void HelpGetFlagOff(int32 Param_Index);
	void HelpGetFlagOn(int32 Param_Index);
	int32 HelpGetFlagSize();
	void HelpNewFlagClear();
	void HelpNewFlagOff(int32 Param_Index);
	void InitializeFlag(bool IsConstructor);
	void ItemNewFlagClear();
	void ItemNewFlagOff(int32 Param_Index);
	void OperationRestrictionFlagOff(EOperationRestriction Type);
	void OperationRestrictionFlagOn(EOperationRestriction Type);
	void SetAllContentsOpened();
	void SetContentsClosed(EContentsOpening Type);
	void SetContentsOpened(EContentsOpening Type);
	void ShopItemNewFlagClear();
	void ShopItemNewFlagOff(int32 Param_Index);
	void ShopTradeAddContentsPopupFlagOff(EShopTradeAddContentsPopup Type);
	void ShopTradeAddContentsPopupFlagOn(EShopTradeAddContentsPopup Type);
	void SystemSaveDataCommonFlagAllOff();
	bool SystemSaveDataCommonFlagCheck(ESystemSaveDataCommonFlag Type);
	void SystemSaveDataCommonFlagClear();
	void SystemSaveDataCommonFlagOff(ESystemSaveDataCommonFlag Type);
	void SystemSaveDataCommonFlagOn(ESystemSaveDataCommonFlag Type);
	void TradeItemNewFlagClear();
	void TradeItemNewFlagOff(int32 Param_Index);
	void TutorialNewFlagClear();
	void TutorialNewFlagOff(int32 Param_Index);
	void WorldMapNewFlagClear();
	void WorldMapNewFlagOff(int32 Param_Index);

	bool AddContentsNewFlagCheck(int32 FlagIdx) const;
	bool BrainmapOpenInfoFlagCheck(int32 FlagIdx) const;
	bool HelpDisplayFlagCheck(EHelpTutorial HelpID) const;
	bool HelpGetFlagCheck(int32 Param_Index) const;
	bool HelpNewFlagCheck(int32 Param_Index) const;
	bool IsContentsOpened(EContentsOpening Type) const;
	bool ItemNewFlagCheck(int32 Param_Index) const;
	bool OperationRestrictionFlagCheck(EOperationRestriction Type) const;
	bool ShopItemNewFlagCheck(int32 Param_Index) const;
	bool ShopTradeAddContentsPopupFlagCheck(EShopTradeAddContentsPopup Type) const;
	bool TradeItemNewFlagCheck(int32 Param_Index) const;
	bool TutorialNewFlagCheck(int32 Param_Index) const;
	bool WorldMapNewFlagCheck(int32 Param_Index) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagManager">();
	}
	static class UFlagManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagManager>();
	}
};
static_assert(alignof(UFlagManager) == 0x000008, "Wrong alignment on UFlagManager");
static_assert(sizeof(UFlagManager) == 0x000198, "Wrong size on UFlagManager");
static_assert(offsetof(UFlagManager, DispatchContentsOpend) == 0x000038, "Member 'UFlagManager::DispatchContentsOpend' has a wrong offset!");
static_assert(offsetof(UFlagManager, DispatchContentsRestricted) == 0x000048, "Member 'UFlagManager::DispatchContentsRestricted' has a wrong offset!");
static_assert(offsetof(UFlagManager, ItemNewFlag) == 0x000058, "Member 'UFlagManager::ItemNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, ShopItemNewFlag) == 0x000068, "Member 'UFlagManager::ShopItemNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, TradeItemNewFlag) == 0x000078, "Member 'UFlagManager::TradeItemNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, WorldMapNewFlag) == 0x000088, "Member 'UFlagManager::WorldMapNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, TutorialNewFlag) == 0x000098, "Member 'UFlagManager::TutorialNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, HelpNewDataFlag) == 0x0000A8, "Member 'UFlagManager::HelpNewDataFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, HelpGetDataFlag) == 0x0000B8, "Member 'UFlagManager::HelpGetDataFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, HelpDisplayFlag) == 0x0000C8, "Member 'UFlagManager::HelpDisplayFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, MainQuestNewFlag) == 0x0000D8, "Member 'UFlagManager::MainQuestNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, SubQuestNewFlag) == 0x0000E8, "Member 'UFlagManager::SubQuestNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, BondsQuestNewFlag) == 0x0000F8, "Member 'UFlagManager::BondsQuestNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, CharaLibraryNewFlag) == 0x000108, "Member 'UFlagManager::CharaLibraryNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, EnemyLibraryNewFlag) == 0x000118, "Member 'UFlagManager::EnemyLibraryNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, PresentNewFlag) == 0x000128, "Member 'UFlagManager::PresentNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, ContentsOpenedFlag) == 0x000138, "Member 'UFlagManager::ContentsOpenedFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, OperationRestrictionFlag) == 0x000148, "Member 'UFlagManager::OperationRestrictionFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, BrainmapOpenInfoFlag) == 0x000158, "Member 'UFlagManager::BrainmapOpenInfoFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, AddContentsNewFlag) == 0x000168, "Member 'UFlagManager::AddContentsNewFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, SystemSaveDataCommonFlag) == 0x000178, "Member 'UFlagManager::SystemSaveDataCommonFlag' has a wrong offset!");
static_assert(offsetof(UFlagManager, ShopTradeAddContentsPopupFlag) == 0x000188, "Member 'UFlagManager::ShopTradeAddContentsPopupFlag' has a wrong offset!");

// Class BattlePrototype.UIItemTrade
// 0xFB70 (0xFEF8 - 0x0388)
class UUIItemTrade : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D8[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D9[0xFB58];                                  // 0x03A0(0xFB58)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseWishList();
	void InitializeFromShop(class UUIShop* UIShop, class UUIShopItemDetails* UiItemDetail, class UUIShopChoice* UiChoice, class UUIShopPartyStatus* UiPartyStatus);
	void InitializeFromWishList(class UUIWishList* UIWishList, class UUIShopItemDetails* UiItemDetail, class UUIShopPartyStatus* UiPartyStatus);
	void InitializeThis(class UREDScrollBox* ScrollBox, class UUIItemTradeListIndex* UiListIndexBase, class UTextBlock* TextIndexItem, class UTextBlock* TextIndexHaveNum, class UUIItemTradeMaterialListIndex* UiMaterialListIndex1, class UUIItemTradeMaterialListIndex* UiMaterialListIndex2, class UUIItemTradeMaterialListIndex* UiMaterialListIndex3, class UTextBlock* TextMaterialName, class UTextBlock* TextMaterialHaveNum, class UTextBlock* TextMaterialNeedNum);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void Start(int32 TradeShopId, bool* IsNewItemAvailableAddLineup);
	void StartWishList();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemTrade">();
	}
	static class UUIItemTrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemTrade>();
	}
};
static_assert(alignof(UUIItemTrade) == 0x000008, "Wrong alignment on UUIItemTrade");
static_assert(sizeof(UUIItemTrade) == 0x00FEF8, "Wrong size on UUIItemTrade");
static_assert(offsetof(UUIItemTrade, ListElementSize) == 0x000388, "Member 'UUIItemTrade::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIItemTrade, ListOffsetSize) == 0x000390, "Member 'UUIItemTrade::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIItemTrade, ListIndexClass) == 0x000398, "Member 'UUIItemTrade::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.CullDistanceEffectBackgroundVolume
// 0x0010 (0x0278 - 0x0268)
class ACullDistanceEffectBackgroundVolume final : public AVolume
{
public:
	float                                         CullDistance;                                      // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Unbound;                                           // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21DC[0x7];                                     // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorBeginOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnActorEndOverlapFunc(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CullDistanceEffectBackgroundVolume">();
	}
	static class ACullDistanceEffectBackgroundVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACullDistanceEffectBackgroundVolume>();
	}
};
static_assert(alignof(ACullDistanceEffectBackgroundVolume) == 0x000008, "Wrong alignment on ACullDistanceEffectBackgroundVolume");
static_assert(sizeof(ACullDistanceEffectBackgroundVolume) == 0x000278, "Wrong size on ACullDistanceEffectBackgroundVolume");
static_assert(offsetof(ACullDistanceEffectBackgroundVolume, CullDistance) == 0x000268, "Member 'ACullDistanceEffectBackgroundVolume::CullDistance' has a wrong offset!");
static_assert(offsetof(ACullDistanceEffectBackgroundVolume, Priority) == 0x00026C, "Member 'ACullDistanceEffectBackgroundVolume::Priority' has a wrong offset!");
static_assert(offsetof(ACullDistanceEffectBackgroundVolume, Unbound) == 0x000270, "Member 'ACullDistanceEffectBackgroundVolume::Unbound' has a wrong offset!");

// Class BattlePrototype.CutCameraComponent
// 0x0040 (0x0100 - 0x00C0)
class UCutCameraComponent final : public UActorComponent
{
public:
	float                                         _OwnerOldCustomDilation;                           // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21DD[0x3C];                                    // 0x00C4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CameraBlendTimeUpdate();
	void ChangeCameraRequest(class FName ParameterName, bool bEnd, bool bPitchSet, float Pitch, class UMeshComponent* Mesh);
	void DebugDisableCutCamera(bool bSet);
	void Setup(class UDataTable* DataTable);

	bool IsUseCutCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CutCameraComponent">();
	}
	static class UCutCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCutCameraComponent>();
	}
};
static_assert(alignof(UCutCameraComponent) == 0x000008, "Wrong alignment on UCutCameraComponent");
static_assert(sizeof(UCutCameraComponent) == 0x000100, "Wrong size on UCutCameraComponent");
static_assert(offsetof(UCutCameraComponent, _OwnerOldCustomDilation) == 0x0000C0, "Member 'UCutCameraComponent::_OwnerOldCustomDilation' has a wrong offset!");

// Class BattlePrototype.DamageAcceptComponent
// 0x0210 (0x02D0 - 0x00C0)
class UDamageAcceptComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             StartDamageAnim;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DamagePopup;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             DamageHit;                                         // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FDamageAnimParam                       ReservedDamageAnimParam;                           // 0x00F0(0x01C8)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21DF[0x18];                                    // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEnemy();
	void TakeDamage(const struct FHCHitResult& HitResult, int32 Damage, float CrashDamage, bool IsDispDamagePoint, bool IsAnimDamage, bool IsDown);
	void TakeDamageSimple(int32 Damage, int32 ReduceGuard, bool IsDispDamagePoint, bool IsPercentDamage);

	EDamagePointKind DecideDamagePointKind() const;
	bool IsStartDamageAnim(const struct FHCHitResult& HitResult, int32 Damage, bool IsDown) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageAcceptComponent">();
	}
	static class UDamageAcceptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageAcceptComponent>();
	}
};
static_assert(alignof(UDamageAcceptComponent) == 0x000008, "Wrong alignment on UDamageAcceptComponent");
static_assert(sizeof(UDamageAcceptComponent) == 0x0002D0, "Wrong size on UDamageAcceptComponent");
static_assert(offsetof(UDamageAcceptComponent, StartDamageAnim) == 0x0000C0, "Member 'UDamageAcceptComponent::StartDamageAnim' has a wrong offset!");
static_assert(offsetof(UDamageAcceptComponent, DamagePopup) == 0x0000D0, "Member 'UDamageAcceptComponent::DamagePopup' has a wrong offset!");
static_assert(offsetof(UDamageAcceptComponent, DamageHit) == 0x0000E0, "Member 'UDamageAcceptComponent::DamageHit' has a wrong offset!");
static_assert(offsetof(UDamageAcceptComponent, ReservedDamageAnimParam) == 0x0000F0, "Member 'UDamageAcceptComponent::ReservedDamageAnimParam' has a wrong offset!");

// Class BattlePrototype.DamageCalcComponent
// 0x00B8 (0x0178 - 0x00C0)
class UDamageCalcComponent final : public UActorComponent
{
public:
	float                                         DAMAGE_FACTOR;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OBJECT_DAMAGE_FACTOR;                              // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FIRE_DAMAGE_FACTOR;                                // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ELECTRIC_DAMAGE_FACTOR;                            // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RANDOM_FACTOR_MIN;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RANDOM_FACTOR_MAX;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_FACTOR;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_CRASH_FACTOR;                             // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_FACTOR_STEALTH;                           // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_CRASH_FACTOR_STEALTH;                     // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_FACTOR_STEALTH_VS;                        // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_CRASH_FACTOR_STEALTH_VS;                  // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_FACTOR_ASSASSIN_VS;                       // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_CRASH_FACTOR_ASSASSIN_VS;                 // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_FACTOR_ASSASSIN_ND_VS;                    // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRITICAL_CRASH_FACTOR_ASSASSIN_ND_VS;              // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BAD_STATE_UP_FACTOR;                               // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BAD_STATE_DOWN_FACTOR;                             // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CRASH_FACTIR;                                      // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ARMOR_DAMAGE_UP_FACTOR;                            // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         COPY_PSYCHIC_ARMOR_FACTOR;                         // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PSYCHICFIELD_DAMAGE_FACTOR_BOSS;                   // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21E3[0x60];                                    // 0x0118(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDifficultyDamageRate(EHCGameDifficulty Difficulty, const struct FDifficultyDamageRate& Rate);

	int32 CalcDamageValue(const struct FHCHitResult& HitResult, bool IsGuard, bool IsRandom, bool IsArmor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageCalcComponent">();
	}
	static class UDamageCalcComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageCalcComponent>();
	}
};
static_assert(alignof(UDamageCalcComponent) == 0x000008, "Wrong alignment on UDamageCalcComponent");
static_assert(sizeof(UDamageCalcComponent) == 0x000178, "Wrong size on UDamageCalcComponent");
static_assert(offsetof(UDamageCalcComponent, DAMAGE_FACTOR) == 0x0000C0, "Member 'UDamageCalcComponent::DAMAGE_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, OBJECT_DAMAGE_FACTOR) == 0x0000C4, "Member 'UDamageCalcComponent::OBJECT_DAMAGE_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, FIRE_DAMAGE_FACTOR) == 0x0000C8, "Member 'UDamageCalcComponent::FIRE_DAMAGE_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, ELECTRIC_DAMAGE_FACTOR) == 0x0000CC, "Member 'UDamageCalcComponent::ELECTRIC_DAMAGE_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, RANDOM_FACTOR_MIN) == 0x0000D0, "Member 'UDamageCalcComponent::RANDOM_FACTOR_MIN' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, RANDOM_FACTOR_MAX) == 0x0000D4, "Member 'UDamageCalcComponent::RANDOM_FACTOR_MAX' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_FACTOR) == 0x0000D8, "Member 'UDamageCalcComponent::CRITICAL_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_CRASH_FACTOR) == 0x0000DC, "Member 'UDamageCalcComponent::CRITICAL_CRASH_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_FACTOR_STEALTH) == 0x0000E0, "Member 'UDamageCalcComponent::CRITICAL_FACTOR_STEALTH' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_CRASH_FACTOR_STEALTH) == 0x0000E4, "Member 'UDamageCalcComponent::CRITICAL_CRASH_FACTOR_STEALTH' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_FACTOR_STEALTH_VS) == 0x0000E8, "Member 'UDamageCalcComponent::CRITICAL_FACTOR_STEALTH_VS' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_CRASH_FACTOR_STEALTH_VS) == 0x0000EC, "Member 'UDamageCalcComponent::CRITICAL_CRASH_FACTOR_STEALTH_VS' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_FACTOR_ASSASSIN_VS) == 0x0000F0, "Member 'UDamageCalcComponent::CRITICAL_FACTOR_ASSASSIN_VS' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_CRASH_FACTOR_ASSASSIN_VS) == 0x0000F4, "Member 'UDamageCalcComponent::CRITICAL_CRASH_FACTOR_ASSASSIN_VS' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_FACTOR_ASSASSIN_ND_VS) == 0x0000F8, "Member 'UDamageCalcComponent::CRITICAL_FACTOR_ASSASSIN_ND_VS' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRITICAL_CRASH_FACTOR_ASSASSIN_ND_VS) == 0x0000FC, "Member 'UDamageCalcComponent::CRITICAL_CRASH_FACTOR_ASSASSIN_ND_VS' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, BAD_STATE_UP_FACTOR) == 0x000100, "Member 'UDamageCalcComponent::BAD_STATE_UP_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, BAD_STATE_DOWN_FACTOR) == 0x000104, "Member 'UDamageCalcComponent::BAD_STATE_DOWN_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, CRASH_FACTIR) == 0x000108, "Member 'UDamageCalcComponent::CRASH_FACTIR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, ARMOR_DAMAGE_UP_FACTOR) == 0x00010C, "Member 'UDamageCalcComponent::ARMOR_DAMAGE_UP_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, COPY_PSYCHIC_ARMOR_FACTOR) == 0x000110, "Member 'UDamageCalcComponent::COPY_PSYCHIC_ARMOR_FACTOR' has a wrong offset!");
static_assert(offsetof(UDamageCalcComponent, PSYCHICFIELD_DAMAGE_FACTOR_BOSS) == 0x000114, "Member 'UDamageCalcComponent::PSYCHICFIELD_DAMAGE_FACTOR_BOSS' has a wrong offset!");

// Class BattlePrototype.DamageFlyConditionComponent
// 0x0040 (0x01A0 - 0x0160)
class UDamageFlyConditionComponent final : public UConditionComponent
{
public:
	float                                         _landingSec;                                       // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _recoverableHeight;                                // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _recoverStartVelocity;                             // 0x0168(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21E6[0x2C];                                    // 0x0174(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InputRecoverButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageFlyConditionComponent">();
	}
	static class UDamageFlyConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageFlyConditionComponent>();
	}
};
static_assert(alignof(UDamageFlyConditionComponent) == 0x000010, "Wrong alignment on UDamageFlyConditionComponent");
static_assert(sizeof(UDamageFlyConditionComponent) == 0x0001A0, "Wrong size on UDamageFlyConditionComponent");
static_assert(offsetof(UDamageFlyConditionComponent, _landingSec) == 0x000160, "Member 'UDamageFlyConditionComponent::_landingSec' has a wrong offset!");
static_assert(offsetof(UDamageFlyConditionComponent, _recoverableHeight) == 0x000164, "Member 'UDamageFlyConditionComponent::_recoverableHeight' has a wrong offset!");
static_assert(offsetof(UDamageFlyConditionComponent, _recoverStartVelocity) == 0x000168, "Member 'UDamageFlyConditionComponent::_recoverStartVelocity' has a wrong offset!");

// Class BattlePrototype.DamagePropertyMediatorComponent
// 0x0160 (0x0220 - 0x00C0)
class UDamagePropertyMediatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_21E7[0x140];                                   // 0x00C0(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            _damagePrimitives;                                 // 0x0200(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_21E8[0x10];                                    // 0x0210(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDamagePropertyMediatorComponent* GetDamagePropertyMediatorComponentFromActor(class AActor* Actor);

	void ClearBlowRate(const class FName& ClaimantName);
	void ClearDamageCollisionDisable(const class FName& ClaimantName);
	void ClearDamageRate(const class FName& ClaimantName);
	void ClearHitZeroEffectSE(const class FName& ClaimantName);
	ECollisionEnabled GetCacheCollisionType(int32 Param_Index);
	int32 GetCacheCollisionTypeIndex(class UPrimitiveComponent* PPrimitive);
	int32 GetCacheCollisionTypeNum();
	void SetBlowRate(const class FName& ClaimantName, float BlowRate);
	void SetCacheCollisionType(int32 Param_Index, ECollisionEnabled Type);
	void SetDamageCollisionDisable(const class FName& ClaimantName);
	void SetDamageRate(const class FName& ClaimantName, float DamageRate);
	void SetHitZeroEffectSE(const class FName& ClaimantName, const struct FHitZeroEffectAndSE& EffectSE);

	float CalcTotalBlowRate() const;
	float CalcTotalDamageRate() const;
	struct FHitZeroEffectAndSE GetTotalHitZeroEffectSE() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamagePropertyMediatorComponent">();
	}
	static class UDamagePropertyMediatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamagePropertyMediatorComponent>();
	}
};
static_assert(alignof(UDamagePropertyMediatorComponent) == 0x000008, "Wrong alignment on UDamagePropertyMediatorComponent");
static_assert(sizeof(UDamagePropertyMediatorComponent) == 0x000220, "Wrong size on UDamagePropertyMediatorComponent");
static_assert(offsetof(UDamagePropertyMediatorComponent, _damagePrimitives) == 0x000200, "Member 'UDamagePropertyMediatorComponent::_damagePrimitives' has a wrong offset!");

// Class BattlePrototype.DatabaseManager
// 0x0338 (0x0360 - 0x0028)
class UDatabaseManager final : public UObject
{
public:
	uint8                                         Pad_21EC[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        M_pGameInstance;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemData*                              ItemData;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClearGetterData*                       ClearGetterData;                                   // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTextDatabaseData>              TextList;                                          // 0x0048(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UMessageData*>      MessageList;                                       // 0x0058(0x0050)(Protected, NativeAccessSpecifierProtected)
	class UEnemyDropData*                         EnemyDropData;                                     // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTradeItemData*                         TradeItemData;                                     // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuestData*                             QuestData;                                         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrainMessageData*                      BrainMessageData;                                  // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULoadTipsData*                          LoadTipsData;                                      // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryEnemyData*                      LibraryEnemyData;                                  // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryCharaData*                      LibraryCharaData;                                  // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHelpTutorialData*                      HelpTutorialData;                                  // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDetailedMapData*                       DetailedMapData;                                   // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             SpeakerData;                                       // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShowDestinationData*                   ShowDestinationData;                               // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPresentData*                           PresentData;                                       // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorldmapBatchOpenData*                 WorldmapBatchOpenData;                             // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FItemFavorabilityParamDataCell> ItemFavorabilityParam;                             // 0x0110(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBondsLevelupData*                      BondsLevelupData;                                  // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTeamBondsLevelupData*                  TeamBondsLevelupData;                              // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FActionIconSupportParam>        ActionIconSupportParamList;                        // 0x0130(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBrainTalkDataBase                     M_BrainTalkDatabase;                               // 0x0140(0x0120)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21ED[0x28];                                    // 0x0260(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerID>                             M_CharaSortListM;                                  // 0x0288(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EPlayerID>                             M_CharaSortListF;                                  // 0x0298(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21EE[0xB8];                                    // 0x02A8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BT_BrainTalkAsyncLoadExec();
	void BT_BrainTalkAsyncLoadStart();
	void BT_BrainTalkLoadWork();
	void BT_LoadCategoryDatatable();
	class UMessageData* FindMessageData(const class FString& TableName);
	class UBrainMessageData* GetBrainMessageData();
	class UClearGetterData* GetClearGetterData();
	class UDetailedMapData* GetDetailedMapData();
	class UEnemyDropData* GetEnemyDropData();
	class UHelpTutorialData* GetHelpTutorialData();
	class UItemData* GetItemData();
	class FString GetItemDataDescription(class FName ID);
	class FString GetItemDataName(class FName ID);
	float GetItemFavorabilityParam(EItemFavorability Favorability, bool IsFirstTime);
	class ULibraryCharaData* GetLibraryCharaData();
	class ULibraryEnemyData* GetLibraryEnemyData();
	class ULoadTipsData* GetLoadTipsData();
	bool GetMessageData(struct FMessageDataCell* MessageDataCell, const class FString& TableName, const class FString& ID);
	const TArray<EPlayerID> GetPlayerSortList(EPlayerID MainID);
	class UPresentData* GetPresentData();
	class UQuestData* GetQuestData();
	class UShowDestinationData* GetShowDestinationData();
	void GetSpeakerData(class FName RowName, struct FMessageDataCell* Param_SpeakerData);
	class FString GetText(ETextType TextType, class FName ID);
	class UTradeItemData* GetTradeItemData();
	class FString GetWhoSpeak(const class FString& DisplayName);
	void Initialize();
	bool LoadAndAppendMessageFromPath(const class FString& TableName, const class FString& FilePath);
	bool LoadMessage(const class FString& TableName, class UDataTable* DataTable);
	bool LoadMessageFromDataTable(const class FString& TableName, class UDataTable* DataTable);
	bool LoadMessageFromPath(const class FString& TableName, const class FString& FilePath);
	bool LoadResidentMessageData();
	bool LoadTextFromPath(ETextType TextType, const class FString& FilePath);
	void PreLoadAllVoiceLast(const class FString& TableName);
	bool UnloadMessage(const class FString& TableName);
	void UnloadMessageAll();
	bool UnloadText(ETextType TextType);
	void UnloadTextAll();

	bool IsFinishBrainTalkLoad() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DatabaseManager">();
	}
	static class UDatabaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDatabaseManager>();
	}
};
static_assert(alignof(UDatabaseManager) == 0x000010, "Wrong alignment on UDatabaseManager");
static_assert(sizeof(UDatabaseManager) == 0x000360, "Wrong size on UDatabaseManager");
static_assert(offsetof(UDatabaseManager, M_pGameInstance) == 0x000030, "Member 'UDatabaseManager::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, ItemData) == 0x000038, "Member 'UDatabaseManager::ItemData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, ClearGetterData) == 0x000040, "Member 'UDatabaseManager::ClearGetterData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, TextList) == 0x000048, "Member 'UDatabaseManager::TextList' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, MessageList) == 0x000058, "Member 'UDatabaseManager::MessageList' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, EnemyDropData) == 0x0000A8, "Member 'UDatabaseManager::EnemyDropData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, TradeItemData) == 0x0000B0, "Member 'UDatabaseManager::TradeItemData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, QuestData) == 0x0000B8, "Member 'UDatabaseManager::QuestData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, BrainMessageData) == 0x0000C0, "Member 'UDatabaseManager::BrainMessageData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, LoadTipsData) == 0x0000C8, "Member 'UDatabaseManager::LoadTipsData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, LibraryEnemyData) == 0x0000D0, "Member 'UDatabaseManager::LibraryEnemyData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, LibraryCharaData) == 0x0000D8, "Member 'UDatabaseManager::LibraryCharaData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, HelpTutorialData) == 0x0000E0, "Member 'UDatabaseManager::HelpTutorialData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, DetailedMapData) == 0x0000E8, "Member 'UDatabaseManager::DetailedMapData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, SpeakerData) == 0x0000F0, "Member 'UDatabaseManager::SpeakerData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, ShowDestinationData) == 0x0000F8, "Member 'UDatabaseManager::ShowDestinationData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, PresentData) == 0x000100, "Member 'UDatabaseManager::PresentData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, WorldmapBatchOpenData) == 0x000108, "Member 'UDatabaseManager::WorldmapBatchOpenData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, ItemFavorabilityParam) == 0x000110, "Member 'UDatabaseManager::ItemFavorabilityParam' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, BondsLevelupData) == 0x000120, "Member 'UDatabaseManager::BondsLevelupData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, TeamBondsLevelupData) == 0x000128, "Member 'UDatabaseManager::TeamBondsLevelupData' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, ActionIconSupportParamList) == 0x000130, "Member 'UDatabaseManager::ActionIconSupportParamList' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, M_BrainTalkDatabase) == 0x000140, "Member 'UDatabaseManager::M_BrainTalkDatabase' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, M_CharaSortListM) == 0x000288, "Member 'UDatabaseManager::M_CharaSortListM' has a wrong offset!");
static_assert(offsetof(UDatabaseManager, M_CharaSortListF) == 0x000298, "Member 'UDatabaseManager::M_CharaSortListF' has a wrong offset!");

// Class BattlePrototype.DataTableExtends
// 0x0000 (0x00C8 - 0x00C8)
class UDataTableExtends final : public UDataTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataTableExtends">();
	}
	static class UDataTableExtends* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataTableExtends>();
	}
};
static_assert(alignof(UDataTableExtends) == 0x000008, "Wrong alignment on UDataTableExtends");
static_assert(sizeof(UDataTableExtends) == 0x0000C8, "Wrong size on UDataTableExtends");

// Class BattlePrototype.DeadStateMediatorComponent
// 0x0028 (0x00E8 - 0x00C0)
class UDeadStateMediatorComponent final : public UActorComponent
{
public:
	float                                         _deadStartTime;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _deadKeepSec;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _disableAutoRevive;                                // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21FB[0x7];                                     // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRevive;                                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21FC[0x8];                                     // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsAbleDead();
	void SetDisableAutoRevibeAfterDead();
	void StartDead();
	bool TryStartDead();
	void UpdateDead();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeadStateMediatorComponent">();
	}
	static class UDeadStateMediatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeadStateMediatorComponent>();
	}
};
static_assert(alignof(UDeadStateMediatorComponent) == 0x000008, "Wrong alignment on UDeadStateMediatorComponent");
static_assert(sizeof(UDeadStateMediatorComponent) == 0x0000E8, "Wrong size on UDeadStateMediatorComponent");
static_assert(offsetof(UDeadStateMediatorComponent, _deadStartTime) == 0x0000C0, "Member 'UDeadStateMediatorComponent::_deadStartTime' has a wrong offset!");
static_assert(offsetof(UDeadStateMediatorComponent, _deadKeepSec) == 0x0000C4, "Member 'UDeadStateMediatorComponent::_deadKeepSec' has a wrong offset!");
static_assert(offsetof(UDeadStateMediatorComponent, _disableAutoRevive) == 0x0000C8, "Member 'UDeadStateMediatorComponent::_disableAutoRevive' has a wrong offset!");
static_assert(offsetof(UDeadStateMediatorComponent, OnRevive) == 0x0000D0, "Member 'UDeadStateMediatorComponent::OnRevive' has a wrong offset!");

// Class BattlePrototype.DebuggingItemImage
// 0x0048 (0x0310 - 0x02C8)
class ADebuggingItemImage final : public ADebuggingItemBase
{
public:
	FMulticastInlineDelegateProperty_             OnChangedImage;                                    // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangedIndex;                                    // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTexture*                               Image;                                             // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FText>                           StringArray;                                       // 0x02F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Index_DebuggingItemImage;                          // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21FD[0xC];                                     // 0x0304(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKeyLeftFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void OnKeyRightFunc(const class ADebuggingItemBase* InItem, bool IsRepeat, int32 InSpeed);
	void SetImage(class UTexture* Texture);
	void SetStringIndex(int32 InIndex);

	int32 GetStringIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemImage">();
	}
	static class ADebuggingItemImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemImage>();
	}
};
static_assert(alignof(ADebuggingItemImage) == 0x000008, "Wrong alignment on ADebuggingItemImage");
static_assert(sizeof(ADebuggingItemImage) == 0x000310, "Wrong size on ADebuggingItemImage");
static_assert(offsetof(ADebuggingItemImage, OnChangedImage) == 0x0002C8, "Member 'ADebuggingItemImage::OnChangedImage' has a wrong offset!");
static_assert(offsetof(ADebuggingItemImage, OnChangedIndex) == 0x0002D8, "Member 'ADebuggingItemImage::OnChangedIndex' has a wrong offset!");
static_assert(offsetof(ADebuggingItemImage, Image) == 0x0002E8, "Member 'ADebuggingItemImage::Image' has a wrong offset!");
static_assert(offsetof(ADebuggingItemImage, StringArray) == 0x0002F0, "Member 'ADebuggingItemImage::StringArray' has a wrong offset!");
static_assert(offsetof(ADebuggingItemImage, Index_DebuggingItemImage) == 0x000300, "Member 'ADebuggingItemImage::Index_DebuggingItemImage' has a wrong offset!");

// Class BattlePrototype.DebuggingItemScrResInnerChange
// 0x0008 (0x0308 - 0x0300)
class ADebuggingItemScrResInnerChange final : public ADebuggingItemInt
{
public:
	uint8                                         Pad_2200[0x8];                                     // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChangeValue(const class ADebuggingItemInt* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrResInnerChange">();
	}
	static class ADebuggingItemScrResInnerChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrResInnerChange>();
	}
};
static_assert(alignof(ADebuggingItemScrResInnerChange) == 0x000008, "Wrong alignment on ADebuggingItemScrResInnerChange");
static_assert(sizeof(ADebuggingItemScrResInnerChange) == 0x000308, "Wrong size on ADebuggingItemScrResInnerChange");

// Class BattlePrototype.DebuggingItemScrModeChange
// 0x0000 (0x0310 - 0x0310)
class ADebuggingItemScrModeChange final : public ADebuggingItemScrSetting
{
public:
	void OnChangeValue(const class ADebuggingItemStringArray* InItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrModeChange">();
	}
	static class ADebuggingItemScrModeChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrModeChange>();
	}
};
static_assert(alignof(ADebuggingItemScrModeChange) == 0x000008, "Wrong alignment on ADebuggingItemScrModeChange");
static_assert(sizeof(ADebuggingItemScrModeChange) == 0x000310, "Wrong size on ADebuggingItemScrModeChange");

// Class BattlePrototype.DebuggingItemScrResGroup
// 0x0000 (0x02D0 - 0x02D0)
class ADebuggingItemScrResGroup final : public ADebuggingItemGroup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemScrResGroup">();
	}
	static class ADebuggingItemScrResGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemScrResGroup>();
	}
};
static_assert(alignof(ADebuggingItemScrResGroup) == 0x000008, "Wrong alignment on ADebuggingItemScrResGroup");
static_assert(sizeof(ADebuggingItemScrResGroup) == 0x0002D0, "Wrong size on ADebuggingItemScrResGroup");

// Class BattlePrototype.DebuggingManager
// 0x0170 (0x03A0 - 0x0230)
class ADebuggingManager final : public AActor
{
public:
	uint8                                         Pad_2201[0x20];                                    // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReadyDebugging;                                  // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EDebuggingPage                                Page;                                              // 0x0260(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2202[0x4F];                                    // 0x0261(0x004F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            DebuggingWidget;                                   // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDebuggingWidget*>               DebuggingTreeWidget;                               // 0x02B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDebuggingStartupObject*                StartupObject;                                     // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2203[0x18];                                    // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ADebuggingItemStringArray*              M_pDebugTimeSaveDataComboBox;                      // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugDriveDrawCrashBonusAll;                      // 0x02F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugAutoInput;                                   // 0x02F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugAutoEvent;                                   // 0x02F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPrintSequencerFrame;                         // 0x02F3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugAutoInputDelayTime;                           // 0x02F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPlayerOneBrainCrash;                         // 0x02F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2204[0x3];                                     // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalTownPeopleCrowdNum;                           // 0x02FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveTownPeopleCrowdNum;                          // 0x0300(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTownPeopleNum;                                // 0x0304(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveTownPeopleNum;                               // 0x0308(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADebuggingItemInGameAchievementGroup> AchievementGroup;                                  // 0x030C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADebuggingItemFlagManagerGroup> CharaLibFlagGroup;                                 // 0x0314(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADebuggingItemFlagManagerGroup> EnemyLibFlagGroup;                                 // 0x031C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ADebuggingItemClearGetterGroup> ClearGetterGroup;                                  // 0x0324(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ATrialParamDebugGroup>   TrialParamGroup;                                   // 0x032C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AAriseCollaboParamDebugGroup> AriseCollaboParamGroup;                            // 0x0334(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugEnemyInstantBadCondition;                    // 0x033C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyOneKill;                                // 0x033D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyOneBreakArmor;                          // 0x033E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyBrainCrashAccess;                       // 0x033F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyForceWait;                              // 0x0340(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyNoReaction;                             // 0x0341(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyDrawEyeRay;                             // 0x0342(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnableEnemyHpRateDamage;                     // 0x0343(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugEnemyHPRateDamage;                            // 0x0344(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugEnemyNoAttack;                                // 0x0348(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyAllowanceIgnoreOutOfScreen;             // 0x0349(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyAllowanceIgnoreRestrictAttackOther;     // 0x034A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyRepopNoTime;                            // 0x034B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyRepopNoRange;                           // 0x034C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugStopUpdateEnemyTickEnable;                   // 0x034D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugForceEnableUpdateEnemyTickEnable;            // 0x034E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyDispRepopSettingData;                   // 0x034F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyDispTickControlInfo;                    // 0x0350(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDebugEnemyDispSettingInfo;                      // 0x0351(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDebugEnemyDispGroupInfo;                        // 0x0352(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyDispNavMeshFlag;                        // 0x0353(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugEnemyCrashAccumulation;                       // 0x0354(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugEnemyCrashAttenuationOff;                    // 0x0358(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDisablePlanarReflection;                     // 0x0359(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDispRevision;                                // 0x035A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDamageCalcLog;                               // 0x035B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugCrushDamageCalcLog;                          // 0x035C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugHasBrokenAllBattlefield;                     // 0x035D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayLogEventAssetLoad;                         // 0x035E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2205[0x1];                                     // 0x035F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DebugLoggerString;                                 // 0x0360(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 DebugLoggerTime;                                   // 0x0370(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2206[0x18];                                    // 0x0380(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugNpcNoBattle;                                 // 0x0398(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     DebugControlNonePlayerID;                          // 0x0399(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawNpcInputStick;                           // 0x039A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2207[0x5];                                     // 0x039B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ADebuggingManager* GetDebuggingManagerInstance(const class UObject* WorldContextObject);

	void AddDebugLogger(const class FString& String, float DrawSeconds);
	void BeginPageAjito();
	void BeginPageBattle();
	void BeginPageEnemy();
	void BeginPageEvent();
	void BeginPageParty();
	void BeginPagePlayer();
	void BeginPageRender();
	void BeginPageScene();
	void BeginPageSound();
	void BeginPageSystem();
	void BeginPageUI();
	bool DebugCreateEnemy(const struct FVector& Location);
	void DebugEnemyDispNavMesh();
	bool DebugGetEnemyCrashAttenuationOff();
	void DebugInputPause();
	void DebugInputStepFrame();
	int32 DebugSelectNextCreateEnemy(int32 AddValue);
	int32 DebugSelectPrevCreateEnemy(int32 SubValue);
	void DebugSetEnemyCrashAccumulation(int32 DebugCrashAccumulation);
	void DebugSetEnemyCrashAttenuationOff(bool DebugEnemyCrashAttenuationOff);
	void DebugUpdateDisablePlanarReflection();
	void DrawDebugLogger(float DeltaSeconds);
	void Dump();
	void EndPageAjito();
	void EndPageBattle();
	void EndPageEnemy();
	void EndPageEvent();
	void EndPageParty();
	void EndPagePlayer();
	void EndPageRender();
	void EndPageScene();
	void EndPageSound();
	void EndPageSystem();
	void EndPageUI();
	void ExportDebuggingItemText();
	void FinishWindow();
	bool GetAllSimulatorMissionRelease();
	class FString GetDamageCalcLog();
	class FString GetDebuggingText(const class FString& Key, bool IsReferenceJp);
	class FString GetDispPresentStringsBonsai11349();
	class FString GetRevisionString();
	bool IsDisplayLogEventAssetLoad();
	void LoadDebuggingParameter(bool IsBroadcast);
	void RegisterChild(EDebuggingPage InPage, class ADebuggingItemBase* InItem);
	void ResetDebuggingParameter();
	void SaveDebuggingParameter();
	class ADebuggingItemBase* SearchItem(EDebuggingPage InPage, const class FText& InHashName, bool InIgnoreCase);
	void SetAllSimulatorMissionRelease(bool bRelease);
	void SetDebugControlNonePlayerID(EPlayerID ID);
	void SetDebugDisablePlanarReflection(bool IsDisable);
	void SetDebugDispRevisions(bool IsDisp);
	void SetDebugDrawNpcInputStick(bool Value);
	void SetDebuggingSelectStrings(const TArray<class FName>& AreaSelectLabels, const TArray<class FString>& AreaSelectStrings, const TArray<class FName>& ScenarioSelectLabels, const TArray<class FString>& ScenerioSelectStrings, const TArray<class FName>& SevedataSelectLabels, const TArray<class FString>& SavedataSelectStrings);
	void SetDebugHasBrokenAllBattlefield(bool AllBroken);
	void SetDebugNpcNoBattle(bool bEnable);
	void SetDebugPhotomodeOutline(bool IsEnable);
	void SetPage(EDebuggingPage InPage);
	void StartWindow();
	void TickPageAjito(float DeltaSeconds);
	void TickPageBattle(float DeltaSeconds);
	void TickPageEnemy(float DeltaSeconds);
	void TickPageEvent(float DeltaSeconds);
	void TickPageParty(float DeltaSeconds);
	void TickPagePlayer(float DeltaSeconds);
	void TickPageRender(float DeltaSeconds);
	void TickPageScene(float DeltaSeconds);
	void TickPageSound(float DeltaSeconds);
	void TickPageSystem(float DeltaSeconds);
	void TickPageUI(float DeltaSeconds);
	void UnregisterChildFromHashName(EDebuggingPage InPage, const class FText& InHashName);
	void UnregisterChildFromItem(EDebuggingPage InPage, class ADebuggingItemBase* InItem);

	class FName DebugGetCreateEnemyName() const;
	int32 DebugGetEnemyCrashAccumulation() const;
	bool DebugIsDisablePlanarReflection() const;
	bool DebugIsDispRevisions() const;
	EPlayerID GetDebugControlNonePlayerID() const;
	bool GetDebugDrawNpcInputStick() const;
	float GetDebugEnemyHpRateDamage() const;
	int32 GetDebugLotteryParamIndex() const;
	bool IsDebugCrushDamageCalcLog() const;
	bool IsDebugDamageCalcLog() const;
	bool IsDebugEnableEnemyHpRateDamage() const;
	bool IsDebugEnemyAllowanceIgnoreOutOfScreen() const;
	bool IsDebugEnemyAllowanceIgnoreRestrictAttackOther() const;
	bool IsDebugEnemyBlow() const;
	bool IsDebugEnemyBrainCrashAccess() const;
	bool IsDebugEnemyDispGroupInfo() const;
	bool IsDebugEnemyDispRepopSettingData() const;
	bool IsDebugEnemyDispSettingInfo() const;
	bool IsDebugEnemyDispTickControlInfo() const;
	bool IsDebugEnemyDrawEyeRay() const;
	bool IsDebugEnemyForceWait() const;
	bool IsDebugEnemyInstantBadCondition() const;
	bool IsDebugEnemyKnockBack() const;
	bool IsDebugEnemyNoAttack() const;
	bool IsDebugEnemyNoReaction() const;
	bool IsDebugEnemyOneBreakArmor() const;
	bool IsDebugEnemyOneKill() const;
	bool IsDebugEnemyRepopNoRange() const;
	bool IsDebugEnemyRepopNoTime() const;
	bool IsDebugEnemyWince() const;
	bool IsDebugForceEnableUpdateEnemyTickEnable() const;
	bool IsDebugHasBrokenAllBattlefield() const;
	bool IsDebugNpcNoBattle() const;
	bool IsDebugStopUpdateEnemyTickEnable() const;
	bool IsDispPresentBonsai11349() const;
	bool IsEnableDebugLotteryParam() const;
	bool IsEnableDebugPauseInput() const;
	bool IsEnableDebugPhotomodeOutline() const;
	bool IsOpenWindow() const;
	bool IsReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingManager">();
	}
	static class ADebuggingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingManager>();
	}
};
static_assert(alignof(ADebuggingManager) == 0x000008, "Wrong alignment on ADebuggingManager");
static_assert(sizeof(ADebuggingManager) == 0x0003A0, "Wrong size on ADebuggingManager");
static_assert(offsetof(ADebuggingManager, OnReadyDebugging) == 0x000250, "Member 'ADebuggingManager::OnReadyDebugging' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, Page) == 0x000260, "Member 'ADebuggingManager::Page' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebuggingWidget) == 0x0002B0, "Member 'ADebuggingManager::DebuggingWidget' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebuggingTreeWidget) == 0x0002B8, "Member 'ADebuggingManager::DebuggingTreeWidget' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, StartupObject) == 0x0002C8, "Member 'ADebuggingManager::StartupObject' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, M_pDebugTimeSaveDataComboBox) == 0x0002E8, "Member 'ADebuggingManager::M_pDebugTimeSaveDataComboBox' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDriveDrawCrashBonusAll) == 0x0002F0, "Member 'ADebuggingManager::bDebugDriveDrawCrashBonusAll' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugAutoInput) == 0x0002F1, "Member 'ADebuggingManager::bDebugAutoInput' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugAutoEvent) == 0x0002F2, "Member 'ADebuggingManager::bDebugAutoEvent' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugPrintSequencerFrame) == 0x0002F3, "Member 'ADebuggingManager::bDebugPrintSequencerFrame' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugAutoInputDelayTime) == 0x0002F4, "Member 'ADebuggingManager::DebugAutoInputDelayTime' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugPlayerOneBrainCrash) == 0x0002F8, "Member 'ADebuggingManager::bDebugPlayerOneBrainCrash' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, TotalTownPeopleCrowdNum) == 0x0002FC, "Member 'ADebuggingManager::TotalTownPeopleCrowdNum' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, ActiveTownPeopleCrowdNum) == 0x000300, "Member 'ADebuggingManager::ActiveTownPeopleCrowdNum' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, TotalTownPeopleNum) == 0x000304, "Member 'ADebuggingManager::TotalTownPeopleNum' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, ActiveTownPeopleNum) == 0x000308, "Member 'ADebuggingManager::ActiveTownPeopleNum' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, AchievementGroup) == 0x00030C, "Member 'ADebuggingManager::AchievementGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, CharaLibFlagGroup) == 0x000314, "Member 'ADebuggingManager::CharaLibFlagGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, EnemyLibFlagGroup) == 0x00031C, "Member 'ADebuggingManager::EnemyLibFlagGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, ClearGetterGroup) == 0x000324, "Member 'ADebuggingManager::ClearGetterGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, TrialParamGroup) == 0x00032C, "Member 'ADebuggingManager::TrialParamGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, AriseCollaboParamGroup) == 0x000334, "Member 'ADebuggingManager::AriseCollaboParamGroup' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyInstantBadCondition) == 0x00033C, "Member 'ADebuggingManager::bDebugEnemyInstantBadCondition' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyOneKill) == 0x00033D, "Member 'ADebuggingManager::bDebugEnemyOneKill' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyOneBreakArmor) == 0x00033E, "Member 'ADebuggingManager::bDebugEnemyOneBreakArmor' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyBrainCrashAccess) == 0x00033F, "Member 'ADebuggingManager::bDebugEnemyBrainCrashAccess' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyForceWait) == 0x000340, "Member 'ADebuggingManager::bDebugEnemyForceWait' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyNoReaction) == 0x000341, "Member 'ADebuggingManager::bDebugEnemyNoReaction' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyDrawEyeRay) == 0x000342, "Member 'ADebuggingManager::bDebugEnemyDrawEyeRay' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnableEnemyHpRateDamage) == 0x000343, "Member 'ADebuggingManager::bDebugEnableEnemyHpRateDamage' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugEnemyHPRateDamage) == 0x000344, "Member 'ADebuggingManager::DebugEnemyHPRateDamage' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugEnemyNoAttack) == 0x000348, "Member 'ADebuggingManager::DebugEnemyNoAttack' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyAllowanceIgnoreOutOfScreen) == 0x000349, "Member 'ADebuggingManager::bDebugEnemyAllowanceIgnoreOutOfScreen' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyAllowanceIgnoreRestrictAttackOther) == 0x00034A, "Member 'ADebuggingManager::bDebugEnemyAllowanceIgnoreRestrictAttackOther' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyRepopNoTime) == 0x00034B, "Member 'ADebuggingManager::bDebugEnemyRepopNoTime' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyRepopNoRange) == 0x00034C, "Member 'ADebuggingManager::bDebugEnemyRepopNoRange' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugStopUpdateEnemyTickEnable) == 0x00034D, "Member 'ADebuggingManager::bDebugStopUpdateEnemyTickEnable' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugForceEnableUpdateEnemyTickEnable) == 0x00034E, "Member 'ADebuggingManager::bDebugForceEnableUpdateEnemyTickEnable' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyDispRepopSettingData) == 0x00034F, "Member 'ADebuggingManager::bDebugEnemyDispRepopSettingData' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyDispTickControlInfo) == 0x000350, "Member 'ADebuggingManager::bDebugEnemyDispTickControlInfo' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bIsDebugEnemyDispSettingInfo) == 0x000351, "Member 'ADebuggingManager::bIsDebugEnemyDispSettingInfo' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bIsDebugEnemyDispGroupInfo) == 0x000352, "Member 'ADebuggingManager::bIsDebugEnemyDispGroupInfo' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyDispNavMeshFlag) == 0x000353, "Member 'ADebuggingManager::bDebugEnemyDispNavMeshFlag' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugEnemyCrashAccumulation) == 0x000354, "Member 'ADebuggingManager::DebugEnemyCrashAccumulation' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugEnemyCrashAttenuationOff) == 0x000358, "Member 'ADebuggingManager::bDebugEnemyCrashAttenuationOff' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDisablePlanarReflection) == 0x000359, "Member 'ADebuggingManager::bDebugDisablePlanarReflection' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDispRevision) == 0x00035A, "Member 'ADebuggingManager::bDebugDispRevision' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDamageCalcLog) == 0x00035B, "Member 'ADebuggingManager::bDebugDamageCalcLog' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugCrushDamageCalcLog) == 0x00035C, "Member 'ADebuggingManager::bDebugCrushDamageCalcLog' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugHasBrokenAllBattlefield) == 0x00035D, "Member 'ADebuggingManager::bDebugHasBrokenAllBattlefield' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDisplayLogEventAssetLoad) == 0x00035E, "Member 'ADebuggingManager::bDisplayLogEventAssetLoad' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugLoggerString) == 0x000360, "Member 'ADebuggingManager::DebugLoggerString' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugLoggerTime) == 0x000370, "Member 'ADebuggingManager::DebugLoggerTime' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugNpcNoBattle) == 0x000398, "Member 'ADebuggingManager::bDebugNpcNoBattle' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, DebugControlNonePlayerID) == 0x000399, "Member 'ADebuggingManager::DebugControlNonePlayerID' has a wrong offset!");
static_assert(offsetof(ADebuggingManager, bDebugDrawNpcInputStick) == 0x00039A, "Member 'ADebuggingManager::bDebugDrawNpcInputStick' has a wrong offset!");

// Class BattlePrototype.DebuggingWidget
// 0x0058 (0x0288 - 0x0230)
class UDebuggingWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2210[0x58];                                    // 0x0230(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingWidget">();
	}
	static class UDebuggingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebuggingWidget>();
	}
};
static_assert(alignof(UDebuggingWidget) == 0x000008, "Wrong alignment on UDebuggingWidget");
static_assert(sizeof(UDebuggingWidget) == 0x000288, "Wrong size on UDebuggingWidget");

// Class BattlePrototype.DebuggingWindowInterface
// 0x0000 (0x0028 - 0x0028)
class IDebuggingWindowInterface final : public IInterface
{
public:
	void OnChangePage(EDebuggingPage NewPage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingWindowInterface">();
	}
	static class IDebuggingWindowInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDebuggingWindowInterface>();
	}
};
static_assert(alignof(IDebuggingWindowInterface) == 0x000008, "Wrong alignment on IDebuggingWindowInterface");
static_assert(sizeof(IDebuggingWindowInterface) == 0x000028, "Wrong size on IDebuggingWindowInterface");

// Class BattlePrototype.DebugPrintComponent
// 0x0010 (0x00D0 - 0x00C0)
class UDebugPrintComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2211[0x10];                                    // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DrawHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugPrintComponent">();
	}
	static class UDebugPrintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugPrintComponent>();
	}
};
static_assert(alignof(UDebugPrintComponent) == 0x000008, "Wrong alignment on UDebugPrintComponent");
static_assert(sizeof(UDebugPrintComponent) == 0x0000D0, "Wrong size on UDebugPrintComponent");

// Class BattlePrototype.DebugWarpPointBase
// 0x0000 (0x0230 - 0x0230)
class ADebugWarpPointBase final : public AActor
{
public:
	class FName GetWarpPointName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugWarpPointBase">();
	}
	static class ADebugWarpPointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugWarpPointBase>();
	}
};
static_assert(alignof(ADebugWarpPointBase) == 0x000008, "Wrong alignment on ADebugWarpPointBase");
static_assert(sizeof(ADebugWarpPointBase) == 0x000230, "Wrong size on ADebugWarpPointBase");

// Class BattlePrototype.DeepenTheBondsParamManager
// 0x00B8 (0x00E0 - 0x0028)
class UDeepenTheBondsParamManager final : public UObject
{
public:
	uint8                                         Pad_2212[0xB8];                                    // 0x0028(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ControlTimerAtChangePlayer(bool bYuito);
	void GetRandomSelectChar(const TArray<class AAjitoMember*>& AjitMember, class AAjitoMember** SelectedChar);
	void GetSelectedTogetherCharID(TArray<EPlayerID>* SelectedArray);
	void OnRecheckFlag(bool bYuito);
	void RemoveSelectedChar(EPlayerID CharID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeepenTheBondsParamManager">();
	}
	static class UDeepenTheBondsParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeepenTheBondsParamManager>();
	}
};
static_assert(alignof(UDeepenTheBondsParamManager) == 0x000008, "Wrong alignment on UDeepenTheBondsParamManager");
static_assert(sizeof(UDeepenTheBondsParamManager) == 0x0000E0, "Wrong size on UDeepenTheBondsParamManager");

// Class BattlePrototype.DestroyConditionComponent
// 0x0000 (0x0160 - 0x0160)
class UDestroyConditionComponent final : public UConditionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyConditionComponent">();
	}
	static class UDestroyConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyConditionComponent>();
	}
};
static_assert(alignof(UDestroyConditionComponent) == 0x000010, "Wrong alignment on UDestroyConditionComponent");
static_assert(sizeof(UDestroyConditionComponent) == 0x000160, "Wrong size on UDestroyConditionComponent");

// Class BattlePrototype.DetailedMapDBAsset
// 0x0050 (0x0078 - 0x0028)
class UDetailedMapDBAsset final : public UObject
{
public:
	TMap<class FName, struct FDetailedMapDBDataCell> DetailedMapDBMap_;                                 // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetailedMapDBAsset">();
	}
	static class UDetailedMapDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetailedMapDBAsset>();
	}
};
static_assert(alignof(UDetailedMapDBAsset) == 0x000008, "Wrong alignment on UDetailedMapDBAsset");
static_assert(sizeof(UDetailedMapDBAsset) == 0x000078, "Wrong size on UDetailedMapDBAsset");
static_assert(offsetof(UDetailedMapDBAsset, DetailedMapDBMap_) == 0x000028, "Member 'UDetailedMapDBAsset::DetailedMapDBMap_' has a wrong offset!");

// Class BattlePrototype.DropItem
// 0x00C8 (0x02F8 - 0x0230)
class ADropItem : public AActor
{
public:
	class FName                                   ItemNameID_;                                       // 0x0230(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ItemNum_;                                          // 0x0238(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCoreDrop_;                                       // 0x023C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2213[0x3];                                     // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DropSpeedBase_;                                    // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropAddSpeed_;                                     // 0x0244(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AddSpeedValue_;                                    // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         becomeCanGettingItemTime_;                         // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropDownSpeed_;                                    // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2214[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         DropParticleComponent_;                            // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         AcquiredParticleComponent_;                        // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSParticleSystemComponentBase*         GetParticleComponent_;                             // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TakenDistance_;                                    // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TakenAndDestroyDistance_;                          // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       TakenSphereComponent_;                             // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       AdsorptionSphereComponent_;                        // 0x0280(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdsorptionSpeed_;                                  // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AdsorptionVector_;                                 // 0x028C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDropItemStateName                            NowState_;                                         // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2215[0x3];                                     // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPos_;                                        // 0x029C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDispersionMove_;                                 // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2216[0x3];                                     // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActiveTickCounter_;                                // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RegistNum_;                                        // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2217[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          GetSound_;                                         // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          AddItemSeCue;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2218[0x30];                                    // 0x02C8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindGetItem();
	void ComputeAdsorptionVector(const struct FVector& TargetLocation);
	float ComputeAndGetDropDownSpeed(float Time);
	void DestroyThisItem();
	void DoActiveAcquiredParticle();
	void DoAdsorption(float DTime);
	void DropDown(float DropSpeed);
	void GetParticleFinished(class UParticleSystemComponent* PSystem);
	void PlayAddItemSound();
	void PlayGetSound();
	void SetAutoTakenFlag(bool bAuto);
	void SetDropParticle();
	void SetItemDataID(class FName SId);
	void SetItemDataNum(int32 Num);
	void SetItemState(EDropItemStateName NewState);
	void SetMeshVisibleAndActive(bool IsVisible);
	void SetOtherParticle(class UParticleSystem* DropParticle, class UParticleSystem* AquParticle, class UParticleSystem* GetParticle);
	void SetUseParticle(EDropItemParticleName DpName);
	void SwitchTickAtBeforeRenderInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropItem">();
	}
	static class ADropItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADropItem>();
	}
};
static_assert(alignof(ADropItem) == 0x000008, "Wrong alignment on ADropItem");
static_assert(sizeof(ADropItem) == 0x0002F8, "Wrong size on ADropItem");
static_assert(offsetof(ADropItem, ItemNameID_) == 0x000230, "Member 'ADropItem::ItemNameID_' has a wrong offset!");
static_assert(offsetof(ADropItem, ItemNum_) == 0x000238, "Member 'ADropItem::ItemNum_' has a wrong offset!");
static_assert(offsetof(ADropItem, IsCoreDrop_) == 0x00023C, "Member 'ADropItem::IsCoreDrop_' has a wrong offset!");
static_assert(offsetof(ADropItem, DropSpeedBase_) == 0x000240, "Member 'ADropItem::DropSpeedBase_' has a wrong offset!");
static_assert(offsetof(ADropItem, DropAddSpeed_) == 0x000244, "Member 'ADropItem::DropAddSpeed_' has a wrong offset!");
static_assert(offsetof(ADropItem, AddSpeedValue_) == 0x000248, "Member 'ADropItem::AddSpeedValue_' has a wrong offset!");
static_assert(offsetof(ADropItem, becomeCanGettingItemTime_) == 0x00024C, "Member 'ADropItem::becomeCanGettingItemTime_' has a wrong offset!");
static_assert(offsetof(ADropItem, DropDownSpeed_) == 0x000250, "Member 'ADropItem::DropDownSpeed_' has a wrong offset!");
static_assert(offsetof(ADropItem, DropParticleComponent_) == 0x000258, "Member 'ADropItem::DropParticleComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, AcquiredParticleComponent_) == 0x000260, "Member 'ADropItem::AcquiredParticleComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, GetParticleComponent_) == 0x000268, "Member 'ADropItem::GetParticleComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, TakenDistance_) == 0x000270, "Member 'ADropItem::TakenDistance_' has a wrong offset!");
static_assert(offsetof(ADropItem, TakenAndDestroyDistance_) == 0x000274, "Member 'ADropItem::TakenAndDestroyDistance_' has a wrong offset!");
static_assert(offsetof(ADropItem, TakenSphereComponent_) == 0x000278, "Member 'ADropItem::TakenSphereComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, AdsorptionSphereComponent_) == 0x000280, "Member 'ADropItem::AdsorptionSphereComponent_' has a wrong offset!");
static_assert(offsetof(ADropItem, AdsorptionSpeed_) == 0x000288, "Member 'ADropItem::AdsorptionSpeed_' has a wrong offset!");
static_assert(offsetof(ADropItem, AdsorptionVector_) == 0x00028C, "Member 'ADropItem::AdsorptionVector_' has a wrong offset!");
static_assert(offsetof(ADropItem, NowState_) == 0x000298, "Member 'ADropItem::NowState_' has a wrong offset!");
static_assert(offsetof(ADropItem, TargetPos_) == 0x00029C, "Member 'ADropItem::TargetPos_' has a wrong offset!");
static_assert(offsetof(ADropItem, IsDispersionMove_) == 0x0002A8, "Member 'ADropItem::IsDispersionMove_' has a wrong offset!");
static_assert(offsetof(ADropItem, ActiveTickCounter_) == 0x0002AC, "Member 'ADropItem::ActiveTickCounter_' has a wrong offset!");
static_assert(offsetof(ADropItem, RegistNum_) == 0x0002B0, "Member 'ADropItem::RegistNum_' has a wrong offset!");
static_assert(offsetof(ADropItem, GetSound_) == 0x0002B8, "Member 'ADropItem::GetSound_' has a wrong offset!");
static_assert(offsetof(ADropItem, AddItemSeCue) == 0x0002C0, "Member 'ADropItem::AddItemSeCue' has a wrong offset!");

// Class BattlePrototype.DynamicMaterialControllerComponent
// 0x0070 (0x0130 - 0x00C0)
class UDynamicMaterialControllerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             _dispatcherEndParameterFade;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2219[0x60];                                    // 0x00D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDynamicMaterialControllerComponent* GetDynamicMaterialControllerComponent(class AActor* Actor);

	float GetScalarParameterValue(class FName ParameterName);
	struct FLinearColor GetVectorParameterValue(class FName ParameterName);
	void SetScalarParameterValue(class FName ParameterName, float Value);
	void SetTextureParameterValue(class FName ParameterName, class UTexture* Value);
	void SetupMeshMaterials();
	void SetVectorParameterValue(class FName ParameterName, const struct FLinearColor& Value);
	void StartFadeScalarParameter(class FName ParameterName, bool bToOne, float FadeSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMaterialControllerComponent">();
	}
	static class UDynamicMaterialControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMaterialControllerComponent>();
	}
};
static_assert(alignof(UDynamicMaterialControllerComponent) == 0x000008, "Wrong alignment on UDynamicMaterialControllerComponent");
static_assert(sizeof(UDynamicMaterialControllerComponent) == 0x000130, "Wrong size on UDynamicMaterialControllerComponent");
static_assert(offsetof(UDynamicMaterialControllerComponent, _dispatcherEndParameterFade) == 0x0000C0, "Member 'UDynamicMaterialControllerComponent::_dispatcherEndParameterFade' has a wrong offset!");

// Class BattlePrototype.EffectBackgroundMother
// 0x0008 (0x0238 - 0x0230)
class AEffectBackgroundMother : public AActor
{
public:
	float                                         MergeDistance_;                                    // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221B[0x4];                                     // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool MergeEffectBG();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectBackgroundMother">();
	}
	static class AEffectBackgroundMother* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectBackgroundMother>();
	}
};
static_assert(alignof(AEffectBackgroundMother) == 0x000008, "Wrong alignment on AEffectBackgroundMother");
static_assert(sizeof(AEffectBackgroundMother) == 0x000238, "Wrong size on AEffectBackgroundMother");
static_assert(offsetof(AEffectBackgroundMother, MergeDistance_) == 0x000230, "Member 'AEffectBackgroundMother::MergeDistance_' has a wrong offset!");

// Class BattlePrototype.EnemyAddDamageShakeComponentBase
// 0x0088 (0x0148 - 0x00C0)
class UEnemyAddDamageShakeComponentBase : public UActorComponent
{
public:
	class ARSCharacterBase*                       MOwnerCharacter;                                   // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221C[0x8];                                     // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MShakeMaxCount;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MShakeScale;                                       // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MShakeCurveData;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MRotateRange;                                      // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MShakeRangeMin;                                    // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MShakeRangeMax;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MOneShakeTimer;                                    // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MTriggerShakeScale;                                // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MKnockBackShakeScale;                              // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MCharaTypeShakeScale;                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221D[0x4C];                                    // 0x00FC(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcShakeScale_Native();
	void End_Native();
	struct FVector GetRandomVec_Native(const struct FVector& CurrentVec, float Range, bool IsRight);
	void Start_Native(bool TriggerAttack);
	void Update_Native(float DeltaSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAddDamageShakeComponentBase">();
	}
	static class UEnemyAddDamageShakeComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAddDamageShakeComponentBase>();
	}
};
static_assert(alignof(UEnemyAddDamageShakeComponentBase) == 0x000008, "Wrong alignment on UEnemyAddDamageShakeComponentBase");
static_assert(sizeof(UEnemyAddDamageShakeComponentBase) == 0x000148, "Wrong size on UEnemyAddDamageShakeComponentBase");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MOwnerCharacter) == 0x0000C0, "Member 'UEnemyAddDamageShakeComponentBase::MOwnerCharacter' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeMaxCount) == 0x0000D0, "Member 'UEnemyAddDamageShakeComponentBase::MShakeMaxCount' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeScale) == 0x0000D4, "Member 'UEnemyAddDamageShakeComponentBase::MShakeScale' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeCurveData) == 0x0000D8, "Member 'UEnemyAddDamageShakeComponentBase::MShakeCurveData' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MRotateRange) == 0x0000E0, "Member 'UEnemyAddDamageShakeComponentBase::MRotateRange' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeRangeMin) == 0x0000E4, "Member 'UEnemyAddDamageShakeComponentBase::MShakeRangeMin' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MShakeRangeMax) == 0x0000E8, "Member 'UEnemyAddDamageShakeComponentBase::MShakeRangeMax' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MOneShakeTimer) == 0x0000EC, "Member 'UEnemyAddDamageShakeComponentBase::MOneShakeTimer' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MTriggerShakeScale) == 0x0000F0, "Member 'UEnemyAddDamageShakeComponentBase::MTriggerShakeScale' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MKnockBackShakeScale) == 0x0000F4, "Member 'UEnemyAddDamageShakeComponentBase::MKnockBackShakeScale' has a wrong offset!");
static_assert(offsetof(UEnemyAddDamageShakeComponentBase, MCharaTypeShakeScale) == 0x0000F8, "Member 'UEnemyAddDamageShakeComponentBase::MCharaTypeShakeScale' has a wrong offset!");

// Class BattlePrototype.EnemyAiVariableComponent
// 0x0000 (0x00C0 - 0x00C0)
class UEnemyAiVariableComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAiVariableComponent">();
	}
	static class UEnemyAiVariableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAiVariableComponent>();
	}
};
static_assert(alignof(UEnemyAiVariableComponent) == 0x000008, "Wrong alignment on UEnemyAiVariableComponent");
static_assert(sizeof(UEnemyAiVariableComponent) == 0x0000C0, "Wrong size on UEnemyAiVariableComponent");

// Class BattlePrototype.EnemyAroundEffectComponentBase
// 0x0070 (0x0130 - 0x00C0)
class UEnemyAroundEffectComponentBase : public UActorComponent
{
public:
	bool                                          MbUseEffect;                                       // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221F[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MCommonRate;                                       // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAttachRate;                                       // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2220[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         MEffectHandle;                                     // 0x00D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbVisible;                                         // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2221[0x3];                                     // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MVertSurfaceParameterName;                         // 0x00DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MVertSurfaceParameterCommonRateName;               // 0x00E4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MVertSurfaceParameterAttachRateName;               // 0x00EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MUseMultiEmitter;                                  // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2222[0x3];                                     // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           VertSurfaceParameterCommonRateNameList;            // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           EmitterNameList;                                   // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  EmitterEnableList;                                 // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeDeitherValue;                                 // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MDelayFadeDeitherFlag;                             // 0x012C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MEndWeakHideEffect;                                // 0x012D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2223[0x2];                                     // 0x012E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DelaySetFadeDeitherValue();
	bool EndAroundWeakEffect_Native(int32 EmitterIndex);
	int32 GetEmitterLastIndex();
	void HiddenEffect_Native(bool NewHidden);
	void Initialize(bool UseEffect, float CommonRate, float AttachRate, bool Visible);
	bool IsDisableAllEmitter();
	bool IsEnableAllEmitter();
	bool IsUseEffect_Native();
	bool IsUseMultiEmitter();
	bool IsVisible_Native();
	bool IsVisibleEffect_Native(int32 EmitterIndex);
	void RegisterCameraDitherParticleHandle_FromNative(class AActor* Owner, class URSParticleSystemComponentBase* AroundWeakEffect);
	void SetEffectParam_Native(float NewCommonRate, float NewAttachRate);
	void SetEffectParameter();
	void SetFadeDeitherValue(float DeitherValue);
	void SetVisibleEffect_Native(bool Visible);
	class URSParticleSystemComponentBase* SpawnEmitter_FromNative(class USkeletalMeshComponent* TargetMesh);
	bool StartAroundWeakEffect_Native(int32 EmitterIndex);
	void UnregisterCameraDitherParticleHandle_FromNative(class AActor* Owner, class URSParticleSystemComponentBase* EffectHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAroundEffectComponentBase">();
	}
	static class UEnemyAroundEffectComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAroundEffectComponentBase>();
	}
};
static_assert(alignof(UEnemyAroundEffectComponentBase) == 0x000008, "Wrong alignment on UEnemyAroundEffectComponentBase");
static_assert(sizeof(UEnemyAroundEffectComponentBase) == 0x000130, "Wrong size on UEnemyAroundEffectComponentBase");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MbUseEffect) == 0x0000C0, "Member 'UEnemyAroundEffectComponentBase::MbUseEffect' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MCommonRate) == 0x0000C4, "Member 'UEnemyAroundEffectComponentBase::MCommonRate' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MAttachRate) == 0x0000C8, "Member 'UEnemyAroundEffectComponentBase::MAttachRate' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MEffectHandle) == 0x0000D0, "Member 'UEnemyAroundEffectComponentBase::MEffectHandle' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MbVisible) == 0x0000D8, "Member 'UEnemyAroundEffectComponentBase::MbVisible' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MVertSurfaceParameterName) == 0x0000DC, "Member 'UEnemyAroundEffectComponentBase::MVertSurfaceParameterName' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MVertSurfaceParameterCommonRateName) == 0x0000E4, "Member 'UEnemyAroundEffectComponentBase::MVertSurfaceParameterCommonRateName' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MVertSurfaceParameterAttachRateName) == 0x0000EC, "Member 'UEnemyAroundEffectComponentBase::MVertSurfaceParameterAttachRateName' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MUseMultiEmitter) == 0x0000F4, "Member 'UEnemyAroundEffectComponentBase::MUseMultiEmitter' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, VertSurfaceParameterCommonRateNameList) == 0x0000F8, "Member 'UEnemyAroundEffectComponentBase::VertSurfaceParameterCommonRateNameList' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, EmitterNameList) == 0x000108, "Member 'UEnemyAroundEffectComponentBase::EmitterNameList' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, EmitterEnableList) == 0x000118, "Member 'UEnemyAroundEffectComponentBase::EmitterEnableList' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MFadeDeitherValue) == 0x000128, "Member 'UEnemyAroundEffectComponentBase::MFadeDeitherValue' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MDelayFadeDeitherFlag) == 0x00012C, "Member 'UEnemyAroundEffectComponentBase::MDelayFadeDeitherFlag' has a wrong offset!");
static_assert(offsetof(UEnemyAroundEffectComponentBase, MEndWeakHideEffect) == 0x00012D, "Member 'UEnemyAroundEffectComponentBase::MEndWeakHideEffect' has a wrong offset!");

// Class BattlePrototype.EnemyCheckDodgeJustComponent
// 0x0008 (0x00C8 - 0x00C0)
class UEnemyCheckDodgeJustComponent final : public UActorComponent
{
public:
	float                                         MDodgeRadius;                                      // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MDodgeRadiusRangeAttack;                           // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CheckEnableDodgeJust(const struct FVector& Location, const struct FVector& UpDir, const struct FVector& Offset, float Height, float Radius, class UHitCheckComponent* HitCheck, float CheckScale, float CheckRangeScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyCheckDodgeJustComponent">();
	}
	static class UEnemyCheckDodgeJustComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyCheckDodgeJustComponent>();
	}
};
static_assert(alignof(UEnemyCheckDodgeJustComponent) == 0x000008, "Wrong alignment on UEnemyCheckDodgeJustComponent");
static_assert(sizeof(UEnemyCheckDodgeJustComponent) == 0x0000C8, "Wrong size on UEnemyCheckDodgeJustComponent");
static_assert(offsetof(UEnemyCheckDodgeJustComponent, MDodgeRadius) == 0x0000C0, "Member 'UEnemyCheckDodgeJustComponent::MDodgeRadius' has a wrong offset!");
static_assert(offsetof(UEnemyCheckDodgeJustComponent, MDodgeRadiusRangeAttack) == 0x0000C4, "Member 'UEnemyCheckDodgeJustComponent::MDodgeRadiusRangeAttack' has a wrong offset!");

// Class BattlePrototype.EnemyDamageMoveComponentBase
// 0x0058 (0x0118 - 0x00C0)
class UEnemyDamageMoveComponentBase : public UActorComponent
{
public:
	class ARSCharacterBase*                       MOwnerEnemy;                                       // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222B[0x50];                                    // 0x00C8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetLength();
	void SetDamageMoveScale(float Scale);
	void Start_Native(const struct FVector& DamageDir, float Power, bool DeadMove, class AActor* Attacker);
	void Update_Native(float DeltaSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDamageMoveComponentBase">();
	}
	static class UEnemyDamageMoveComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDamageMoveComponentBase>();
	}
};
static_assert(alignof(UEnemyDamageMoveComponentBase) == 0x000008, "Wrong alignment on UEnemyDamageMoveComponentBase");
static_assert(sizeof(UEnemyDamageMoveComponentBase) == 0x000118, "Wrong size on UEnemyDamageMoveComponentBase");
static_assert(offsetof(UEnemyDamageMoveComponentBase, MOwnerEnemy) == 0x0000C0, "Member 'UEnemyDamageMoveComponentBase::MOwnerEnemy' has a wrong offset!");

// Class BattlePrototype.EnemyDeadMoveComponentBase
// 0x0050 (0x0110 - 0x00C0)
class UEnemyDeadMoveComponentBase : public UActorComponent
{
public:
	class ARSCharacterBase*                       MOwnerEnemy;                                       // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222D[0x48];                                    // 0x00C8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Start_Native(float BlendExp, float MoveLength, EEasingFunc Function, float MoveSeconds, const struct FVector& DamageDir);
	void Update_Native(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDeadMoveComponentBase">();
	}
	static class UEnemyDeadMoveComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDeadMoveComponentBase>();
	}
};
static_assert(alignof(UEnemyDeadMoveComponentBase) == 0x000008, "Wrong alignment on UEnemyDeadMoveComponentBase");
static_assert(sizeof(UEnemyDeadMoveComponentBase) == 0x000110, "Wrong size on UEnemyDeadMoveComponentBase");
static_assert(offsetof(UEnemyDeadMoveComponentBase, MOwnerEnemy) == 0x0000C0, "Member 'UEnemyDeadMoveComponentBase::MOwnerEnemy' has a wrong offset!");

// Class BattlePrototype.EnemyDropData
// 0x0018 (0x0040 - 0x0028)
class UEnemyDropData final : public UObject
{
public:
	class URSGameInstance*                        GameInst_;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RefEnemyDropTable;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RefBattleSimulateEnemyDropTable;                   // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetBattleSimulateEnemyDropData(struct FEnemyDropDataCell* EnemyDropData, class FName CharacterId);
	bool GetEnemyDropData(struct FEnemyDropDataCell* EnemyDropData, class FName ID);
	bool GetEnemyDropDataAllRound(struct FEnemyDropDataCell* EnemyDropData, class FName ID, class FName CharacterItemDropId);
	bool GetEnemyDropDataFromIndex(struct FEnemyDropDataCell* EnemyDropData, int32 Param_Index);
	class FName GetIdFromIndex(int32 Param_Index);
	bool LoadBattleSimulateEnemyDropDataTable(const class FString& BattleSimulateEnemyDropTablePath);
	bool LoadEnemyDropDataTable(const class FString& EnemyDropTablePath);
	void SetGameInst(class URSGameInstance* Inst);

	bool IsValidResource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDropData">();
	}
	static class UEnemyDropData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyDropData>();
	}
};
static_assert(alignof(UEnemyDropData) == 0x000008, "Wrong alignment on UEnemyDropData");
static_assert(sizeof(UEnemyDropData) == 0x000040, "Wrong size on UEnemyDropData");
static_assert(offsetof(UEnemyDropData, GameInst_) == 0x000028, "Member 'UEnemyDropData::GameInst_' has a wrong offset!");
static_assert(offsetof(UEnemyDropData, RefEnemyDropTable) == 0x000030, "Member 'UEnemyDropData::RefEnemyDropTable' has a wrong offset!");
static_assert(offsetof(UEnemyDropData, RefBattleSimulateEnemyDropTable) == 0x000038, "Member 'UEnemyDropData::RefBattleSimulateEnemyDropTable' has a wrong offset!");

// Class BattlePrototype.EnemyFixParamComponentBase
// 0x0068 (0x0128 - 0x00C0)
class UEnemyFixParamComponentBase : public UActorComponent
{
public:
	float                                         MChangeCrashHighRate;                              // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCrashDamageTime;                                  // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLaunchLMotionScale;                               // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MReactionSWeakCorrectionValue;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MReactionLWeakCorrectionValue;                     // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownWeakCorrectionValue;                          // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCrashWeakCorrectionValue;                         // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MRouteReactionSBonus;                              // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MRouteReactionLBonus;                              // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MRouteDownBonus;                                   // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCrashBonus;                                   // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MBCChancePlayRate;                                 // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDetectIcon_FindSeconds;                           // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSensingHeight;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MEnableMoveHeight;                                 // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAIActionHeight;                                   // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_RangeTop;                            // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_RangeMiddle;                         // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_HeightTop;                           // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_IntervalTop;                         // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_LimitTop;                            // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_IntervalMiddle;                      // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_LimitMiddle;                         // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_IntervalBottom;                      // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTickPriority_LimitBottom;                         // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2235[0x4];                                     // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyFixParamComponentBase">();
	}
	static class UEnemyFixParamComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyFixParamComponentBase>();
	}
};
static_assert(alignof(UEnemyFixParamComponentBase) == 0x000008, "Wrong alignment on UEnemyFixParamComponentBase");
static_assert(sizeof(UEnemyFixParamComponentBase) == 0x000128, "Wrong size on UEnemyFixParamComponentBase");
static_assert(offsetof(UEnemyFixParamComponentBase, MChangeCrashHighRate) == 0x0000C0, "Member 'UEnemyFixParamComponentBase::MChangeCrashHighRate' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MCrashDamageTime) == 0x0000C4, "Member 'UEnemyFixParamComponentBase::MCrashDamageTime' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MLaunchLMotionScale) == 0x0000C8, "Member 'UEnemyFixParamComponentBase::MLaunchLMotionScale' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MReactionSWeakCorrectionValue) == 0x0000CC, "Member 'UEnemyFixParamComponentBase::MReactionSWeakCorrectionValue' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MReactionLWeakCorrectionValue) == 0x0000D0, "Member 'UEnemyFixParamComponentBase::MReactionLWeakCorrectionValue' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MDownWeakCorrectionValue) == 0x0000D4, "Member 'UEnemyFixParamComponentBase::MDownWeakCorrectionValue' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MCrashWeakCorrectionValue) == 0x0000D8, "Member 'UEnemyFixParamComponentBase::MCrashWeakCorrectionValue' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MRouteReactionSBonus) == 0x0000DC, "Member 'UEnemyFixParamComponentBase::MRouteReactionSBonus' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MRouteReactionLBonus) == 0x0000E0, "Member 'UEnemyFixParamComponentBase::MRouteReactionLBonus' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MRouteDownBonus) == 0x0000E4, "Member 'UEnemyFixParamComponentBase::MRouteDownBonus' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MDownCrashBonus) == 0x0000E8, "Member 'UEnemyFixParamComponentBase::MDownCrashBonus' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MBCChancePlayRate) == 0x0000EC, "Member 'UEnemyFixParamComponentBase::MBCChancePlayRate' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MDetectIcon_FindSeconds) == 0x0000F0, "Member 'UEnemyFixParamComponentBase::MDetectIcon_FindSeconds' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MSensingHeight) == 0x0000F4, "Member 'UEnemyFixParamComponentBase::MSensingHeight' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MEnableMoveHeight) == 0x0000F8, "Member 'UEnemyFixParamComponentBase::MEnableMoveHeight' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MAIActionHeight) == 0x0000FC, "Member 'UEnemyFixParamComponentBase::MAIActionHeight' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_RangeTop) == 0x000100, "Member 'UEnemyFixParamComponentBase::MTickPriority_RangeTop' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_RangeMiddle) == 0x000104, "Member 'UEnemyFixParamComponentBase::MTickPriority_RangeMiddle' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_HeightTop) == 0x000108, "Member 'UEnemyFixParamComponentBase::MTickPriority_HeightTop' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_IntervalTop) == 0x00010C, "Member 'UEnemyFixParamComponentBase::MTickPriority_IntervalTop' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_LimitTop) == 0x000110, "Member 'UEnemyFixParamComponentBase::MTickPriority_LimitTop' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_IntervalMiddle) == 0x000114, "Member 'UEnemyFixParamComponentBase::MTickPriority_IntervalMiddle' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_LimitMiddle) == 0x000118, "Member 'UEnemyFixParamComponentBase::MTickPriority_LimitMiddle' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_IntervalBottom) == 0x00011C, "Member 'UEnemyFixParamComponentBase::MTickPriority_IntervalBottom' has a wrong offset!");
static_assert(offsetof(UEnemyFixParamComponentBase, MTickPriority_LimitBottom) == 0x000120, "Member 'UEnemyFixParamComponentBase::MTickPriority_LimitBottom' has a wrong offset!");

// Class BattlePrototype.EnemyGoalComponentBase
// 0x0040 (0x0100 - 0x00C0)
class UEnemyGoalComponentBase : public UActorComponent
{
public:
	class UEnemyCalcGoalComponent*                MCalcComponent;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MMoveGoalActor;                                    // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MMyEnemy;                                          // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARSCharacterBase*                       MTargetCharacter;                                  // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MTargetLocation;                                   // 0x00E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnemyGoalType                                MGoalType;                                         // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2236[0x3];                                     // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MHitWallRadius;                                    // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MHitWallHeight;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbDisableUpdateCharacter;                          // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2237[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector CorrectionHitCollision_Native(const struct FVector& SrcLocation, const struct FVector& DstLocation, float Radius);
	void EndPlay_Native();
	class AActor* GetGoalActor_Native();
	class ARSCharacterBase* GetTargetActor_Native();
	struct FVector GetTargetLocation_Native();
	void Initialize_Native();
	float InitializeGetCapsuleRadius_FromNative(class AActor* Owner);
	class UEnemyCalcGoalComponent* InitializeGetEnemyCalcComponent_FromNative(class AActor* Owner);
	class AActor* InitializeSpawnMoveGoalActor_FromNative(class AActor* Owner);
	void MainTick_Native(float DeltaSeconds);
	void ResetGoalIntervalTime_Native();
	void SetGoalIntervalTime_Native(float NewIntervalTime);
	void SetTargetActor_Native(class ARSCharacterBase* Character);
	void SetTargetLocation_Native(const struct FVector& Location);
	void UpdateTargetCharacter_Native(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyGoalComponentBase">();
	}
	static class UEnemyGoalComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyGoalComponentBase>();
	}
};
static_assert(alignof(UEnemyGoalComponentBase) == 0x000008, "Wrong alignment on UEnemyGoalComponentBase");
static_assert(sizeof(UEnemyGoalComponentBase) == 0x000100, "Wrong size on UEnemyGoalComponentBase");
static_assert(offsetof(UEnemyGoalComponentBase, MCalcComponent) == 0x0000C0, "Member 'UEnemyGoalComponentBase::MCalcComponent' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MMoveGoalActor) == 0x0000C8, "Member 'UEnemyGoalComponentBase::MMoveGoalActor' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MMyEnemy) == 0x0000D0, "Member 'UEnemyGoalComponentBase::MMyEnemy' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MTargetCharacter) == 0x0000D8, "Member 'UEnemyGoalComponentBase::MTargetCharacter' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MTargetLocation) == 0x0000E0, "Member 'UEnemyGoalComponentBase::MTargetLocation' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MGoalType) == 0x0000EC, "Member 'UEnemyGoalComponentBase::MGoalType' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MHitWallRadius) == 0x0000F0, "Member 'UEnemyGoalComponentBase::MHitWallRadius' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MHitWallHeight) == 0x0000F4, "Member 'UEnemyGoalComponentBase::MHitWallHeight' has a wrong offset!");
static_assert(offsetof(UEnemyGoalComponentBase, MbDisableUpdateCharacter) == 0x0000F8, "Member 'UEnemyGoalComponentBase::MbDisableUpdateCharacter' has a wrong offset!");

// Class BattlePrototype.EnemyGroundCheckComponent
// 0x00A8 (0x0178 - 0x00D0)
class UEnemyGroundCheckComponent final : public UEnemyAsyncTaskComponentBase
{
public:
	uint8                                         Pad_2239[0xA8];                                    // 0x00D0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginGroundCheck();
	void CalcRotateMesh(class USkeletalMeshComponent* MeshComp, float InterpSpeed, float AngleLimit, bool EndFit);
	void CalcRotateRot(float OffsetYaw, const struct FVector& ForwardVector, const struct FTransform& Transform, const struct FVector& baseUpVector, const struct FRotator& baseRot, float InterpSpeed, float AngleLimit, bool EndFit);
	void CalcRotateRotMesh(class USkeletalMeshComponent* MeshComp, float OffsetYaw, float InterpSpeed, float AngleLimit, bool EndFit);
	void CalcRotateRotToMesh(class USkeletalMeshComponent* MeshComp, float OffsetYaw, float InterpSpeed, float AngleLimit, bool EndFit);
	struct FRotator CalcRotation(const struct FRotator& baseRot, float InterpSpeed);
	struct FRotator CalcRotationToUpVector(float OffsetYaw, const struct FVector& ForwardVector, const struct FTransform& Transform, const struct FRotator& baseRot, float InterpSpeed, const struct FVector& UpVector);
	void EndGroundCheck();
	void InitSetting(bool MultipleChecks, float CheckHeight, float CapsuleRadius);
	void SetCheckPos(const struct FVector& Position);
	void SetIntervalTime(float NewIntervalTime);
	void SetRotateMesh(class USkeletalMeshComponent* MeshComp, float InterpSpeed, float AngleLimit, bool EndFit);
	void SetRotation(class USkeletalMeshComponent* MeshComp, float InterpSpeed);
	void SetRotationToUpVector(class USkeletalMeshComponent* MeshComp, float InterpSpeed, const struct FVector& UpVector);

	struct FRotator GetCalcRotator() const;
	struct FVector GetUpVector() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyGroundCheckComponent">();
	}
	static class UEnemyGroundCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyGroundCheckComponent>();
	}
};
static_assert(alignof(UEnemyGroundCheckComponent) == 0x000008, "Wrong alignment on UEnemyGroundCheckComponent");
static_assert(sizeof(UEnemyGroundCheckComponent) == 0x000178, "Wrong size on UEnemyGroundCheckComponent");

// Class BattlePrototype.EnemyMaterialAccessorComponent
// 0x0000 (0x0360 - 0x0360)
class UEnemyMaterialAccessorComponent : public UMaterialAccessorComponent
{
public:
	void SetEnemyMesh(class USkeletalMeshComponent* EnemyMesh);
	void SetupDefaultParameter(class ACharacter* Enemy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyMaterialAccessorComponent">();
	}
	static class UEnemyMaterialAccessorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyMaterialAccessorComponent>();
	}
};
static_assert(alignof(UEnemyMaterialAccessorComponent) == 0x000008, "Wrong alignment on UEnemyMaterialAccessorComponent");
static_assert(sizeof(UEnemyMaterialAccessorComponent) == 0x000360, "Wrong size on UEnemyMaterialAccessorComponent");

// Class BattlePrototype.EnemyScriptComponent
// 0x02A8 (0x0368 - 0x00C0)
class UEnemyScriptComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2242[0x94];                                    // 0x00C0(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTargetHeight;                                     // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MReceiveMontage;                                   // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIgnoreUpdateMoveMaxSpeed;                         // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsSpawnNow;                                      // 0x0161(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbUseDefaultSpawnSearchParam;                      // 0x0162(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsBattleEnemy;                                   // 0x0163(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsWait;                                          // 0x0164(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsEventWait;                                     // 0x0165(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsBT_ForceBreak;                                 // 0x0166(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsWander;                                        // 0x0167(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbEnableWander;                                    // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsBattleStart;                                   // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsBoss;                                          // 0x016A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbCollisionHitWall;                                // 0x016B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MESpawnState;                                      // 0x016C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2243[0x3];                                     // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MInitGroundPos;                                    // 0x0170(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFlyModeChangeIgnoreSeconds;                       // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 MFlyEnemyPawn;                                     // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnemyFormType                                MEFormType;                                        // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2244[0x3];                                     // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MOutRangeFadeValue;                                // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MOutRangeFadeValueInt;                             // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MWeaponOutRangeFadeValueInt;                       // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                MRecordTickEnabledComponentList;                   // 0x0198(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2245[0x24];                                    // 0x01A8(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTickActorSeconds;                                 // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2246[0x84];                                    // 0x01D0(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MUpdateFindPlayerNotRenderedTime;                  // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2247[0x50];                                    // 0x0258(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  MbDisableWeakAroundEffect;                         // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MGroupID;                                          // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MBattlefieldFenceAppearRate;                       // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<uint8, struct FAiParamEnemyInfo>         MAiTableDataMap;                                   // 0x02C0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2248[0x8];                                     // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          MbInvincible;                                      // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2249[0x3];                                     // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MWeakNo;                                           // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MArmorNo;                                          // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterDeadType                            MCharaDeadType;                                    // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsDeadStartNotify;                                // 0x0325(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224A[0x2];                                     // 0x0326(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDamagePartCollisionComponent*>  MWeakComponent;                                    // 0x0328(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIgnorePenetrateArmor;                            // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224B[0x2F];                                    // 0x0339(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBattleActor(bool& IsNotAddedBattleManager);
	void AddResetSecondRate();
	void BrakeArmor(const TArray<int32>& ArmorPartsNo);
	void CalcAccumulationByDefence(float RefWince, float RefKnockback, float RefDown, float RefCrashScale, float RefCrashCapCheckRate, float* OutWince, float* OutKnockback, float* OutDown, float* OutCrashScale, float* OutCrashCapCheckRate, class AActor* AttackActor, bool IsEnemyDamageknockBack);
	bool CalcAccumulationByDefence_CheckInvincible(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale);
	float CalcFinalDamageByDefence(float BaseDamage);
	void CalcNormalMaterialRate(float& L_Value, float& L_EmissivePowerValue, float& WeakDamageMaterialTime, float NormalWeakMaterialScale, float NormalWeakMaterialRateMin, float NormalWeakMaterialRateMax, float NormalWeakMaterialEmissivePowerMin, float NormalWeakMaterialEmissivePowerMax, class UCurveFloat* WeakMaterialCurve);
	class ARSCharacterBase* CalcTargetInfo(float* L_TargetDistance, float* L_TargetHeight, float* L_TargetAngle, bool InIsBattling, const struct FVector& InBaseLocation);
	void CalcTickNative(const struct FVector& InitPos, float EnableMoveArea, float EnableMoveHeight, bool* IsHitCheck, float* DistanceFromEnemyInitToPlayer, float* HeightFromEnemyInitToPlayer, float* DistanceFromEnemyToPlayer, float* HeightFromEnemyToPlayer);
	bool CalcTickSeconds_Native(float DeltaSec);
	void CalcTickSecondsNative(float* OutIntervalActorTime, bool* OutExecTick, bool* OutIncrementUpdateEnemy, float DeltaSec, EEnemyTickPriorityType InTickPriority, bool InCanUpdateEnemy);
	float CalcWeakAttackMaterialRate(float& L_Value, float& L_EmissivePowerValue, float& WeakDamageMaterialTime, float WeakDamageMaterialScale, float WeakMaterialPointRateMax, float WeakMaterialEmissivePowerMax, class UCurveFloat* WeakMaterialCurve, bool& ChangingWeakDamageMaterial, bool& IsWeakEffect, bool IsMultiWeak);
	void CheckIgnoreSuperArmor(const TArray<EHCSkillExtraType>& SkillExtraTypes);
	void CheckUniqueObjState_AddSkillExtraType(const struct FHCHitResult& HitResult, TArray<EHCSkillExtraType>& SkillExtraType);
	bool CheckUniqueObjState_CrashChanceCancel(bool IsBrainCrashAccess);
	void ClearSaveBodyEmissiveValue();
	bool EnableInvincible(bool Enable);
	void EnableLostAction(bool bEnable);
	void EnableTickComponentWasRecording();
	void FlyHeightAdjust(float DeltaSeconds, float FlyBaseZ, bool IsFlyState, bool Param_IsMoveAnim, bool FlyAdjust, float FlyLowerHeight, float FlyHighestHeight, float FlyAdjustSpeed, float AnyMoreDifferenceUpdate);
	void FlyPawnSetActorAllTickEnabledNative(bool Enabled, class AActor* FlyEnemyPawn, class UActorComponent* DefaultSceneRoot, class UActorComponent* FloatingPawnMovement, class AActor* AIController, class UActorComponent* PathFollowingComp);
	void ForceSettingOutRangeFade(bool IsDisp);
	struct FAiParamEnemyInfo GetAiTableDataNative(uint8 ActionEnum);
	bool GetAndUpdateContinuousSameDamageReaction();
	float GetCaptureAreaNative(uint8 SpawnState, float ChangeCaptureArea);
	struct FVector GetDamagePartDir(class UDamagePartCollisionComponent* DamagePartCollisionComponent);
	struct FVector GetEyePositionNative(class FName EyeSocketName);
	void GetHitStopParam(const struct FHCSkillCommonInfo& SkillInfo, bool* IgnoreTarget, EHCHitStopCauseType* CauseType);
	bool GetIsBattleMode_Native();
	bool GetIsDead_Native();
	float GetMoveAreaNative();
	float GetParamBasicAccumulation(EEnemyDamageType DamageType);
	float GetParamTableResistance(EEnemyDamageType DamageType);
	struct FVector GetRestoreBrainFieldLocation();
	float GetSaveBodyEmissiveValue(int32 Param_Index);
	float GetSearchAngleNative(uint8 SpawnState, float ChangeSearchAngle);
	float GetSearchRangeNative(uint8 SpawnState, float ChangeSearchRange);
	float GetSensingAreaNative(uint8 SpawnState, float ChangeSensingArea);
	float GetTargetAngle(const struct FVector& baseDist, const struct FVector& TargetDist);
	void GetTickIntervalSecondsParam(float* OutDefaultSeconds, float* OutMaxSeconds, EEnemyTickPriorityType InTickPriority);
	void GetUsedWeaponAllListNative(const TArray<class AEnemyWeaponBase*>& WeaponList, TArray<class AEnemyWeaponBase*>& Result);
	void InitCoolDownTimerBP(int32 Num);
	void Initialize(class UCharacterMovementComponent* CharaMoveComp, class UCharactersParameterComponent* CharactersParameterComp, class UEnemyLookCheckComponent* LookCheckComp, class UEnemyAnimControllerComponent* AnimController, class USkeletalMeshComponent* MeshComp, class UHateTargetComponent* HateTargetComp, class UEnemyFixParamComponentBase* FixParam, class USearchingComponent* SearchingComponent, class UChangeWeakStateComponentBase* ChangeWeakStateComponent, class UEnemyAroundEffectComponentBase* AroundEffectComponentBase, bool IsIgnoreAllowance, bool IsIgnoreRestrictAttackOther, bool UseDefaultSpawnSearchParam);
	bool IsArmor(class UPrimitiveComponent* PrimitiveComponent);
	bool IsBrainCrashDeadState();
	bool IsContinuityDamageMotion(EnemyAliveAnimKind AliveAnimKind);
	bool IsCrashChanceAndIgnore();
	bool IsDamageDownWait();
	bool IsDamageKnockBack();
	bool IsDamageSuperArmor();
	bool IsDeadAfterReaction(const TArray<EHCSkillExtraType>& SkillExtraTypes);
	bool IsDelayDeath_Native();
	bool IsDisableTargetBattleNative();
	bool IsDisableWeakAroundEffect(int32 Param_Index);
	bool IsDistanceAngleCheck(class AActor* Target, const struct FVector& TargetLocation, float Range, float Angle, const struct FRotator& Rot, bool NoHeight, const struct FVector& SelfLocation, bool SelfLocationOn);
	bool IsDownDamageToDead(bool bEnableConsiderFlag);
	bool IsDuringLaunchDamage(bool IsNewLaunch, bool DamageFloating, bool NewDamageFloating);
	bool IsEnableMoveRangeNative(float EnableMoveArea, float DistanceFromEnemyInitToPlayer, float EnableMoveHeight, float HeightFromEnemyInitToPlayer);
	bool IsEnableWeak();
	bool IsEnemyTickDisableCondition_Native(bool bDiscoverClosed);
	bool IsFloodedAnimRootMotionScale(bool Param_IsMoveAnim);
	bool IsFlyHeightAdjust();
	bool IsFlying();
	bool IsHitFromMainPlayer(class AActor* Attacker);
	bool IsHitPart(class UPrimitiveComponent* PrimitiveComponent, int32 No);
	bool IsHitWeak(class UPrimitiveComponent* PrimitiveComponent, const struct FHCSkillCommonInfo& SkillInfo);
	bool IsHitWeak_HitResult(const TArray<struct FHCHitResult>& HitResults);
	bool IsHitWeak_HitResultS(const struct FHCHitResult& HitResults);
	bool IsHpPercentDown(float Percent, bool* Error);
	bool IsInitLayout_Native();
	bool IsInvincible(bool* InvincibleAll, bool* InvincibleParts);
	bool IsNotDamageMotion(bool NotDamageMotion);
	bool IsNotTargetNative();
	bool IsPlayerOutOfBattleFieldFence();
	bool IsPsychic_Obj_MapGimmickDamage(EHCSkillAttackType SkillAttackType);
	bool IsPsychicObjectCombo(const struct FHCHitResult& HitResult);
	bool IsSkillExtraType(const TArray<EHCSkillExtraType>& SkillExtraTypes, EHCSkillExtraType ExtraType);
	bool IsSkillExtraType_CommonInfo(const struct FHCSkillCommonInfo& SkillInfo, EHCSkillExtraType ExtraType);
	bool IsStateStealthNative(EEnemyStealthState StealthState);
	bool IsStealthEnableNative();
	bool IsStealthSeeEnebleNative(bool* IsValid);
	bool IsStopWeakEmissive();
	bool IsSuspendFollowAttack();
	bool IsSuspendIKCondition();
	bool IsTrigger(const TArray<EHCSkillExtraType>& SkillExtraTypes);
	bool IsValidSaveBodyEmissiveValue(int32 Param_Index);
	void MainTick(float DeltaSeconds);
	void ModifyElectricAccumulationBySuperArmor(float& RefElectric, bool IsSuperArmor);
	void ModifyHitResultPrimitiveWeakPoint(class USkeletalMeshComponent* Mesh, struct FHCHitResult& HitResult, bool* ModifiedPrimitive);
	bool NotDamageMontage(bool IsRequestAddDamageMontage);
	void OnDamageActorHit_ChangeWeakState(class AActor* Attacker, const struct FHCHitResult& HitResult);
	void OnDamageActorHit_DamageInfo(const struct FHCHitResult& HitResult, class AActor** Attack, struct FVector* DamageLocation, struct FVector* DamageDir);
	void OnDamageActorHit_IsHitWeek(struct FHCHitResult& RefHitResult);
	void PostTick(float DeltaSeconds);
	bool PreAreaCheck(int32 AreaOutSequence);
	void PreTick(float DeltaSeconds);
	bool PreUpdateWeakAroundEffect(bool* IsExit);
	void PreUpdateWeakMaterialRate(const TArray<class FString>& SlotNameList, float& MaterialTime, float DeltaSec, bool* R_isMultiWeak);
	EEnemyTickPriorityType PrioritizeTickNative(EEnemyTickPriorityType InTickPriority, bool InIsBoss, bool InIsSimple, bool InIsBattling, float InRangeMiddle, float RangeTop, float HeightTop);
	void PutoutInformation(bool IsSideDamage, const struct FVector& HitDir, const struct FVector& HitPosition, bool* IsRight, bool* IsLeft, bool* IsBack);
	void RecordTickEnabledComponents(const TArray<class UActorComponent*>& ComponentList);
	struct FHCHitResult ReplaceHitResult(const struct FHCHitResult& HitResult);
	bool RequestAddDamageL(const struct FHCSkillCommonInfo& SkillInfo);
	bool RequestDownMotion(const struct FHCSkillCommonInfo& SkillInfo, bool IsDownSasFlagIgnoreDownTriggerFlag);
	bool RequestLaunchMotion(bool LaunchIgnorePriority, bool IsMotionReception, bool& IsOverWriteMotion);
	bool RequestLaunchMotion_Damage(bool LaunchIgnorePriority);
	void ResetAreaOutParam();
	void RestoreWeakEmissive_Native(const class FString& WeakSlotName);
	void SearchForceReactionType(const TArray<EHCSkillExtraType>& SkillExtraTypes, TArray<EHCSkillExtraType>& ForceExtraTypes);
	void SetAbsoluteDetectTarget(bool IsAbsolute, class FName ClaimantName);
	void SetAbsolutelyNoReactionBP(bool bEnable);
	void SetAreaOutDamageWaitTimer(float AddTime, float MaxTime);
	void SetConsiderDownDead(bool bEnable);
	void SetCoolDownTimerBP(int32 Param_Index, float Value);
	void SetDisableTargetBattleNative(bool _disable);
	void SetDisableWeakAroundEffect(int32 Param_Index, bool _isEnable);
	void SetEnableWeak(bool _isEnable);
	void SetFindPlayerType(EEnemyFindPlayerType FindType);
	void SetFindValue(float Value);
	void SetIgnoreCaptureRange(bool IsIgnore);
	void SetIgnoreCrashChance(bool bIgnoreCrashChance);
	void SetIgnorePenetrateArmor(bool bIgnore);
	void SetMainPlayerSearchBasicInfo(const struct FSearchBasicInfo& Info);
	void SetMainPlayerSearchTestInfo(const struct FSearchTestInfo& Info);
	void SetOutRangeFadeValue(float FadeValue);
	void SetQuickFind(bool bEnable);
	void SetRestoreBrainFieldLocation(const struct FVector& RestoreLocation);
	void SetSaveBodyEmissiveValue(int32 Param_Index, float Value);
	void SetSimulatePhisics(bool bEnable);
	void SetStopWeakEmissive(bool _isStop);
	void SetTargetSearchBasicInfo(const struct FSearchBasicInfo& Info);
	void SetTargetSearchTestInfo(const struct FSearchTestInfo& Info);
	void SetTickIntervalSecondsParam(float _TickPriorityIntervalMiddle, float _TickPriorityLimitMiddle, float _TickPriorityIntervalTop, float _TickPriorityLimitTop, float _TickPriorityIntervalBottom, float _TickPriorityLimitBottom);
	void SettingOutRangeFade(float OutRange);
	void SetWeakEmissiveOff_Native(const class FString& WeakSlotName);
	void SetWeakMaterialValue(float _emissivePowerMax, float _pointRateMax);
	void SetWeaponOutRangeFade(const TArray<class AEnemyWeaponBase*>& WeaponArray, float DeitherValue, float FadeRate);
	void StartDamageAnimFunc(bool ObjAttackDirect, const struct FVector& LDir, const struct FVector& ObjAttackDirection, const struct FVector& ObjLocation, const struct FVector& AttackLocation, const struct FVector& AttackDir, struct FRotator& RefRotator, struct FVector& RefHit, struct FVector& RefDir);
	float TimerDecrement(float Base, float Time);
	void TimerDecrementRef(float& Base, float Time, bool bLimitZero);
	void TimerIncrementRef(float& Base, float Time);
	struct FVector UpdateAdditionalDecal(float& DecalLerpSpeed, float DecalFollowSpeedDefault, float DecalFollowSpeedFast, const struct FVector& LastAdditionalDecalLocation, const struct FVector& Offset, class FName AttachSocketNameAdditionalDecal);
	bool UpdateAreaCheck(int32 AreaOutSequence, bool IsAreaOut, const struct FVector& InitPos, float DeltaSeconds, float OutRange, float OffsetRange, float AreaOutTimer);
	struct FVector UpdateCommonDecal(float& DecalLerpSpeed, float DecalFollowSpeedDefault, float DecalFollowSpeedFast, float DeletaSeconds, const struct FVector& LastDecalLocation, const struct FVector& Offset, class FName AttachSocketNameAdditionalDecal);
	void UpdateDetectPlayer(float SearchViewRange, float SearchViewAngle, float SearchSensingRange, float CaptureRange, float SearchHeight);
	void UpdateDetectTarget(const class ARSCharacterBase* Target, float SearchViewRange, float SearchViewAngle, float SearchSensingRange, float CaptureRange, float SearchHeight);
	bool UpdateEnableIK(bool EnableRequestIk);
	void UpdateEnemyUro();
	void UpdateFindPlayerValue(float DeltaSeconds);
	void UpdateFloodedAnimRootMotionScale(bool& IsFoodedFlg, bool IsMoveAnim);
	void UpdateFlyEnemyParam(float DeltaSeconds, const struct FVector& OldLocation);
	bool UpdateFlyMoveSlopeRestoreSeconds(bool FlyMoveSlopeRestore, float DeltaSeconds, float RotPow);
	bool UpdateGroundCheckTimer(struct FGameTimer& GameTimer, float GroundCheckTime);
	void UpdateGroundEffect(EEm0800EffectType& GroundEffectType);
	float UpdateHitDamageMaterialArmor(float Sec, float ArmorFlashScale, float& RefArmorFlashTime);
	void UpdateIsSameDamageReaction(bool IsMotionReception, EnemyDamageAnimKind DamageKind);
	void UpdateMainPlayerInfo();
	void UpdateOutRangeFade(float* DeitherValue, float TargetRange, float DeltaSeconds, float FadeRange, float InRange, float OutRange, float FadeTime, float FadeRate, bool ForceDisp);
	void UpdatePreviousElapsedTime(float ElapsedTime);
	void UpdateRootMotionChildPawn(const struct FVector& RootLocation, bool PossibleGroundCheck, float BeforeFlyPawnZ, struct FVector& ActorLocation, float& FlyPawnZ, float AnyMoreDifferenceUpdate);
	void UpdateRotator(bool ChildMove, float DeltaSeconds, float NoNavMoveInterpSpeed);
	void UpdateScoutingNative(float DeltaSeconds, uint8 SpawnState, float ChangeSearchRange, float ChangeSearchAngle, float ChangeSensingArea, float ChangeCaptureArea, class FName EyeSocketName);
	bool UpdateSetFlying(bool DamageFloating, bool IsFlyState);
	void UpdateTargetInfo(const class ARSCharacterBase* Target);
	void UpdateTraceChildPawn(const struct FVector& RootLocation, bool PossibleGroundCheck, float BeforeFlyPawnZ, struct FVector& ActorLocation, float& FlyPawnZ);
	void UpdateUro(class USkinnedMeshComponent* TargetMesh, EnemyAliveAnimKind AnimKind);
	void UpdateVisibilityBasedAnimTickOption(bool IsBattleenemy);
	bool UpdateWeakAroundEffect(TArray<bool>& StartWeakAroundEffect, bool BrainFieldSealWeakParticle, bool PreCheck);
	void UpdateWeakMaterialRate(const TArray<class FString>& SlotNameList, float RateValue, float EmissivePowerValue);
	bool WeakMaterialHitDamage(const TArray<struct FHCHitResult>& HitResults);

	struct FSearchBasicInfo CalcSearchInfo(const class ARSCharacterBase* Target) const;
	struct FSearchTestInfo CalcSearchTest(const class ARSCharacterBase* Target, const struct FSearchBasicInfo& basicInfo, float SearchViewRange, float SearchViewAngle, float SearchSensingRange, float CaptureRange, float SearchHeight) const;
	float GetCoolDownTimerBP(int32 Param_Index) const;
	EEnemyFindPlayerType GetFindPlayerType() const;
	float GetFindValue() const;
	const struct FSearchBasicInfo GetMainPlayerSearchBasicInfo() const;
	const struct FSearchTestInfo GetMainPlayerSearchTestInfo() const;
	EEnemyFindPlayerType GetOldFindPlayerType() const;
	const struct FSearchBasicInfo GetTargetSearchBasicInfo() const;
	const struct FSearchTestInfo GetTargetSearchTestInfo() const;
	bool IsAbsoluteDetectTarget() const;
	bool IsAbsolutelyNoReactionBP() const;
	bool IsChangeOldFindType() const;
	bool IsCheckAliveAnimKind(EnemyAliveAnimKind CheckKind) const;
	bool IsCheckDamageAnimKind(EnemyDamageAnimKind CheckKind) const;
	bool IsCheckDamageDownAnimKind(EnemyDamageDownAnimKind CheckKind) const;
	bool IsCheckEnemyKind(EnemyKind CheckKind) const;
	bool IsConsiderDownDead() const;
	bool IsDamage() const;
	bool IsEnableLostAction() const;
	bool IsEnemyDamageLaunchCPP() const;
	bool IsEnemyStopAnimKind(bool IsWait, bool IsEventWait) const;
	bool IsEvent() const;
	bool IsIgnoreCaptureRange() const;
	bool IsIgnorePenetrateArmor() const;
	bool IsMoveAnim(EnemyMoveAnimKind CheckKind) const;
	bool IsNeedResetStateMachine(float ElapsedTime, float ResetSecond) const;
	bool IsQuickFind() const;
	bool IsUpdateEnemyTickEnableNative(bool IsBoss, bool StopUpdateEnemyTickEnable, bool IsTickMove) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyScriptComponent">();
	}
	static class UEnemyScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyScriptComponent>();
	}
};
static_assert(alignof(UEnemyScriptComponent) == 0x000008, "Wrong alignment on UEnemyScriptComponent");
static_assert(sizeof(UEnemyScriptComponent) == 0x000368, "Wrong size on UEnemyScriptComponent");
static_assert(offsetof(UEnemyScriptComponent, MTargetHeight) == 0x000154, "Member 'UEnemyScriptComponent::MTargetHeight' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MReceiveMontage) == 0x000158, "Member 'UEnemyScriptComponent::MReceiveMontage' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MIgnoreUpdateMoveMaxSpeed) == 0x000160, "Member 'UEnemyScriptComponent::MIgnoreUpdateMoveMaxSpeed' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsSpawnNow) == 0x000161, "Member 'UEnemyScriptComponent::MbIsSpawnNow' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbUseDefaultSpawnSearchParam) == 0x000162, "Member 'UEnemyScriptComponent::MbUseDefaultSpawnSearchParam' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsBattleEnemy) == 0x000163, "Member 'UEnemyScriptComponent::MbIsBattleEnemy' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsWait) == 0x000164, "Member 'UEnemyScriptComponent::MbIsWait' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsEventWait) == 0x000165, "Member 'UEnemyScriptComponent::MbIsEventWait' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsBT_ForceBreak) == 0x000166, "Member 'UEnemyScriptComponent::MbIsBT_ForceBreak' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsWander) == 0x000167, "Member 'UEnemyScriptComponent::MbIsWander' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbEnableWander) == 0x000168, "Member 'UEnemyScriptComponent::MbEnableWander' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsBattleStart) == 0x000169, "Member 'UEnemyScriptComponent::MbIsBattleStart' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIsBoss) == 0x00016A, "Member 'UEnemyScriptComponent::MbIsBoss' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbCollisionHitWall) == 0x00016B, "Member 'UEnemyScriptComponent::MbCollisionHitWall' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MESpawnState) == 0x00016C, "Member 'UEnemyScriptComponent::MESpawnState' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MInitGroundPos) == 0x000170, "Member 'UEnemyScriptComponent::MInitGroundPos' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MFlyModeChangeIgnoreSeconds) == 0x00017C, "Member 'UEnemyScriptComponent::MFlyModeChangeIgnoreSeconds' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MFlyEnemyPawn) == 0x000180, "Member 'UEnemyScriptComponent::MFlyEnemyPawn' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MEFormType) == 0x000188, "Member 'UEnemyScriptComponent::MEFormType' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MOutRangeFadeValue) == 0x00018C, "Member 'UEnemyScriptComponent::MOutRangeFadeValue' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MOutRangeFadeValueInt) == 0x000190, "Member 'UEnemyScriptComponent::MOutRangeFadeValueInt' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MWeaponOutRangeFadeValueInt) == 0x000194, "Member 'UEnemyScriptComponent::MWeaponOutRangeFadeValueInt' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MRecordTickEnabledComponentList) == 0x000198, "Member 'UEnemyScriptComponent::MRecordTickEnabledComponentList' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MTickActorSeconds) == 0x0001CC, "Member 'UEnemyScriptComponent::MTickActorSeconds' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MUpdateFindPlayerNotRenderedTime) == 0x000254, "Member 'UEnemyScriptComponent::MUpdateFindPlayerNotRenderedTime' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbDisableWeakAroundEffect) == 0x0002A8, "Member 'UEnemyScriptComponent::MbDisableWeakAroundEffect' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MGroupID) == 0x0002B8, "Member 'UEnemyScriptComponent::MGroupID' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MBattlefieldFenceAppearRate) == 0x0002BC, "Member 'UEnemyScriptComponent::MBattlefieldFenceAppearRate' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MAiTableDataMap) == 0x0002C0, "Member 'UEnemyScriptComponent::MAiTableDataMap' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbInvincible) == 0x000318, "Member 'UEnemyScriptComponent::MbInvincible' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MWeakNo) == 0x00031C, "Member 'UEnemyScriptComponent::MWeakNo' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MArmorNo) == 0x000320, "Member 'UEnemyScriptComponent::MArmorNo' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MCharaDeadType) == 0x000324, "Member 'UEnemyScriptComponent::MCharaDeadType' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MIsDeadStartNotify) == 0x000325, "Member 'UEnemyScriptComponent::MIsDeadStartNotify' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MWeakComponent) == 0x000328, "Member 'UEnemyScriptComponent::MWeakComponent' has a wrong offset!");
static_assert(offsetof(UEnemyScriptComponent, MbIgnorePenetrateArmor) == 0x000338, "Member 'UEnemyScriptComponent::MbIgnorePenetrateArmor' has a wrong offset!");

// Class BattlePrototype.EnemyWeaponBase
// 0x0108 (0x0338 - 0x0230)
class AEnemyWeaponBase : public AActor
{
public:
	uint8                                         Pad_2291[0x38];                                    // 0x0230(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTotalDeltaSeconds;                                // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbEnableSweep;                                     // 0x026C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbNotLineCheck;                                    // 0x026D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2292[0x2];                                     // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MOldLocation;                                      // 0x0270(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MTargetLocation;                                   // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetDistance;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetDistanceCheck;                              // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnemyWeaponMoveKind                          MMoveKind;                                         // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2293[0x3];                                     // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MLifeTimer;                                        // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MInitLocation;                                     // 0x0298(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAdjustAngle;                                      // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MMaxCorrectAngleZ;                                 // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAdjustFloorAngle;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitAngleUp;                                     // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitAngleDown;                                   // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitAngleLR;                                     // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAdjustAngleDistanceMax;                           // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAdjustAngleDistanceMin;                           // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitDistanceAdjustAngleUp;                       // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MLimitDistanceAdjustAngleDown;                     // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbNewCorrectDir;                                   // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MWeaponActiveNative;                               // 0x02CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsCurveTargetMove;                                // 0x02CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2294[0x1];                                     // 0x02CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MCurveTargetMoveSpeed;                             // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2295[0x4];                                     // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MCurveTargetMove;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsHitCurveTargetMove;                             // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2296[0x3];                                     // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MCommonMoveDir;                                    // 0x02E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCommonMoveSpeed;                                  // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCommonMoveGravity;                                // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MProjectileGravityScale;                           // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsAnyHit;                                         // 0x02FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbNotUseAttackCollision;                           // 0x02FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbHitPhysics;                                      // 0x02FE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2297[0x1];                                     // 0x02FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MPhysicsHalfHeightScale;                           // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MPhysicsRadiusScale;                               // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MPhysicsCollisionHitLocation;                      // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbDisableHitPhysics;                               // 0x0314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2298[0x3];                                     // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MPhysicsRotationOffset;                            // 0x0318(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          MbDisableUpdatePhysics;                            // 0x0324(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbIsFloatObjectExist;                              // 0x0325(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MbDisablePhysicsCollision;                         // 0x0326(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2299[0x11];                                    // 0x0327(0x0011)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIgnoreJustDodgeNative();
	void AttackCollisionEndNative(bool IsVisible);
	struct FVector CorrectBulletDirectionNative(const struct FVector& FireLocation, const struct FVector& TargetLocation, const struct FVector& FireForwardVector, float AbsoluteAngleZ, float MaxAngleZ, float Speed);
	void EndCurveTargetMove_FromNative(float Sec);
	void EndHomingNative();
	void EndPhysicsCollisionNative();
	class UPrimitiveComponent* GetAttackCollisionPrimitiveNative(bool* IsSphere);
	class AActor* GetAttackOwnerTargetCharaNative();
	class UHitCheckComponent* GetHitCheckComponent_FromNative();
	struct FVector GetLocationTwoFrameAgo();
	float GetTargetDistanceNative();
	bool HitAfterCurveMoveTarget_FromNative(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitCurveMoveTargetNative(const struct FVector& HitLocation, const struct FVector& HitNormal);
	void HitPhysicsCollisionNative(const struct FVector& HitLocation);
	void InitCommonMoveNative(const struct FVector& InitPos, const struct FVector& MoveDir, float MoveSpeed, bool NoTargetMove);
	void InitCommonMovewithGravityNative(const struct FVector& InitPos, const struct FVector& MoveDir, float MoveSpeed, float Gravity, bool NoTargetMove);
	void InitializeNative(class UProjectileMovementComponent* ProjectileMovement, class UHitCheckComponent* HitCheck, class USphereComponent* AttackCollision, class UCapsuleComponent* AttackCollisionCapsule, class URSParticleSystemComponentBase* RSParticleSystem, class USkeletalMeshComponent* BulletMesh, class UCapsuleComponent* PhysicsCollision);
	void InitializePhysicsCollisionNative();
	void InitPreviousLocations(const struct FVector& InitLocation);
	bool IsHitFloorNative(const struct FVector& Normal);
	void IsHitLineCheckNative(const struct FVector& StartLocation, const struct FVector& EndLocation, bool* IsAnyHit, struct FHitResult* HitResult);
	bool ProjectileHitProcess_FromNative(bool IsHitPlayer, const struct FVector& HitLocation, const struct FVector& HitNormal);
	bool ProjectileHitProcessNative(bool IsHitPlayer, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void SetCurveTargetMoveInitNative();
	void SetTargetMoveEffectRotationNative();
	void SetWeaponActiveNative(bool Active);
	bool SetWeaponVisibilityNative(bool IsVisible);
	void StartPhysicsCollisionNative();
	void UpdateAddIgnoreJustDodgeNative(float DeltaTime, float& IgnoreJustDodgeTimer);
	void UpdateCommonMoveNative(float DeltaTime);
	void UpdateCurveTargetMoveNative(float DeltaTime);
	bool UpdateLifeTimeNative(bool InterceptReserve, float DeltaTime, float& LifeTime);
	void UpdatePhysicsCollisionNative(float DeltaTime);
	void UpdatePreviousLocations();
	void UpdateTargetNative(bool BreakLostTarget, class AActor* Target, class AActor* AttackOwner, float& LifeTime);

	bool IsWeaponActiveNative() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyWeaponBase">();
	}
	static class AEnemyWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyWeaponBase>();
	}
};
static_assert(alignof(AEnemyWeaponBase) == 0x000008, "Wrong alignment on AEnemyWeaponBase");
static_assert(sizeof(AEnemyWeaponBase) == 0x000338, "Wrong size on AEnemyWeaponBase");
static_assert(offsetof(AEnemyWeaponBase, MTotalDeltaSeconds) == 0x000268, "Member 'AEnemyWeaponBase::MTotalDeltaSeconds' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbEnableSweep) == 0x00026C, "Member 'AEnemyWeaponBase::MbEnableSweep' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbNotLineCheck) == 0x00026D, "Member 'AEnemyWeaponBase::MbNotLineCheck' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MOldLocation) == 0x000270, "Member 'AEnemyWeaponBase::MOldLocation' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MTargetLocation) == 0x00027C, "Member 'AEnemyWeaponBase::MTargetLocation' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MTargetDistance) == 0x000288, "Member 'AEnemyWeaponBase::MTargetDistance' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MTargetDistanceCheck) == 0x00028C, "Member 'AEnemyWeaponBase::MTargetDistanceCheck' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MMoveKind) == 0x000290, "Member 'AEnemyWeaponBase::MMoveKind' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLifeTimer) == 0x000294, "Member 'AEnemyWeaponBase::MLifeTimer' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MInitLocation) == 0x000298, "Member 'AEnemyWeaponBase::MInitLocation' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MAdjustAngle) == 0x0002A4, "Member 'AEnemyWeaponBase::MAdjustAngle' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MMaxCorrectAngleZ) == 0x0002A8, "Member 'AEnemyWeaponBase::MMaxCorrectAngleZ' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MAdjustFloorAngle) == 0x0002AC, "Member 'AEnemyWeaponBase::MAdjustFloorAngle' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitAngleUp) == 0x0002B0, "Member 'AEnemyWeaponBase::MLimitAngleUp' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitAngleDown) == 0x0002B4, "Member 'AEnemyWeaponBase::MLimitAngleDown' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitAngleLR) == 0x0002B8, "Member 'AEnemyWeaponBase::MLimitAngleLR' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MAdjustAngleDistanceMax) == 0x0002BC, "Member 'AEnemyWeaponBase::MAdjustAngleDistanceMax' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MAdjustAngleDistanceMin) == 0x0002C0, "Member 'AEnemyWeaponBase::MAdjustAngleDistanceMin' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitDistanceAdjustAngleUp) == 0x0002C4, "Member 'AEnemyWeaponBase::MLimitDistanceAdjustAngleUp' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MLimitDistanceAdjustAngleDown) == 0x0002C8, "Member 'AEnemyWeaponBase::MLimitDistanceAdjustAngleDown' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbNewCorrectDir) == 0x0002CC, "Member 'AEnemyWeaponBase::MbNewCorrectDir' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MWeaponActiveNative) == 0x0002CD, "Member 'AEnemyWeaponBase::MWeaponActiveNative' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MIsCurveTargetMove) == 0x0002CE, "Member 'AEnemyWeaponBase::MIsCurveTargetMove' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCurveTargetMoveSpeed) == 0x0002D0, "Member 'AEnemyWeaponBase::MCurveTargetMoveSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCurveTargetMove) == 0x0002D8, "Member 'AEnemyWeaponBase::MCurveTargetMove' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MIsHitCurveTargetMove) == 0x0002E0, "Member 'AEnemyWeaponBase::MIsHitCurveTargetMove' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCommonMoveDir) == 0x0002E4, "Member 'AEnemyWeaponBase::MCommonMoveDir' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCommonMoveSpeed) == 0x0002F0, "Member 'AEnemyWeaponBase::MCommonMoveSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MCommonMoveGravity) == 0x0002F4, "Member 'AEnemyWeaponBase::MCommonMoveGravity' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MProjectileGravityScale) == 0x0002F8, "Member 'AEnemyWeaponBase::MProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MIsAnyHit) == 0x0002FC, "Member 'AEnemyWeaponBase::MIsAnyHit' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbNotUseAttackCollision) == 0x0002FD, "Member 'AEnemyWeaponBase::MbNotUseAttackCollision' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbHitPhysics) == 0x0002FE, "Member 'AEnemyWeaponBase::MbHitPhysics' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MPhysicsHalfHeightScale) == 0x000300, "Member 'AEnemyWeaponBase::MPhysicsHalfHeightScale' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MPhysicsRadiusScale) == 0x000304, "Member 'AEnemyWeaponBase::MPhysicsRadiusScale' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MPhysicsCollisionHitLocation) == 0x000308, "Member 'AEnemyWeaponBase::MPhysicsCollisionHitLocation' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbDisableHitPhysics) == 0x000314, "Member 'AEnemyWeaponBase::MbDisableHitPhysics' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MPhysicsRotationOffset) == 0x000318, "Member 'AEnemyWeaponBase::MPhysicsRotationOffset' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbDisableUpdatePhysics) == 0x000324, "Member 'AEnemyWeaponBase::MbDisableUpdatePhysics' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbIsFloatObjectExist) == 0x000325, "Member 'AEnemyWeaponBase::MbIsFloatObjectExist' has a wrong offset!");
static_assert(offsetof(AEnemyWeaponBase, MbDisablePhysicsCollision) == 0x000326, "Member 'AEnemyWeaponBase::MbDisablePhysicsCollision' has a wrong offset!");

// Class BattlePrototype.EventAsset
// 0x0038 (0x0060 - 0x0028)
class UEventAsset final : public UObject
{
public:
	int32                                         ID;                                                // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A8[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        FilePath;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Asset;                                             // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A9[0x10];                                    // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishLoad();
	void Release();

	class UObject* GetAsset() const;
	bool IsLoaded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventAsset">();
	}
	static class UEventAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventAsset>();
	}
};
static_assert(alignof(UEventAsset) == 0x000008, "Wrong alignment on UEventAsset");
static_assert(sizeof(UEventAsset) == 0x000060, "Wrong size on UEventAsset");
static_assert(offsetof(UEventAsset, ID) == 0x000028, "Member 'UEventAsset::ID' has a wrong offset!");
static_assert(offsetof(UEventAsset, FilePath) == 0x000030, "Member 'UEventAsset::FilePath' has a wrong offset!");
static_assert(offsetof(UEventAsset, Asset) == 0x000048, "Member 'UEventAsset::Asset' has a wrong offset!");

// Class BattlePrototype.EventCableMeshOptionBase
// 0x0008 (0x0238 - 0x0230)
class AEventCableMeshOptionBase final : public AActor
{
public:
	class USkeletalMeshComponent*                 ParentSkeletalMesh_;                               // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool AttachToPlayerSocket();
	struct FTransform CalcSASCodeSocketWorldTransform(class FName SocketName);
	void CalcSASCodeSocketWorldTransforms(const TArray<class FName>& SocketNames, TMap<class FName, struct FTransform>* OutSocketLocations);
	bool GetParent();
	bool Initialize();
	bool SetAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCableMeshOptionBase">();
	}
	static class AEventCableMeshOptionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventCableMeshOptionBase>();
	}
};
static_assert(alignof(AEventCableMeshOptionBase) == 0x000008, "Wrong alignment on AEventCableMeshOptionBase");
static_assert(sizeof(AEventCableMeshOptionBase) == 0x000238, "Wrong size on AEventCableMeshOptionBase");
static_assert(offsetof(AEventCableMeshOptionBase, ParentSkeletalMesh_) == 0x000230, "Member 'AEventCableMeshOptionBase::ParentSkeletalMesh_' has a wrong offset!");

// Class BattlePrototype.EventCaptureActorBase
// 0x0008 (0x0238 - 0x0230)
class AEventCaptureActorBase : public ARSActorSystemBase
{
public:
	uint8                                         Pad_22AB[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePlMaterial(class ACharacter* ChildStaticPl, class UMaterialInterface* Source, EEventPlMaterialType Type);
	void CheckPlMaterialType(class ACharacter* ChildStaticPl, EEventPlMaterialType* Type, bool* Change);
	void SequenceAlpha(float Time, float Start, float End, class UCurveFloat* Curve, bool Loop);
	void SequenceMove(float Time, const struct FVector2D& Start, const struct FVector2D& End, class UCurveFloat* Curve, bool Loop);
	void SequenceScale(float Time, float Start, float End, class UCurveFloat* Curve, bool Loop);
	void SetEffectAlpha(float Alpha);
	void SetEffectMove(const struct FVector2D& Offset);
	void SetEffectScale(float Scale);
	void SetupAlphaSortNative(int32 Priority, const TArray<class UPrimitiveComponent*>& BackTargetPrimitiveComps, const TArray<class UPrimitiveComponent*>& TargetPrimitiveComps, const TArray<class UPrimitiveComponent*>& FrontTargetPrimitiveComps, class USkeletalMeshComponent* ChildMesh);
	void SetupAlphaSortNative2(class ACharacter* ChildStaticPl, class URSParticleSystemComponentBase* CurrentFrameParticle, class URSParticleSystemComponentBase* CurrentFrameTelepathyParticle, class URSParticleSystemComponentBase* CurrentFrameOverTelepathyParticle);
	void SetupHighResDOF(class URSSceneCaptureComponent2D* SceneCapture, float ScaleX);
	void StoreSequencerInGameTransform(class ULevelSequence* Sequnece, float SequencePosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCaptureActorBase">();
	}
	static class AEventCaptureActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventCaptureActorBase>();
	}
};
static_assert(alignof(AEventCaptureActorBase) == 0x000008, "Wrong alignment on AEventCaptureActorBase");
static_assert(sizeof(AEventCaptureActorBase) == 0x000238, "Wrong size on AEventCaptureActorBase");

// Class BattlePrototype.EventFacialCaptureRenderFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UEventFacialCaptureRenderFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FEventFacialCaptureRenderSettings AddEventFacialCaptureRenderSettings(const struct FEventFacialCaptureRenderSettings& BaseSetting, const struct FEventFacialCaptureRenderSettings& OverrideSetting);
	static void ConvertEventFacialCaptureRenderSettingsToMaterialParameters(const struct FEventFacialCaptureRenderSettings& Setting, TArray<class FName>* ParameterNames, TArray<float>* ParameterValues);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventFacialCaptureRenderFunctionLibrary">();
	}
	static class UEventFacialCaptureRenderFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventFacialCaptureRenderFunctionLibrary>();
	}
};
static_assert(alignof(UEventFacialCaptureRenderFunctionLibrary) == 0x000008, "Wrong alignment on UEventFacialCaptureRenderFunctionLibrary");
static_assert(sizeof(UEventFacialCaptureRenderFunctionLibrary) == 0x000028, "Wrong size on UEventFacialCaptureRenderFunctionLibrary");

// Class BattlePrototype.StaticCameraControlDataParam
// 0x0010 (0x0040 - 0x0030)
class UStaticCameraControlDataParam final : public UDataAsset
{
public:
	float                                         CameraInterpSpeed;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnableEaseInOut;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B7[0x3];                                     // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EaseInOutExp;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotate;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticCameraControlDataParam">();
	}
	static class UStaticCameraControlDataParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticCameraControlDataParam>();
	}
};
static_assert(alignof(UStaticCameraControlDataParam) == 0x000008, "Wrong alignment on UStaticCameraControlDataParam");
static_assert(sizeof(UStaticCameraControlDataParam) == 0x000040, "Wrong size on UStaticCameraControlDataParam");
static_assert(offsetof(UStaticCameraControlDataParam, CameraInterpSpeed) == 0x000030, "Member 'UStaticCameraControlDataParam::CameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(UStaticCameraControlDataParam, IsEnableEaseInOut) == 0x000034, "Member 'UStaticCameraControlDataParam::IsEnableEaseInOut' has a wrong offset!");
static_assert(offsetof(UStaticCameraControlDataParam, EaseInOutExp) == 0x000038, "Member 'UStaticCameraControlDataParam::EaseInOutExp' has a wrong offset!");
static_assert(offsetof(UStaticCameraControlDataParam, MaxRotate) == 0x00003C, "Member 'UStaticCameraControlDataParam::MaxRotate' has a wrong offset!");

// Class BattlePrototype.EventManager
// 0x0118 (0x0348 - 0x0230)
class AEventManager : public AActor
{
public:
	uint8                                         Pad_22B8[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressId;                                        // 0x0238(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B9[0x4];                                     // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StoreOwnerShipExternalActorTag;                    // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInvalidFade;                                     // 0x0248(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSkipEvent;                                       // 0x0249(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCutSceneCalledSkipEvent;                         // 0x024A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCurrentSkipFadeOut;                              // 0x024B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCurrentTalkEvent;                                // 0x024C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCurrentAjitoStayEvent;                           // 0x024D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForceBrainTalkMode;                              // 0x024E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BA[0x1];                                     // 0x024F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaticEventSoundPressure;                          // 0x0250(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BB[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharaAnimationAccessor*>      CharaAnimationAccessorArray;                       // 0x0258(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_StoreUnControlMgrFlags;                          // 0x0268(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDisableDynamicResInStaticCutScene;               // 0x026C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStoreSequencerInGameTransformEvent;              // 0x026D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BC[0x2];                                     // 0x026E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartCutSceneNative;                             // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndCutSceneNative;                               // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBeforeChangeProgressIDNative;                    // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAfterChangeProgressIDNative;                     // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSubMakeEventArray;                               // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class URSParticleSystemComponentBase*         StaticCutsceneBG;                                  // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARSLevelSequenceActor*                  Sequencer;                                         // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_messageTableName;                                // 0x02D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         MakeEventActorArray;                               // 0x02E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22BD[0x10];                                    // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrayOfMID>                    CapturePPMStatic;                                  // 0x0300(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FArrayOfMID>                    CapturePPMDynamic;                                 // 0x0310(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             M_PreLoadPPMList;                                  // 0x0320(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22BE[0x10];                                    // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_IsCutScenePhotoMode;                             // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22BF[0x7];                                     // 0x0341(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMakeEventActorArray(class AActor* Actor);
	void AddMessageVoiceRipSyncInfoList(class URSAtomComponentBase* AtomComp, class FName RipSyncBoardJointID);
	void AfterChangeProgressID();
	void BeforeChangeProgressID();
	void BindingActorNative(const class FName& ActorTag, const class FText& BindingName);
	void CallAfterChangeProgressIDNative();
	void CallBeforeChangeProgressIDNative();
	void CallEndCutSceneNative();
	void CallStartCutSceneNative();
	void ChangeSpeakerToVoice(class URSAtomComponentBase* Voice);
	void CheckAndSetTalkEventPlayerRipSync(const class FString& MessageLabel, class URSAtomComponentBase* PAtomComponent);
	bool CheckProgressID(int32 MinProgressID, int32 MaxProgressID);
	bool CheckScenarioFlagListC(const TArray<struct FShowDestinationFlgCheck>& FlgCheckList);
	void ClearFacialNormalCache();
	void ClearSequencerInCharacter();
	bool EnableEventUnControlMgrFlag(EEventUnControlManagerType UnControlMgrType);
	void EndTalkEvent();
	void EndWork();
	void EventAllManagerEnd(bool RestoreTickEnable, bool RestoreVisibility);
	void EventAllManagerStart(bool TickEnable, bool Visibility);
	void FinishSequencer();
	class UEventAssetPoolComponent* GetAssetPool();
	class AEventCaptureActorBase* GetCaptureActorBase(int32 Param_Index);
	int32 GetCurrentChapterID();
	TArray<class FString> GetLoadedAndLoadingMakeEventPathList();
	TArray<class AActor*> GetMakeEventActorArray();
	int32 GetMakeEventActorArrayNum();
	const struct FArrayOfMID GetOrLoadPPMDynamic(EEventPostProcessID EventPostProcessID, bool Load);
	const struct FArrayOfMID GetOrLoadPPMStatic(EEventPostProcessID EventPostProcessID, bool Load);
	bool HiddenEventName3DWidget();
	bool IsCurrentCreditEvent();
	bool IsCurrentEventOffSkipEndFade();
	bool IsCurrentZeroEP();
	bool IsCutSceneEventNative();
	bool IsCutScenePhotoMode();
	bool IsEmptySeqCaptureFuncList();
	bool IsEndDynamicCutscene();
	bool IsEndPostProcessSequencer();
	bool IsEndPresentSequencer();
	bool IsExistMakeEventActor();
	bool IsFadeAnimation();
	bool IsLoadingMakeEventAsset();
	bool IsNowSettingSeqCaptureBrainMes();
	bool IsPlayBeforeBoardAnimation();
	bool IsPlayingNewStaticBaseAnimation();
	bool IsPlayingNewStaticPhaseAnimation();
	bool IsTalkEvent();
	bool IsValidEventCommand();
	void IsValidEventCommandTypeFromNative(EEventTriggerCheckType EventCommandType, bool CheckBrainTalkEvent, bool* IsValid);
	bool IsValidTimerEventCommand(bool CheckBrainTalkEvent, float WithinTime);
	bool IsVisibleCharaNameForProgressID(EPlayerID PlayerId);
	bool IsWaitSequencerCaptureBG();
	void IsWorldMapShowDestinationForAreaName2Native(int32 LocationId, int32 AreaId, int32 PortalID, uint8 ShowType, class UDatabaseManager* DatabaseManager, bool IsProgressBondsEpisode, class UUserParamManager* UserParamManager, bool* IsShow, int32* VisibleWeight);
	bool OnBattleFieldEnd();
	void OnChangeSoundPressure(float SoundPressure);
	bool OnSkipInput();
	bool OnWaitInputFinishEvent();
	void PreLoadPPM(EEventPostProcessID EventPostProcessID, TArray<class UMaterialInterface*>* OutPPMList);
	void PreLoadPPMResident(const TArray<EEventPostProcessID>& EventPostProcessIDList);
	void ResetPrestreamTextures(const TArray<class UTexture2D*>& SetupTextures);
	bool RestoreVisibilityEventName3DWidget();
	void SetIsCutScenePhotoMode(bool EnablePhotoMode);
	void SetMessageTableName(const class FString& TableName);
	void SetPPMAsset(EEventPostProcessID EventPostProcessID, const TArray<TSoftObjectPtr<class UMaterialInterface>>& Assets, class FName ResetParamName, float ResetParamValue);
	void SetProgressIDNative(int32 Param_ProgressId);
	void SetSequenceEnd();
	bool SetStaticEventSkyPause(bool Pause);
	void SetupPrestreamTextures(class AActor* MakeEventActor, TArray<class UTexture2D*>* OutSetupTextures);
	class AActor* SpawnActorEvent(class UClass* ActorAsset, bool IsPersistant);
	class AActor* SpawnActorFromBP(class UBlueprint* ActorAsset, const class FText& BindingName);
	class AActor* SpawnActorNative(class UClass* ActorAsset, const class FText& BindingName);
	void StartDynamicCutscene(const class FString& CutsceneName);
	void StartDynamicCutsceneFromAsset(class ULevelSequence* Sequence, bool IsSeamlessInGame);
	void StartEventFinishWaitMode_AfterCounter();
	void StartTalkEvent();
	void SubMakeEventActorArray(class AActor* Actor);
	void UnloadPPMNative(EEventPostProcessID EventPostProcessID);
	void UpdateFacialNormalNative(TArray<class AActor*>* TargetSkelMeshActors, bool bUseCache);
	void WaitSequencerSetting(const class UObject* WorldContextObject_, const struct FLatentActionInfo& LatentInfo_);

	class FString GetMessageTableName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventManager">();
	}
	static class AEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventManager>();
	}
};
static_assert(alignof(AEventManager) == 0x000008, "Wrong alignment on AEventManager");
static_assert(sizeof(AEventManager) == 0x000348, "Wrong size on AEventManager");
static_assert(offsetof(AEventManager, ProgressId) == 0x000238, "Member 'AEventManager::ProgressId' has a wrong offset!");
static_assert(offsetof(AEventManager, StoreOwnerShipExternalActorTag) == 0x000240, "Member 'AEventManager::StoreOwnerShipExternalActorTag' has a wrong offset!");
static_assert(offsetof(AEventManager, IsInvalidFade) == 0x000248, "Member 'AEventManager::IsInvalidFade' has a wrong offset!");
static_assert(offsetof(AEventManager, IsSkipEvent) == 0x000249, "Member 'AEventManager::IsSkipEvent' has a wrong offset!");
static_assert(offsetof(AEventManager, IsCutSceneCalledSkipEvent) == 0x00024A, "Member 'AEventManager::IsCutSceneCalledSkipEvent' has a wrong offset!");
static_assert(offsetof(AEventManager, IsCurrentSkipFadeOut) == 0x00024B, "Member 'AEventManager::IsCurrentSkipFadeOut' has a wrong offset!");
static_assert(offsetof(AEventManager, IsCurrentTalkEvent) == 0x00024C, "Member 'AEventManager::IsCurrentTalkEvent' has a wrong offset!");
static_assert(offsetof(AEventManager, IsCurrentAjitoStayEvent) == 0x00024D, "Member 'AEventManager::IsCurrentAjitoStayEvent' has a wrong offset!");
static_assert(offsetof(AEventManager, IsForceBrainTalkMode) == 0x00024E, "Member 'AEventManager::IsForceBrainTalkMode' has a wrong offset!");
static_assert(offsetof(AEventManager, StaticEventSoundPressure) == 0x000250, "Member 'AEventManager::StaticEventSoundPressure' has a wrong offset!");
static_assert(offsetof(AEventManager, CharaAnimationAccessorArray) == 0x000258, "Member 'AEventManager::CharaAnimationAccessorArray' has a wrong offset!");
static_assert(offsetof(AEventManager, M_StoreUnControlMgrFlags) == 0x000268, "Member 'AEventManager::M_StoreUnControlMgrFlags' has a wrong offset!");
static_assert(offsetof(AEventManager, IsDisableDynamicResInStaticCutScene) == 0x00026C, "Member 'AEventManager::IsDisableDynamicResInStaticCutScene' has a wrong offset!");
static_assert(offsetof(AEventManager, IsStoreSequencerInGameTransformEvent) == 0x00026D, "Member 'AEventManager::IsStoreSequencerInGameTransformEvent' has a wrong offset!");
static_assert(offsetof(AEventManager, OnStartCutSceneNative) == 0x000270, "Member 'AEventManager::OnStartCutSceneNative' has a wrong offset!");
static_assert(offsetof(AEventManager, OnEndCutSceneNative) == 0x000280, "Member 'AEventManager::OnEndCutSceneNative' has a wrong offset!");
static_assert(offsetof(AEventManager, OnBeforeChangeProgressIDNative) == 0x000290, "Member 'AEventManager::OnBeforeChangeProgressIDNative' has a wrong offset!");
static_assert(offsetof(AEventManager, OnAfterChangeProgressIDNative) == 0x0002A0, "Member 'AEventManager::OnAfterChangeProgressIDNative' has a wrong offset!");
static_assert(offsetof(AEventManager, OnSubMakeEventArray) == 0x0002B0, "Member 'AEventManager::OnSubMakeEventArray' has a wrong offset!");
static_assert(offsetof(AEventManager, StaticCutsceneBG) == 0x0002C0, "Member 'AEventManager::StaticCutsceneBG' has a wrong offset!");
static_assert(offsetof(AEventManager, Sequencer) == 0x0002C8, "Member 'AEventManager::Sequencer' has a wrong offset!");
static_assert(offsetof(AEventManager, M_messageTableName) == 0x0002D0, "Member 'AEventManager::M_messageTableName' has a wrong offset!");
static_assert(offsetof(AEventManager, MakeEventActorArray) == 0x0002E0, "Member 'AEventManager::MakeEventActorArray' has a wrong offset!");
static_assert(offsetof(AEventManager, CapturePPMStatic) == 0x000300, "Member 'AEventManager::CapturePPMStatic' has a wrong offset!");
static_assert(offsetof(AEventManager, CapturePPMDynamic) == 0x000310, "Member 'AEventManager::CapturePPMDynamic' has a wrong offset!");
static_assert(offsetof(AEventManager, M_PreLoadPPMList) == 0x000320, "Member 'AEventManager::M_PreLoadPPMList' has a wrong offset!");
static_assert(offsetof(AEventManager, M_IsCutScenePhotoMode) == 0x000340, "Member 'AEventManager::M_IsCutScenePhotoMode' has a wrong offset!");

// Class BattlePrototype.EventManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IEventManagerInterface final : public IInterface
{
public:
	bool EventManagerEnd(bool RestoreEnableTick, bool RestoreVisibility);
	bool EventManagerStart(bool EnableTick, bool Visibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventManagerInterface">();
	}
	static class IEventManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventManagerInterface>();
	}
};
static_assert(alignof(IEventManagerInterface) == 0x000008, "Wrong alignment on IEventManagerInterface");
static_assert(sizeof(IEventManagerInterface) == 0x000028, "Wrong size on IEventManagerInterface");

// Class BattlePrototype.EventSkeletalMeshSoft
// 0x0000 (0x02B8 - 0x02B8)
class AEventSkeletalMeshSoft final : public ASkeletalMeshActor
{
public:
	void SetDummyMesh(class USkeletalMesh* InMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSkeletalMeshSoft">();
	}
	static class AEventSkeletalMeshSoft* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSkeletalMeshSoft>();
	}
};
static_assert(alignof(AEventSkeletalMeshSoft) == 0x000008, "Wrong alignment on AEventSkeletalMeshSoft");
static_assert(sizeof(AEventSkeletalMeshSoft) == 0x0002B8, "Wrong size on AEventSkeletalMeshSoft");

// Class BattlePrototype.EventSwitchPlayer
// 0x0010 (0x02C8 - 0x02B8)
class AEventSwitchPlayer : public ASkeletalMeshActor
{
public:
	TArray<TSoftObjectPtr<class USkeletalMesh>>   Meshes;                                            // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ResetMesh();
	void SetDummyMesh(class USkeletalMesh* InMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventSwitchPlayer">();
	}
	static class AEventSwitchPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventSwitchPlayer>();
	}
};
static_assert(alignof(AEventSwitchPlayer) == 0x000008, "Wrong alignment on AEventSwitchPlayer");
static_assert(sizeof(AEventSwitchPlayer) == 0x0002C8, "Wrong size on AEventSwitchPlayer");
static_assert(offsetof(AEventSwitchPlayer, Meshes) == 0x0002B8, "Member 'AEventSwitchPlayer::Meshes' has a wrong offset!");

// Class BattlePrototype.ExporterArg
// 0x0000 (0x0028 - 0x0028)
class UExporterArg final : public UObject
{
public:
	static bool IsStartAutoExporter();
	static void SetStartAutoExporter(bool IsStartAuto);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExporterArg">();
	}
	static class UExporterArg* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExporterArg>();
	}
};
static_assert(alignof(UExporterArg) == 0x000008, "Wrong alignment on UExporterArg");
static_assert(sizeof(UExporterArg) == 0x000028, "Wrong size on UExporterArg");

// Class BattlePrototype.ExtendableArrowComponent
// 0x0000 (0x0420 - 0x0420)
class UExtendableArrowComponent final : public UArrowComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtendableArrowComponent">();
	}
	static class UExtendableArrowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtendableArrowComponent>();
	}
};
static_assert(alignof(UExtendableArrowComponent) == 0x000010, "Wrong alignment on UExtendableArrowComponent");
static_assert(sizeof(UExtendableArrowComponent) == 0x000420, "Wrong size on UExtendableArrowComponent");

// Class BattlePrototype.FallFloorAnimInstance
// 0x0020 (0x0290 - 0x0270)
class UFallFloorAnimInstance final : public UAnimInstance
{
public:
	uint8                                         Pad_22D0[0x8];                                     // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsBreakAll;                                        // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRemovedAnyBlock;                                 // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D1[0x6];                                     // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        BoneScales;                                        // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FallFloorAnimInstance">();
	}
	static class UFallFloorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFallFloorAnimInstance>();
	}
};
static_assert(alignof(UFallFloorAnimInstance) == 0x000010, "Wrong alignment on UFallFloorAnimInstance");
static_assert(sizeof(UFallFloorAnimInstance) == 0x000290, "Wrong size on UFallFloorAnimInstance");
static_assert(offsetof(UFallFloorAnimInstance, IsBreakAll) == 0x000278, "Member 'UFallFloorAnimInstance::IsBreakAll' has a wrong offset!");
static_assert(offsetof(UFallFloorAnimInstance, IsRemovedAnyBlock) == 0x000279, "Member 'UFallFloorAnimInstance::IsRemovedAnyBlock' has a wrong offset!");
static_assert(offsetof(UFallFloorAnimInstance, BoneScales) == 0x000280, "Member 'UFallFloorAnimInstance::BoneScales' has a wrong offset!");

// Class BattlePrototype.FinishMoveActor
// 0x0090 (0x02C0 - 0x0230)
class AFinishMoveActor : public AActor
{
public:
	ERSPartyPlayerKind                            TargetPartyType_;                                  // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D2[0x7];                                     // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TargetSocketName_;                                 // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomParam_;                                        // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLocationInterpolation_;                      // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetFOVInterpolation_;                           // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLocationInterpolation_;                      // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           FinishMoveCamera_;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SequenceRate_;                                     // 0x0260(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D3[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       GameCameraComponet_;                               // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           GameCameraActor_;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookingForEnemy_;                                // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D4[0x3];                                     // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EnemyLocation_;                                    // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D5[0x24];                                    // 0x0288(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CameraRotatBeforeSwitch_;                          // 0x02AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D6[0x8];                                     // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishMoveBegin(bool IsChangeBeforeData, const struct FVector& beforePos, float beforeFOV);
	void FinishMoveUpdate();
	struct FVector GetBeforeLocation();
	void SetCameraTick(bool bActivate);
	void SlowSpeedEvent();
	void SlowSpeedEventEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinishMoveActor">();
	}
	static class AFinishMoveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFinishMoveActor>();
	}
};
static_assert(alignof(AFinishMoveActor) == 0x000008, "Wrong alignment on AFinishMoveActor");
static_assert(sizeof(AFinishMoveActor) == 0x0002C0, "Wrong size on AFinishMoveActor");
static_assert(offsetof(AFinishMoveActor, TargetPartyType_) == 0x000230, "Member 'AFinishMoveActor::TargetPartyType_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, TargetSocketName_) == 0x000238, "Member 'AFinishMoveActor::TargetSocketName_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, ZoomParam_) == 0x000248, "Member 'AFinishMoveActor::ZoomParam_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, TargetLocationInterpolation_) == 0x00024C, "Member 'AFinishMoveActor::TargetLocationInterpolation_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, TargetFOVInterpolation_) == 0x000250, "Member 'AFinishMoveActor::TargetFOVInterpolation_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, CameraLocationInterpolation_) == 0x000254, "Member 'AFinishMoveActor::CameraLocationInterpolation_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, FinishMoveCamera_) == 0x000258, "Member 'AFinishMoveActor::FinishMoveCamera_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, SequenceRate_) == 0x000260, "Member 'AFinishMoveActor::SequenceRate_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, GameCameraComponet_) == 0x000268, "Member 'AFinishMoveActor::GameCameraComponet_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, GameCameraActor_) == 0x000270, "Member 'AFinishMoveActor::GameCameraActor_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, IsLookingForEnemy_) == 0x000278, "Member 'AFinishMoveActor::IsLookingForEnemy_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, EnemyLocation_) == 0x00027C, "Member 'AFinishMoveActor::EnemyLocation_' has a wrong offset!");
static_assert(offsetof(AFinishMoveActor, CameraRotatBeforeSwitch_) == 0x0002AC, "Member 'AFinishMoveActor::CameraRotatBeforeSwitch_' has a wrong offset!");

// Class BattlePrototype.FixPoseActorComponent
// 0x0018 (0x00D8 - 0x00C0)
class UFixPoseActorComponent final : public UActorComponent
{
public:
	class UShapeComponent*                        TargetShape;                                       // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotate;                                            // 0x00C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsFixVelocity;                                     // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFixRot;                                          // 0x00D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D8[0x2];                                     // 0x00D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixPoseActorComponent">();
	}
	static class UFixPoseActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixPoseActorComponent>();
	}
};
static_assert(alignof(UFixPoseActorComponent) == 0x000008, "Wrong alignment on UFixPoseActorComponent");
static_assert(sizeof(UFixPoseActorComponent) == 0x0000D8, "Wrong size on UFixPoseActorComponent");
static_assert(offsetof(UFixPoseActorComponent, TargetShape) == 0x0000C0, "Member 'UFixPoseActorComponent::TargetShape' has a wrong offset!");
static_assert(offsetof(UFixPoseActorComponent, Rotate) == 0x0000C8, "Member 'UFixPoseActorComponent::Rotate' has a wrong offset!");
static_assert(offsetof(UFixPoseActorComponent, IsFixVelocity) == 0x0000D4, "Member 'UFixPoseActorComponent::IsFixVelocity' has a wrong offset!");
static_assert(offsetof(UFixPoseActorComponent, IsFixRot) == 0x0000D5, "Member 'UFixPoseActorComponent::IsFixRot' has a wrong offset!");

// Class BattlePrototype.FlagManagerUtility
// 0x0000 (0x0028 - 0x0028)
class UFlagManagerUtility final : public UBlueprintFunctionLibrary
{
public:
	static void CharaLibraryNewFlagOff(const class UObject* WorldContextObject, ELibraryFlagType Param_Index);
	static void CharaLibraryNewFlagOn(const class UObject* WorldContextObject, class FName ID);
	static bool CheckOperationRestrictionFlag(const class UObject* WorldContextObject, EOperationRestriction Type);
	static void EnemyLibraryNewFlagOn(const class UObject* WorldContextObject, class FName ID);
	static bool HelpGetFlagCheck(const class UObject* WorldContextObject, EHelpTutorial Type);
	static void HelpGetFlagOff(const class UObject* WorldContextObject, EHelpTutorial Type);
	static void HelpGetFlagOn(const class UObject* WorldContextObject, EHelpTutorial Type);
	static void InitializeFlagManager(const class UObject* WorldContextObject);
	static bool IsContentsOpened(const class UObject* WorldContextObject, EContentsOpening Type);
	static void OperationRestrictionFlagOff(const class UObject* WorldContextObject, EOperationRestriction Type);
	static void OperationRestrictionFlagOn(const class UObject* WorldContextObject, EOperationRestriction Type);
	static void SetAllContentsOpened(const class UObject* WorldContextObject);
	static void SetContentsClosed(const class UObject* WorldContextObject, EContentsOpening Type);
	static void SetContentsOpened(const class UObject* WorldContextObject, EContentsOpening Type);
	static bool SystemSaveDataCommonFlagCheck(const class UObject* WorldContextObject, ESystemSaveDataCommonFlag Type);
	static void SystemSaveDataCommonFlagOff(const class UObject* WorldContextObject, ESystemSaveDataCommonFlag Type);
	static void SystemSaveDataCommonFlagOn(const class UObject* WorldContextObject, ESystemSaveDataCommonFlag Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagManagerUtility">();
	}
	static class UFlagManagerUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagManagerUtility>();
	}
};
static_assert(alignof(UFlagManagerUtility) == 0x000008, "Wrong alignment on UFlagManagerUtility");
static_assert(sizeof(UFlagManagerUtility) == 0x000028, "Wrong size on UFlagManagerUtility");

// Class BattlePrototype.FlamesConditionComponent
// 0x0020 (0x0180 - 0x0160)
class UFlamesConditionComponent final : public UConditionComponent
{
public:
	float                                         _intervalDamagePercent;                            // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E6[0x4];                                     // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        _pFlameEffect;                                     // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _pAttackedComp;                                    // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _pEffectComp;                                      // 0x0178(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlamesConditionComponent">();
	}
	static class UFlamesConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlamesConditionComponent>();
	}
};
static_assert(alignof(UFlamesConditionComponent) == 0x000010, "Wrong alignment on UFlamesConditionComponent");
static_assert(sizeof(UFlamesConditionComponent) == 0x000180, "Wrong size on UFlamesConditionComponent");
static_assert(offsetof(UFlamesConditionComponent, _intervalDamagePercent) == 0x000160, "Member 'UFlamesConditionComponent::_intervalDamagePercent' has a wrong offset!");
static_assert(offsetof(UFlamesConditionComponent, _pFlameEffect) == 0x000168, "Member 'UFlamesConditionComponent::_pFlameEffect' has a wrong offset!");
static_assert(offsetof(UFlamesConditionComponent, _pAttackedComp) == 0x000170, "Member 'UFlamesConditionComponent::_pAttackedComp' has a wrong offset!");
static_assert(offsetof(UFlamesConditionComponent, _pEffectComp) == 0x000178, "Member 'UFlamesConditionComponent::_pEffectComp' has a wrong offset!");

// Class BattlePrototype.CharacterPhysicalSurfaceActionSoundResource
// 0x0018 (0x0040 - 0x0028)
class UCharacterPhysicalSurfaceActionSoundResource final : public UObject
{
public:
	TArray<struct FCharacterPhysicalSurfaceActionSoundResourceArrray> ResourceList;                                      // 0x0028(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E7[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USoundAtomCue* GetResource(EGamePhysicalSurfaceType SurfaceType, ECharacterPhysicalActionType ActionType);
	bool IsLoaded();
	bool LoadAsset(const struct FCharacterPhysicalSurfaceActionSound& ActionSound);
	bool UnloadAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPhysicalSurfaceActionSoundResource">();
	}
	static class UCharacterPhysicalSurfaceActionSoundResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPhysicalSurfaceActionSoundResource>();
	}
};
static_assert(alignof(UCharacterPhysicalSurfaceActionSoundResource) == 0x000008, "Wrong alignment on UCharacterPhysicalSurfaceActionSoundResource");
static_assert(sizeof(UCharacterPhysicalSurfaceActionSoundResource) == 0x000040, "Wrong size on UCharacterPhysicalSurfaceActionSoundResource");
static_assert(offsetof(UCharacterPhysicalSurfaceActionSoundResource, ResourceList) == 0x000028, "Member 'UCharacterPhysicalSurfaceActionSoundResource::ResourceList' has a wrong offset!");

// Class BattlePrototype.FootStepComponent
// 0x0028 (0x00E8 - 0x00C0)
class UFootStepComponent final : public UActorComponent
{
public:
	class FName                                   EffectTableId;                                     // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundTableId;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterPhysicalSurfaceActionEffectResource* EffectActionResCache;                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterPhysicalSurfaceActionSoundResource* SoundActionResCache;                               // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeginPlayLoadAsset;                              // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22EA[0x7];                                     // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayEffect(const EGamePhysicalSurfaceType PhysicsType, const ECharacterPhysicalActionType ActionType, const struct FTransform& Transform, class AActor* Creator);
	void PlayEffectByName(const EGamePhysicalSurfaceType PhysicsType, class FName ActionType, const struct FTransform& Transform, class AActor* Creator);
	void PlaySound(const EGamePhysicalSurfaceType PhysicsType, const ECharacterPhysicalActionType ActionType, const struct FVector& Location, const struct FRotator& Rotation, class AActor* Creator);
	void PlaySoundByName(const EGamePhysicalSurfaceType PhysicsType, class FName ActionType, const struct FVector& Location, const struct FRotator& Rotation, class AActor* Creator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootStepComponent">();
	}
	static class UFootStepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootStepComponent>();
	}
};
static_assert(alignof(UFootStepComponent) == 0x000008, "Wrong alignment on UFootStepComponent");
static_assert(sizeof(UFootStepComponent) == 0x0000E8, "Wrong size on UFootStepComponent");
static_assert(offsetof(UFootStepComponent, EffectTableId) == 0x0000C0, "Member 'UFootStepComponent::EffectTableId' has a wrong offset!");
static_assert(offsetof(UFootStepComponent, SoundTableId) == 0x0000C8, "Member 'UFootStepComponent::SoundTableId' has a wrong offset!");
static_assert(offsetof(UFootStepComponent, EffectActionResCache) == 0x0000D0, "Member 'UFootStepComponent::EffectActionResCache' has a wrong offset!");
static_assert(offsetof(UFootStepComponent, SoundActionResCache) == 0x0000D8, "Member 'UFootStepComponent::SoundActionResCache' has a wrong offset!");
static_assert(offsetof(UFootStepComponent, IsBeginPlayLoadAsset) == 0x0000E0, "Member 'UFootStepComponent::IsBeginPlayLoadAsset' has a wrong offset!");

// Class BattlePrototype.FreeCameraController
// 0x0028 (0x05C0 - 0x0598)
class AFreeCameraController final : public APlayerController
{
public:
	class APlayerController*                      OriginalControllerRef;                             // 0x0598(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayer*                                OriginalPlayer;                                    // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      OriginalViewTargetPCRef;                           // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OriginalViewTargetRef;                             // 0x05B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F4[0x8];                                     // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeCameraController">();
	}
	static class AFreeCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFreeCameraController>();
	}
};
static_assert(alignof(AFreeCameraController) == 0x000008, "Wrong alignment on AFreeCameraController");
static_assert(sizeof(AFreeCameraController) == 0x0005C0, "Wrong size on AFreeCameraController");
static_assert(offsetof(AFreeCameraController, OriginalControllerRef) == 0x000598, "Member 'AFreeCameraController::OriginalControllerRef' has a wrong offset!");
static_assert(offsetof(AFreeCameraController, OriginalPlayer) == 0x0005A0, "Member 'AFreeCameraController::OriginalPlayer' has a wrong offset!");
static_assert(offsetof(AFreeCameraController, OriginalViewTargetPCRef) == 0x0005A8, "Member 'AFreeCameraController::OriginalViewTargetPCRef' has a wrong offset!");
static_assert(offsetof(AFreeCameraController, OriginalViewTargetRef) == 0x0005B0, "Member 'AFreeCameraController::OriginalViewTargetRef' has a wrong offset!");

// Class BattlePrototype.GameDifficultyDefine
// 0x0010 (0x00D0 - 0x00C0)
class UGameDifficultyDefine final : public UActorComponent
{
public:
	float                                         M_addMag;                                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_difficultyMag;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_defaultMag;                                      // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22F5[0x4];                                     // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DifficultyMagCalc();
	float GetDefaultMag();
	float GetDifficultyMag();
	void SetAddMag(float _addMag);
	void SetDefaultMag(float _defaultMag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDifficultyDefine">();
	}
	static class UGameDifficultyDefine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDifficultyDefine>();
	}
};
static_assert(alignof(UGameDifficultyDefine) == 0x000008, "Wrong alignment on UGameDifficultyDefine");
static_assert(sizeof(UGameDifficultyDefine) == 0x0000D0, "Wrong size on UGameDifficultyDefine");
static_assert(offsetof(UGameDifficultyDefine, M_addMag) == 0x0000C0, "Member 'UGameDifficultyDefine::M_addMag' has a wrong offset!");
static_assert(offsetof(UGameDifficultyDefine, M_difficultyMag) == 0x0000C4, "Member 'UGameDifficultyDefine::M_difficultyMag' has a wrong offset!");
static_assert(offsetof(UGameDifficultyDefine, M_defaultMag) == 0x0000C8, "Member 'UGameDifficultyDefine::M_defaultMag' has a wrong offset!");

// Class BattlePrototype.GameSingleton
// 0x0160 (0x0188 - 0x0028)
class UGameSingleton final : public UObject
{
public:
	uint8                                         Pad_22F6[0x130];                                   // 0x0028(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              M_CurrentResolution;                               // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_MinimizeTimer;                                   // 0x0160(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_ResolutionChangeTimer;                           // 0x0164(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_DefaultResolutionTimer;                          // 0x0168(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsFocus;                                         // 0x016C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22F7[0x1B];                                    // 0x016D(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameSingleton* GetForBP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSingleton">();
	}
	static class UGameSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSingleton>();
	}
};
static_assert(alignof(UGameSingleton) == 0x000008, "Wrong alignment on UGameSingleton");
static_assert(sizeof(UGameSingleton) == 0x000188, "Wrong size on UGameSingleton");
static_assert(offsetof(UGameSingleton, M_CurrentResolution) == 0x000158, "Member 'UGameSingleton::M_CurrentResolution' has a wrong offset!");
static_assert(offsetof(UGameSingleton, M_MinimizeTimer) == 0x000160, "Member 'UGameSingleton::M_MinimizeTimer' has a wrong offset!");
static_assert(offsetof(UGameSingleton, M_ResolutionChangeTimer) == 0x000164, "Member 'UGameSingleton::M_ResolutionChangeTimer' has a wrong offset!");
static_assert(offsetof(UGameSingleton, M_DefaultResolutionTimer) == 0x000168, "Member 'UGameSingleton::M_DefaultResolutionTimer' has a wrong offset!");
static_assert(offsetof(UGameSingleton, M_IsFocus) == 0x00016C, "Member 'UGameSingleton::M_IsFocus' has a wrong offset!");

// Class BattlePrototype.GimmickActionBase
// 0x0080 (0x02B0 - 0x0230)
class AGimmickActionBase final : public AActor
{
public:
	uint8                                         Pad_22F8[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsActionEnableWhileOpen;                           // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActionEnableWhileClose;                          // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F9[0x6];                                     // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActionIcon*                            ActionIcon;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FA[0x8];                                     // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          ShowBoxComponent;                                  // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   ChildActionIcon;                                   // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMakeEventActor>            OnActionMakeEventActorClass;                       // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMakeEventActor*                        OnActionMakeEventActor;                            // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMakeEventActor>            OnExitMakeEventActorClass;                         // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMakeEventActor*                        OnExitMakeEventActor;                              // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22FB[0x4];                                     // 0x0288(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ActionIconWorldPositionOffset;                     // 0x028C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconType                               ActionIconType;                                    // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionIconSubQuestState                      ActionIconSubQuestState;                           // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOnAction;                                        // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOnExit;                                          // 0x029B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22FC[0x4];                                     // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGimmickObjectBase*                     TargetGimmickObject;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUseActionIcon;                                   // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22FD[0x7];                                     // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CallCloseEventToGimmickObject();
	bool CallOpenEventToGimmickObject();
	void DisableAction();
	bool IsActionEnable();
	void SetActionIconVisible(bool Visible);
	void UpdateActionEnable(EGimmickObjectStatus Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickActionBase">();
	}
	static class AGimmickActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickActionBase>();
	}
};
static_assert(alignof(AGimmickActionBase) == 0x000008, "Wrong alignment on AGimmickActionBase");
static_assert(sizeof(AGimmickActionBase) == 0x0002B0, "Wrong size on AGimmickActionBase");
static_assert(offsetof(AGimmickActionBase, IsActionEnableWhileOpen) == 0x000238, "Member 'AGimmickActionBase::IsActionEnableWhileOpen' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, IsActionEnableWhileClose) == 0x000239, "Member 'AGimmickActionBase::IsActionEnableWhileClose' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ActionIcon) == 0x000240, "Member 'AGimmickActionBase::ActionIcon' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ShowBoxComponent) == 0x000250, "Member 'AGimmickActionBase::ShowBoxComponent' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, EventBoxComponent) == 0x000258, "Member 'AGimmickActionBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ChildActionIcon) == 0x000260, "Member 'AGimmickActionBase::ChildActionIcon' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, OnActionMakeEventActorClass) == 0x000268, "Member 'AGimmickActionBase::OnActionMakeEventActorClass' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, OnActionMakeEventActor) == 0x000270, "Member 'AGimmickActionBase::OnActionMakeEventActor' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, OnExitMakeEventActorClass) == 0x000278, "Member 'AGimmickActionBase::OnExitMakeEventActorClass' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, OnExitMakeEventActor) == 0x000280, "Member 'AGimmickActionBase::OnExitMakeEventActor' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ActionIconWorldPositionOffset) == 0x00028C, "Member 'AGimmickActionBase::ActionIconWorldPositionOffset' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ActionIconType) == 0x000298, "Member 'AGimmickActionBase::ActionIconType' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, ActionIconSubQuestState) == 0x000299, "Member 'AGimmickActionBase::ActionIconSubQuestState' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, IsOnAction) == 0x00029A, "Member 'AGimmickActionBase::IsOnAction' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, IsOnExit) == 0x00029B, "Member 'AGimmickActionBase::IsOnExit' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, TargetGimmickObject) == 0x0002A0, "Member 'AGimmickActionBase::TargetGimmickObject' has a wrong offset!");
static_assert(offsetof(AGimmickActionBase, IsUseActionIcon) == 0x0002A8, "Member 'AGimmickActionBase::IsUseActionIcon' has a wrong offset!");

// Class BattlePrototype.GimmickBase
// 0x0008 (0x0238 - 0x0230)
class AGimmickBase final : public AActor
{
public:
	uint8                                         Pad_22FE[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBase">();
	}
	static class AGimmickBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBase>();
	}
};
static_assert(alignof(AGimmickBase) == 0x000008, "Wrong alignment on AGimmickBase");
static_assert(sizeof(AGimmickBase) == 0x000238, "Wrong size on AGimmickBase");

// Class BattlePrototype.ResourceManager
// 0x01D0 (0x0400 - 0x0230)
class AResourceManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_22FF[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FNpcMergeMeshResource>     NpcMergeMesh;                                      // 0x0238(0x0050)(NativeAccessSpecifierPrivate)
	class UDataTable*                             MipPrestreamMeshDataTable;                         // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      MipPrestreams;                                     // 0x0290(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     MipPrestreamTextures;                              // 0x02E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2300[0x10];                                    // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             NotExistsAssets;                                   // 0x0300(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class FName>                             ExistsAssets;                                      // 0x0350(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class UTexture2D*, int32>                ReleaseTransientTextures;                          // 0x03A0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2301[0x10];                                    // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNotExistsList(class FName Param_Name);
	void AddReleaseTransientTexture(class UTexture2D* Texture);
	bool CheckExists(class FName Param_Name);
	bool CheckNotExists(class FName Param_Name);
	void ClearNotExistsList();
	void DumpMipPrestream();
	void DumpNPCMergeMesh();
	int32 GetMipPrestreamLockMeshNum();
	int32 GetMipPrestreamMeshNum();
	int32 GetMipPrestreamTextureNum();
	void GetSnowCaptures(TArray<class ASnowCaptureBase*>* OutSnowCaptures);
	bool IsReadyAllMipPrestream();
	bool IsReadyMipPrestreamMesh(class FName MeshName);
	void LockMipPrestreamMesh(const TArray<class FName>& MeshNames);
	void ProtectedGetMipPrestreamPlayerMeshes(TArray<class USkeletalMesh*>* SkeletalMeshes, TArray<class UStaticMesh*>* StaticMeshes, EPlayerID PlayerId, bool bLoad);
	void ProtectedGetMipPrestreamPlayerSoftMeshes(TArray<TSoftObjectPtr<class USkeletalMesh>>* SkeletalMeshes, TArray<TSoftObjectPtr<class UObject>>* Attachment1Meshes, TArray<TSoftObjectPtr<class UMaterialInstance>>* Attachment1Materials, TArray<TSoftObjectPtr<class UObject>>* Attachment2Meshes, TArray<TSoftObjectPtr<class UMaterialInstance>>* Attachment2Materials, TArray<TSoftObjectPtr<class UObject>>* Attachment3Meshes, TArray<TSoftObjectPtr<class UMaterialInstance>>* Attachment3Materials, EPlayerID PlayerId);
	void ResetAllLockMipPrestreamMesh();
	void ResetAllMipPrestream();
	void ResetMipPrestreamEvent(const struct FResourceMipPrestreamEventTable& EventData, bool bForce);
	void ResetMipPrestreamMesh(class FName MeshName, bool bForce);
	void SetMipPrestreamEvent(const struct FResourceMipPrestreamEventTable& EventData, bool bLoad);
	void SetMipPrestreamMesh(class FName MeshName, bool bLoad, bool HighPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResourceManager">();
	}
	static class AResourceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AResourceManager>();
	}
};
static_assert(alignof(AResourceManager) == 0x000008, "Wrong alignment on AResourceManager");
static_assert(sizeof(AResourceManager) == 0x000400, "Wrong size on AResourceManager");
static_assert(offsetof(AResourceManager, NpcMergeMesh) == 0x000238, "Member 'AResourceManager::NpcMergeMesh' has a wrong offset!");
static_assert(offsetof(AResourceManager, MipPrestreamMeshDataTable) == 0x000288, "Member 'AResourceManager::MipPrestreamMeshDataTable' has a wrong offset!");
static_assert(offsetof(AResourceManager, MipPrestreams) == 0x000290, "Member 'AResourceManager::MipPrestreams' has a wrong offset!");
static_assert(offsetof(AResourceManager, MipPrestreamTextures) == 0x0002E0, "Member 'AResourceManager::MipPrestreamTextures' has a wrong offset!");
static_assert(offsetof(AResourceManager, NotExistsAssets) == 0x000300, "Member 'AResourceManager::NotExistsAssets' has a wrong offset!");
static_assert(offsetof(AResourceManager, ExistsAssets) == 0x000350, "Member 'AResourceManager::ExistsAssets' has a wrong offset!");
static_assert(offsetof(AResourceManager, ReleaseTransientTextures) == 0x0003A0, "Member 'AResourceManager::ReleaseTransientTextures' has a wrong offset!");

// Class BattlePrototype.GimmickObjectBase
// 0x0040 (0x0270 - 0x0230)
class AGimmickObjectBase final : public AActor
{
public:
	uint8                                         Pad_230B[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          Blocker;                                           // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenValue;                                         // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenThreshold;                                     // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenCloseTime;                                     // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230C[0x4];                                     // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnChangeStatus;                                    // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_230D[0x8];                                     // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EGimmickObjectStatus GetGimmickStatus();
	void SetBlockerCollision(bool Enable);
	void SetGimmickStatus(EGimmickObjectStatus Status);
	void UpdateOpenValueInClosing(float DelataSeconds);
	void UpdateOpenValueInOpening(float DelataSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickObjectBase">();
	}
	static class AGimmickObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickObjectBase>();
	}
};
static_assert(alignof(AGimmickObjectBase) == 0x000008, "Wrong alignment on AGimmickObjectBase");
static_assert(sizeof(AGimmickObjectBase) == 0x000270, "Wrong size on AGimmickObjectBase");
static_assert(offsetof(AGimmickObjectBase, Blocker) == 0x000240, "Member 'AGimmickObjectBase::Blocker' has a wrong offset!");
static_assert(offsetof(AGimmickObjectBase, OpenValue) == 0x000248, "Member 'AGimmickObjectBase::OpenValue' has a wrong offset!");
static_assert(offsetof(AGimmickObjectBase, OpenThreshold) == 0x00024C, "Member 'AGimmickObjectBase::OpenThreshold' has a wrong offset!");
static_assert(offsetof(AGimmickObjectBase, OpenCloseTime) == 0x000250, "Member 'AGimmickObjectBase::OpenCloseTime' has a wrong offset!");
static_assert(offsetof(AGimmickObjectBase, OnChangeStatus) == 0x000258, "Member 'AGimmickObjectBase::OnChangeStatus' has a wrong offset!");

// Class BattlePrototype.GimmickObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IGimmickObjectInterface final : public IInterface
{
public:
	void GimmickClose();
	void GimmickCloseForce();
	void GimmickOpen();
	void GimmickOpenForce();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickObjectInterface">();
	}
	static class IGimmickObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGimmickObjectInterface>();
	}
};
static_assert(alignof(IGimmickObjectInterface) == 0x000008, "Wrong alignment on IGimmickObjectInterface");
static_assert(sizeof(IGimmickObjectInterface) == 0x000028, "Wrong size on IGimmickObjectInterface");

// Class BattlePrototype.DebuggingItemPlayTimeGroup
// 0x0030 (0x0300 - 0x02D0)
class ADebuggingItemPlayTimeGroup final : public ADebuggingItemGroup
{
public:
	TWeakObjectPtr<class ADebuggingItemInt>       TimeInt;                                           // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       TimeHour;                                          // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       TimeMinute;                                        // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemInt>       TimeSecond;                                        // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemLabel>     Label;                                             // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserParamManager*                      ParamMan;                                          // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangePlayTime(const class ADebuggingItemInt* Item);
	void OnChangePlayTimePartial(const class ADebuggingItemInt* Item);
	void OnExecChangePlayTime(const class ADebuggingItemEvent* Item);
	void UpdateDebugParam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemPlayTimeGroup">();
	}
	static class ADebuggingItemPlayTimeGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemPlayTimeGroup>();
	}
};
static_assert(alignof(ADebuggingItemPlayTimeGroup) == 0x000008, "Wrong alignment on ADebuggingItemPlayTimeGroup");
static_assert(sizeof(ADebuggingItemPlayTimeGroup) == 0x000300, "Wrong size on ADebuggingItemPlayTimeGroup");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, TimeInt) == 0x0002D0, "Member 'ADebuggingItemPlayTimeGroup::TimeInt' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, TimeHour) == 0x0002D8, "Member 'ADebuggingItemPlayTimeGroup::TimeHour' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, TimeMinute) == 0x0002E0, "Member 'ADebuggingItemPlayTimeGroup::TimeMinute' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, TimeSecond) == 0x0002E8, "Member 'ADebuggingItemPlayTimeGroup::TimeSecond' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, Label) == 0x0002F0, "Member 'ADebuggingItemPlayTimeGroup::Label' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPlayTimeGroup, ParamMan) == 0x0002F8, "Member 'ADebuggingItemPlayTimeGroup::ParamMan' has a wrong offset!");

// Class BattlePrototype.HateTargetComponent
// 0x0120 (0x01E0 - 0x00C0)
class UHateTargetComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class ARSCharacterBase>        MTargetLock;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MTargetLockNo;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230E[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharactersParameterComponent*          MTargetLockParam;                                  // 0x00D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARSCharacterBase>        MTargetLockOnce;                                   // 0x00D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MTargetLockOnceNo;                                 // 0x00E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230F[0x4];                                     // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharactersParameterComponent*          MTargetLockOnceParam;                              // 0x00E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ARSCharacterBase>        MTargetLockConfusion;                              // 0x00F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharactersParameterComponent*          MOwnerParam;                                       // 0x00F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockTime;                                   // 0x0100(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockUpdateTime;                             // 0x0104(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetLockNearUpdateTime;                         // 0x0108(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsTargetLockNear;                                 // 0x010C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsTargetLockPlayer;                               // 0x010D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsTargetLockNPC;                                  // 0x010E(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MBeforeIsTargetLockPlayer;                         // 0x010F(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MBeforeIsTargetLockNPC;                            // 0x0110(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2310[0x3];                                     // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MRange;                                            // 0x0114(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHateTargetParam>               MHateTargetParam;                                  // 0x0118(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHateParam                             MHateParam;                                        // 0x0128(0x0080)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MBerserkOnHateRate;                                // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsLookTargetRange;                                // 0x01AC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2311[0x3];                                     // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTargetNearRange;                                  // 0x01B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetFarRange;                                   // 0x01B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsTargetRangeIgnoreHate;                          // 0x01B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2312[0x3];                                     // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ARSCharacterBase>        MDirectTargetLock;                                 // 0x01BC(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MIsLookTargetRangeHate;                            // 0x01C4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2313[0x3];                                     // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MTargetNearRangeHate;                              // 0x01C8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MTargetFarRangeHate;                               // 0x01CC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2314[0x10];                                    // 0x01D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddHate(class ARSCharacterBase* Target, float HateValue, float TechScale, bool bAccumulation, bool bDirect);
	void AddHateTargetParam(class ARSCharacterBase* Target, EHATETYPE Num, EHATETYPE Down);
	void ClearHateTargetParam();
	void EnableLockTargetNPC(bool bEnable);
	void EnableLockTargetPlayer(bool bEnable);
	void EnableLockTargetRange(bool bEnable, float RangeNear, float RangeFar, bool bIgnoreHate);
	void EnableLockTargetRangeHate(bool bEnable, float RangeNear, float RangeFar);
	float GetBasisHate(class ARSCharacterBase* MainPlayer, class ARSCharacterBase* Target);
	void HateTargetParamAddHate(class ARSCharacterBase* Target, EHATETYPE Num);
	void HateTargetParamSubHate(class ARSCharacterBase* Target, EHATETYPE Num);
	void ResetAllHate();
	void ResetDirectTargetLock();
	void ResetHate(class ARSCharacterBase* Target);
	void SetDirectTargetLock(class ARSCharacterBase* Target);
	void SetHateParam(const struct FHateParam& Param);
	void SetNoAttackCount(float NoAttackSecond);
	void SetTargetLock(class ARSCharacterBase* Target, int32 No);
	void SetTargetLockConfusion(class ARSCharacterBase* Target);
	void SubHate(class ARSCharacterBase* Target, float HateValue, float TechScale);
	void UpdateTarget(float DeltaTime);

	TArray<struct FHateTargetParam> GetHateTargetParam() const;
	class ARSCharacterBase* GetTargetLock() const;
	class ARSCharacterBase* GetTargetLockConfusion() const;
	bool IsLockTargetNPC() const;
	bool IsLockTargetPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HateTargetComponent">();
	}
	static class UHateTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHateTargetComponent>();
	}
};
static_assert(alignof(UHateTargetComponent) == 0x000008, "Wrong alignment on UHateTargetComponent");
static_assert(sizeof(UHateTargetComponent) == 0x0001E0, "Wrong size on UHateTargetComponent");
static_assert(offsetof(UHateTargetComponent, MTargetLock) == 0x0000C0, "Member 'UHateTargetComponent::MTargetLock' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockNo) == 0x0000C8, "Member 'UHateTargetComponent::MTargetLockNo' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockParam) == 0x0000D0, "Member 'UHateTargetComponent::MTargetLockParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockOnce) == 0x0000D8, "Member 'UHateTargetComponent::MTargetLockOnce' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockOnceNo) == 0x0000E0, "Member 'UHateTargetComponent::MTargetLockOnceNo' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockOnceParam) == 0x0000E8, "Member 'UHateTargetComponent::MTargetLockOnceParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockConfusion) == 0x0000F0, "Member 'UHateTargetComponent::MTargetLockConfusion' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MOwnerParam) == 0x0000F8, "Member 'UHateTargetComponent::MOwnerParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockTime) == 0x000100, "Member 'UHateTargetComponent::MTargetLockTime' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockUpdateTime) == 0x000104, "Member 'UHateTargetComponent::MTargetLockUpdateTime' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetLockNearUpdateTime) == 0x000108, "Member 'UHateTargetComponent::MTargetLockNearUpdateTime' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsTargetLockNear) == 0x00010C, "Member 'UHateTargetComponent::MIsTargetLockNear' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsTargetLockPlayer) == 0x00010D, "Member 'UHateTargetComponent::MIsTargetLockPlayer' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsTargetLockNPC) == 0x00010E, "Member 'UHateTargetComponent::MIsTargetLockNPC' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MBeforeIsTargetLockPlayer) == 0x00010F, "Member 'UHateTargetComponent::MBeforeIsTargetLockPlayer' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MBeforeIsTargetLockNPC) == 0x000110, "Member 'UHateTargetComponent::MBeforeIsTargetLockNPC' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MRange) == 0x000114, "Member 'UHateTargetComponent::MRange' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MHateTargetParam) == 0x000118, "Member 'UHateTargetComponent::MHateTargetParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MHateParam) == 0x000128, "Member 'UHateTargetComponent::MHateParam' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MBerserkOnHateRate) == 0x0001A8, "Member 'UHateTargetComponent::MBerserkOnHateRate' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsLookTargetRange) == 0x0001AC, "Member 'UHateTargetComponent::MIsLookTargetRange' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetNearRange) == 0x0001B0, "Member 'UHateTargetComponent::MTargetNearRange' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetFarRange) == 0x0001B4, "Member 'UHateTargetComponent::MTargetFarRange' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsTargetRangeIgnoreHate) == 0x0001B8, "Member 'UHateTargetComponent::MIsTargetRangeIgnoreHate' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MDirectTargetLock) == 0x0001BC, "Member 'UHateTargetComponent::MDirectTargetLock' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MIsLookTargetRangeHate) == 0x0001C4, "Member 'UHateTargetComponent::MIsLookTargetRangeHate' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetNearRangeHate) == 0x0001C8, "Member 'UHateTargetComponent::MTargetNearRangeHate' has a wrong offset!");
static_assert(offsetof(UHateTargetComponent, MTargetFarRangeHate) == 0x0001CC, "Member 'UHateTargetComponent::MTargetFarRangeHate' has a wrong offset!");

// Class BattlePrototype.HitBitComponent
// 0x0020 (0x00E0 - 0x00C0)
class UHitBitComponent final : public UActorComponent
{
public:
	bool                                          _bAutoInitHitBit;                                  // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231E[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EHitBitKind>                           _initHitBitKinds;                                  // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231F[0x8];                                     // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 CalcAttackHitBit(const struct FHCCollisionCommonInfo& CommonInfo);
	static int32 CalcDamageHitBit(class AActor* Actor);

	bool IsHit(int32 HitBit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitBitComponent">();
	}
	static class UHitBitComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitBitComponent>();
	}
};
static_assert(alignof(UHitBitComponent) == 0x000008, "Wrong alignment on UHitBitComponent");
static_assert(sizeof(UHitBitComponent) == 0x0000E0, "Wrong size on UHitBitComponent");
static_assert(offsetof(UHitBitComponent, _bAutoInitHitBit) == 0x0000C0, "Member 'UHitBitComponent::_bAutoInitHitBit' has a wrong offset!");
static_assert(offsetof(UHitBitComponent, _initHitBitKinds) == 0x0000C8, "Member 'UHitBitComponent::_initHitBitKinds' has a wrong offset!");

// Class BattlePrototype.RenderingSettingsFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URenderingSettingsFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FRenderingSettings MergeRenderingSettings(const struct FRenderingSettings& DefaultSettings, const struct FRenderingSettings& OverrideSettings);
	static void SetupRenderingSettingsSSRResolution(class UObject* WorldContextObject, const struct FRenderingSettings& Settings);
	static void SetupRenderingSettingsTranslucencyResolution(class UObject* WorldContextObject, const struct FRenderingSettings& Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderingSettingsFunctionLibrary">();
	}
	static class URenderingSettingsFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderingSettingsFunctionLibrary>();
	}
};
static_assert(alignof(URenderingSettingsFunctionLibrary) == 0x000008, "Wrong alignment on URenderingSettingsFunctionLibrary");
static_assert(sizeof(URenderingSettingsFunctionLibrary) == 0x000028, "Wrong size on URenderingSettingsFunctionLibrary");

// Class BattlePrototype.HitCheckComponent
// 0x0050 (0x0110 - 0x00C0)
class UHitCheckComponent final : public UActorComponent
{
public:
	bool                                          IsCallCheckHitInTick;                              // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2323[0x4F];                                    // 0x00C1(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHitCheckComponent* GetHitCheckComponentFromActor(class AActor* Actor);
	static bool IsNoDamagePartFromHCHitResult(const struct FHCHitResult& HitResult);

	void AddAttackCollision(class UObject* Notify, class AActor* Owner, class UAnimSequenceBase* Animation, const struct FHCAttackCollisionInfo& AttackCollisionInfo, class UMeshComponent* OtherMesh);
	void AddFixedCollisionByPrimitiveSkill(class AActor* Owner, class UPrimitiveComponent* Primitive, const struct FHCCollisionCommonInfo& CommonInfo, const struct FHCSkillCommonInfo& Skill, const struct FHCHitEffectInfo& EffectInfo, class AActor* AttackOwner, float LimitHeight);
	void AddFixedCollisionBySceneCompSkill(class AActor* Owner, class USceneComponent* SceneComp, float Radius, float HalfHeight, const struct FHCCollisionCommonInfo& CommonInfo, const struct FHCSkillCommonInfo& Skill, const struct FHCHitEffectInfo& EffectInfo, class AActor* AttackOwner, float LimitHeight);
	void AddIgnoreJustDodgeFixedCollisionData(class USceneComponent* SceneComp);
	bool CheckAttackCollisionSkillExtraType(int32 Param_Index, EHCSkillExtraType CheckExtraType);
	bool CheckFixedCollisionSkillExtraType(int32 Param_Index, EHCSkillExtraType CheckExtraType);
	void CheckHit(float DeltaSeconds);
	bool GetAttackCollisionCapsule(int32 Param_Index, struct FVector* OutStartLocation, struct FVector* OutEndLocation, float* OutRadius);
	bool GetFixedCollisionCapsule(int32 Param_Index, struct FVector* OutStartLocation, struct FVector* OutEndLocation, float* OutRadius);
	void InterceptFixedCollisionData(class USceneComponent* SceneComp, class AActor* NewAttackOwner);
	void InterceptFixedCollisionDataEnemy(class USceneComponent* SceneComp, class AActor* NewAttackOwner, const struct FHCCollisionCommonInfo& RefInterceptCommon, const struct FHCSkillCommonInfo& RefInterceptSkill);
	void RemoveAttackCollision(class UObject* Notify, class AActor* Owner, class UAnimSequenceBase* Animation);
	void RemoveFixedCollision(class USceneComponent* SceneComp);

	class AActor* GetAttackCollisionAttacker(int32 Param_Index) const;
	int32 GetAttackCollisionNum() const;
	class AActor* GetFixedCollisionAttacker(int32 Param_Index) const;
	class AActor* GetFixedCollisionAttackSource(int32 Param_Index) const;
	int32 GetFixedCollisionNum() const;
	bool IsFixedCollisionInterceptAble(int32 Param_Index) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitCheckComponent">();
	}
	static class UHitCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitCheckComponent>();
	}
};
static_assert(alignof(UHitCheckComponent) == 0x000008, "Wrong alignment on UHitCheckComponent");
static_assert(sizeof(UHitCheckComponent) == 0x000110, "Wrong size on UHitCheckComponent");
static_assert(offsetof(UHitCheckComponent, IsCallCheckHitInTick) == 0x0000C0, "Member 'UHitCheckComponent::IsCallCheckHitInTick' has a wrong offset!");

// Class BattlePrototype.PlayerShadeNoiseComponent
// 0x0040 (0x0100 - 0x00C0)
class UPlayerShadeNoiseComponent final : public UActorComponent
{
public:
	float                                         CharacterMovementSpeedUpScale;                     // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterRotationSpeedUpScale;                     // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeshComponent*                         TargetMesh;                                        // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       TargetMaterials;                                   // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_232F[0x20];                                    // 0x00E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FirstSetup(class UMeshComponent* InMesh, float InCharacterMovementSpeedUpScale, float InCharacterRotationSpeedUpScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerShadeNoiseComponent">();
	}
	static class UPlayerShadeNoiseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerShadeNoiseComponent>();
	}
};
static_assert(alignof(UPlayerShadeNoiseComponent) == 0x000008, "Wrong alignment on UPlayerShadeNoiseComponent");
static_assert(sizeof(UPlayerShadeNoiseComponent) == 0x000100, "Wrong size on UPlayerShadeNoiseComponent");
static_assert(offsetof(UPlayerShadeNoiseComponent, CharacterMovementSpeedUpScale) == 0x0000C0, "Member 'UPlayerShadeNoiseComponent::CharacterMovementSpeedUpScale' has a wrong offset!");
static_assert(offsetof(UPlayerShadeNoiseComponent, CharacterRotationSpeedUpScale) == 0x0000C4, "Member 'UPlayerShadeNoiseComponent::CharacterRotationSpeedUpScale' has a wrong offset!");
static_assert(offsetof(UPlayerShadeNoiseComponent, TargetMesh) == 0x0000C8, "Member 'UPlayerShadeNoiseComponent::TargetMesh' has a wrong offset!");
static_assert(offsetof(UPlayerShadeNoiseComponent, TargetMaterials) == 0x0000D0, "Member 'UPlayerShadeNoiseComponent::TargetMaterials' has a wrong offset!");

// Class BattlePrototype.HitCheckReceiverComponent
// 0x0030 (0x00F0 - 0x00C0)
class UHitCheckReceiverComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchHitAttack;                                 // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchHitDirectAttack;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchHitDamage;                                 // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UHitCheckReceiverComponent* GetHitCheckReceiverComponentFromActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitCheckReceiverComponent">();
	}
	static class UHitCheckReceiverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitCheckReceiverComponent>();
	}
};
static_assert(alignof(UHitCheckReceiverComponent) == 0x000008, "Wrong alignment on UHitCheckReceiverComponent");
static_assert(sizeof(UHitCheckReceiverComponent) == 0x0000F0, "Wrong size on UHitCheckReceiverComponent");
static_assert(offsetof(UHitCheckReceiverComponent, DispatchHitAttack) == 0x0000C0, "Member 'UHitCheckReceiverComponent::DispatchHitAttack' has a wrong offset!");
static_assert(offsetof(UHitCheckReceiverComponent, DispatchHitDirectAttack) == 0x0000D0, "Member 'UHitCheckReceiverComponent::DispatchHitDirectAttack' has a wrong offset!");
static_assert(offsetof(UHitCheckReceiverComponent, DispatchHitDamage) == 0x0000E0, "Member 'UHitCheckReceiverComponent::DispatchHitDamage' has a wrong offset!");

// Class BattlePrototype.HitCheckUtility
// 0x0000 (0x0028 - 0x0028)
class UHitCheckUtility final : public UBlueprintFunctionLibrary
{
public:
	static float GetCollisionValueFromCommonInfo(const struct FHCCollisionCommonInfo& CommonInfo, EHCCollisionValueKind Kind);
	static float GetConditionValueFromCommonInfo(const struct FHCCollisionCommonInfo& CommonInfo, EConditionKind Kind);
	static float GetElementValueFromCommonInfo(const struct FHCCollisionCommonInfo& CommonInfo, EHCElementKind Kind);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitCheckUtility">();
	}
	static class UHitCheckUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitCheckUtility>();
	}
};
static_assert(alignof(UHitCheckUtility) == 0x000008, "Wrong alignment on UHitCheckUtility");
static_assert(sizeof(UHitCheckUtility) == 0x000028, "Wrong size on UHitCheckUtility");

// Class BattlePrototype.PsychicObjectBasicC
// 0x00F0 (0x0320 - 0x0230)
class APsychicObjectBasicC : public AActor
{
public:
	uint8                                         Pad_2333[0x18];                                    // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	BattlePrototype::EPsychicObjectID             PsychicObjectIdC;                                  // 0x0248(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2334[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         PMeshComp;                                         // 0x0250(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         PShadowComp;                                       // 0x0258(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCpuAccessC;                                       // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckCpuAccessC;                                  // 0x0261(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRegisterableC;                                    // 0x0262(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActiveC;                                          // 0x0263(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInUseC;                                           // 0x0264(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTickC;                                            // 0x0265(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2335[0x2];                                     // 0x0266(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           TickReferenceList;                                 // 0x0268(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMaterialParameterEnableC;                         // 0x0278(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlEnableC;                           // 0x0279(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlAwakeC;                            // 0x027A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlCheckC;                            // 0x027B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlCheckRenderC;                      // 0x027C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2336[0x3];                                     // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimulateControlCheckRenderRadiusSqC;               // 0x0280(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlApplyC;                            // 0x0284(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControlBackUpC;                           // 0x0285(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRenderC;                                          // 0x0286(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSwingTypeC;                                       // 0x0287(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBrainFieldObjectC;                                // 0x0288(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUniqueObjectC;                                    // 0x0289(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTownSettingC;                                     // 0x028A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackupSettingC;                                   // 0x028B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackupSimualteC;                                  // 0x028C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchableC;                                      // 0x028D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipCheckRenderedC;                               // 0x028E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFixSearchPosC;                                    // 0x028F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SearchPosC;                                        // 0x0290(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchHeightC;                                    // 0x029C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2337[0x3];                                     // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchHeightMinC;                                  // 0x02A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchHeightMaxC;                                  // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchRadiusC;                                     // 0x02A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchSizeValueC;                                  // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SearchPointC;                                      // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bArrangeResetEnableC;                              // 0x02B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2338[0xB];                                     // 0x02B5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ArrangeActorTransformC;                            // 0x02C0(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             ArrangeMeshTransformC;                             // 0x02F0(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	bool CheckDestroyDistanceC(float ChkDist);
	bool CheckPsychicObjectStillInWorld(float KillZ);
	TArray<class UMeshComponent*> GetMaterialParameterMeshList();
	class UMeshComponent* GetPsychicObjectMesh();
	class UMeshComponent* GetPsychicObjectShadow();
	bool GetUniqueObjectAttackParameter(struct FHCCollisionCommonInfo* OutCommonInto, struct FHCSkillCommonInfo* OutSkillInfo);
	class UAnimMontage* GetUniqueObjectPlayerMontage(EPsychicObjectUniqueMontageIndex MontageIndex, bool bLeft, bool bMaleHero);
	void InitializeCpuAccess();
	bool IsAllowCpuAccess();
	void ResetArrangeTransformC();
	bool SetDistanceDestroyC();
	bool SetPsychicObjectFellOutOfWorld(const class UDamageType* PDmgType);
	void SetPsychicObjectIdC(BattlePrototype::EPsychicObjectID PsyObjId);
	void SetPsychicObjectMaterialParameterEnableC(bool Flag);
	void SetPsychicObjectRegisterableC(bool Flag);
	void SetPsychicObjectSearchable(bool Flag);
	void SetPsychicObjectSearchableC(bool Flag);
	void SetPsychicObjectSearchHeight(bool bFlag, float HeightMin, float HeightMix);
	void SetPsychicObjectSearchPos(bool bFlag, const struct FVector& Pos);
	void SetPsychicObjectSearchPosC(bool bFlag, const struct FVector& Pos);
	void SetPsychicObjectSearchSkipCheckRenderedC(bool Flag);
	void SetPsychicObjectSimulateControlAwakeC(bool Flag);
	void SetPsychicObjectSimulateControlCheckC(bool Flag);
	void SetPsychicObjectSimulateControlEnableC(bool Flag);
	void SetPsychicObjectSimulateControlRenderCheckParamC(bool Flag, float Radius);
	struct FHitResult SetSceneComponentLocationRotation(class USceneComponent* SceneComp, const struct FVector& Location, const struct FRotator& Rotation, bool bSweep);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectBasicC">();
	}
	static class APsychicObjectBasicC* GetDefaultObj()
	{
		return GetDefaultObjImpl<APsychicObjectBasicC>();
	}
};
static_assert(alignof(APsychicObjectBasicC) == 0x000010, "Wrong alignment on APsychicObjectBasicC");
static_assert(sizeof(APsychicObjectBasicC) == 0x000320, "Wrong size on APsychicObjectBasicC");
static_assert(offsetof(APsychicObjectBasicC, PsychicObjectIdC) == 0x000248, "Member 'APsychicObjectBasicC::PsychicObjectIdC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, PMeshComp) == 0x000250, "Member 'APsychicObjectBasicC::PMeshComp' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, PShadowComp) == 0x000258, "Member 'APsychicObjectBasicC::PShadowComp' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bCpuAccessC) == 0x000260, "Member 'APsychicObjectBasicC::bCpuAccessC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bCheckCpuAccessC) == 0x000261, "Member 'APsychicObjectBasicC::bCheckCpuAccessC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bRegisterableC) == 0x000262, "Member 'APsychicObjectBasicC::bRegisterableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bActiveC) == 0x000263, "Member 'APsychicObjectBasicC::bActiveC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bInUseC) == 0x000264, "Member 'APsychicObjectBasicC::bInUseC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bTickC) == 0x000265, "Member 'APsychicObjectBasicC::bTickC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, TickReferenceList) == 0x000268, "Member 'APsychicObjectBasicC::TickReferenceList' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bMaterialParameterEnableC) == 0x000278, "Member 'APsychicObjectBasicC::bMaterialParameterEnableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlEnableC) == 0x000279, "Member 'APsychicObjectBasicC::bSimulateControlEnableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlAwakeC) == 0x00027A, "Member 'APsychicObjectBasicC::bSimulateControlAwakeC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlCheckC) == 0x00027B, "Member 'APsychicObjectBasicC::bSimulateControlCheckC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlCheckRenderC) == 0x00027C, "Member 'APsychicObjectBasicC::bSimulateControlCheckRenderC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SimulateControlCheckRenderRadiusSqC) == 0x000280, "Member 'APsychicObjectBasicC::SimulateControlCheckRenderRadiusSqC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlApplyC) == 0x000284, "Member 'APsychicObjectBasicC::bSimulateControlApplyC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSimulateControlBackUpC) == 0x000285, "Member 'APsychicObjectBasicC::bSimulateControlBackUpC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bRenderC) == 0x000286, "Member 'APsychicObjectBasicC::bRenderC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSwingTypeC) == 0x000287, "Member 'APsychicObjectBasicC::bSwingTypeC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bBrainFieldObjectC) == 0x000288, "Member 'APsychicObjectBasicC::bBrainFieldObjectC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bUniqueObjectC) == 0x000289, "Member 'APsychicObjectBasicC::bUniqueObjectC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bTownSettingC) == 0x00028A, "Member 'APsychicObjectBasicC::bTownSettingC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bBackupSettingC) == 0x00028B, "Member 'APsychicObjectBasicC::bBackupSettingC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bBackupSimualteC) == 0x00028C, "Member 'APsychicObjectBasicC::bBackupSimualteC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSearchableC) == 0x00028D, "Member 'APsychicObjectBasicC::bSearchableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSkipCheckRenderedC) == 0x00028E, "Member 'APsychicObjectBasicC::bSkipCheckRenderedC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bFixSearchPosC) == 0x00028F, "Member 'APsychicObjectBasicC::bFixSearchPosC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchPosC) == 0x000290, "Member 'APsychicObjectBasicC::SearchPosC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bSearchHeightC) == 0x00029C, "Member 'APsychicObjectBasicC::bSearchHeightC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchHeightMinC) == 0x0002A0, "Member 'APsychicObjectBasicC::SearchHeightMinC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchHeightMaxC) == 0x0002A4, "Member 'APsychicObjectBasicC::SearchHeightMaxC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchRadiusC) == 0x0002A8, "Member 'APsychicObjectBasicC::SearchRadiusC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchSizeValueC) == 0x0002AC, "Member 'APsychicObjectBasicC::SearchSizeValueC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, SearchPointC) == 0x0002B0, "Member 'APsychicObjectBasicC::SearchPointC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, bArrangeResetEnableC) == 0x0002B4, "Member 'APsychicObjectBasicC::bArrangeResetEnableC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, ArrangeActorTransformC) == 0x0002C0, "Member 'APsychicObjectBasicC::ArrangeActorTransformC' has a wrong offset!");
static_assert(offsetof(APsychicObjectBasicC, ArrangeMeshTransformC) == 0x0002F0, "Member 'APsychicObjectBasicC::ArrangeMeshTransformC' has a wrong offset!");

// Class BattlePrototype.HitEffectInterface
// 0x0000 (0x0028 - 0x0028)
class IHitEffectInterface final : public IInterface
{
public:
	EFHitEffectPriority GetHitEffectPriorityInterface();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitEffectInterface">();
	}
	static class IHitEffectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHitEffectInterface>();
	}
};
static_assert(alignof(IHitEffectInterface) == 0x000008, "Wrong alignment on IHitEffectInterface");
static_assert(sizeof(IHitEffectInterface) == 0x000028, "Wrong size on IHitEffectInterface");

// Class BattlePrototype.HitStopComponent
// 0x0048 (0x0108 - 0x00C0)
class UHitStopComponent final : public UActorComponent
{
public:
	float                                         HitStopTime_Short;                                 // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTime_Middle;                                // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTime_Large;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTime_XLarge;                                // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTime_XXLarge;                               // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_Short;                                 // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_Middle;                                // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_Large;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_XLarge;                                // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRate_XXLarge;                               // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopDelay;                                      // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2344[0x1C];                                    // 0x00EC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHitStopComponent* GetHitStopComponent(class AActor* Actor);

	void EndHitStop();
	void SetActiveHitStop(bool ActiveHitStop);
	void StartHitStop(float HitStopSec, float ActionSpeedRate);
	void StartHitStopByType(EHCRestictedHitStopType HitStopType, bool bCritical);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitStopComponent">();
	}
	static class UHitStopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitStopComponent>();
	}
};
static_assert(alignof(UHitStopComponent) == 0x000008, "Wrong alignment on UHitStopComponent");
static_assert(sizeof(UHitStopComponent) == 0x000108, "Wrong size on UHitStopComponent");
static_assert(offsetof(UHitStopComponent, HitStopTime_Short) == 0x0000C0, "Member 'UHitStopComponent::HitStopTime_Short' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopTime_Middle) == 0x0000C4, "Member 'UHitStopComponent::HitStopTime_Middle' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopTime_Large) == 0x0000C8, "Member 'UHitStopComponent::HitStopTime_Large' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopTime_XLarge) == 0x0000CC, "Member 'UHitStopComponent::HitStopTime_XLarge' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopTime_XXLarge) == 0x0000D0, "Member 'UHitStopComponent::HitStopTime_XXLarge' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_Short) == 0x0000D4, "Member 'UHitStopComponent::HitStopRate_Short' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_Middle) == 0x0000D8, "Member 'UHitStopComponent::HitStopRate_Middle' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_Large) == 0x0000DC, "Member 'UHitStopComponent::HitStopRate_Large' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_XLarge) == 0x0000E0, "Member 'UHitStopComponent::HitStopRate_XLarge' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopRate_XXLarge) == 0x0000E4, "Member 'UHitStopComponent::HitStopRate_XXLarge' has a wrong offset!");
static_assert(offsetof(UHitStopComponent, HitStopDelay) == 0x0000E8, "Member 'UHitStopComponent::HitStopDelay' has a wrong offset!");

// Class BattlePrototype.PostProcessOverraySystem
// 0x0000 (0x0230 - 0x0230)
class APostProcessOverraySystem : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessOverraySystem">();
	}
	static class APostProcessOverraySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<APostProcessOverraySystem>();
	}
};
static_assert(alignof(APostProcessOverraySystem) == 0x000008, "Wrong alignment on APostProcessOverraySystem");
static_assert(sizeof(APostProcessOverraySystem) == 0x000230, "Wrong size on APostProcessOverraySystem");

// Class BattlePrototype.HoveringComponent
// 0x0038 (0x00F8 - 0x00C0)
class UHoveringComponent final : public UActorComponent
{
public:
	float                                         _minFlightAltitude;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxFlightAltitude;                                // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoveringCharacter;                              // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2345[0x7];                                     // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _disableClaimantNames;                             // 0x00D0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _claimantName;                                     // 0x00E0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2346[0x10];                                    // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UHoveringComponent* GetHoveringComponent(class AActor* Actor);

	void ClearDisableHovering(const class FName& ClaimantName);
	void SetDisableHovering(const class FName& ClaimantName);

	float GetFlightAltitudeAverage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoveringComponent">();
	}
	static class UHoveringComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoveringComponent>();
	}
};
static_assert(alignof(UHoveringComponent) == 0x000008, "Wrong alignment on UHoveringComponent");
static_assert(sizeof(UHoveringComponent) == 0x0000F8, "Wrong size on UHoveringComponent");
static_assert(offsetof(UHoveringComponent, _minFlightAltitude) == 0x0000C0, "Member 'UHoveringComponent::_minFlightAltitude' has a wrong offset!");
static_assert(offsetof(UHoveringComponent, _maxFlightAltitude) == 0x0000C4, "Member 'UHoveringComponent::_maxFlightAltitude' has a wrong offset!");
static_assert(offsetof(UHoveringComponent, _isHoveringCharacter) == 0x0000C8, "Member 'UHoveringComponent::_isHoveringCharacter' has a wrong offset!");
static_assert(offsetof(UHoveringComponent, _disableClaimantNames) == 0x0000D0, "Member 'UHoveringComponent::_disableClaimantNames' has a wrong offset!");
static_assert(offsetof(UHoveringComponent, _claimantName) == 0x0000E0, "Member 'UHoveringComponent::_claimantName' has a wrong offset!");

// Class BattlePrototype.PlayerSASHologramAttackCheckComponent
// 0x0090 (0x0150 - 0x00C0)
class UPlayerSASHologramAttackCheckComponent : public UActorComponent
{
public:
	float                                         ENABLE_CALLTIME;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ATTACK_INTERVAL_TIME;                              // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CANCEL_INTERVAL_TIME;                              // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         REQUEST_DISTANCE_MAX;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSASHologramAttackCheckData>    CallDataTable;                                     // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSASHologramAttackProbabilityData> ProbabilityDataTable;                              // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2347[0x60];                                    // 0x00F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCallUI(EPlayerID PlayerId);
	void CancelCall(bool bInterval);
	void CheckHologramAttack(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	void DebugPrintLog(bool bSet);
	void DebugSetAlways(bool bSet);
	void DebugSetFixPlayerID(EPlayerID PlayerId);
	void DebugSetIgnoreInterval(bool bSet);
	void EndCallUI(bool bSuccess);
	int32 GetHologramRushCount();
	bool IsEnableSASHologram(EPlayerID PlayerId);
	bool IsManualMode();
	void LoadDataTable();
	void NotifyAttackBegin();
	void NotifyAttackEnd();
	void SetEnableCheck(bool bSet);
	void SetManualMode(bool bManual);
	void SetTimerPause(bool bPause);

	EPlayerID GetCallPlayer() const;
	bool IsAttackState() const;
	bool IsDoneCallPlayer() const;
	bool IsExistCall() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSASHologramAttackCheckComponent">();
	}
	static class UPlayerSASHologramAttackCheckComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSASHologramAttackCheckComponent>();
	}
};
static_assert(alignof(UPlayerSASHologramAttackCheckComponent) == 0x000008, "Wrong alignment on UPlayerSASHologramAttackCheckComponent");
static_assert(sizeof(UPlayerSASHologramAttackCheckComponent) == 0x000150, "Wrong size on UPlayerSASHologramAttackCheckComponent");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, ENABLE_CALLTIME) == 0x0000C0, "Member 'UPlayerSASHologramAttackCheckComponent::ENABLE_CALLTIME' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, ATTACK_INTERVAL_TIME) == 0x0000C4, "Member 'UPlayerSASHologramAttackCheckComponent::ATTACK_INTERVAL_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, CANCEL_INTERVAL_TIME) == 0x0000C8, "Member 'UPlayerSASHologramAttackCheckComponent::CANCEL_INTERVAL_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, REQUEST_DISTANCE_MAX) == 0x0000CC, "Member 'UPlayerSASHologramAttackCheckComponent::REQUEST_DISTANCE_MAX' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, CallDataTable) == 0x0000D0, "Member 'UPlayerSASHologramAttackCheckComponent::CallDataTable' has a wrong offset!");
static_assert(offsetof(UPlayerSASHologramAttackCheckComponent, ProbabilityDataTable) == 0x0000E0, "Member 'UPlayerSASHologramAttackCheckComponent::ProbabilityDataTable' has a wrong offset!");

// Class BattlePrototype.IceConditionComponent
// 0x0030 (0x0190 - 0x0160)
class UIceConditionComponent final : public UConditionComponent
{
public:
	float                                         _iceActionSpeedRate;                               // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _iceDamageRate;                                    // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _pIceBeginSound;                                   // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _pIceEndSound;                                     // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AIceConditionEffectActor*               _pEffectActor;                                     // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2349[0x10];                                    // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IceConditionComponent">();
	}
	static class UIceConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIceConditionComponent>();
	}
};
static_assert(alignof(UIceConditionComponent) == 0x000010, "Wrong alignment on UIceConditionComponent");
static_assert(sizeof(UIceConditionComponent) == 0x000190, "Wrong size on UIceConditionComponent");
static_assert(offsetof(UIceConditionComponent, _iceActionSpeedRate) == 0x000160, "Member 'UIceConditionComponent::_iceActionSpeedRate' has a wrong offset!");
static_assert(offsetof(UIceConditionComponent, _iceDamageRate) == 0x000164, "Member 'UIceConditionComponent::_iceDamageRate' has a wrong offset!");
static_assert(offsetof(UIceConditionComponent, _pIceBeginSound) == 0x000168, "Member 'UIceConditionComponent::_pIceBeginSound' has a wrong offset!");
static_assert(offsetof(UIceConditionComponent, _pIceEndSound) == 0x000170, "Member 'UIceConditionComponent::_pIceEndSound' has a wrong offset!");
static_assert(offsetof(UIceConditionComponent, _pEffectActor) == 0x000178, "Member 'UIceConditionComponent::_pEffectActor' has a wrong offset!");

// Class BattlePrototype.PreventDamageMotionComponent
// 0x0028 (0x00E8 - 0x00C0)
class UPreventDamageMotionComponent final : public UActorComponent
{
public:
	int32                                         _maxGuardValue;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardRecoverStartSec;                             // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _recoverGuardPerSec;                               // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardBreakMinSec;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardBreakMaxSec;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardValue;                                       // 0x00D4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _guardReduceCount;                                 // 0x00D8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _guardBreakCount;                                  // 0x00DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardBreakStartTime;                              // 0x00E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234A[0x4];                                     // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReduceGuard(int32 ReducedValue);
	void ResetGuardValue();

	float GetGuardValue() const;
	bool IsGuardBreak() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreventDamageMotionComponent">();
	}
	static class UPreventDamageMotionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreventDamageMotionComponent>();
	}
};
static_assert(alignof(UPreventDamageMotionComponent) == 0x000008, "Wrong alignment on UPreventDamageMotionComponent");
static_assert(sizeof(UPreventDamageMotionComponent) == 0x0000E8, "Wrong size on UPreventDamageMotionComponent");
static_assert(offsetof(UPreventDamageMotionComponent, _maxGuardValue) == 0x0000C0, "Member 'UPreventDamageMotionComponent::_maxGuardValue' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardRecoverStartSec) == 0x0000C4, "Member 'UPreventDamageMotionComponent::_guardRecoverStartSec' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _recoverGuardPerSec) == 0x0000C8, "Member 'UPreventDamageMotionComponent::_recoverGuardPerSec' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardBreakMinSec) == 0x0000CC, "Member 'UPreventDamageMotionComponent::_guardBreakMinSec' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardBreakMaxSec) == 0x0000D0, "Member 'UPreventDamageMotionComponent::_guardBreakMaxSec' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardValue) == 0x0000D4, "Member 'UPreventDamageMotionComponent::_guardValue' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardReduceCount) == 0x0000D8, "Member 'UPreventDamageMotionComponent::_guardReduceCount' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardBreakCount) == 0x0000DC, "Member 'UPreventDamageMotionComponent::_guardBreakCount' has a wrong offset!");
static_assert(offsetof(UPreventDamageMotionComponent, _guardBreakStartTime) == 0x0000E0, "Member 'UPreventDamageMotionComponent::_guardBreakStartTime' has a wrong offset!");

// Class BattlePrototype.IntroTutorialManager
// 0x0050 (0x0280 - 0x0230)
class AIntroTutorialManager : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnSuccessInput;                                    // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_234B[0x20];                                    // 0x0240(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundAtomCue*>                  SEArray;                                           // 0x0260(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_234C[0x10];                                    // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeginIntroTutorial();
	void DisplaySuccess();
	void EndDispCurrentMiniTips(bool ForceStop);
	void EndDispMiniTips(EHelpTutorial TutorialID, bool ForceStop);
	bool EndIntroTutorial();
	bool EndTutorial();
	void OnTutorialSuccess_Attack();
	void OnTutorialSuccess_ChangeLockon();
	void OnTutorialSuccess_Dash();
	void OnTutorialSuccess_Dodge();
	void OnTutorialSuccess_Jump();
	void OnTutorialSuccess_LaunchAttack();
	void OnTutorialSuccess_Lockon();
	void OnTutorialSuccess_Psychic();
	void OnTutorialSuccess_PsychicCombo();
	void OnTutorialSuccess_SpecialAttack();
	void OnTutorialSuccess_StepInAttack();
	bool RemoveEnemysNoDead(int32 GroupID, int32 SubGroupID);
	bool RestrictPlayerAttack(bool IsOn);
	bool RestrictPlayerLaunchAttack(bool IsOn);
	bool RestrictPlayerPsychic(bool IsOn);
	bool RestrictPlayerSpecialAttack(bool IsOn);
	bool SetTutrialPKGaugeRecovery(bool IsOn);
	void StartDispMiniTips(EHelpTutorial TutorialID, class FName GuideID, float MinDispTime);
	bool StartTutorial(EIntroTutorialType Type);
	void StopDispMiniTipsAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntroTutorialManager">();
	}
	static class AIntroTutorialManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIntroTutorialManager>();
	}
};
static_assert(alignof(AIntroTutorialManager) == 0x000008, "Wrong alignment on AIntroTutorialManager");
static_assert(sizeof(AIntroTutorialManager) == 0x000280, "Wrong size on AIntroTutorialManager");
static_assert(offsetof(AIntroTutorialManager, OnSuccessInput) == 0x000230, "Member 'AIntroTutorialManager::OnSuccessInput' has a wrong offset!");
static_assert(offsetof(AIntroTutorialManager, SEArray) == 0x000260, "Member 'AIntroTutorialManager::SEArray' has a wrong offset!");

// Class BattlePrototype.PsychicObjectSpawnComponent
// 0x0000 (0x04A0 - 0x04A0)
class UPsychicObjectSpawnComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectSpawnComponent">();
	}
	static class UPsychicObjectSpawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychicObjectSpawnComponent>();
	}
};
static_assert(alignof(UPsychicObjectSpawnComponent) == 0x000010, "Wrong alignment on UPsychicObjectSpawnComponent");
static_assert(sizeof(UPsychicObjectSpawnComponent) == 0x0004A0, "Wrong size on UPsychicObjectSpawnComponent");

// Class BattlePrototype.ItemCaptureStaticMeshBase
// 0x0018 (0x0248 - 0x0230)
class AItemCaptureStaticMeshBase final : public AActor
{
public:
	TSubclassOf<class AItemCaptureStaticMeshBase> bpClass;                                           // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_rootComp;                                        // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            M_staticMesh;                                      // 0x0240(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool GenerateStaticMesh(const class UObject* WorldContextObject, TSubclassOf<class AItemCaptureStaticMeshBase> bpClassType, const class FString& MeshPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCaptureStaticMeshBase">();
	}
	static class AItemCaptureStaticMeshBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemCaptureStaticMeshBase>();
	}
};
static_assert(alignof(AItemCaptureStaticMeshBase) == 0x000008, "Wrong alignment on AItemCaptureStaticMeshBase");
static_assert(sizeof(AItemCaptureStaticMeshBase) == 0x000248, "Wrong size on AItemCaptureStaticMeshBase");
static_assert(offsetof(AItemCaptureStaticMeshBase, bpClass) == 0x000230, "Member 'AItemCaptureStaticMeshBase::bpClass' has a wrong offset!");
static_assert(offsetof(AItemCaptureStaticMeshBase, M_rootComp) == 0x000238, "Member 'AItemCaptureStaticMeshBase::M_rootComp' has a wrong offset!");
static_assert(offsetof(AItemCaptureStaticMeshBase, M_staticMesh) == 0x000240, "Member 'AItemCaptureStaticMeshBase::M_staticMesh' has a wrong offset!");

// Class BattlePrototype.ItemData
// 0x00D8 (0x0100 - 0x0028)
class UItemData final : public UObject
{
public:
	class UDataTable*                             RefItemTable;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RefArrangeItemTable;                               // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           ItemIDs;                                           // 0x0038(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPlayerID, struct FItemIDArray>          PresentItemDataM;                                  // 0x0048(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<EPlayerID, struct FItemIDArray>          PresentItemDataF;                                  // 0x0098(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           BattleItemIDs;                                     // 0x00E8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorld*                                 M_pWorld;                                          // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetArrangeData(struct FArrangeItemDataCell* ArrangeItemData, class FName ID);
	bool GetData(struct FItemDataCell* ItemData, class FName ID);
	bool GetDataByItemID(struct FItemDataCell* ItemData, int32 ItemId);
	class FString GetDescription(class FName ID);
	EItemFavorability GetFavorability(class FName ID, EPlayerID CharID);
	int32 GetItemIndex(class FName ID);
	class FString GetName(class FName ID);
	int32 GetTradeNumberOfTimes(class FName ID);
	bool LoadItemDataTable(const class FString& ItemTablePath, const class FString& ArrangeItemDataTablePath);

	const TArray<class FName> GetItemIDs() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData">();
	}
	static class UItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData>();
	}
};
static_assert(alignof(UItemData) == 0x000008, "Wrong alignment on UItemData");
static_assert(sizeof(UItemData) == 0x000100, "Wrong size on UItemData");
static_assert(offsetof(UItemData, RefItemTable) == 0x000028, "Member 'UItemData::RefItemTable' has a wrong offset!");
static_assert(offsetof(UItemData, RefArrangeItemTable) == 0x000030, "Member 'UItemData::RefArrangeItemTable' has a wrong offset!");
static_assert(offsetof(UItemData, ItemIDs) == 0x000038, "Member 'UItemData::ItemIDs' has a wrong offset!");
static_assert(offsetof(UItemData, PresentItemDataM) == 0x000048, "Member 'UItemData::PresentItemDataM' has a wrong offset!");
static_assert(offsetof(UItemData, PresentItemDataF) == 0x000098, "Member 'UItemData::PresentItemDataF' has a wrong offset!");
static_assert(offsetof(UItemData, BattleItemIDs) == 0x0000E8, "Member 'UItemData::BattleItemIDs' has a wrong offset!");
static_assert(offsetof(UItemData, M_pWorld) == 0x0000F8, "Member 'UItemData::M_pWorld' has a wrong offset!");

// Class BattlePrototype.PsychicObjectManager
// 0x0248 (0x0478 - 0x0230)
class APsychicObjectManager : public AActor
{
public:
	uint8                                         Pad_2355[0x18];                                    // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         PsychicObjectClassList_S;                          // 0x0248(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_M;                          // 0x0258(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_L;                          // 0x0268(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_XL;                         // 0x0278(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_XXL;                        // 0x0288(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         PsychicObjectClassList_Swing;                      // 0x0298(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2356[0x10];                                    // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSizeListSkipSwingType;                            // 0x02B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2357[0x1F];                                    // 0x02B9(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         PsychicObjectClassList_Unknown;                    // 0x02D8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2358[0x8];                                     // 0x02E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPsychicObjectListInfo> PsychicObjectListByLevel;                          // 0x02F0(0x0050)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2359[0xC];                                     // 0x0340(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchDistanceMinEnemy;                            // 0x034C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchCheckTraceEnemy;                            // 0x0350(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_235A[0x3];                                     // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchDistanceMinNpc;                              // 0x0354(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchCheckTraceNpc;                              // 0x0358(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_235B[0x37];                                    // 0x0359(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FocusParamDistList;                                // 0x0390(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FocusParamDistPointList;                           // 0x03A0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 FocusParamAngleList;                               // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FocusParamAnglePointList;                          // 0x03C0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_235C[0x28];                                    // 0x03D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDispSearchScore;                             // 0x03F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDispSearchParam;                             // 0x03F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDispSearchNpc;                               // 0x03FA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235D[0x7D];                                    // 0x03FB(0x007D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckEnemyObject(bool bUnqObj, bool ChkCapture, bool ChkAttack);
	bool CheckNpcObject(bool bUnqObj, bool bEnemy, bool ChkCapture, bool ChkAttack);
	void ClearPsychicObjectList();
	void DebugCheckPsychicObjectSizeListNum();
	void DebugLog(const class FString& LogString);
	void DebugMultiSphereTraceForObject(TArray<struct FHitResult>* ResultList, const struct FVector& PosS, const struct FVector& Pose, float Radius, bool bDbDraw, bool bDbPrint);
	void DebugPrintPsychicObjectSizeList();
	void DebugPrintRegisterInfo();
	void DebugPrintString(const class FString& LogString);
	TArray<EPsychicObjectSizeType> GetAvailableRegisterSizeArray(int32 Len, const TArray<EPsychicObjectSizeType>& RequestSize);
	class AActor* GetEnemyObject(bool bUnqObj);
	void GetFocusPsychicObject(struct FPsychicObjectFocusResult* Result);
	class AActor* GetNpcObject(bool bUnqObj, bool bEnemy);
	TArray<class AActor*> GetPsychicObjectListByLevelName(const class FName LevelName);
	int32 GetPsychicObjectNumByLevelName(const class FName LevelName);
	class AActor* GetPsychicObjectRegisterActor(int32 Idx);
	int32 GetPsychicObjectRegisterNum();
	class UClass* GetRandomPsychicObjectRegisterClass(EPsychicObjectSizeType ObjSize);
	class UClass* GetRandomSwingTypeObjectRegisterClass();
	bool IsFloatObjectExist();
	bool IsFocusSearchEnable();
	bool IsFocusSearchPause();
	void RegisterMapGimmick(class AActor* PActor, float DistMin);
	void RegisterPsychicObject(class AActor* PsyObjActor);
	void ResetNpcObject(bool bUnqObj, bool bEnemy);
	void ResetPsychicObjectArrangeTransform();
	void SearchEnemyPsychicObject(bool bUnqObj, const struct FVector& ChkPos, struct FPsychicObjectFocusResult* Result);
	void SearchFocusPsychicObject(const struct FVector& ChkPos, const struct FVector& ChkDir, struct FPsychicObjectFocusResult* Result);
	void SearchNpcPsychicObject(bool bUnqObj, bool bEnemy, const struct FVector& ChkPos, struct FPsychicObjectFocusResult* Result);
	bool SetDuelPoleType(bool bDuelType);
	bool SetEnablePsychicObjectRegister(const class FString& RefName, bool Flag);
	void SetEnemySearchID(BattlePrototype::EPsychicObjectID SearchId);
	void SetFocusParameter(const TArray<float>& DistList, const TArray<int32>& DistPointList, const TArray<float>& AngleList, const TArray<int32>& AnglePointList);
	void SetFocusSearchEnable(bool Flag, class FName TagName);
	void SetFocusSearchPause(bool Flag, class FName TagName, bool bResetResult);
	void SetNpcSearchDistanceMin(float Dist);
	void SetPsychicObjectListEventC(bool bStart, bool bTick, bool bVisibility);
	void SetPsychicObjectMaterialDitherParameter(bool bChkDist, float ApplyRadius);
	void SetPsychicObjectMaterialDitherParameterOnce(bool bChkOnce, float ApplyRadius);
	void SetPsychicObjectMaterialValueDither(bool bRestore, float Rate);
	void SetPsychicObjectRegisterSkip(bool Flag);
	void SetPsychicObjectTownSetting(bool Flag);
	void SetSearchComponent(class UPsychicObjectSearchComponent* Comp);
	void SetSearchFocus(bool Flag);
	void UnregisterMapGimmick(class AActor* PActor);
	void UnregisterPsychicObject(class AActor* PsyObjActor);

	bool IsSetSearchComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectManager">();
	}
	static class APsychicObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APsychicObjectManager>();
	}
};
static_assert(alignof(APsychicObjectManager) == 0x000008, "Wrong alignment on APsychicObjectManager");
static_assert(sizeof(APsychicObjectManager) == 0x000478, "Wrong size on APsychicObjectManager");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_S) == 0x000248, "Member 'APsychicObjectManager::PsychicObjectClassList_S' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_M) == 0x000258, "Member 'APsychicObjectManager::PsychicObjectClassList_M' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_L) == 0x000268, "Member 'APsychicObjectManager::PsychicObjectClassList_L' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_XL) == 0x000278, "Member 'APsychicObjectManager::PsychicObjectClassList_XL' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_XXL) == 0x000288, "Member 'APsychicObjectManager::PsychicObjectClassList_XXL' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_Swing) == 0x000298, "Member 'APsychicObjectManager::PsychicObjectClassList_Swing' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bSizeListSkipSwingType) == 0x0002B8, "Member 'APsychicObjectManager::bSizeListSkipSwingType' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectClassList_Unknown) == 0x0002D8, "Member 'APsychicObjectManager::PsychicObjectClassList_Unknown' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, PsychicObjectListByLevel) == 0x0002F0, "Member 'APsychicObjectManager::PsychicObjectListByLevel' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, SearchDistanceMinEnemy) == 0x00034C, "Member 'APsychicObjectManager::SearchDistanceMinEnemy' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bSearchCheckTraceEnemy) == 0x000350, "Member 'APsychicObjectManager::bSearchCheckTraceEnemy' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, SearchDistanceMinNpc) == 0x000354, "Member 'APsychicObjectManager::SearchDistanceMinNpc' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bSearchCheckTraceNpc) == 0x000358, "Member 'APsychicObjectManager::bSearchCheckTraceNpc' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, FocusParamDistList) == 0x000390, "Member 'APsychicObjectManager::FocusParamDistList' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, FocusParamDistPointList) == 0x0003A0, "Member 'APsychicObjectManager::FocusParamDistPointList' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, FocusParamAngleList) == 0x0003B0, "Member 'APsychicObjectManager::FocusParamAngleList' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, FocusParamAnglePointList) == 0x0003C0, "Member 'APsychicObjectManager::FocusParamAnglePointList' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bDebugDispSearchScore) == 0x0003F8, "Member 'APsychicObjectManager::bDebugDispSearchScore' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bDebugDispSearchParam) == 0x0003F9, "Member 'APsychicObjectManager::bDebugDispSearchParam' has a wrong offset!");
static_assert(offsetof(APsychicObjectManager, bDebugDispSearchNpc) == 0x0003FA, "Member 'APsychicObjectManager::bDebugDispSearchNpc' has a wrong offset!");

// Class BattlePrototype.ItemDataUtility
// 0x0000 (0x0028 - 0x0028)
class UItemDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool GetArrangeItemDataCell(const class UObject* WorldContextObject, struct FArrangeItemDataCell* ItemData, class FName ID);
	static EItemCategory GetItemCategory(int32 ItemId);
	static int32 GetItemCategoryID(int32 ItemId);
	static bool GetItemDataCell(const class UObject* WorldContextObject, struct FItemDataCell* ItemData, class FName ID);
	static bool GetItemDataCellByItemId(const class UObject* WorldContextObject, struct FItemDataCell* ItemData, int32 ItemId);
	static class FText GetItemDataDescription(const class UObject* WorldContextObject, const struct FItemDataCell& ItemDataCell);
	static class FText GetItemDataName(const class UObject* WorldContextObject, const struct FItemDataCell& ItemDataCell);
	static void GetItemIDs(const class UObject* WorldContextObject, TArray<class FName>* ItemIDs);
	static int32 GetItemIndex(const class UObject* WorldContextObject, class FName ID);
	static EItemRarity GetItemRarity(const struct FItemDataCell& ItemDataCell);
	static bool GetLotteryResultItemID(const class UObject* WorldContextObject, const bool IsRare, const struct FArrangeItemDataCell& ArrangeItemDataCell, class FName* ItemId, int32* ItemNum);
	static int32 GetNumOfEquipment(const class UObject* WorldContextObject, const class FName& ItemId);
	static bool IsCategoryAttachment(EItemCategory Category);
	static bool IsInvalidSell(const struct FItemDataCell& ItemDataCell);
	static bool IsValidItemId(int32 ItemId);
	static class FName MakeItemDataName(int32 ItemId);
	static int32 MakeItemID(EItemCategory Category, int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDataUtility">();
	}
	static class UItemDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDataUtility>();
	}
};
static_assert(alignof(UItemDataUtility) == 0x000008, "Wrong alignment on UItemDataUtility");
static_assert(sizeof(UItemDataUtility) == 0x000028, "Wrong size on UItemDataUtility");

// Class BattlePrototype.PsychicObjectSoundComponent
// 0x0040 (0x0100 - 0x00C0)
class UPsychicObjectSoundComponent final : public UActorComponent
{
public:
	uint8                                         Pad_237A[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideEffectTableId;                             // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverrideSoundTableId;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFootStepComponent*                     FootStepComponent;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitActorInfoAtPsychic>         HitActorList;                                      // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSeInterval;                                     // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaySeVelocity;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRunSeVelocity;                                 // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_237B[0x4];                                     // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectSoundComponent">();
	}
	static class UPsychicObjectSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychicObjectSoundComponent>();
	}
};
static_assert(alignof(UPsychicObjectSoundComponent) == 0x000008, "Wrong alignment on UPsychicObjectSoundComponent");
static_assert(sizeof(UPsychicObjectSoundComponent) == 0x000100, "Wrong size on UPsychicObjectSoundComponent");
static_assert(offsetof(UPsychicObjectSoundComponent, OverrideEffectTableId) == 0x0000C8, "Member 'UPsychicObjectSoundComponent::OverrideEffectTableId' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, OverrideSoundTableId) == 0x0000D0, "Member 'UPsychicObjectSoundComponent::OverrideSoundTableId' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, FootStepComponent) == 0x0000D8, "Member 'UPsychicObjectSoundComponent::FootStepComponent' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, HitActorList) == 0x0000E0, "Member 'UPsychicObjectSoundComponent::HitActorList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, HitSeInterval) == 0x0000F0, "Member 'UPsychicObjectSoundComponent::HitSeInterval' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, PlaySeVelocity) == 0x0000F4, "Member 'UPsychicObjectSoundComponent::PlaySeVelocity' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSoundComponent, PlayRunSeVelocity) == 0x0000F8, "Member 'UPsychicObjectSoundComponent::PlayRunSeVelocity' has a wrong offset!");

// Class BattlePrototype.JumpAreaBase
// 0x0040 (0x0278 - 0x0238)
class AJumpAreaBase final : public ATriggerBox
{
public:
	int32                                         LocationNo;                                        // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNo;                                            // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalNo;                                          // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSelectNextAreaFunction;                         // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_237D[0x3];                                     // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LocationNoJumpTo;                                  // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaNoJumpTo;                                      // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalNoJumpTo;                                    // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartPortalNameJumpTo;                             // 0x0254(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpenWorldMap;                                    // 0x025C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_237E[0x3];                                     // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ToDetailSubAreaName;                               // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAreaInfoTweakCondition>        Conditions;                                        // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool IsAcceptableJumpArea();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JumpAreaBase">();
	}
	static class AJumpAreaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJumpAreaBase>();
	}
};
static_assert(alignof(AJumpAreaBase) == 0x000008, "Wrong alignment on AJumpAreaBase");
static_assert(sizeof(AJumpAreaBase) == 0x000278, "Wrong size on AJumpAreaBase");
static_assert(offsetof(AJumpAreaBase, LocationNo) == 0x000238, "Member 'AJumpAreaBase::LocationNo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, AreaNo) == 0x00023C, "Member 'AJumpAreaBase::AreaNo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, PortalNo) == 0x000240, "Member 'AJumpAreaBase::PortalNo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, UseSelectNextAreaFunction) == 0x000244, "Member 'AJumpAreaBase::UseSelectNextAreaFunction' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, LocationNoJumpTo) == 0x000248, "Member 'AJumpAreaBase::LocationNoJumpTo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, AreaNoJumpTo) == 0x00024C, "Member 'AJumpAreaBase::AreaNoJumpTo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, PortalNoJumpTo) == 0x000250, "Member 'AJumpAreaBase::PortalNoJumpTo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, StartPortalNameJumpTo) == 0x000254, "Member 'AJumpAreaBase::StartPortalNameJumpTo' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, IsOpenWorldMap) == 0x00025C, "Member 'AJumpAreaBase::IsOpenWorldMap' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, ToDetailSubAreaName) == 0x000260, "Member 'AJumpAreaBase::ToDetailSubAreaName' has a wrong offset!");
static_assert(offsetof(AJumpAreaBase, Conditions) == 0x000268, "Member 'AJumpAreaBase::Conditions' has a wrong offset!");

// Class BattlePrototype.QuestDataUtility
// 0x0020 (0x0048 - 0x0028)
class UQuestDataUtility final : public UBlueprintFunctionLibrary
{
public:
	uint8                                         Pad_237F[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckDLCQuestContentCheck(const class UObject* WorldContextObject, class FName QuestId);
	static bool CheckFinishedDLCBonds(const class UObject* WorldContextObject, EPlayerID HeroID, EPlayerID TargetID, int32 DlcNumber);
	static void GetCharStartedDLCBonds(const class UObject* WorldContextObject, class FName DlcBondsID, EPlayerID* StartedCharID);
	static bool KillEnemyDataForSubQuest(const class UObject* WorldContextObject, class FName EnemyName, const struct FHCHitResult& HcResult, EPsychicObjectUniqueType PoType, bool bBrainCrashMulti, EPlayerID HoloPlayerID);
	static void SetDLCBondsStartTargetChar(const class UObject* WorldContextObject, class FName DlcBondsID, EPlayerID StartChar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestDataUtility">();
	}
	static class UQuestDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestDataUtility>();
	}
};
static_assert(alignof(UQuestDataUtility) == 0x000008, "Wrong alignment on UQuestDataUtility");
static_assert(sizeof(UQuestDataUtility) == 0x000048, "Wrong size on UQuestDataUtility");

// Class BattlePrototype.LC21MapGimmickManager
// 0x0038 (0x0268 - 0x0230)
class ALC21MapGimmickManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_2386[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     BossFloorActorClass;                               // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AMapGimmickObject*>              Objects;                                           // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBossFloorInfo>                 ObjectInfoList;                                    // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentGimmickNo;                                  // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MostLeftFloorNo;                                   // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool ChangePhase(int32 PhaseNo);
	void ClearObjectInfoList();
	bool FallLeftFloor(float OffsetY);
	bool FindAllObjectsAndInitialize();
	void GetAllFloorObjectsAndSort();
	int32 GetMostRightSideFloorNo(float Offset, int32 StartId, int32 EndId, bool CheckIsFall);
	bool RemoveAllPart();
	bool StartEventLaser();
	bool StartEventLaserCenter();
	bool StartEventLaserFar();
	bool StartEventLaserSetWall();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LC21MapGimmickManager">();
	}
	static class ALC21MapGimmickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALC21MapGimmickManager>();
	}
};
static_assert(alignof(ALC21MapGimmickManager) == 0x000008, "Wrong alignment on ALC21MapGimmickManager");
static_assert(sizeof(ALC21MapGimmickManager) == 0x000268, "Wrong size on ALC21MapGimmickManager");
static_assert(offsetof(ALC21MapGimmickManager, BossFloorActorClass) == 0x000238, "Member 'ALC21MapGimmickManager::BossFloorActorClass' has a wrong offset!");
static_assert(offsetof(ALC21MapGimmickManager, Objects) == 0x000240, "Member 'ALC21MapGimmickManager::Objects' has a wrong offset!");
static_assert(offsetof(ALC21MapGimmickManager, ObjectInfoList) == 0x000250, "Member 'ALC21MapGimmickManager::ObjectInfoList' has a wrong offset!");
static_assert(offsetof(ALC21MapGimmickManager, CurrentGimmickNo) == 0x000260, "Member 'ALC21MapGimmickManager::CurrentGimmickNo' has a wrong offset!");
static_assert(offsetof(ALC21MapGimmickManager, MostLeftFloorNo) == 0x000264, "Member 'ALC21MapGimmickManager::MostLeftFloorNo' has a wrong offset!");

// Class BattlePrototype.LevelManager
// 0x0020 (0x0250 - 0x0230)
class ALevelManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_238A[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCompleteUnloadLevelAll;                          // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_238B[0x8];                                     // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CallAreaPostLoadFunction(int32 LocationId, int32 AreaId, int32 VariationID, bool IsFirstTry, bool* Initialized);
	bool CallAreaSelectVariationFunction(int32 LocationId, int32 AreaId, int32 VariationID, int32 PortaflID, bool NoChange, int32* OutLocationID, int32* OutAreaID, int32* OutVariationID);
	bool CheckTweakConditionFunc(const struct FAreaInfoTweakCondition& TweakCondition);
	void CopyCurrentSimulatorLevelInfosName();
	class FName GetAreaBGName(int32 LocationId, int32 AreaId, int32 VariationID);
	bool GetAreaInfoFromNative(class FName AreName, TArray<class FName>& OutLevenName);
	class FName GetAreaName(int32 LocationId, int32 AreaId, int32 VariationID);
	class FName GetShortAreaName(int32 LocationId, int32 AreaId);
	int32 GetStreamingTextureNum();
	bool IsValidCurrentSimulatorLevelInfosName();
	void SetStreamingSettings(const struct FRSStreamingSettings& Settings);
	int32 StreamingTextureBlockTillAllRequestsFinished(float TimeLimit, bool bLogResults);
	int32 StreamingTextureLoadAllBlock();
	void SyncUnloadStreamLevels();

	struct FRSStreamingSettings GetCurrentStreamingSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelManager">();
	}
	static class ALevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelManager>();
	}
};
static_assert(alignof(ALevelManager) == 0x000008, "Wrong alignment on ALevelManager");
static_assert(sizeof(ALevelManager) == 0x000250, "Wrong size on ALevelManager");
static_assert(offsetof(ALevelManager, OnCompleteUnloadLevelAll) == 0x000238, "Member 'ALevelManager::OnCompleteUnloadLevelAll' has a wrong offset!");

// Class BattlePrototype.PurposeMessageParamManager
// 0x0028 (0x0050 - 0x0028)
class UPurposeMessageParamManager final : public UObject
{
public:
	class UDataTable*                             DataTable_;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             bondsPurposeTable_;                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2392[0x18];                                    // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetBondsPurposeMessage(EPlayerID HeroID, EPlayerID TargetID);
	class FName GetDLCBondsPurposeMessage();
	class FName GetPurposeMessage();
	int32 GetPurposeMessageNum();
	void InitData(class URSGameInstance* GameInst);
	void SetPurposeMessage(const class FString& MessageID);
	void SetPurposeMessageNum(int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PurposeMessageParamManager">();
	}
	static class UPurposeMessageParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPurposeMessageParamManager>();
	}
};
static_assert(alignof(UPurposeMessageParamManager) == 0x000008, "Wrong alignment on UPurposeMessageParamManager");
static_assert(sizeof(UPurposeMessageParamManager) == 0x000050, "Wrong size on UPurposeMessageParamManager");
static_assert(offsetof(UPurposeMessageParamManager, DataTable_) == 0x000028, "Member 'UPurposeMessageParamManager::DataTable_' has a wrong offset!");
static_assert(offsetof(UPurposeMessageParamManager, bondsPurposeTable_) == 0x000030, "Member 'UPurposeMessageParamManager::bondsPurposeTable_' has a wrong offset!");

// Class BattlePrototype.BondsLevelupData
// 0x0038 (0x0060 - 0x0028)
class UBondsLevelupData final : public UObject
{
public:
	uint8                                         Pad_2394[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBondsLevelupExpData>           ExpListM;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBondsLevelupExpData>           ExpListF;                                          // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBondsLevelupExpData                   DummyList;                                         // 0x0050(0x0010)(NativeAccessSpecifierPrivate)

public:
	void LoadDataTable();

	const TArray<int32> GetBondsLevelupTable(EPlayerID PlayerId, EPlayerID TargetID) const;
	bool IsValidResource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BondsLevelupData">();
	}
	static class UBondsLevelupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBondsLevelupData>();
	}
};
static_assert(alignof(UBondsLevelupData) == 0x000008, "Wrong alignment on UBondsLevelupData");
static_assert(sizeof(UBondsLevelupData) == 0x000060, "Wrong size on UBondsLevelupData");
static_assert(offsetof(UBondsLevelupData, ExpListM) == 0x000030, "Member 'UBondsLevelupData::ExpListM' has a wrong offset!");
static_assert(offsetof(UBondsLevelupData, ExpListF) == 0x000040, "Member 'UBondsLevelupData::ExpListF' has a wrong offset!");
static_assert(offsetof(UBondsLevelupData, DummyList) == 0x000050, "Member 'UBondsLevelupData::DummyList' has a wrong offset!");

// Class BattlePrototype.TeamBondsLevelupData
// 0x0018 (0x0040 - 0x0028)
class UTeamBondsLevelupData final : public UObject
{
public:
	uint8                                         Pad_2396[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DataTableM;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableF;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void LoadDataTable();

	class UDataTable* GetTeamBondsLevelupTable(EPlayerID PlayerId) const;
	bool IsValidResource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamBondsLevelupData">();
	}
	static class UTeamBondsLevelupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamBondsLevelupData>();
	}
};
static_assert(alignof(UTeamBondsLevelupData) == 0x000008, "Wrong alignment on UTeamBondsLevelupData");
static_assert(sizeof(UTeamBondsLevelupData) == 0x000040, "Wrong size on UTeamBondsLevelupData");
static_assert(offsetof(UTeamBondsLevelupData, DataTableM) == 0x000030, "Member 'UTeamBondsLevelupData::DataTableM' has a wrong offset!");
static_assert(offsetof(UTeamBondsLevelupData, DataTableF) == 0x000038, "Member 'UTeamBondsLevelupData::DataTableF' has a wrong offset!");

// Class BattlePrototype.PsychicObjectSearchComponent
// 0x01B0 (0x0280 - 0x00D0)
class UPsychicObjectSearchComponent : public URSAsyncTaskActorComponent
{
public:
	uint8                                         Pad_2398[0x8];                                     // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchUpdateSearchObject;                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2399[0x30];                                    // 0x00E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FocusParamDistList;                                // 0x0118(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FocusParamDistPointList;                           // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 FocusParamAngleList;                               // 0x0138(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 FocusParamAnglePointList;                          // 0x0148(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239A[0x90];                                    // 0x0158(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PsychicFieldObjectNum;                             // 0x01E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PsychicFieldRadius;                                // 0x01EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugPrintPsychicFieldSearch;                      // 0x01F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239B[0x1B];                                    // 0x01F1(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDispSyncProc;                                // 0x020C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDispSearchProc;                              // 0x020D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDispSearchScore;                             // 0x020E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239C[0x1];                                     // 0x020F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugDispSearchCount;                              // 0x0210(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugDispTraceCount;                               // 0x0214(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239D[0x60];                                    // 0x0218(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDispSearchEnpc;                              // 0x0278(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239E[0x7];                                     // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckEnpcPsychicObject(bool ChkCapture, bool ChkAttack);
	void DebugDispFocusSearchProc(const struct FVector& Pos);
	class AActor* GetEnpcPsychicObject();
	class AActor* GetSearchResultNrl();
	class AActor* GetSearchResultUnq();
	bool IsFocusSearchEnable();
	void RegisterMapGimmick(class AActor* PActor, float DistMin);
	void SearchEnpcPsychicObject(const struct FVector& ChkPos, struct FPsychicObjectEvaluateData* Result);
	TArray<class AActor*> SearchPsychicFieldObject();
	TArray<class AActor*> SearchPsychicFieldTarget(const struct FVector& SearchPos, class AActor* PTargetActor);
	void SetEnpcSearchParameter(float RadiusMin);
	void SetFocusSearchEnable(bool Flag, class FName TagName);
	void SetFocusSearchHeightParameter(float HeightMin, float HeightMax);
	void SetFocusSearchScoreParameter(const TArray<float>& DistList, const TArray<int32>& DistPointList, const TArray<float>& AngleList, const TArray<int32>& AnglePointList);
	void SetPsychicFieldParameter(float Radius, int32 ObjNum);
	TArray<class AActor*> SortByDistance(const TArray<class AActor*>& ActorList, class AActor* PTargetActor, bool bAscend, bool bIgnoreZ, bool bSearchPos, const struct FVector& CheckPos, float SearchRadius);
	TArray<class AActor*> SortBySize(const TArray<class AActor*>& ActorList, bool bAscend);
	void UnregisterMapGimmick(class AActor* PActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectSearchComponent">();
	}
	static class UPsychicObjectSearchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychicObjectSearchComponent>();
	}
};
static_assert(alignof(UPsychicObjectSearchComponent) == 0x000008, "Wrong alignment on UPsychicObjectSearchComponent");
static_assert(sizeof(UPsychicObjectSearchComponent) == 0x000280, "Wrong size on UPsychicObjectSearchComponent");
static_assert(offsetof(UPsychicObjectSearchComponent, DispatchUpdateSearchObject) == 0x0000D8, "Member 'UPsychicObjectSearchComponent::DispatchUpdateSearchObject' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, FocusParamDistList) == 0x000118, "Member 'UPsychicObjectSearchComponent::FocusParamDistList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, FocusParamDistPointList) == 0x000128, "Member 'UPsychicObjectSearchComponent::FocusParamDistPointList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, FocusParamAngleList) == 0x000138, "Member 'UPsychicObjectSearchComponent::FocusParamAngleList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, FocusParamAnglePointList) == 0x000148, "Member 'UPsychicObjectSearchComponent::FocusParamAnglePointList' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, PsychicFieldObjectNum) == 0x0001E8, "Member 'UPsychicObjectSearchComponent::PsychicFieldObjectNum' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, PsychicFieldRadius) == 0x0001EC, "Member 'UPsychicObjectSearchComponent::PsychicFieldRadius' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, DebugPrintPsychicFieldSearch) == 0x0001F0, "Member 'UPsychicObjectSearchComponent::DebugPrintPsychicFieldSearch' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, bDebugDispSyncProc) == 0x00020C, "Member 'UPsychicObjectSearchComponent::bDebugDispSyncProc' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, bDebugDispSearchProc) == 0x00020D, "Member 'UPsychicObjectSearchComponent::bDebugDispSearchProc' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, bDebugDispSearchScore) == 0x00020E, "Member 'UPsychicObjectSearchComponent::bDebugDispSearchScore' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, DebugDispSearchCount) == 0x000210, "Member 'UPsychicObjectSearchComponent::DebugDispSearchCount' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, DebugDispTraceCount) == 0x000214, "Member 'UPsychicObjectSearchComponent::DebugDispTraceCount' has a wrong offset!");
static_assert(offsetof(UPsychicObjectSearchComponent, bDebugDispSearchEnpc) == 0x000278, "Member 'UPsychicObjectSearchComponent::bDebugDispSearchEnpc' has a wrong offset!");

// Class BattlePrototype.LibraryCharaData
// 0x0018 (0x0040 - 0x0028)
class ULibraryCharaData final : public UObject
{
public:
	class ULibraryCharaDBAsset*                   Asset;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OpenDataM;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             OpenDataF;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool LoadDataAsset(const class FString& Path, const class FString& OpenDataPathM, const class FString& OpenDataPathF);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryCharaData">();
	}
	static class ULibraryCharaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryCharaData>();
	}
};
static_assert(alignof(ULibraryCharaData) == 0x000008, "Wrong alignment on ULibraryCharaData");
static_assert(sizeof(ULibraryCharaData) == 0x000040, "Wrong size on ULibraryCharaData");
static_assert(offsetof(ULibraryCharaData, Asset) == 0x000028, "Member 'ULibraryCharaData::Asset' has a wrong offset!");
static_assert(offsetof(ULibraryCharaData, OpenDataM) == 0x000030, "Member 'ULibraryCharaData::OpenDataM' has a wrong offset!");
static_assert(offsetof(ULibraryCharaData, OpenDataF) == 0x000038, "Member 'ULibraryCharaData::OpenDataF' has a wrong offset!");

// Class BattlePrototype.LibraryCharacterParam
// 0x0030 (0x0058 - 0x0028)
class ULibraryCharacterParam final : public UObject
{
public:
	struct FFlag                                  LibFlags;                                          // 0x0028(0x0010)(Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           OpenLibList;                                       // 0x0038(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryCharaData*                      DataTable;                                         // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSGameInstance*                        GameInstance;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 CheckLibraryOpenByProgresNo(int32 ProgressNo);
	void CloseCharLib(class FName LibName);
	int32 GetDBKeys(TArray<class FName>* Dst);
	bool GetLibraryData(struct FLibraryCharaDataCell* Data, class FName CharaID, bool IsDebugOpen);
	bool GetLibraryTwoShotPhotos(TArray<class FString>* Data, class FName CharaID, bool IsDebugOpen);
	void GetTwoshotCheckFlagList(TArray<ELibraryFlagType>* List);
	void GetTwoShotPairList(TArray<struct FTwoShotPair>* List);
	void InitData(class URSGameInstance* Param_GameInstance);
	void OffFlag(ELibraryFlagType FlagNo);
	void OnFlag(ELibraryFlagType FlagNo);
	void OpenCharLib(class FName LibName);

	bool CheckFlag(ELibraryFlagType FlagNo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryCharacterParam">();
	}
	static class ULibraryCharacterParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryCharacterParam>();
	}
};
static_assert(alignof(ULibraryCharacterParam) == 0x000008, "Wrong alignment on ULibraryCharacterParam");
static_assert(sizeof(ULibraryCharacterParam) == 0x000058, "Wrong size on ULibraryCharacterParam");
static_assert(offsetof(ULibraryCharacterParam, LibFlags) == 0x000028, "Member 'ULibraryCharacterParam::LibFlags' has a wrong offset!");
static_assert(offsetof(ULibraryCharacterParam, OpenLibList) == 0x000038, "Member 'ULibraryCharacterParam::OpenLibList' has a wrong offset!");
static_assert(offsetof(ULibraryCharacterParam, DataTable) == 0x000048, "Member 'ULibraryCharacterParam::DataTable' has a wrong offset!");
static_assert(offsetof(ULibraryCharacterParam, GameInstance) == 0x000050, "Member 'ULibraryCharacterParam::GameInstance' has a wrong offset!");

// Class BattlePrototype.LibraryCharacterParamUtility
// 0x0000 (0x0028 - 0x0028)
class ULibraryCharacterParamUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool CharaLibraryCheckFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static bool CharaLibraryOffFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static bool CharaLibraryOnFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static int32 CheckLibraryOpenByProgresNo(const class UObject* WorldContextObject, int32 ProgressNo);
	static bool OpenCharacterLibray(const class UObject* WorldContextObject, class FName LibName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryCharacterParamUtility">();
	}
	static class ULibraryCharacterParamUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryCharacterParamUtility>();
	}
};
static_assert(alignof(ULibraryCharacterParamUtility) == 0x000008, "Wrong alignment on ULibraryCharacterParamUtility");
static_assert(sizeof(ULibraryCharacterParamUtility) == 0x000028, "Wrong size on ULibraryCharacterParamUtility");

// Class BattlePrototype.LibraryEnemyData
// 0x0008 (0x0030 - 0x0028)
class ULibraryEnemyData final : public UObject
{
public:
	class ULibraryEnemyDBAsset*                   Asset;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool LoadDataAsset(const class FString& AssetPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryEnemyData">();
	}
	static class ULibraryEnemyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryEnemyData>();
	}
};
static_assert(alignof(ULibraryEnemyData) == 0x000008, "Wrong alignment on ULibraryEnemyData");
static_assert(sizeof(ULibraryEnemyData) == 0x000030, "Wrong size on ULibraryEnemyData");
static_assert(offsetof(ULibraryEnemyData, Asset) == 0x000028, "Member 'ULibraryEnemyData::Asset' has a wrong offset!");

// Class BattlePrototype.LibraryEnemyParamUtility
// 0x0000 (0x0028 - 0x0028)
class ULibraryEnemyParamUtility final : public UBlueprintFunctionLibrary
{
public:
	static bool EnemyLibraryCheckFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static bool EnemyLibraryIsOpenLibrary(const class UObject* WorldContextObject, class FName EnemyId);
	static bool EnemyLibraryOffFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static bool EnemyLibraryOnFlag(const class UObject* WorldContextObject, ELibraryFlagType FlagNo);
	static void EnemyLibraryUpdateGetDropItem(const class UObject* WorldContextObject, class FName EnemyId, class FName ItemId);
	static void EnemyLibraryUpdateIncKillNum(const class UObject* WorldContextObject, class FName EnemyId);
	static int32 GetImageVariationNum(const class UObject* WorldContextObject, class FName EnemyId, bool IsDebugOpen);
	static void GetItemDroppingEnemyList(const class UObject* WorldContextObject, class FName ItemId, TArray<class FName>* OutEnemyList);
	static bool GetLibraryData(const class UObject* WorldContextObject, struct FLibraryEnemyDataCell* Data, class FName EnemyId, bool IsDebugOpen);
	static bool GetLibraryDataFromLibraryID(const class UObject* WorldContextObject, struct FLibraryEnemyDataCell* Data, class FName LibraryID, bool IsDebugOpen);
	static bool OpenEnemyLibray(const class UObject* WorldContextObject, class FName EnemyId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LibraryEnemyParamUtility">();
	}
	static class ULibraryEnemyParamUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULibraryEnemyParamUtility>();
	}
};
static_assert(alignof(ULibraryEnemyParamUtility) == 0x000008, "Wrong alignment on ULibraryEnemyParamUtility");
static_assert(sizeof(ULibraryEnemyParamUtility) == 0x000028, "Wrong size on ULibraryEnemyParamUtility");

// Class BattlePrototype.LoadTipsData
// 0x0010 (0x0038 - 0x0028)
class ULoadTipsData final : public UObject
{
public:
	class UDataTable*                             LoadingTipsDataTable;                              // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             RetryLoadingTipsDataTable;                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadTipsData">();
	}
	static class ULoadTipsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadTipsData>();
	}
};
static_assert(alignof(ULoadTipsData) == 0x000008, "Wrong alignment on ULoadTipsData");
static_assert(sizeof(ULoadTipsData) == 0x000038, "Wrong size on ULoadTipsData");
static_assert(offsetof(ULoadTipsData, LoadingTipsDataTable) == 0x000028, "Member 'ULoadTipsData::LoadingTipsDataTable' has a wrong offset!");
static_assert(offsetof(ULoadTipsData, RetryLoadingTipsDataTable) == 0x000030, "Member 'ULoadTipsData::RetryLoadingTipsDataTable' has a wrong offset!");

// Class BattlePrototype.LoadTipsParamManager
// 0x00C8 (0x00F0 - 0x0028)
class ULoadTipsParamManager final : public UObject
{
public:
	TArray<struct FLoadTipsParam>                 LoadTipsParams_;                                   // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLoadTipsBlockParam>            LoadTipsBlockDataParamsM_;                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLoadTipsBlockParam>            LoadTipsBlockDataParamsF_;                         // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLoadTipsBlockParam>            LoadTipsBlockDataParamsCommon_;                    // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         beforeSelectTipsID_;                               // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B7[0xC];                                     // 0x006C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        GameInst_;                                         // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULoadTipsData*                          LoadTipsData_;                                     // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      DisplayCount_;                                     // 0x0088(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_23B8[0x18];                                    // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetBeginningTips(EPlayerID PlayerId, int32 ProgressNo, int32 NextLocation);
	int32 GetNextTips();
	void InitData(class URSGameInstance* GameInst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadTipsParamManager">();
	}
	static class ULoadTipsParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadTipsParamManager>();
	}
};
static_assert(alignof(ULoadTipsParamManager) == 0x000008, "Wrong alignment on ULoadTipsParamManager");
static_assert(sizeof(ULoadTipsParamManager) == 0x0000F0, "Wrong size on ULoadTipsParamManager");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsParams_) == 0x000028, "Member 'ULoadTipsParamManager::LoadTipsParams_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsBlockDataParamsM_) == 0x000038, "Member 'ULoadTipsParamManager::LoadTipsBlockDataParamsM_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsBlockDataParamsF_) == 0x000048, "Member 'ULoadTipsParamManager::LoadTipsBlockDataParamsF_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsBlockDataParamsCommon_) == 0x000058, "Member 'ULoadTipsParamManager::LoadTipsBlockDataParamsCommon_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, beforeSelectTipsID_) == 0x000068, "Member 'ULoadTipsParamManager::beforeSelectTipsID_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, GameInst_) == 0x000078, "Member 'ULoadTipsParamManager::GameInst_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, LoadTipsData_) == 0x000080, "Member 'ULoadTipsParamManager::LoadTipsData_' has a wrong offset!");
static_assert(offsetof(ULoadTipsParamManager, DisplayCount_) == 0x000088, "Member 'ULoadTipsParamManager::DisplayCount_' has a wrong offset!");

// Class BattlePrototype.MainEventLatentActor
// 0x0008 (0x0238 - 0x0230)
class AMainEventLatentActor final : public AActor
{
public:
	uint8                                         Pad_23BA[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainEventLatentActor">();
	}
	static class AMainEventLatentActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMainEventLatentActor>();
	}
};
static_assert(alignof(AMainEventLatentActor) == 0x000008, "Wrong alignment on AMainEventLatentActor");
static_assert(sizeof(AMainEventLatentActor) == 0x000238, "Wrong size on AMainEventLatentActor");

// Class BattlePrototype.ManagerInterface
// 0x0000 (0x0028 - 0x0028)
class IManagerInterface final : public IInterface
{
public:
	void DelayBeginPlay();
	bool FinalizeManager(EManagerProcTiming Timing);
	bool InitializeManager(EManagerProcTiming Timing);
	bool IsNeedFrameWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManagerInterface">();
	}
	static class IManagerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IManagerInterface>();
	}
};
static_assert(alignof(IManagerInterface) == 0x000008, "Wrong alignment on IManagerInterface");
static_assert(sizeof(IManagerInterface) == 0x000028, "Wrong size on IManagerInterface");

// Class BattlePrototype.MapGimmickManager
// 0x0108 (0x0338 - 0x0230)
class AMapGimmickManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_23BB[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBeginOverlapMapGimmickAreaEvent;                 // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndOverlapMapGimmickAreaEvent;                   // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExecMapGimmickEvent;                             // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeFinishedMapGimmickEvent;                   // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeReuseStartMapGimmickEvent;                 // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FString>                         FinishedGimmickNames;                              // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         AllMapGimmicks;                                    // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGimmickTriggerVolume*>          AllTriggerVolumes;                                 // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AMapGimmickObject*>              ActivatedMapGimmicks;                              // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMovingRoadActor>               MovingActors;                                      // 0x02C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint8>                                 LiftFloorList;                                     // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EMapGimmickType, int32>                  GimmickUseTimeMap;                                 // 0x02E8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	bool ActivateMapGimmick(class AMapGimmickObject* Map_gimmick);
	bool AddMapGimmickUseTime(class AMapGimmickObject* Gimmick);
	bool CallOnBeginOverlapMapGimmickAreaEvent(class AMapGimmickObject* Map_gimmick);
	bool CallOnChangeFinishedMapGimmickEvent(class AMapGimmickObject* Map_gimmick);
	bool CallOnChangeReuseStartMapGimmickEvent(class AMapGimmickObject* Map_gimmick);
	bool CallOnEndOverlapMapGimmickAreaEvent(class AMapGimmickObject* Map_gimmick);
	bool CallOnExecMapGimmickEvent(class AMapGimmickObject* Map_gimmick);
	bool CanChargeMapGimmick(class AMapGimmickObject* Map_gimmick);
	bool DeactivateMapGimmick(class AMapGimmickObject* Map_gimmick);
	int32 GetLiftFloor(ELiftFloorInfoId ID);
	int32 GetMapGimmickUseTime(EMapGimmickType Type);
	void InitializeAreaData();
	void InitializeAtAreaStart();
	void OnBeginOverlapMovingRoad(class AActor* Actor, class AActor* RoadActor);
	void OnEndOverlapMovingRoad(class AActor* Actor, class AActor* RoadActor);
	void RegisterMapGimmick(class AActor* Actor);
	bool RequestToMapGimmick(EMapGimmickStateRequest Request, class AMapGimmickObject* Map_gimmick);
	void SetLiftFloor(ELiftFloorInfoId ID, int32 Floor);
	void UnregisterMapGimmick(class AActor* Actor);

	bool IsActivatedMapGimmick(class AMapGimmickObject* Map_gimmick) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapGimmickManager">();
	}
	static class AMapGimmickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapGimmickManager>();
	}
};
static_assert(alignof(AMapGimmickManager) == 0x000008, "Wrong alignment on AMapGimmickManager");
static_assert(sizeof(AMapGimmickManager) == 0x000338, "Wrong size on AMapGimmickManager");
static_assert(offsetof(AMapGimmickManager, OnBeginOverlapMapGimmickAreaEvent) == 0x000238, "Member 'AMapGimmickManager::OnBeginOverlapMapGimmickAreaEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, OnEndOverlapMapGimmickAreaEvent) == 0x000248, "Member 'AMapGimmickManager::OnEndOverlapMapGimmickAreaEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, OnExecMapGimmickEvent) == 0x000258, "Member 'AMapGimmickManager::OnExecMapGimmickEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, OnChangeFinishedMapGimmickEvent) == 0x000268, "Member 'AMapGimmickManager::OnChangeFinishedMapGimmickEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, OnChangeReuseStartMapGimmickEvent) == 0x000278, "Member 'AMapGimmickManager::OnChangeReuseStartMapGimmickEvent' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, FinishedGimmickNames) == 0x000288, "Member 'AMapGimmickManager::FinishedGimmickNames' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, AllMapGimmicks) == 0x000298, "Member 'AMapGimmickManager::AllMapGimmicks' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, AllTriggerVolumes) == 0x0002A8, "Member 'AMapGimmickManager::AllTriggerVolumes' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, ActivatedMapGimmicks) == 0x0002B8, "Member 'AMapGimmickManager::ActivatedMapGimmicks' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, MovingActors) == 0x0002C8, "Member 'AMapGimmickManager::MovingActors' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, LiftFloorList) == 0x0002D8, "Member 'AMapGimmickManager::LiftFloorList' has a wrong offset!");
static_assert(offsetof(AMapGimmickManager, GimmickUseTimeMap) == 0x0002E8, "Member 'AMapGimmickManager::GimmickUseTimeMap' has a wrong offset!");

// Class BattlePrototype.REDImage
// 0x00D8 (0x02E8 - 0x0210)
class UREDImage final : public UImage
{
public:
	uint8                                         Pad_23CB[0x8];                                     // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FlagMouse;                                         // 0x0218(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CC[0x3];                                     // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MouseHitOffsetPos;                                 // 0x021C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetSize;                                // 0x0224(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitDisp;                                 // 0x022C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CD[0x3];                                     // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRedMouseArgument                      MouseCallArgument;                                 // 0x0230(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CE[0x4];                                     // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_ImageFocusMouse;                                 // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_ImageUnFocusMouse;                               // 0x0250(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_ImageDownMouse;                                  // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bIsStartTick;                                      // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CF[0x17];                                    // 0x0271(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIBase>                 M_ParentUIBase;                                    // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugDraw;                                       // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGeometry                              M_geometry;                                        // 0x0298(0x0038)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorPixel;                                       // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorSize;                                        // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorPos;                                         // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CheckCircle();
	bool CheckCircleCore(const struct FVector2D& Position);
	bool CheckRectangle();
	bool CheckRectangleCore(const struct FVector2D& Position);
	struct FVector2D GetAbsolutePosition();
	struct FVector2D GetAbsoluteSize();
	void RedImageDown__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedImageFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedImageUnFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void SetMouseDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);
	void SetMouseMode(bool Mousemode, int32 InputLevel);
	void SetParentUIBase(class UUIBase* PUiBase);

	bool GetMouseDisable() const;
	int32 GetMouseInputLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDImage">();
	}
	static class UREDImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDImage>();
	}
};
static_assert(alignof(UREDImage) == 0x000008, "Wrong alignment on UREDImage");
static_assert(sizeof(UREDImage) == 0x0002E8, "Wrong size on UREDImage");
static_assert(offsetof(UREDImage, FlagMouse) == 0x000218, "Member 'UREDImage::FlagMouse' has a wrong offset!");
static_assert(offsetof(UREDImage, MouseHitOffsetPos) == 0x00021C, "Member 'UREDImage::MouseHitOffsetPos' has a wrong offset!");
static_assert(offsetof(UREDImage, MouseHitOffsetSize) == 0x000224, "Member 'UREDImage::MouseHitOffsetSize' has a wrong offset!");
static_assert(offsetof(UREDImage, DebugMouseHitDisp) == 0x00022C, "Member 'UREDImage::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDImage, MouseCallArgument) == 0x000230, "Member 'UREDImage::MouseCallArgument' has a wrong offset!");
static_assert(offsetof(UREDImage, M_ImageFocusMouse) == 0x000240, "Member 'UREDImage::M_ImageFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDImage, M_ImageUnFocusMouse) == 0x000250, "Member 'UREDImage::M_ImageUnFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDImage, M_ImageDownMouse) == 0x000260, "Member 'UREDImage::M_ImageDownMouse' has a wrong offset!");
static_assert(offsetof(UREDImage, bIsStartTick) == 0x000270, "Member 'UREDImage::bIsStartTick' has a wrong offset!");
static_assert(offsetof(UREDImage, M_ParentUIBase) == 0x000288, "Member 'UREDImage::M_ParentUIBase' has a wrong offset!");
static_assert(offsetof(UREDImage, M_DebugDraw) == 0x000290, "Member 'UREDImage::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UREDImage, M_geometry) == 0x000298, "Member 'UREDImage::M_geometry' has a wrong offset!");
static_assert(offsetof(UREDImage, VectorPixel) == 0x0002D0, "Member 'UREDImage::VectorPixel' has a wrong offset!");
static_assert(offsetof(UREDImage, VectorSize) == 0x0002D8, "Member 'UREDImage::VectorSize' has a wrong offset!");
static_assert(offsetof(UREDImage, VectorPos) == 0x0002E0, "Member 'UREDImage::VectorPos' has a wrong offset!");

// Class BattlePrototype.MapGimmickObject
// 0x03F0 (0x0620 - 0x0230)
class AMapGimmickObject : public AActor
{
public:
	uint8                                         Pad_23D6[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AMapGimmickManager*                     MapGimmickManager;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapGimmickType                               MapGimmickType;                                    // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D7[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             StateDefineTable;                                  // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InitialStateName;                                  // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseWeightGauge;                                    // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseBossGauge;                                      // 0x0261(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverlapBroadcastToPlayer;                        // 0x0262(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUseGimmickFlag;                                 // 0x0263(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D8[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ModelRootComponent;                                // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentStateName;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentStateStep;                                  // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D9[0x4];                                     // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMapGimmickState                       CurrentState;                                      // 0x0280(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         TimeInState;                                       // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeTimeToActivate;                              // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeCancelingTime;                               // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PsychicCost;                                       // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentChargeTime;                                 // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialChargeTime;                                 // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAdjustPlaceInCharge;                             // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DA[0x3];                                     // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LengthPlaceInCharge;                               // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAdjustPlaceInFinish;                             // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DB[0x3];                                     // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LengthPlaceInFinish;                               // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePlayerTick;                                     // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DC[0x7];                                     // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             PlayerCaptureAnimationInfoDataTable;               // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerCaptureLeftAnimationInfoDataTable;           // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerFinishAnimationInfoDataTable;                // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerKasaneCaptureRightAnimationInfoDataTable;    // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerKasaneCaptureLeftAnimationInfoDataTable;     // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerKasaneFinishAnimationInfoDataTable;          // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHCCollisionCommonInfo                 CollisionInfo;                                     // 0x0328(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FHCSkillCommonInfo                     CollisionSkillInfo;                                // 0x0398(0x00F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FMapGimmickState>               States;                                            // 0x0488(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMapGimmickStateLevelSequence> StateLevelSequences;                               // 0x0498(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, class ARSLevelSequenceActor*> LevelSequenceActors;                               // 0x04E8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsSearchable;                                      // 0x0538(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSearchUnique;                                    // 0x0539(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSearchMapGimmick;                                // 0x053A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInForceIconArea;                                 // 0x053B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInLimitIconArea;                                 // 0x053C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCanceling;                                       // 0x053D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x053E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSetupSequencePlay;                               // 0x053F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             PlayerTransBeforeSequence;                         // 0x0540(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             CameraTransBeforeSequence;                         // 0x0570(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             CameraTransAfterSequence;                          // 0x05A0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ActivateCameraBeginInterpSec;                      // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23DD[0x4];                                     // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ActivateCameraBeginInterpCurve;                    // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsEndPlaybackcameraSequence;                       // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23DE[0x3];                                     // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateCameraEndInterpSec;                        // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ActivateCameraEndInterpCurve;                      // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsNeedTick;                                        // 0x05F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCharging;                                        // 0x05F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUsing;                                           // 0x05F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExplodeNeedTick;                                   // 0x05F3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPlayerInVolume;                                  // 0x05F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFinished;                                        // 0x05F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanReuse;                                          // 0x05F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsFailedByEnemy;                                   // 0x05F7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGimmickTriggerVolume*>          HitVolumes;                                        // 0x05F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AGimmickTriggerVolume>   LastHitVolume;                                     // 0x0608(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMapGimmickFinishDir                          LastHitVolumeDir;                                  // 0x0610(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _CanActivate;                                      // 0x0611(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          StateNeedTick;                                     // 0x0612(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AlreadyExplode;                                    // 0x0613(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsDelayUpdateIconVisible;                          // 0x0614(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ToBeIconVisible;                                   // 0x0615(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23DF[0xA];                                     // 0x0616(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CallbackUseThisGimmick(class AMapGimmickObject* Gimmick);
	bool CallFunctionByName(class FName StateName, float DeltaTime, EMapGimmickStatusFunc Func_0);
	bool CallStateBeginFunction(class FName StateName);
	bool CallStateCancelFunction(class FName StateName);
	bool CallStateEndFunction(class FName StateName);
	bool CallStateTickFunction(float DeltaTime, class FName StateName);
	bool CanCharge();
	class FName ChangeState(class FName StateName);
	class FName ChangeToNextInCancelState();
	class FName ChangeToNextState();
	void CustomDelay(class UObject* WorldContextObject_, float Duration, const struct FLatentActionInfo& LatentInfo_);
	float GetCaptureMovementScale(EPlayerID Player);
	float GetFinishMovementScale(EPlayerID Player);
	class UAnimMontage* GetPlayerCancelAnimation(EPlayerCaptureAnimPattern Pattern, EPlayerID Player);
	float GetPlayerCustomDilation();
	float GetPlayerDeltaSecond();
	class UAnimMontage* GetPlayerEndAnimation(EPlayerCaptureAnimPattern Pattern, EPlayerID Player);
	class UAnimMontage* GetPlayerLoopAnimation(EPlayerCaptureAnimPattern Pattern, EPlayerID Player);
	class UAnimMontage* GetPlayerStartAnimation(EPlayerCaptureAnimPattern Pattern, EPlayerID Player);
	const struct FMapGimmickState GetStateByName(class FName StateName);
	void InitializeGimmickStatus();
	bool IsActive();
	bool OnBeginForceIconVisibleOverlap();
	void OnBeginOverlapCallback(class AGimmickTriggerVolume* Volume, class AActor* OverlappedActor, class AActor* OtherActor);
	bool OnBeginTriggerVolumeOverlap();
	bool OnBeginUseLimitIconVisibleOverlap();
	void OnChangeGimmickState(class FName StateName);
	bool OnEndForceIconVisibleOverlap();
	void OnEndOverlapCallback(class AGimmickTriggerVolume* Volume, class AActor* OverlappedActor, class AActor* OtherActor);
	bool OnEndTriggerVolumeOverlap();
	bool OnEndUseLimitIconVisibleOverlap();
	void OnStateBeginFunction(class FName StateName);
	void OnStateEndFunction(class FName StateName);
	void PartnerOnBeginOverlapCallback(class AGimmickTriggerVolume* Volume, class AActor* OverlappedActor, class AActor* OtherActor, ERSPartyPlayerKind PlayerId);
	bool PartnerOnBeginTriggerVolumeOverlap(ERSPartyPlayerKind PlayerId, class AGimmickTriggerVolume* Volume);
	void PartnerOnEndOverlapCallback(class AGimmickTriggerVolume* Volume, class AActor* OverlappedActor, class AActor* OtherActor, ERSPartyPlayerKind PlayerId);
	bool PartnerOnEndTriggerVolumeOverlap(ERSPartyPlayerKind PlayerId, class AGimmickTriggerVolume* Volume);
	bool RequestChangeState(EMapGimmickStateRequest Type);
	void ResetChargeTime();
	bool SetActive(bool Active);
	void SetAlreadyExplode(bool Explode);
	bool SetAttackCollisionActive(bool Active);
	void SetCanActivate(bool CanActivate);
	void SetEnableAttackCollision(bool Enable);
	void SetEnablePhysics(bool Enable);
	void SetEnablePhysicsPerBone(class USkeletalMeshComponent* SkeletalMesh, class FName BoneName, bool Enable);
	void SetExplosionNeedTick(bool Need);
	bool SetIconGaugeEnableProxy(bool Enable);
	bool SetIconVisible(bool Visible, bool IsSuccess, bool IsCancel);
	void SetIsFinished(bool Finished);
	bool SetLimitIconVisible(bool Visible, bool Limit, bool IsSuccess);
	bool SetNeedTick(bool Need);
	void SetStateNeedTick(bool Need);
	void SetUsing(bool Using);
	bool UpdateWidgetGauge();

	bool CanActivate() const;
	bool CanAddDriveGauge() const;
	class UPrimitiveComponent* GetAttackCollisionPrimitive() const;
	class USceneComponent* GetIconComponent() const;
	struct FVector GetIconPosition() const;
	bool GetIsFinished() const;
	class USceneComponent* GetLookAtComponent() const;
	struct FVector GetLookAtPosition() const;
	class FName GetNextCancelStateName() const;
	class FName GetNextStateName() const;
	class USceneComponent* GetPlayerLookAtComponent() const;
	struct FVector GetPlayerLookAtPosition() const;
	class UPrimitiveComponent* GetPrimitive() const;
	float GetPsychicCost() const;
	bool OnMapGimmickChargeCancel(class AMapGimmickObject* GimmickActor) const;
	bool OnMapGimmickChargeEnd(class AMapGimmickObject* GimmickActor) const;
	bool OnMapGimmickChargeStart(class AMapGimmickObject* GimmickActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapGimmickObject">();
	}
	static class AMapGimmickObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapGimmickObject>();
	}
};
static_assert(alignof(AMapGimmickObject) == 0x000010, "Wrong alignment on AMapGimmickObject");
static_assert(sizeof(AMapGimmickObject) == 0x000620, "Wrong size on AMapGimmickObject");
static_assert(offsetof(AMapGimmickObject, MapGimmickManager) == 0x000240, "Member 'AMapGimmickObject::MapGimmickManager' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, MapGimmickType) == 0x000248, "Member 'AMapGimmickObject::MapGimmickType' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, StateDefineTable) == 0x000250, "Member 'AMapGimmickObject::StateDefineTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, InitialStateName) == 0x000258, "Member 'AMapGimmickObject::InitialStateName' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, UseWeightGauge) == 0x000260, "Member 'AMapGimmickObject::UseWeightGauge' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, UseBossGauge) == 0x000261, "Member 'AMapGimmickObject::UseBossGauge' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsOverlapBroadcastToPlayer) == 0x000262, "Member 'AMapGimmickObject::IsOverlapBroadcastToPlayer' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CanUseGimmickFlag) == 0x000263, "Member 'AMapGimmickObject::CanUseGimmickFlag' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ModelRootComponent) == 0x000268, "Member 'AMapGimmickObject::ModelRootComponent' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CurrentStateName) == 0x000270, "Member 'AMapGimmickObject::CurrentStateName' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CurrentStateStep) == 0x000278, "Member 'AMapGimmickObject::CurrentStateStep' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CurrentState) == 0x000280, "Member 'AMapGimmickObject::CurrentState' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, TimeInState) == 0x0002C8, "Member 'AMapGimmickObject::TimeInState' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ChargeTimeToActivate) == 0x0002CC, "Member 'AMapGimmickObject::ChargeTimeToActivate' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ChargeCancelingTime) == 0x0002D0, "Member 'AMapGimmickObject::ChargeCancelingTime' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PsychicCost) == 0x0002D4, "Member 'AMapGimmickObject::PsychicCost' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CurrentChargeTime) == 0x0002D8, "Member 'AMapGimmickObject::CurrentChargeTime' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, InitialChargeTime) == 0x0002DC, "Member 'AMapGimmickObject::InitialChargeTime' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsAdjustPlaceInCharge) == 0x0002E0, "Member 'AMapGimmickObject::IsAdjustPlaceInCharge' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LengthPlaceInCharge) == 0x0002E4, "Member 'AMapGimmickObject::LengthPlaceInCharge' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsAdjustPlaceInFinish) == 0x0002E8, "Member 'AMapGimmickObject::IsAdjustPlaceInFinish' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LengthPlaceInFinish) == 0x0002EC, "Member 'AMapGimmickObject::LengthPlaceInFinish' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, UsePlayerTick) == 0x0002F0, "Member 'AMapGimmickObject::UsePlayerTick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerCaptureAnimationInfoDataTable) == 0x0002F8, "Member 'AMapGimmickObject::PlayerCaptureAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerCaptureLeftAnimationInfoDataTable) == 0x000300, "Member 'AMapGimmickObject::PlayerCaptureLeftAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerFinishAnimationInfoDataTable) == 0x000308, "Member 'AMapGimmickObject::PlayerFinishAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerKasaneCaptureRightAnimationInfoDataTable) == 0x000310, "Member 'AMapGimmickObject::PlayerKasaneCaptureRightAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerKasaneCaptureLeftAnimationInfoDataTable) == 0x000318, "Member 'AMapGimmickObject::PlayerKasaneCaptureLeftAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerKasaneFinishAnimationInfoDataTable) == 0x000320, "Member 'AMapGimmickObject::PlayerKasaneFinishAnimationInfoDataTable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CollisionInfo) == 0x000328, "Member 'AMapGimmickObject::CollisionInfo' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CollisionSkillInfo) == 0x000398, "Member 'AMapGimmickObject::CollisionSkillInfo' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, States) == 0x000488, "Member 'AMapGimmickObject::States' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, StateLevelSequences) == 0x000498, "Member 'AMapGimmickObject::StateLevelSequences' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LevelSequenceActors) == 0x0004E8, "Member 'AMapGimmickObject::LevelSequenceActors' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsSearchable) == 0x000538, "Member 'AMapGimmickObject::IsSearchable' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsSearchUnique) == 0x000539, "Member 'AMapGimmickObject::IsSearchUnique' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsSearchMapGimmick) == 0x00053A, "Member 'AMapGimmickObject::IsSearchMapGimmick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsInForceIconArea) == 0x00053B, "Member 'AMapGimmickObject::IsInForceIconArea' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsInLimitIconArea) == 0x00053C, "Member 'AMapGimmickObject::IsInLimitIconArea' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsCanceling) == 0x00053D, "Member 'AMapGimmickObject::IsCanceling' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, bIsActive) == 0x00053E, "Member 'AMapGimmickObject::bIsActive' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsSetupSequencePlay) == 0x00053F, "Member 'AMapGimmickObject::IsSetupSequencePlay' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, PlayerTransBeforeSequence) == 0x000540, "Member 'AMapGimmickObject::PlayerTransBeforeSequence' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CameraTransBeforeSequence) == 0x000570, "Member 'AMapGimmickObject::CameraTransBeforeSequence' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CameraTransAfterSequence) == 0x0005A0, "Member 'AMapGimmickObject::CameraTransAfterSequence' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ActivateCameraBeginInterpSec) == 0x0005D0, "Member 'AMapGimmickObject::ActivateCameraBeginInterpSec' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ActivateCameraBeginInterpCurve) == 0x0005D8, "Member 'AMapGimmickObject::ActivateCameraBeginInterpCurve' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsEndPlaybackcameraSequence) == 0x0005E0, "Member 'AMapGimmickObject::IsEndPlaybackcameraSequence' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ActivateCameraEndInterpSec) == 0x0005E4, "Member 'AMapGimmickObject::ActivateCameraEndInterpSec' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ActivateCameraEndInterpCurve) == 0x0005E8, "Member 'AMapGimmickObject::ActivateCameraEndInterpCurve' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsNeedTick) == 0x0005F0, "Member 'AMapGimmickObject::IsNeedTick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsCharging) == 0x0005F1, "Member 'AMapGimmickObject::IsCharging' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsUsing) == 0x0005F2, "Member 'AMapGimmickObject::IsUsing' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ExplodeNeedTick) == 0x0005F3, "Member 'AMapGimmickObject::ExplodeNeedTick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsPlayerInVolume) == 0x0005F4, "Member 'AMapGimmickObject::IsPlayerInVolume' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsFinished) == 0x0005F5, "Member 'AMapGimmickObject::IsFinished' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, CanReuse) == 0x0005F6, "Member 'AMapGimmickObject::CanReuse' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsFailedByEnemy) == 0x0005F7, "Member 'AMapGimmickObject::IsFailedByEnemy' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, HitVolumes) == 0x0005F8, "Member 'AMapGimmickObject::HitVolumes' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LastHitVolume) == 0x000608, "Member 'AMapGimmickObject::LastHitVolume' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, LastHitVolumeDir) == 0x000610, "Member 'AMapGimmickObject::LastHitVolumeDir' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, _CanActivate) == 0x000611, "Member 'AMapGimmickObject::_CanActivate' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, StateNeedTick) == 0x000612, "Member 'AMapGimmickObject::StateNeedTick' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, AlreadyExplode) == 0x000613, "Member 'AMapGimmickObject::AlreadyExplode' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, IsDelayUpdateIconVisible) == 0x000614, "Member 'AMapGimmickObject::IsDelayUpdateIconVisible' has a wrong offset!");
static_assert(offsetof(AMapGimmickObject, ToBeIconVisible) == 0x000615, "Member 'AMapGimmickObject::ToBeIconVisible' has a wrong offset!");

// Class BattlePrototype.MapIconData
// 0x0000 (0x0028 - 0x0028)
class UMapIconData final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapIconData">();
	}
	static class UMapIconData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapIconData>();
	}
};
static_assert(alignof(UMapIconData) == 0x000008, "Wrong alignment on UMapIconData");
static_assert(sizeof(UMapIconData) == 0x000028, "Wrong size on UMapIconData");

// Class BattlePrototype.REDRetainerBox
// 0x0000 (0x0158 - 0x0158)
class UREDRetainerBox final : public URetainerBox
{
public:
	void SetPhase(int32 _phase);
	void SetPhaseCount(int32 _count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDRetainerBox">();
	}
	static class UREDRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDRetainerBox>();
	}
};
static_assert(alignof(UREDRetainerBox) == 0x000008, "Wrong alignment on UREDRetainerBox");
static_assert(sizeof(UREDRetainerBox) == 0x000158, "Wrong size on UREDRetainerBox");

// Class BattlePrototype.MapIconExporter
// 0x00C0 (0x02F0 - 0x0230)
class AMapIconExporter final : public AActor
{
public:
	uint8                                         Pad_23F7[0xC0];                                    // 0x0230(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CurrentArrangeIcon();
	void CurrentMapIcon(int32 LocationId, int32 AreaId);
	void ExportArrangeIconJson();
	void ExportMapIconJson();
	void StartupArrangeItemAtCurrentBegin();
	void StartupMapIconAtCurrentBegin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapIconExporter">();
	}
	static class AMapIconExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapIconExporter>();
	}
};
static_assert(alignof(AMapIconExporter) == 0x000008, "Wrong alignment on AMapIconExporter");
static_assert(sizeof(AMapIconExporter) == 0x0002F0, "Wrong size on AMapIconExporter");

// Class BattlePrototype.MaterialAccessorCompLibrary
// 0x0000 (0x0028 - 0x0028)
class UMaterialAccessorCompLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void SetupMeshListMACParametersNative(class UObject* WorldContextObject, const TArray<class UMeshComponent*>& MeshComps, const TArray<struct FMACVariableFloat>& MACScalars, const TArray<EMaterialAccessorSetupID>& MACScalarSetupIDs, const TArray<struct FMACVariableVector>& MACVectors, const TArray<EMaterialAccessorSetupID>& MACVectorSetupIDs);
	static void SetupMeshMACParametersNative(class UObject* WorldContextObject, class UMeshComponent* MeshComp, const TArray<struct FMACVariableFloat>& MACScalars, const TArray<EMaterialAccessorSetupID>& MACScalarSetupIDs, const TArray<struct FMACVariableVector>& MACVectors, const TArray<EMaterialAccessorSetupID>& MACVectorSetupIDs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialAccessorCompLibrary">();
	}
	static class UMaterialAccessorCompLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialAccessorCompLibrary>();
	}
};
static_assert(alignof(UMaterialAccessorCompLibrary) == 0x000008, "Wrong alignment on UMaterialAccessorCompLibrary");
static_assert(sizeof(UMaterialAccessorCompLibrary) == 0x000028, "Wrong size on UMaterialAccessorCompLibrary");

// Class BattlePrototype.REDWidgetUtility
// 0x0000 (0x0028 - 0x0028)
class UREDWidgetUtility final : public UBlueprintFunctionLibrary
{
public:
	static void ClearFontAtlas();
	static void ConvertButtonIconPlatform(class UImage* Image);
	static void ConvertImagePathPlatformName(class UImage* Image);
	static void CopyHorizontalBoxProperty(class UHorizontalBox* Source, class UHorizontalBox* Dest);
	static void CopyImageProperty(class UImage* Source, class UImage* Dest);
	static void CopyOverlayProperty(class UOverlay* Source, class UOverlay* Dest);
	static void CopySlotProperty(class UWidget* Source, class UWidget* Dest);
	static void CopySpacerProperty(class USpacer* Source, class USpacer* Dest);
	static void CopyTextBlockProperty(class UTextBlock* Source, class UTextBlock* Dest);
	static void CreateWidgetRED(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetType, class UUserWidget*& Output);
	static void GetAbsolutePosition(class UWidget* Widget, float* X, float* Y);
	static struct FVector2D GetAbsolutePositionVector2D(class UWidget* Widget);
	static void GetAbsoluteScreenOfffset(const class UObject* WorldContextObject, const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	static void GetDesiredSizeWithPrepass(class UWidget* Widget, float* Width, float* Height);
	static class UInvalidationBox* GetFirstInvalidationBox(class UUserWidget* Widget);
	static EPlayerID GetMainPlayerID(const class UObject* WorldContextObject);
	static void GetRelativePosition(class UWidget* Widget, float* X, float* Y);
	static struct FVector2D GetRelativePositionVector2D(class UWidget* Widget);
	static void GetScreenOffset(const class UObject* WorldContextObject, const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	static void GetScreenOffsetReverse(const class UObject* WorldContextObject, const struct FVector2D& baseOffset, struct FVector2D* CalcOffset);
	static void GetViewportOffset(const class UObject* WorldContextObject, const struct FVector2D& AbsolutePosition, struct FVector2D* CalcOffset);
	static bool IsEnableCrashVision(const class UObject* WorldContextObject);
	static bool IsEnableKarenEpisode(const class UObject* WorldContextObject);
	static bool IsEnableNexusDrive(const class UObject* WorldContextObject);
	static bool IsManualDrive(const class UObject* WorldContextObject);
	static bool IsPlayingVisionSimulator(const class UObject* WorldContextObject);
	static bool IsSpoiler(const class UObject* WorldContextObject, const class FName& ItemId);
	static bool IsYuitoMode(const class UObject* WorldContextObject);
	static void ProjectWorldToScreen2(const class UObject* WorldContextObject, const struct FVector& WorldPosition, struct FVector2D* ScreenPosition);
	static void SetCurrentLocationAreaName(const class UObject* WorldObject, int32 LocationNo, int32 AreaNo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDWidgetUtility">();
	}
	static class UREDWidgetUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDWidgetUtility>();
	}
};
static_assert(alignof(UREDWidgetUtility) == 0x000008, "Wrong alignment on UREDWidgetUtility");
static_assert(sizeof(UREDWidgetUtility) == 0x000028, "Wrong size on UREDWidgetUtility");

// Class BattlePrototype.MaterialStealthParam
// 0x0010 (0x0040 - 0x0030)
class UMaterialStealthParam final : public UDataAsset
{
public:
	int32                                         SampleFrame;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelaySec;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2401[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialStealthParam">();
	}
	static class UMaterialStealthParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialStealthParam>();
	}
};
static_assert(alignof(UMaterialStealthParam) == 0x000008, "Wrong alignment on UMaterialStealthParam");
static_assert(sizeof(UMaterialStealthParam) == 0x000040, "Wrong size on UMaterialStealthParam");
static_assert(offsetof(UMaterialStealthParam, SampleFrame) == 0x000030, "Member 'UMaterialStealthParam::SampleFrame' has a wrong offset!");
static_assert(offsetof(UMaterialStealthParam, InterpSpeed) == 0x000034, "Member 'UMaterialStealthParam::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UMaterialStealthParam, DelaySec) == 0x000038, "Member 'UMaterialStealthParam::DelaySec' has a wrong offset!");

// Class BattlePrototype.RSMaterialSwitchLibrary
// 0x0000 (0x0028 - 0x0028)
class URSMaterialSwitchLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearMaterialSwitchCache(struct FMaterialSwitchCache& MaterialCache);
	static void ClearSwitchMaterialLayerIDs(struct FMaterialSwitchCache& MaterialCache, const TArray<int32>& LayerIDs);
	static bool RestoreSwitchMaterial(struct FMaterialSwitchCache& MaterialCache, int32 RestoreNum);
	static void RestoreSwitchMaterialLayerIDs(struct FMaterialSwitchCache& MaterialCache, const TArray<int32>& LayerIDs, bool ClearCache);
	static void SwitchMaterial(struct FMaterialSwitchCache& MaterialCache, class UPrimitiveComponent* Primitive, class UMaterialInterface* NewMaterial, int32* LayerID);
	static void SwitchMaterialExclude(struct FMaterialSwitchCache& MaterialCache, class UPrimitiveComponent* Primitive, const TArray<class FName>& ExcludeMaterialSlots, class UMaterialInterface* NewMaterial, int32* LayerID);
	static void SwitchMaterialExcludeLayerID(struct FMaterialSwitchCache& MaterialCache, int32 LayerID, class UPrimitiveComponent* Primitive, const TArray<class FName>& ExcludeMaterialSlots, class UMaterialInterface* NewMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMaterialSwitchLibrary">();
	}
	static class URSMaterialSwitchLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSMaterialSwitchLibrary>();
	}
};
static_assert(alignof(URSMaterialSwitchLibrary) == 0x000008, "Wrong alignment on URSMaterialSwitchLibrary");
static_assert(sizeof(URSMaterialSwitchLibrary) == 0x000028, "Wrong size on URSMaterialSwitchLibrary");

// Class BattlePrototype.MessageHudManager
// 0x0040 (0x0270 - 0x0230)
class AMessageHudManager final : public AActor
{
public:
	uint8                                         Pad_2407[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         M_swapTagArray;                                    // 0x0238(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETextGender                                   M_textGender;                                      // 0x0248(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2408[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_pluralTagArray;                                  // 0x0250(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 M_ordinalTagArray;                                 // 0x0260(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClearAllTag();
	int32 DrawMessage(int32 WindowType, const class FString& MessageTableName, const class FString& MessageLabel, class FName RipSyncBoardJointID, bool Skipable, float DrawSecond, bool IsSkipVoiceEnd, bool IsVoiceOnlyMessage, bool IsWaitMode);
	void GetMessageDataCellFromLabel(struct FMessageDataCell* MessageDataCell, const class FString& MessageLabel, const class FString& MessageTable);
	void GetMessageFromLabel(class FString* Message, const class FString& MessageLabel, const class FString& MessageTable);
	bool GetMessageTableName(class FString* MessageTableName, const class UObject* Object);
	void PreLoadAllVoice(const class FString& MessageTableName);
	void SetGenderTag(const ETextGender& TextGender);
	bool SetMessageTableName(const class FString& MessageTableName, class UObject* Object);
	void SetOrdinalTag(int32 Param_Index, int32 Value);
	void SetOrdinalTagArray(const TArray<int32>& ValueArray);
	void SetPluralTag(int32 Param_Index, int32 Value);
	void SetPluralTagArray(const TArray<int32>& ValueArray);
	void SetSwapTag(int32 Param_Index, const class FString& String);
	void SetSwapTagArray(const TArray<class FString>& StringArray);

	bool CheckEndAllMessage(bool FlagCheckClose) const;
	bool CheckEndMessage(int32 MessageIndex) const;
	int32 GetChoiceResult(int32 MessageIndex) const;
	int32 GetLastChoiceResult() const;
	const TArray<int32> GetOrdinalTagArray() const;
	const TArray<int32> GetPluralTagArray() const;
	const TArray<class FString> GetSwapTagArray() const;
	ETextGender GetTextGender() const;
	void SkipMessage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageHudManager">();
	}
	static class AMessageHudManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMessageHudManager>();
	}
};
static_assert(alignof(AMessageHudManager) == 0x000008, "Wrong alignment on AMessageHudManager");
static_assert(sizeof(AMessageHudManager) == 0x000270, "Wrong size on AMessageHudManager");
static_assert(offsetof(AMessageHudManager, M_swapTagArray) == 0x000238, "Member 'AMessageHudManager::M_swapTagArray' has a wrong offset!");
static_assert(offsetof(AMessageHudManager, M_textGender) == 0x000248, "Member 'AMessageHudManager::M_textGender' has a wrong offset!");
static_assert(offsetof(AMessageHudManager, M_pluralTagArray) == 0x000250, "Member 'AMessageHudManager::M_pluralTagArray' has a wrong offset!");
static_assert(offsetof(AMessageHudManager, M_ordinalTagArray) == 0x000260, "Member 'AMessageHudManager::M_ordinalTagArray' has a wrong offset!");

// Class BattlePrototype.REDOverlay
// 0x00D8 (0x0208 - 0x0130)
class UREDOverlay final : public UOverlay
{
public:
	uint8                                         Pad_2410[0x8];                                     // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FlagMouse;                                         // 0x0138(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2411[0x3];                                     // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRedMouseArgument                      MouseCallArgument;                                 // 0x013C(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetPos;                                 // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetSize;                                // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitDisp;                                 // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2412[0x7];                                     // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_OverlayFocusMouse;                               // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_OverlayUnFocusMouse;                             // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_OverlayDownMouse;                                // 0x0180(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          bIsStartTick;                                      // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2413[0x17];                                    // 0x0191(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIBase>                 M_ParentUIBase;                                    // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugDraw;                                       // 0x01B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGeometry                              M_geometry;                                        // 0x01B8(0x0038)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorPixel;                                       // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorSize;                                        // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              VectorPos;                                         // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CheckCircle();
	bool CheckCircleCore(const struct FVector2D& Position);
	bool CheckRectangle();
	bool CheckRectangleCore(const struct FVector2D& Position);
	struct FVector2D GetAbsolutePosition();
	struct FVector2D GetAbsoluteSize();
	void RedOverlayDown__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedOverlayFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedOverlayUnFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void SetMouseDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);
	void SetMouseMode(bool Mousemode, int32 InputLevel);
	void SetParentUIBase(class UUIBase* PUiBase);

	bool GetMouseDisable() const;
	int32 GetMouseInputLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDOverlay">();
	}
	static class UREDOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDOverlay>();
	}
};
static_assert(alignof(UREDOverlay) == 0x000008, "Wrong alignment on UREDOverlay");
static_assert(sizeof(UREDOverlay) == 0x000208, "Wrong size on UREDOverlay");
static_assert(offsetof(UREDOverlay, FlagMouse) == 0x000138, "Member 'UREDOverlay::FlagMouse' has a wrong offset!");
static_assert(offsetof(UREDOverlay, MouseCallArgument) == 0x00013C, "Member 'UREDOverlay::MouseCallArgument' has a wrong offset!");
static_assert(offsetof(UREDOverlay, MouseHitOffsetPos) == 0x000148, "Member 'UREDOverlay::MouseHitOffsetPos' has a wrong offset!");
static_assert(offsetof(UREDOverlay, MouseHitOffsetSize) == 0x000150, "Member 'UREDOverlay::MouseHitOffsetSize' has a wrong offset!");
static_assert(offsetof(UREDOverlay, DebugMouseHitDisp) == 0x000158, "Member 'UREDOverlay::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_OverlayFocusMouse) == 0x000160, "Member 'UREDOverlay::M_OverlayFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_OverlayUnFocusMouse) == 0x000170, "Member 'UREDOverlay::M_OverlayUnFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_OverlayDownMouse) == 0x000180, "Member 'UREDOverlay::M_OverlayDownMouse' has a wrong offset!");
static_assert(offsetof(UREDOverlay, bIsStartTick) == 0x000190, "Member 'UREDOverlay::bIsStartTick' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_ParentUIBase) == 0x0001A8, "Member 'UREDOverlay::M_ParentUIBase' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_DebugDraw) == 0x0001B0, "Member 'UREDOverlay::M_DebugDraw' has a wrong offset!");
static_assert(offsetof(UREDOverlay, M_geometry) == 0x0001B8, "Member 'UREDOverlay::M_geometry' has a wrong offset!");
static_assert(offsetof(UREDOverlay, VectorPixel) == 0x0001F0, "Member 'UREDOverlay::VectorPixel' has a wrong offset!");
static_assert(offsetof(UREDOverlay, VectorSize) == 0x0001F8, "Member 'UREDOverlay::VectorSize' has a wrong offset!");
static_assert(offsetof(UREDOverlay, VectorPos) == 0x000200, "Member 'UREDOverlay::VectorPos' has a wrong offset!");

// Class BattlePrototype.MessageViewerBase
// 0x0070 (0x02A0 - 0x0230)
class AMessageViewerBase final : public AActor
{
public:
	TWeakObjectPtr<class UDataTable>              SettingDataTable;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETextLanguage                                 CurrentLanguage;                                   // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241A[0x3];                                     // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentCategory;                                   // 0x023C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241B[0x4];                                     // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentFileName;                                   // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurrentLabel;                                      // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETextLanguage>                         LanguageList;                                      // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMsgViewerData>                 DataFileList;                                      // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           MessageLabelList;                                  // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMsgViewerLoadedData                   LoadedData;                                        // 0x0290(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_241C[0x4];                                     // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateFileListBySetting(ETextLanguage Language, class FName Setting);
	void CreateLabelList(const class FString& DispName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageViewerBase">();
	}
	static class AMessageViewerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMessageViewerBase>();
	}
};
static_assert(alignof(AMessageViewerBase) == 0x000008, "Wrong alignment on AMessageViewerBase");
static_assert(sizeof(AMessageViewerBase) == 0x0002A0, "Wrong size on AMessageViewerBase");
static_assert(offsetof(AMessageViewerBase, SettingDataTable) == 0x000230, "Member 'AMessageViewerBase::SettingDataTable' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, CurrentLanguage) == 0x000238, "Member 'AMessageViewerBase::CurrentLanguage' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, CurrentCategory) == 0x00023C, "Member 'AMessageViewerBase::CurrentCategory' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, CurrentFileName) == 0x000248, "Member 'AMessageViewerBase::CurrentFileName' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, CurrentLabel) == 0x000258, "Member 'AMessageViewerBase::CurrentLabel' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, LanguageList) == 0x000260, "Member 'AMessageViewerBase::LanguageList' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, DataFileList) == 0x000270, "Member 'AMessageViewerBase::DataFileList' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, MessageLabelList) == 0x000280, "Member 'AMessageViewerBase::MessageLabelList' has a wrong offset!");
static_assert(offsetof(AMessageViewerBase, LoadedData) == 0x000290, "Member 'AMessageViewerBase::LoadedData' has a wrong offset!");

// Class BattlePrototype.MoveImpulseComponent
// 0x0040 (0x0100 - 0x00C0)
class UMoveImpulseComponent final : public UActorComponent
{
public:
	bool                                          _isDebugDraw;                                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241E[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _decSpeed;                                         // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _claimantName;                                     // 0x00C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _nowVelocity;                                      // 0x00D0(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _oldLocation;                                      // 0x00DC(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241F[0x18];                                    // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMoveImpulseComponent* GetMoveImpulseComponent(class AActor* Actor);

	void SetImpulse(const struct FVector& Velocity);
	void UpdateFlying();
	void UpdateFunction(float DeltaTime);

	struct FVector GetVelocity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveImpulseComponent">();
	}
	static class UMoveImpulseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveImpulseComponent>();
	}
};
static_assert(alignof(UMoveImpulseComponent) == 0x000008, "Wrong alignment on UMoveImpulseComponent");
static_assert(sizeof(UMoveImpulseComponent) == 0x000100, "Wrong size on UMoveImpulseComponent");
static_assert(offsetof(UMoveImpulseComponent, _isDebugDraw) == 0x0000C0, "Member 'UMoveImpulseComponent::_isDebugDraw' has a wrong offset!");
static_assert(offsetof(UMoveImpulseComponent, _decSpeed) == 0x0000C4, "Member 'UMoveImpulseComponent::_decSpeed' has a wrong offset!");
static_assert(offsetof(UMoveImpulseComponent, _claimantName) == 0x0000C8, "Member 'UMoveImpulseComponent::_claimantName' has a wrong offset!");
static_assert(offsetof(UMoveImpulseComponent, _nowVelocity) == 0x0000D0, "Member 'UMoveImpulseComponent::_nowVelocity' has a wrong offset!");
static_assert(offsetof(UMoveImpulseComponent, _oldLocation) == 0x0000DC, "Member 'UMoveImpulseComponent::_oldLocation' has a wrong offset!");

// Class BattlePrototype.MoveInputComponent
// 0x0068 (0x0128 - 0x00C0)
class UMoveInputComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2420[0x68];                                    // 0x00C0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearInputVector();
	void SetFixCamera(bool bFix);
	void UpdateMoveInputVector(float AxisValueX, float AxisValueY);

	struct FVector CalcInputWorldVector() const;
	struct FVector CalcWorldVector(const struct FVector& Dir) const;
	struct FVector GetLatestEnableInputDir() const;
	struct FVector GetLatestEnableInputVector() const;
	struct FVector GetLatestEnableInputWorldVector() const;
	struct FVector GetMoveInputDir() const;
	float GetMoveInputLengthTriggerLimit() const;
	struct FVector GetMoveInputVector() const;
	bool IsFixCamera() const;
	bool IsInputOverLimit(float LimitRate) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveInputComponent">();
	}
	static class UMoveInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveInputComponent>();
	}
};
static_assert(alignof(UMoveInputComponent) == 0x000008, "Wrong alignment on UMoveInputComponent");
static_assert(sizeof(UMoveInputComponent) == 0x000128, "Wrong size on UMoveInputComponent");

// Class BattlePrototype.RSAccountManager
// 0x01E8 (0x0220 - 0x0038)
class URSAccountManager : public URSTickableManagerBase
{
public:
	uint8                                         Pad_2422[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_UserAccountID;                                   // 0x0048(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_AssumedDefaultUserAccountID;                     // 0x0058(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isFirstButtonPushCheck;                          // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isFirstCheckSuccessed;                           // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isInvalidPairingCheck;                           // 0x006A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2423[0x1];                                     // 0x006B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_DelayCounter;                                    // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDebugInvalidXB1ProfileCheck;                    // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDebugTickOutputLog;                             // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2424[0x16];                                    // 0x0072(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             XboxFirstConnectEvent;                             // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             XboxChangeAccountEvent;                            // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             XboxCuttingAccountEvent;                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             XboxReconnectAccountEvent;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             XboxConnectFromInvalidIndexEvent;                  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2425[0x148];                                   // 0x00D8(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool FirstButtonPushCheck();
	bool FirstCheckUserAccount();
	class FString GetControllerProfileID(const int32 _ControllerId);
	int32 GetLocalPlayerControllerID();
	class FString GetLocalPlayerProfileID(const int32 _LocalPlayerIndex);
	class FString GetLocalPlayerUserID();
	void GetLocalPlayerUserInfo();
	void OnAccountChange(const class FString& PrevAccountId, const class FString& NowAccountId);
	void OnAccountConnectFromInvalidIndex(int32 ControllerId, const class FString& AccountId);
	void OnAccountCutting(const class FString& AccountId);
	void OnAccountReconnect(const class FString& AccountId);
	void OnFirstConnect(const class FString& AccountId);
	bool OpenLoginUI(bool IsFirst);
	void OutputAllLoginProfileID();
	void OutputControllerInfo();
	void OutputDebugInfo();
	void OutputLocalPlayerInfo();
	bool RequestFirstSignIn();
	void ResetAccount();
	void SetActiveAllController(const int32 _ControllerId);
	void SetCheckAccountInvalidBitFlag(ECheckAccountFlag Flag, const bool IsInvalid);
	void Test_XboxOneGetUserID();
	bool UpdateController();
	bool UpdateUserAccountID();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAccountManager">();
	}
	static class URSAccountManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAccountManager>();
	}
};
static_assert(alignof(URSAccountManager) == 0x000008, "Wrong alignment on URSAccountManager");
static_assert(sizeof(URSAccountManager) == 0x000220, "Wrong size on URSAccountManager");
static_assert(offsetof(URSAccountManager, _gameInstance) == 0x000040, "Member 'URSAccountManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_UserAccountID) == 0x000048, "Member 'URSAccountManager::M_UserAccountID' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_AssumedDefaultUserAccountID) == 0x000058, "Member 'URSAccountManager::M_AssumedDefaultUserAccountID' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_isFirstButtonPushCheck) == 0x000068, "Member 'URSAccountManager::M_isFirstButtonPushCheck' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_isFirstCheckSuccessed) == 0x000069, "Member 'URSAccountManager::M_isFirstCheckSuccessed' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_isInvalidPairingCheck) == 0x00006A, "Member 'URSAccountManager::M_isInvalidPairingCheck' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_DelayCounter) == 0x00006C, "Member 'URSAccountManager::M_DelayCounter' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_bDebugInvalidXB1ProfileCheck) == 0x000070, "Member 'URSAccountManager::M_bDebugInvalidXB1ProfileCheck' has a wrong offset!");
static_assert(offsetof(URSAccountManager, M_bDebugTickOutputLog) == 0x000071, "Member 'URSAccountManager::M_bDebugTickOutputLog' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxFirstConnectEvent) == 0x000088, "Member 'URSAccountManager::XboxFirstConnectEvent' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxChangeAccountEvent) == 0x000098, "Member 'URSAccountManager::XboxChangeAccountEvent' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxCuttingAccountEvent) == 0x0000A8, "Member 'URSAccountManager::XboxCuttingAccountEvent' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxReconnectAccountEvent) == 0x0000B8, "Member 'URSAccountManager::XboxReconnectAccountEvent' has a wrong offset!");
static_assert(offsetof(URSAccountManager, XboxConnectFromInvalidIndexEvent) == 0x0000C8, "Member 'URSAccountManager::XboxConnectFromInvalidIndexEvent' has a wrong offset!");

// Class BattlePrototype.MovementPropertyInterface
// 0x0000 (0x0028 - 0x0028)
class IMovementPropertyInterface final : public IInterface
{
public:
	bool ClearFlyingForceInterface();
	bool ClearFlyingInterface(const class FName& ClaimantName);
	bool SetFlyingInterface(const class FName& ClaimantName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementPropertyInterface">();
	}
	static class IMovementPropertyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovementPropertyInterface>();
	}
};
static_assert(alignof(IMovementPropertyInterface) == 0x000008, "Wrong alignment on IMovementPropertyInterface");
static_assert(sizeof(IMovementPropertyInterface) == 0x000028, "Wrong size on IMovementPropertyInterface");

// Class BattlePrototype.MovementPropertyMediator
// 0x0280 (0x0340 - 0x00C0)
class UMovementPropertyMediator final : public UActorComponent
{
public:
	float                                         ActionSpeedRateMin;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxWalkSpeed;                               // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxFlySpeed;                                // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedRateMin;                               // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedRateMax;                               // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defaultStepStartSpeed;                            // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _defaultStepDeclaration;                           // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _stepSpeedRateMin;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _stepSpeedRateMax;                                 // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_242B[0x4];                                     // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             OwnerCharacter;                                    // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            OwnerMovement;                                     // 0x00F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_242C[0x248];                                   // 0x00F8(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMovementPropertyMediator* GetMovementPropertyMediatorComponentFromActor(class AActor* Actor);

	void ClearActionSpeedRate(const class FName& ClaimantName);
	void ClearFlying(const class FName& ClaimantName);
	void ClearFlyingForce();
	void ClearMaxFlySpeedRate(const class FName& ClaimantName);
	void ClearMaxWalkSpeedRate(const class FName& ClaimantName);
	void ClearMovementCollisionIgnorePawn(const class FName& ClaimantName);
	void ClearStepSpeedRate(const class FName& ClaimantName);
	void DisableMovement(const class FName& ClaimantName);
	void EnableMovement(const class FName& ClaimantName);
	void SetActionSpeedRate(const class FName& ClaimantName, float SpeedRate);
	void SetFlying(const class FName& ClaimantName);
	void SetMaxFlySpeed(const class FName& ClaimantName, float Speed);
	void SetMaxFlySpeedRate(const class FName& ClaimantName, float Rate);
	void SetMaxWalkSpeed(const class FName& ClaimantName, float Speed);
	void SetMaxWalkSpeedRate(const class FName& ClaimantName, float Rate);
	void SetMovementCollisionIgnorePawn(const class FName& ClaimantName);
	void SetStepSpeedRate(const class FName& ClaimantName, float Rate);

	float CalcDistanceToGround() const;
	bool CheckTouchGround() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementPropertyMediator">();
	}
	static class UMovementPropertyMediator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementPropertyMediator>();
	}
};
static_assert(alignof(UMovementPropertyMediator) == 0x000008, "Wrong alignment on UMovementPropertyMediator");
static_assert(sizeof(UMovementPropertyMediator) == 0x000340, "Wrong size on UMovementPropertyMediator");
static_assert(offsetof(UMovementPropertyMediator, ActionSpeedRateMin) == 0x0000C0, "Member 'UMovementPropertyMediator::ActionSpeedRateMin' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, DefaultMaxWalkSpeed) == 0x0000C4, "Member 'UMovementPropertyMediator::DefaultMaxWalkSpeed' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, DefaultMaxFlySpeed) == 0x0000C8, "Member 'UMovementPropertyMediator::DefaultMaxFlySpeed' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, MaxWalkSpeedRateMin) == 0x0000CC, "Member 'UMovementPropertyMediator::MaxWalkSpeedRateMin' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, MaxWalkSpeedRateMax) == 0x0000D0, "Member 'UMovementPropertyMediator::MaxWalkSpeedRateMax' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, _defaultStepStartSpeed) == 0x0000D4, "Member 'UMovementPropertyMediator::_defaultStepStartSpeed' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, _defaultStepDeclaration) == 0x0000D8, "Member 'UMovementPropertyMediator::_defaultStepDeclaration' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, _stepSpeedRateMin) == 0x0000DC, "Member 'UMovementPropertyMediator::_stepSpeedRateMin' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, _stepSpeedRateMax) == 0x0000E0, "Member 'UMovementPropertyMediator::_stepSpeedRateMax' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, OwnerCharacter) == 0x0000E8, "Member 'UMovementPropertyMediator::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UMovementPropertyMediator, OwnerMovement) == 0x0000F0, "Member 'UMovementPropertyMediator::OwnerMovement' has a wrong offset!");

// Class BattlePrototype.MovingRoadInterface
// 0x0000 (0x0028 - 0x0028)
class IMovingRoadInterface final : public IInterface
{
public:
	struct FTransform GetMovingRoadTransform(class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovingRoadInterface">();
	}
	static class IMovingRoadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovingRoadInterface>();
	}
};
static_assert(alignof(IMovingRoadInterface) == 0x000008, "Wrong alignment on IMovingRoadInterface");
static_assert(sizeof(IMovingRoadInterface) == 0x000028, "Wrong size on IMovingRoadInterface");

// Class BattlePrototype.REDStringUtility
// 0x0000 (0x0028 - 0x0028)
class UREDStringUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AutoScale(class UTextBlock* TextBlock, float Width);
	static ETextLanguage DecrementTextLanguageEnum(ETextLanguage OldLanguage);
	static ETextLanguage GetCurrentTextLanguageEnum();
	static class FString GetDateString(int32 Year, int32 Month, int32 Day);
	static struct FLinearColor GetFontColor(ETextColor TextColor);
	static class FString GetStringWithoutREDTag(class UObject* WorldObject, const class FString& Source);
	static class FString GetTextLanguageName(ETextLanguage Language);
	static ETextLanguage IncrementTextLanguageEnum(ETextLanguage OldLanguage);
	static bool IsFullCharacter(ETextLanguage Language);
	static void ReplaceOneCharacter(class FString& String, int32 Param_Index, const class FString& To);
	static void SetActionTagSingle(class UObject* PWorld, class UImage* IconImage, const class FString& ActionName);
	static void SetActionTagSingleBIG(class UObject* PWorld, class UImage* IconImage, const class FString& ActionName);
	static void SetActionTagSingleBIG_SupportUesKey(class UObject* PWorld, class UImage* IconImage, const class FString& ActionName, ERSGamepadInputName InputName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDStringUtility">();
	}
	static class UREDStringUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDStringUtility>();
	}
};
static_assert(alignof(UREDStringUtility) == 0x000008, "Wrong alignment on UREDStringUtility");
static_assert(sizeof(UREDStringUtility) == 0x000028, "Wrong size on UREDStringUtility");

// Class BattlePrototype.MultiLanguageTextData
// 0x0050 (0x0078 - 0x0028)
class UMultiLanguageTextData final : public UObject
{
public:
	TMap<ETextLanguage, class UTextData*>         TextDataMap;                                       // 0x0028(0x0050)(NativeAccessSpecifierPrivate)

public:
	class FString GetText(ETextLanguage LanguageID, class FName MessageID);
	bool LoadTexts();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiLanguageTextData">();
	}
	static class UMultiLanguageTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiLanguageTextData>();
	}
};
static_assert(alignof(UMultiLanguageTextData) == 0x000008, "Wrong alignment on UMultiLanguageTextData");
static_assert(sizeof(UMultiLanguageTextData) == 0x000078, "Wrong size on UMultiLanguageTextData");
static_assert(offsetof(UMultiLanguageTextData, TextDataMap) == 0x000028, "Member 'UMultiLanguageTextData::TextDataMap' has a wrong offset!");

// Class BattlePrototype.NexusDriveInterface
// 0x0000 (0x0028 - 0x0028)
class INexusDriveInterface final : public IInterface
{
public:
	float GetNexusDriveAccelerator_DamageRate();
	bool GetNexusDriveCombinationVisionCost(float* OutCost, E_SASKindNative SasKind);
	float GetNexusDriveMetal_DamageRate();
	bool GetNexusDrivePsychic_PsychicFieldDown(float* OutDown);
	bool GetNexusDriveStealth_AttackParam(float* OutCrashRate, float* OutKnockback, float* OutDown);
	bool GetNexusDriveTelepoAttackRate(float* OutDamageRate, float* OutCrashRate, float* OutWinceRate, float* OutKnockbackRate, float* OutDownRate, const struct FHCSkillCommonInfo& InSkill);
	bool GetNexusDriveTelepoDamageRateForJewelPool(float* OutCrashRate, float* OutWinceRate, float* OutKnockbackRate, float* OutDownRate, const struct FHCSkillCommonInfo& InSkill);
	bool IsActiveNexusDriveAny();
	bool IsActiveNexusDriveSas(E_SASKindNative Kind);
	bool IsRegisterActiveSasKindAny();
	bool IsRegisterNpcDriveForNexusDrive(EPlayerID PlayerId);
	void NexusDriveAttackHitRecovery(const struct FHCHitResult& HitResult, bool bCopyPlayer);
	void RegisterDelayDriveEnd(EPlayerID PlayerId);
	void RegisterNpcDriveForNexusDrive(EPlayerID PlayerId);
	void UnregisterDelayDriveEnd(EPlayerID PlayerId);
	void UnregisterNpcDriveForNexusDrive(EPlayerID PlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NexusDriveInterface">();
	}
	static class INexusDriveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INexusDriveInterface>();
	}
};
static_assert(alignof(INexusDriveInterface) == 0x000008, "Wrong alignment on INexusDriveInterface");
static_assert(sizeof(INexusDriveInterface) == 0x000028, "Wrong size on INexusDriveInterface");

// Class BattlePrototype.RSActorComponentPsychicObjectBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentPsychicObjectBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentPsychicObjectBase">();
	}
	static class URSActorComponentPsychicObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentPsychicObjectBase>();
	}
};
static_assert(alignof(URSActorComponentPsychicObjectBase) == 0x000008, "Wrong alignment on URSActorComponentPsychicObjectBase");
static_assert(sizeof(URSActorComponentPsychicObjectBase) == 0x0000C0, "Wrong size on URSActorComponentPsychicObjectBase");

// Class BattlePrototype.RSActorComponentPlayerBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentPlayerBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentPlayerBase">();
	}
	static class URSActorComponentPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentPlayerBase>();
	}
};
static_assert(alignof(URSActorComponentPlayerBase) == 0x000008, "Wrong alignment on URSActorComponentPlayerBase");
static_assert(sizeof(URSActorComponentPlayerBase) == 0x0000C0, "Wrong size on URSActorComponentPlayerBase");

// Class BattlePrototype.NpcHomingMoveComponent
// 0x00C0 (0x02C0 - 0x0200)
class UNpcHomingMoveComponent final : public USceneComponent
{
public:
	class USplineComponent*                       SplinePath;                                        // 0x0200(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        TargetShape;                                       // 0x0208(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPosition;                                    // 0x0210(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotOnTargetSpline;                                 // 0x021C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetEndPosition;                                 // 0x0228(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurRot;                                            // 0x0234(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               PrevRot;                                           // 0x0240(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurMoveSpeed;                                      // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurRotSpeed;                                       // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMoveSpeed;                                   // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRot;                                         // 0x0258(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetMoveVec;                                     // 0x0264(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalDistance;                                     // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathTotalDistance;                                 // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMoving;                                          // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTargetMoving;                                    // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_243D[0x2];                                     // 0x027A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundOffsetZ;                                     // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundTestDiff;                                    // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpTestDiff;                                        // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpTestForwardDistance;                             // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownTestForwardDistance;                           // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetStopDistance;                                // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDebug;                                           // 0x0294(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnSplineMove;                                    // 0x0295(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_243E[0x2];                                     // 0x0296(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplineMoveForwardDistance;                         // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineMoveUpDownSpeedMax;                          // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedSeconds;                                    // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFadingAsMovemet;                                 // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_243F[0x3];                                     // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TracingSpeherRadius;                               // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeCheckDistFront;                               // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopeCheckDistRear;                                // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadingInterpolateSeconds;                          // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2440[0x8];                                     // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceMove(float DistanceRate);
	void ResetNpcTransform();
	void SetElapsedTime(float Time);
	void SetSpline(class USplineComponent* Spline);
	void SetTargetPosition(const struct FVector& Target);
	void StartMove();
	void StopMove();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcHomingMoveComponent">();
	}
	static class UNpcHomingMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcHomingMoveComponent>();
	}
};
static_assert(alignof(UNpcHomingMoveComponent) == 0x000010, "Wrong alignment on UNpcHomingMoveComponent");
static_assert(sizeof(UNpcHomingMoveComponent) == 0x0002C0, "Wrong size on UNpcHomingMoveComponent");
static_assert(offsetof(UNpcHomingMoveComponent, SplinePath) == 0x000200, "Member 'UNpcHomingMoveComponent::SplinePath' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetShape) == 0x000208, "Member 'UNpcHomingMoveComponent::TargetShape' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetPosition) == 0x000210, "Member 'UNpcHomingMoveComponent::TargetPosition' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, RotOnTargetSpline) == 0x00021C, "Member 'UNpcHomingMoveComponent::RotOnTargetSpline' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetEndPosition) == 0x000228, "Member 'UNpcHomingMoveComponent::TargetEndPosition' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, CurRot) == 0x000234, "Member 'UNpcHomingMoveComponent::CurRot' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, PrevRot) == 0x000240, "Member 'UNpcHomingMoveComponent::PrevRot' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, CurMoveSpeed) == 0x00024C, "Member 'UNpcHomingMoveComponent::CurMoveSpeed' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, CurRotSpeed) == 0x000250, "Member 'UNpcHomingMoveComponent::CurRotSpeed' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetMoveSpeed) == 0x000254, "Member 'UNpcHomingMoveComponent::TargetMoveSpeed' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetRot) == 0x000258, "Member 'UNpcHomingMoveComponent::TargetRot' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetMoveVec) == 0x000264, "Member 'UNpcHomingMoveComponent::TargetMoveVec' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, LocalDistance) == 0x000270, "Member 'UNpcHomingMoveComponent::LocalDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, PathTotalDistance) == 0x000274, "Member 'UNpcHomingMoveComponent::PathTotalDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsMoving) == 0x000278, "Member 'UNpcHomingMoveComponent::IsMoving' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsTargetMoving) == 0x000279, "Member 'UNpcHomingMoveComponent::IsTargetMoving' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, GroundOffsetZ) == 0x00027C, "Member 'UNpcHomingMoveComponent::GroundOffsetZ' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, GroundTestDiff) == 0x000280, "Member 'UNpcHomingMoveComponent::GroundTestDiff' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, UpTestDiff) == 0x000284, "Member 'UNpcHomingMoveComponent::UpTestDiff' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, UpTestForwardDistance) == 0x000288, "Member 'UNpcHomingMoveComponent::UpTestForwardDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, DownTestForwardDistance) == 0x00028C, "Member 'UNpcHomingMoveComponent::DownTestForwardDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TargetStopDistance) == 0x000290, "Member 'UNpcHomingMoveComponent::TargetStopDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsDebug) == 0x000294, "Member 'UNpcHomingMoveComponent::IsDebug' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsOnSplineMove) == 0x000295, "Member 'UNpcHomingMoveComponent::IsOnSplineMove' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, SplineMoveForwardDistance) == 0x000298, "Member 'UNpcHomingMoveComponent::SplineMoveForwardDistance' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, SplineMoveUpDownSpeedMax) == 0x00029C, "Member 'UNpcHomingMoveComponent::SplineMoveUpDownSpeedMax' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, ElapsedSeconds) == 0x0002A0, "Member 'UNpcHomingMoveComponent::ElapsedSeconds' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, IsFadingAsMovemet) == 0x0002A4, "Member 'UNpcHomingMoveComponent::IsFadingAsMovemet' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, TracingSpeherRadius) == 0x0002A8, "Member 'UNpcHomingMoveComponent::TracingSpeherRadius' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, SlopeCheckDistFront) == 0x0002AC, "Member 'UNpcHomingMoveComponent::SlopeCheckDistFront' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, SlopeCheckDistRear) == 0x0002B0, "Member 'UNpcHomingMoveComponent::SlopeCheckDistRear' has a wrong offset!");
static_assert(offsetof(UNpcHomingMoveComponent, FadingInterpolateSeconds) == 0x0002B4, "Member 'UNpcHomingMoveComponent::FadingInterpolateSeconds' has a wrong offset!");

// Class BattlePrototype.RSAtomComponentBase
// 0x0040 (0x1250 - 0x1210)
class URSAtomComponentBase : public UAtomComponent
{
public:
	class AActor*                                 CreatorActor;                                      // 0x1210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalcSIWAttenuation;                               // 0x1218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2441[0x3];                                     // 0x1219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MSoundVolumeScale;                                 // 0x121C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundFadeState                               MFadeState;                                        // 0x1220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundActionOnFadeOutEnd                      MActionOnFadeOutEnd;                               // 0x1221(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2442[0x2];                                     // 0x1222(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MFadeTime;                                         // 0x1224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeTimer;                                        // 0x1228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeVolume;                                       // 0x122C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeStartVolume;                                  // 0x1230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MFadeFinishVolume;                                 // 0x1234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MSIWAttenuationRate;                               // 0x1238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MSkipAtSequencer;                                  // 0x123C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2443[0x3];                                     // 0x123D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class URSAtomComponentBase* AtomComp)> OnEndPlayAtom;                                     // 0x1240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	void _OnEndPlayAtom();
	void ChangeFade(float FadeTime);
	void Fade(float DeltaTime);
	bool GetAisacByName(const class FString& ControlName, float* Value);
	void Initialize();
	void PauseSound(float FadeTime, float FadeVolume);
	void PlaySound(const class UObject* WorldContextObject, class USoundAtomCue* NewSound, float StartTime, float FadeTime, float FadeVolume, EFilterCallbackType FilterCallbackType);
	void PlaySoundToPad(const class UObject* WorldContextObject, class USoundAtomCue* NewSound, float StartTime, float FadeTime, float FadeVolume, EFilterCallbackType FilterCallbackType);
	void ResumeSound(float FadeTime, float FadeVolume);
	void RSFadeIn(float FadeTime, float FadeVolume);
	void RSFadeOut(float FadeTime, float FadeVolume, ESoundActionOnFadeOutEnd ActionOnFadeOutEnd);
	void SetFadeParam(float FadeTime, float FadeFinishVolume);
	void SetSIWAttenuationRate(float AttenuationRate);
	void StopSound(float FadeTime, float FadeVolume);
	void UpdateVolume();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAtomComponentBase">();
	}
	static class URSAtomComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAtomComponentBase>();
	}
};
static_assert(alignof(URSAtomComponentBase) == 0x000010, "Wrong alignment on URSAtomComponentBase");
static_assert(sizeof(URSAtomComponentBase) == 0x001250, "Wrong size on URSAtomComponentBase");
static_assert(offsetof(URSAtomComponentBase, CreatorActor) == 0x001210, "Member 'URSAtomComponentBase::CreatorActor' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, bCalcSIWAttenuation) == 0x001218, "Member 'URSAtomComponentBase::bCalcSIWAttenuation' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MSoundVolumeScale) == 0x00121C, "Member 'URSAtomComponentBase::MSoundVolumeScale' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeState) == 0x001220, "Member 'URSAtomComponentBase::MFadeState' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MActionOnFadeOutEnd) == 0x001221, "Member 'URSAtomComponentBase::MActionOnFadeOutEnd' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeTime) == 0x001224, "Member 'URSAtomComponentBase::MFadeTime' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeTimer) == 0x001228, "Member 'URSAtomComponentBase::MFadeTimer' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeVolume) == 0x00122C, "Member 'URSAtomComponentBase::MFadeVolume' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeStartVolume) == 0x001230, "Member 'URSAtomComponentBase::MFadeStartVolume' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MFadeFinishVolume) == 0x001234, "Member 'URSAtomComponentBase::MFadeFinishVolume' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MSIWAttenuationRate) == 0x001238, "Member 'URSAtomComponentBase::MSIWAttenuationRate' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, MSkipAtSequencer) == 0x00123C, "Member 'URSAtomComponentBase::MSkipAtSequencer' has a wrong offset!");
static_assert(offsetof(URSAtomComponentBase, OnEndPlayAtom) == 0x001240, "Member 'URSAtomComponentBase::OnEndPlayAtom' has a wrong offset!");

// Class BattlePrototype.NpcSequencerActor
// 0x0030 (0x0330 - 0x0300)
class ANpcSequencerActor final : public ANpcSkeletalMeshActor
{
public:
	class UBoxComponent*                          BoundBoxComponent;                                 // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionHead;                                // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionHandLeft;                            // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionHandRight;                           // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionFootLeft;                            // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       BoundCollisionFootRight;                           // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcSequencerActor">();
	}
	static class ANpcSequencerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcSequencerActor>();
	}
};
static_assert(alignof(ANpcSequencerActor) == 0x000010, "Wrong alignment on ANpcSequencerActor");
static_assert(sizeof(ANpcSequencerActor) == 0x000330, "Wrong size on ANpcSequencerActor");
static_assert(offsetof(ANpcSequencerActor, BoundBoxComponent) == 0x000300, "Member 'ANpcSequencerActor::BoundBoxComponent' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionHead) == 0x000308, "Member 'ANpcSequencerActor::BoundCollisionHead' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionHandLeft) == 0x000310, "Member 'ANpcSequencerActor::BoundCollisionHandLeft' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionHandRight) == 0x000318, "Member 'ANpcSequencerActor::BoundCollisionHandRight' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionFootLeft) == 0x000320, "Member 'ANpcSequencerActor::BoundCollisionFootLeft' has a wrong offset!");
static_assert(offsetof(ANpcSequencerActor, BoundCollisionFootRight) == 0x000328, "Member 'ANpcSequencerActor::BoundCollisionFootRight' has a wrong offset!");

// Class BattlePrototype.RSActorComponentUIBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentUIBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentUIBase">();
	}
	static class URSActorComponentUIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentUIBase>();
	}
};
static_assert(alignof(URSActorComponentUIBase) == 0x000008, "Wrong alignment on URSActorComponentUIBase");
static_assert(sizeof(URSActorComponentUIBase) == 0x0000C0, "Wrong size on URSActorComponentUIBase");

// Class BattlePrototype.NpcSkeletalMeshComponent
// 0x0090 (0x0290 - 0x0200)
class UNpcSkeletalMeshComponent final : public USceneComponent
{
public:
	bool                                          bBeginPlaySetup;                                   // 0x0200(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2448[0x3];                                     // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NpcMeshDataTableID;                                // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NpcMaterialDataTableID;                            // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptimizeMergeMesh;                                // 0x020C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2449[0x3];                                     // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Body;                                              // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 BodyLower;                                         // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Face;                                              // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Hair;                                              // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>         Parts;                                             // 0x0230(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MeshDataTable;                                     // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MaterialDataTable;                                 // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MaterialSkeletonDataTable;                         // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcMeshSkeletonType                          SkeletonType;                                      // 0x0258(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244A[0x37];                                    // 0x0259(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetPartsMaxNum();

	void BeginPlaySetup();
	class USkeletalMeshComponent* GetAnimationComponent();
	class USkeletalMeshComponent* GetRootComponent();
	void GetValidSkeletalMeshComponents(TArray<class USkeletalMeshComponent*>* MeshComps);
	void ResetMaterial(int32 InNpcMaterialDataTableID);
	void ResetMesh(int32 InNpcMeshDataTableID);
	void SetHideOverlap(bool bHide, bool bOneFrame);
	void SetMaterialAmbToBaseSkin(float Value);
	void SetMaterialBaseToAmbSkin(float Value);
	void SetScalarArrayParameterValue(const TArray<class FName>& ParameterNames, const TArray<float>& ParameterValues);
	void SetScalarParameterValue(class FName ParameterName, float ParameterValue);
	void Setup(class AActor* Owner, int32 InNpcMeshDataTableID, class USkeletalMeshComponent* InBody, class USkeletalMeshComponent* InBodyLower, class USkeletalMeshComponent* InFace, class USkeletalMeshComponent* InHair, TArray<class USkeletalMeshComponent*>* InParts);
	void SetupLanding(float Height);
	void SetUseAttachParentBounds(bool IsUse);
	void SetVector4ArrayParameterValue(const TArray<class FName>& ParameterNames, const TArray<struct FLinearColor>& ParameterValues);
	void SetVector4ParameterValue(class FName ParameterName, const struct FLinearColor& ParameterValue);
	void SetVectorParameterValue(class FName ParameterName, const struct FVector& ParameterValue);

	class FString GetSkeletonName() const;
	ENpcMeshSkeletonType GetSkeletonType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcSkeletalMeshComponent">();
	}
	static class UNpcSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcSkeletalMeshComponent>();
	}
};
static_assert(alignof(UNpcSkeletalMeshComponent) == 0x000010, "Wrong alignment on UNpcSkeletalMeshComponent");
static_assert(sizeof(UNpcSkeletalMeshComponent) == 0x000290, "Wrong size on UNpcSkeletalMeshComponent");
static_assert(offsetof(UNpcSkeletalMeshComponent, bBeginPlaySetup) == 0x000200, "Member 'UNpcSkeletalMeshComponent::bBeginPlaySetup' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, NpcMeshDataTableID) == 0x000204, "Member 'UNpcSkeletalMeshComponent::NpcMeshDataTableID' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, NpcMaterialDataTableID) == 0x000208, "Member 'UNpcSkeletalMeshComponent::NpcMaterialDataTableID' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, bOptimizeMergeMesh) == 0x00020C, "Member 'UNpcSkeletalMeshComponent::bOptimizeMergeMesh' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, Body) == 0x000210, "Member 'UNpcSkeletalMeshComponent::Body' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, BodyLower) == 0x000218, "Member 'UNpcSkeletalMeshComponent::BodyLower' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, Face) == 0x000220, "Member 'UNpcSkeletalMeshComponent::Face' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, Hair) == 0x000228, "Member 'UNpcSkeletalMeshComponent::Hair' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, Parts) == 0x000230, "Member 'UNpcSkeletalMeshComponent::Parts' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, MeshDataTable) == 0x000240, "Member 'UNpcSkeletalMeshComponent::MeshDataTable' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, MaterialDataTable) == 0x000248, "Member 'UNpcSkeletalMeshComponent::MaterialDataTable' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, MaterialSkeletonDataTable) == 0x000250, "Member 'UNpcSkeletalMeshComponent::MaterialSkeletonDataTable' has a wrong offset!");
static_assert(offsetof(UNpcSkeletalMeshComponent, SkeletonType) == 0x000258, "Member 'UNpcSkeletalMeshComponent::SkeletonType' has a wrong offset!");

// Class BattlePrototype.RSActorUIBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorUIBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorUIBase">();
	}
	static class ARSActorUIBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorUIBase>();
	}
};
static_assert(alignof(ARSActorUIBase) == 0x000008, "Wrong alignment on ARSActorUIBase");
static_assert(sizeof(ARSActorUIBase) == 0x000230, "Wrong size on ARSActorUIBase");

// Class BattlePrototype.NpcDataParam
// 0x0010 (0x0040 - 0x0030)
class UNpcDataParam final : public UDataAsset
{
public:
	float                                         HeadLookAtClamp;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadLookAtFollowSpeed;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotTurnAngle;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionIcon2OffsetX;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcDataParam">();
	}
	static class UNpcDataParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNpcDataParam>();
	}
};
static_assert(alignof(UNpcDataParam) == 0x000008, "Wrong alignment on UNpcDataParam");
static_assert(sizeof(UNpcDataParam) == 0x000040, "Wrong size on UNpcDataParam");
static_assert(offsetof(UNpcDataParam, HeadLookAtClamp) == 0x000030, "Member 'UNpcDataParam::HeadLookAtClamp' has a wrong offset!");
static_assert(offsetof(UNpcDataParam, HeadLookAtFollowSpeed) == 0x000034, "Member 'UNpcDataParam::HeadLookAtFollowSpeed' has a wrong offset!");
static_assert(offsetof(UNpcDataParam, NotTurnAngle) == 0x000038, "Member 'UNpcDataParam::NotTurnAngle' has a wrong offset!");
static_assert(offsetof(UNpcDataParam, ActionIcon2OffsetX) == 0x00003C, "Member 'UNpcDataParam::ActionIcon2OffsetX' has a wrong offset!");

// Class BattlePrototype.RSAnimationFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSAnimationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* GetAnimBPGeneratedClassFromPath(class UObject* WorldContextObject, const class FString& Path, bool Load);
	static class UAnimationAsset* GetAnimSequenceFromPath(class UObject* WorldContextObject, const class FString& Path, bool Load, class AResourceManager* ResourceManager);
	static struct FVector GetBoneMoveForAnimSequence(class UAnimSequence* AnimSequence, int32 BoneIndex);
	static struct FTransform GetBoneTransformForAnimMontage(const class UAnimMontage* AnimMontage, float Time, int32 BoneIndex, bool bUseRawData);
	static struct FTransform GetBoneTransformForAnimSequence(const class UAnimSequence* AnimSequence, float Time, int32 BoneIndex, bool bUseRawData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAnimationFunctionLibrary">();
	}
	static class URSAnimationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAnimationFunctionLibrary>();
	}
};
static_assert(alignof(URSAnimationFunctionLibrary) == 0x000008, "Wrong alignment on URSAnimationFunctionLibrary");
static_assert(sizeof(URSAnimationFunctionLibrary) == 0x000028, "Wrong size on URSAnimationFunctionLibrary");

// Class BattlePrototype.NpcTownPeopleMob
// 0x0000 (0x03B0 - 0x03B0)
class ANpcTownPeopleMob final : public ANpcTownPeopleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NpcTownPeopleMob">();
	}
	static class ANpcTownPeopleMob* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANpcTownPeopleMob>();
	}
};
static_assert(alignof(ANpcTownPeopleMob) == 0x000010, "Wrong alignment on ANpcTownPeopleMob");
static_assert(sizeof(ANpcTownPeopleMob) == 0x0003B0, "Wrong size on ANpcTownPeopleMob");

// Class BattlePrototype.OnlineTestDestroySession
// 0x0048 (0x0078 - 0x0030)
class UOnlineTestDestroySession final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2450[0x28];                                    // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOnlineTestDestroySession* OnlineTestDestroySession(class UObject* WorldContextObject, class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestDestroySession">();
	}
	static class UOnlineTestDestroySession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineTestDestroySession>();
	}
};
static_assert(alignof(UOnlineTestDestroySession) == 0x000008, "Wrong alignment on UOnlineTestDestroySession");
static_assert(sizeof(UOnlineTestDestroySession) == 0x000078, "Wrong size on UOnlineTestDestroySession");
static_assert(offsetof(UOnlineTestDestroySession, OnSuccess) == 0x000030, "Member 'UOnlineTestDestroySession::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOnlineTestDestroySession, OnFailure) == 0x000040, "Member 'UOnlineTestDestroySession::OnFailure' has a wrong offset!");

// Class BattlePrototype.RSAjitoAnimInstance
// 0x0110 (0x0730 - 0x0620)
class URSAjitoAnimInstance : public UASAnimInstance
{
public:
	uint8                                         Pad_2451[0x8];                                     // 0x0620(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsWaitStateTransition;                             // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReadyToTransitionIdle;                           // 0x0629(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReadyToTransitionTalk;                           // 0x062A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAtInTalking;                                 // 0x062B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAt;                                          // 0x062C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseOverrideAnim;                                   // 0x062D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2452[0x2];                                     // 0x062E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtPoint;                                       // 0x0630(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsToTalkWaiting;                                   // 0x063C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsToIdleWaiting;                                   // 0x063D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberState                             CurrentState;                                      // 0x063E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberState                             RequestedState;                                    // 0x063F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberIdleStateType                     IdleState;                                         // 0x0640(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAjitoMemberTalkStateType                     TalkState;                                         // 0x0641(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2453[0x6];                                     // 0x0642(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAjitoMemberAnimInfo                   AnimInfo;                                          // 0x0648(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAjitoMemberInfo                       MemberInfo;                                        // 0x0698(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimSequence*                          OverrideAnim;                                      // 0x06D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASAnimationSet*                        AnimationSet;                                      // 0x06E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeHorizontal;                                     // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeVertical;                                       // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeBlendRate;                                      // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChangeStateImmediate;                            // 0x06F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsResetState;                                      // 0x06F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStartState;                                      // 0x06F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsIdleOnlyAction;                                  // 0x06F7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextAnimNo;                                        // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPresentEvent;                                    // 0x06FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2454[0x3];                                     // 0x06FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HeadRot;                                           // 0x0700(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsBoxNoDisp;                                       // 0x070C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseKawaiiPhysics;                                  // 0x070D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2455[0x2];                                     // 0x070E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FacialBlendWeight;                                 // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2456[0x4];                                     // 0x0714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _bEnableEyeControl;                                // 0x0718(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2457[0x8];                                     // 0x0728(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearWaitTransitionToIdle();
	void ClearWaitTransitionToTalk();
	bool EndTalking();
	bool InitializeInstance(const struct FAjitoMemberInfo& Info);
	void SetEyeControlEnable(bool bEnable, class FName ClaimantName);
	void SetEyeControlParameter(float Horizontal, float Vertical);
	void SetIsLookAt(bool Param_IsLookAt);
	bool StartTalking();
	void WaitTransitionToIdle(float WaitTime);
	void WaitTransitionToTalk(float WaitTime);

	class UAnimSequenceBase* GetCurrentASNodeAnimSequence() const;
	class FName GetCurrentASNodeAssetName() const;
	class AAjitoMember* GetOwningAjitoMember() const;
	bool IsWaitTransitionToIdle() const;
	bool IsWaitTransitionToTalk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAjitoAnimInstance">();
	}
	static class URSAjitoAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAjitoAnimInstance>();
	}
};
static_assert(alignof(URSAjitoAnimInstance) == 0x000010, "Wrong alignment on URSAjitoAnimInstance");
static_assert(sizeof(URSAjitoAnimInstance) == 0x000730, "Wrong size on URSAjitoAnimInstance");
static_assert(offsetof(URSAjitoAnimInstance, IsWaitStateTransition) == 0x000628, "Member 'URSAjitoAnimInstance::IsWaitStateTransition' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsReadyToTransitionIdle) == 0x000629, "Member 'URSAjitoAnimInstance::IsReadyToTransitionIdle' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsReadyToTransitionTalk) == 0x00062A, "Member 'URSAjitoAnimInstance::IsReadyToTransitionTalk' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsLookAtInTalking) == 0x00062B, "Member 'URSAjitoAnimInstance::IsLookAtInTalking' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsLookAt) == 0x00062C, "Member 'URSAjitoAnimInstance::IsLookAt' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, UseOverrideAnim) == 0x00062D, "Member 'URSAjitoAnimInstance::UseOverrideAnim' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, LookAtPoint) == 0x000630, "Member 'URSAjitoAnimInstance::LookAtPoint' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsToTalkWaiting) == 0x00063C, "Member 'URSAjitoAnimInstance::IsToTalkWaiting' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsToIdleWaiting) == 0x00063D, "Member 'URSAjitoAnimInstance::IsToIdleWaiting' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, CurrentState) == 0x00063E, "Member 'URSAjitoAnimInstance::CurrentState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, RequestedState) == 0x00063F, "Member 'URSAjitoAnimInstance::RequestedState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IdleState) == 0x000640, "Member 'URSAjitoAnimInstance::IdleState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, TalkState) == 0x000641, "Member 'URSAjitoAnimInstance::TalkState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, AnimInfo) == 0x000648, "Member 'URSAjitoAnimInstance::AnimInfo' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, MemberInfo) == 0x000698, "Member 'URSAjitoAnimInstance::MemberInfo' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, OverrideAnim) == 0x0006D8, "Member 'URSAjitoAnimInstance::OverrideAnim' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, AnimationSet) == 0x0006E0, "Member 'URSAjitoAnimInstance::AnimationSet' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, EyeHorizontal) == 0x0006E8, "Member 'URSAjitoAnimInstance::EyeHorizontal' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, EyeVertical) == 0x0006EC, "Member 'URSAjitoAnimInstance::EyeVertical' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, EyeBlendRate) == 0x0006F0, "Member 'URSAjitoAnimInstance::EyeBlendRate' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsChangeStateImmediate) == 0x0006F4, "Member 'URSAjitoAnimInstance::IsChangeStateImmediate' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsResetState) == 0x0006F5, "Member 'URSAjitoAnimInstance::IsResetState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsStartState) == 0x0006F6, "Member 'URSAjitoAnimInstance::IsStartState' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsIdleOnlyAction) == 0x0006F7, "Member 'URSAjitoAnimInstance::IsIdleOnlyAction' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, NextAnimNo) == 0x0006F8, "Member 'URSAjitoAnimInstance::NextAnimNo' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsPresentEvent) == 0x0006FC, "Member 'URSAjitoAnimInstance::IsPresentEvent' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, HeadRot) == 0x000700, "Member 'URSAjitoAnimInstance::HeadRot' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, IsBoxNoDisp) == 0x00070C, "Member 'URSAjitoAnimInstance::IsBoxNoDisp' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, UseKawaiiPhysics) == 0x00070D, "Member 'URSAjitoAnimInstance::UseKawaiiPhysics' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, FacialBlendWeight) == 0x000710, "Member 'URSAjitoAnimInstance::FacialBlendWeight' has a wrong offset!");
static_assert(offsetof(URSAjitoAnimInstance, _bEnableEyeControl) == 0x000718, "Member 'URSAjitoAnimInstance::_bEnableEyeControl' has a wrong offset!");

// Class BattlePrototype.OnlineTestJoinSession
// 0x0150 (0x0180 - 0x0030)
class UOnlineTestJoinSession final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_245A[0x130];                                   // 0x0050(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UOnlineTestJoinSession* OnlineTestJoinSession(class UObject* WorldContextObject, class APlayerController* PlayerController, const struct FBlueprintSessionResult& SearchResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestJoinSession">();
	}
	static class UOnlineTestJoinSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineTestJoinSession>();
	}
};
static_assert(alignof(UOnlineTestJoinSession) == 0x000008, "Wrong alignment on UOnlineTestJoinSession");
static_assert(sizeof(UOnlineTestJoinSession) == 0x000180, "Wrong size on UOnlineTestJoinSession");
static_assert(offsetof(UOnlineTestJoinSession, OnSuccess) == 0x000030, "Member 'UOnlineTestJoinSession::OnSuccess' has a wrong offset!");
static_assert(offsetof(UOnlineTestJoinSession, OnFailure) == 0x000040, "Member 'UOnlineTestJoinSession::OnFailure' has a wrong offset!");

// Class BattlePrototype.OnlineTestPlayerState
// 0x0008 (0x0338 - 0x0330)
class AOnlineTestPlayerState final : public APlayerState
{
public:
	struct FOnlineTestData                        TestData;                                          // 0x0330(0x0008)(BlueprintVisible, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)

public:
	void OnRep_SetTestData();
	void SetData(const struct FOnlineTestData& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineTestPlayerState">();
	}
	static class AOnlineTestPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnlineTestPlayerState>();
	}
};
static_assert(alignof(AOnlineTestPlayerState) == 0x000008, "Wrong alignment on AOnlineTestPlayerState");
static_assert(sizeof(AOnlineTestPlayerState) == 0x000338, "Wrong size on AOnlineTestPlayerState");
static_assert(offsetof(AOnlineTestPlayerState, TestData) == 0x000330, "Member 'AOnlineTestPlayerState::TestData' has a wrong offset!");

// Class BattlePrototype.OptimizeSwitchMaterialLibrary
// 0x0000 (0x0028 - 0x0028)
class UOptimizeSwitchMaterialLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EOptimizeMaterialCheckResultType CanUseOptimizeSwitchMaterialPlayerActor(class AActor* TargetActor, class USkeletalMeshComponent** TargetMeshComp);
	static EOptimizeMaterialCheckResultType CanUseOptimizeSwitchMaterialPlayerComp(class USkeletalMeshComponent* TargetComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptimizeSwitchMaterialLibrary">();
	}
	static class UOptimizeSwitchMaterialLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptimizeSwitchMaterialLibrary>();
	}
};
static_assert(alignof(UOptimizeSwitchMaterialLibrary) == 0x000008, "Wrong alignment on UOptimizeSwitchMaterialLibrary");
static_assert(sizeof(UOptimizeSwitchMaterialLibrary) == 0x000028, "Wrong size on UOptimizeSwitchMaterialLibrary");

// Class BattlePrototype.OutgameDebuggingManager
// 0x00C8 (0x02F8 - 0x0230)
class AOutgameDebuggingManager final : public AActor
{
public:
	uint8                                         Pad_245D[0x20];                                    // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnReadyDebugging;                                  // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EOutgameDebuggingPage                         Page;                                              // 0x0260(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245E[0x4F];                                    // 0x0261(0x004F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            DebuggingWidget;                                   // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDebuggingWidget*>               DebuggingTreeWidget;                               // 0x02B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOutgameDebuggingStartupObject*         StartupObject;                                     // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_245F[0x4];                                     // 0x02D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugAutoInputDelayTime;                           // 0x02D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDispRevision;                                // 0x02D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2460[0x1F];                                    // 0x02D9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AOutgameDebuggingManager* GetDebuggingManagerInstance(const class UObject* WorldContextObject);

	void BeginPageAjito();
	void BeginPageBattle();
	void BeginPageEnemy();
	void BeginPageEvent();
	void BeginPageParty();
	void BeginPagePlayer();
	void BeginPageRender();
	void BeginPageScene();
	void BeginPageSound();
	void BeginPageSystem();
	void BeginPageUI();
	void Dump();
	void EndPageAjito();
	void EndPageBattle();
	void EndPageEnemy();
	void EndPageEvent();
	void EndPageParty();
	void EndPagePlayer();
	void EndPageRender();
	void EndPageScene();
	void EndPageSound();
	void EndPageSystem();
	void EndPageUI();
	void ExportDebuggingItemText();
	void FinishWindow();
	class FString GetDebuggingText(const class FString& Key);
	class FString GetRevisionString();
	void LoadDebuggingParameter(bool IsBroadcast);
	void RegisterChild(EOutgameDebuggingPage InPage, class ADebuggingItemBase* InItem);
	void ResetDebuggingParameter();
	void SaveDebuggingParameter();
	class ADebuggingItemBase* SearchItem(EOutgameDebuggingPage InPage, const class FText& InHashName, bool InIgnoreCase);
	void SetDebugDispRevisions(bool IsDisp);
	void SetPage(EOutgameDebuggingPage InPage);
	void StartWindow();
	void TickPageAjito(float DeltaSeconds);
	void TickPageBattle(float DeltaSeconds);
	void TickPageEnemy(float DeltaSeconds);
	void TickPageEvent(float DeltaSeconds);
	void TickPageParty(float DeltaSeconds);
	void TickPagePlayer(float DeltaSeconds);
	void TickPageRender(float DeltaSeconds);
	void TickPageScene(float DeltaSeconds);
	void TickPageSound(float DeltaSeconds);
	void TickPageSystem(float DeltaSeconds);
	void TickPageUI(float DeltaSeconds);
	void UnregisterChildFromHashName(EOutgameDebuggingPage InPage, const class FText& InHashName);
	void UnregisterChildFromItem(EOutgameDebuggingPage InPage, class ADebuggingItemBase* InItem);

	bool DebugIsDispRevisions() const;
	bool IsReady() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutgameDebuggingManager">();
	}
	static class AOutgameDebuggingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOutgameDebuggingManager>();
	}
};
static_assert(alignof(AOutgameDebuggingManager) == 0x000008, "Wrong alignment on AOutgameDebuggingManager");
static_assert(sizeof(AOutgameDebuggingManager) == 0x0002F8, "Wrong size on AOutgameDebuggingManager");
static_assert(offsetof(AOutgameDebuggingManager, OnReadyDebugging) == 0x000250, "Member 'AOutgameDebuggingManager::OnReadyDebugging' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, Page) == 0x000260, "Member 'AOutgameDebuggingManager::Page' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, DebuggingWidget) == 0x0002B0, "Member 'AOutgameDebuggingManager::DebuggingWidget' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, DebuggingTreeWidget) == 0x0002B8, "Member 'AOutgameDebuggingManager::DebuggingTreeWidget' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, StartupObject) == 0x0002C8, "Member 'AOutgameDebuggingManager::StartupObject' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, DebugAutoInputDelayTime) == 0x0002D4, "Member 'AOutgameDebuggingManager::DebugAutoInputDelayTime' has a wrong offset!");
static_assert(offsetof(AOutgameDebuggingManager, bDebugDispRevision) == 0x0002D8, "Member 'AOutgameDebuggingManager::bDebugDispRevision' has a wrong offset!");

// Class BattlePrototype.OutgameDebuggingWindowInterface
// 0x0000 (0x0028 - 0x0028)
class IOutgameDebuggingWindowInterface final : public IInterface
{
public:
	void OnChangePage(EOutgameDebuggingPage NewPage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutgameDebuggingWindowInterface">();
	}
	static class IOutgameDebuggingWindowInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOutgameDebuggingWindowInterface>();
	}
};
static_assert(alignof(IOutgameDebuggingWindowInterface) == 0x000008, "Wrong alignment on IOutgameDebuggingWindowInterface");
static_assert(sizeof(IOutgameDebuggingWindowInterface) == 0x000028, "Wrong size on IOutgameDebuggingWindowInterface");

// Class BattlePrototype.BondsEpisodeDBAsset
// 0x0050 (0x0078 - 0x0028)
class UBondsEpisodeDBAsset final : public UObject
{
public:
	TMap<class FName, struct FBondsEpisodeDBDataCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BondsEpisodeDBAsset">();
	}
	static class UBondsEpisodeDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBondsEpisodeDBAsset>();
	}
};
static_assert(alignof(UBondsEpisodeDBAsset) == 0x000008, "Wrong alignment on UBondsEpisodeDBAsset");
static_assert(sizeof(UBondsEpisodeDBAsset) == 0x000078, "Wrong size on UBondsEpisodeDBAsset");
static_assert(offsetof(UBondsEpisodeDBAsset, DBMap) == 0x000028, "Member 'UBondsEpisodeDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.PauseUtility
// 0x0000 (0x0028 - 0x0028)
class UPauseUtility final : public UObject
{
public:
	static void DumpRedActorPauseSettings(const class UObject* WorldContextObject);
	static void GetRedPaused(const class UObject* WorldContextObject, int32* ReturnValue);
	static void SetRedPaused(const class UObject* WorldContextObject, int32 PauseFlag, bool bPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseUtility">();
	}
	static class UPauseUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseUtility>();
	}
};
static_assert(alignof(UPauseUtility) == 0x000008, "Wrong alignment on UPauseUtility");
static_assert(sizeof(UPauseUtility) == 0x000028, "Wrong size on UPauseUtility");

// Class BattlePrototype.PhantomBase
// 0x0020 (0x0650 - 0x0630)
class APhantomBase final : public AASCharacter
{
public:
	class UTeamComponent*                         Team;                                              // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHitCheckComponent*                     HitCheck;                                          // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHitCheckReceiverComponent*             HitCheckReceiver;                                  // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicMaterialControllerComponent*    DynamicMaterialController;                         // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2468[0x8];                                     // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnCustomAttackTimingNotified(class FName CustomName);
	void RecvOnEndMaterialFade(class FName ParameterName);
	void RecvOnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void StartMaterialFade(bool bFadeIn, float FadeSec);
	void StartPhantom(class UAnimMontage* Montage, float FadeInSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomBase">();
	}
	static class APhantomBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhantomBase>();
	}
};
static_assert(alignof(APhantomBase) == 0x000010, "Wrong alignment on APhantomBase");
static_assert(sizeof(APhantomBase) == 0x000650, "Wrong size on APhantomBase");
static_assert(offsetof(APhantomBase, Team) == 0x000628, "Member 'APhantomBase::Team' has a wrong offset!");
static_assert(offsetof(APhantomBase, HitCheck) == 0x000630, "Member 'APhantomBase::HitCheck' has a wrong offset!");
static_assert(offsetof(APhantomBase, HitCheckReceiver) == 0x000638, "Member 'APhantomBase::HitCheckReceiver' has a wrong offset!");
static_assert(offsetof(APhantomBase, DynamicMaterialController) == 0x000640, "Member 'APhantomBase::DynamicMaterialController' has a wrong offset!");

// Class BattlePrototype.PhantomSpawnerComponent
// 0x0000 (0x00C0 - 0x00C0)
class UPhantomSpawnerComponent final : public UActorComponent
{
public:
	static class UPhantomSpawnerComponent* GetPhantomSpawner(class AActor* Actor);

	class APhantomBase* SpawnPhantom(TSubclassOf<class APhantomBase> PhantomClass, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, class UAnimMontage* Montage, float FadeInSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhantomSpawnerComponent">();
	}
	static class UPhantomSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhantomSpawnerComponent>();
	}
};
static_assert(alignof(UPhantomSpawnerComponent) == 0x000008, "Wrong alignment on UPhantomSpawnerComponent");
static_assert(sizeof(UPhantomSpawnerComponent) == 0x0000C0, "Wrong size on UPhantomSpawnerComponent");

// Class BattlePrototype.PhotoModeCamera
// 0x00F0 (0x0AD0 - 0x09E0)
class APhotoModeCamera : public ACameraActor
{
public:
	float                                         MAX_SPEED_H;                                       // 0x09E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ACCELERATION_H;                                    // 0x09E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAX_SPEED_V;                                       // 0x09E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ACCELERATION_V;                                    // 0x09EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAX_ROTATE_SPEED;                                  // 0x09F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ACCELERATION_ROTATE;                               // 0x09F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAX_ANGLE_V;                                       // 0x09F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ROTATE_SPEED_ROLL;                                 // 0x09FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAX_ROTATE_ROLL;                                   // 0x0A00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAX_MOVE_RANGE;                                    // 0x0A04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MIN_FOV;                                           // 0x0A08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MAX_FOV;                                           // 0x0A0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV_ADD_VALUE;                                     // 0x0A10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RANGE_LIMIT_SLIDE_ANGLE;                           // 0x0A14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BACKGROUND_SLIDE_ANGLE;                            // 0x0A18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BACKGROUND_SLIDE_OFFSET;                           // 0x0A1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BACKGROUND_STEPUP_HEIGHT;                          // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_246E[0x4];                                     // 0x0A24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      DitherCapsuleComponent;                            // 0x0A28(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      HumanDitherCapsuleComponent;                       // 0x0A30(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_246F[0x58];                                    // 0x0A38(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DITHER_INTERP_TIME;                                // 0x0A90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DIR_DITHER_CHECK_RANGE_OFFSET;                     // 0x0A94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DIR_DITHER_CHECK_SCREEN_OFFSET_LEFT;               // 0x0A98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DIR_DITHER_CHECK_SCREEN_OFFSET_RIGHT;              // 0x0A9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DIR_DITHER_CHECK_SCREEN_OFFSET_TOP;                // 0x0AA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DIR_DITHER_CHECK_SCREEN_OFFSET_BOTTOM;             // 0x0AA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DirDitherDataTable;                                // 0x0AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPhotoModecDitherManageData>    DitherDataList;                                    // 0x0AB0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2470[0x10];                                    // 0x0AC0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCameraFov(float AddValue);
	void AddCameraRollAngle(float AddValue);
	void BeginPhotoCamera();
	void DebugDirDitherForceCheck(bool bUnder, bool bSpine);
	void DebugDisableDirDither(bool bSet);
	void DebugDisableOverlapDither(bool bSet);
	void DebugDrawDirDitherInfo(bool bSet);
	void DebugUseDebugParameter(bool bSet, float CheckAngle, float DitherAngle, float DistMin, float DistDefault, float DistMax, class FName SocketName);
	bool DoBeginPhotoCamera();
	bool DoEndPhotoCamera();
	void EndPhotoCamera();
	float GetCameraFov();
	float GetCameraFovMax();
	float GetCameraFovMin();
	float GetCameraRollAngle();
	float GetCameraRollAngleMax();
	float GetCameraRollAngleMin();
	float GetCollisionRadius();
	void OnBeginDitherOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndDitherOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void ResetCamera();
	void ResetFov();
	void ResetRollAngle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhotoModeCamera">();
	}
	static class APhotoModeCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhotoModeCamera>();
	}
};
static_assert(alignof(APhotoModeCamera) == 0x000010, "Wrong alignment on APhotoModeCamera");
static_assert(sizeof(APhotoModeCamera) == 0x000AD0, "Wrong size on APhotoModeCamera");
static_assert(offsetof(APhotoModeCamera, MAX_SPEED_H) == 0x0009E0, "Member 'APhotoModeCamera::MAX_SPEED_H' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, ACCELERATION_H) == 0x0009E4, "Member 'APhotoModeCamera::ACCELERATION_H' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, MAX_SPEED_V) == 0x0009E8, "Member 'APhotoModeCamera::MAX_SPEED_V' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, ACCELERATION_V) == 0x0009EC, "Member 'APhotoModeCamera::ACCELERATION_V' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, MAX_ROTATE_SPEED) == 0x0009F0, "Member 'APhotoModeCamera::MAX_ROTATE_SPEED' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, ACCELERATION_ROTATE) == 0x0009F4, "Member 'APhotoModeCamera::ACCELERATION_ROTATE' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, MAX_ANGLE_V) == 0x0009F8, "Member 'APhotoModeCamera::MAX_ANGLE_V' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, ROTATE_SPEED_ROLL) == 0x0009FC, "Member 'APhotoModeCamera::ROTATE_SPEED_ROLL' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, MAX_ROTATE_ROLL) == 0x000A00, "Member 'APhotoModeCamera::MAX_ROTATE_ROLL' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, MAX_MOVE_RANGE) == 0x000A04, "Member 'APhotoModeCamera::MAX_MOVE_RANGE' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, MIN_FOV) == 0x000A08, "Member 'APhotoModeCamera::MIN_FOV' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, MAX_FOV) == 0x000A0C, "Member 'APhotoModeCamera::MAX_FOV' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, FOV_ADD_VALUE) == 0x000A10, "Member 'APhotoModeCamera::FOV_ADD_VALUE' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, RANGE_LIMIT_SLIDE_ANGLE) == 0x000A14, "Member 'APhotoModeCamera::RANGE_LIMIT_SLIDE_ANGLE' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, BACKGROUND_SLIDE_ANGLE) == 0x000A18, "Member 'APhotoModeCamera::BACKGROUND_SLIDE_ANGLE' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, BACKGROUND_SLIDE_OFFSET) == 0x000A1C, "Member 'APhotoModeCamera::BACKGROUND_SLIDE_OFFSET' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, BACKGROUND_STEPUP_HEIGHT) == 0x000A20, "Member 'APhotoModeCamera::BACKGROUND_STEPUP_HEIGHT' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, DitherCapsuleComponent) == 0x000A28, "Member 'APhotoModeCamera::DitherCapsuleComponent' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, HumanDitherCapsuleComponent) == 0x000A30, "Member 'APhotoModeCamera::HumanDitherCapsuleComponent' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, DITHER_INTERP_TIME) == 0x000A90, "Member 'APhotoModeCamera::DITHER_INTERP_TIME' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, DIR_DITHER_CHECK_RANGE_OFFSET) == 0x000A94, "Member 'APhotoModeCamera::DIR_DITHER_CHECK_RANGE_OFFSET' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, DIR_DITHER_CHECK_SCREEN_OFFSET_LEFT) == 0x000A98, "Member 'APhotoModeCamera::DIR_DITHER_CHECK_SCREEN_OFFSET_LEFT' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, DIR_DITHER_CHECK_SCREEN_OFFSET_RIGHT) == 0x000A9C, "Member 'APhotoModeCamera::DIR_DITHER_CHECK_SCREEN_OFFSET_RIGHT' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, DIR_DITHER_CHECK_SCREEN_OFFSET_TOP) == 0x000AA0, "Member 'APhotoModeCamera::DIR_DITHER_CHECK_SCREEN_OFFSET_TOP' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, DIR_DITHER_CHECK_SCREEN_OFFSET_BOTTOM) == 0x000AA4, "Member 'APhotoModeCamera::DIR_DITHER_CHECK_SCREEN_OFFSET_BOTTOM' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, DirDitherDataTable) == 0x000AA8, "Member 'APhotoModeCamera::DirDitherDataTable' has a wrong offset!");
static_assert(offsetof(APhotoModeCamera, DitherDataList) == 0x000AB0, "Member 'APhotoModeCamera::DitherDataList' has a wrong offset!");

// Class BattlePrototype.MainQuestDBAsset
// 0x0050 (0x0078 - 0x0028)
class UMainQuestDBAsset final : public UObject
{
public:
	TMap<class FName, struct FMainQuestDBDataCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainQuestDBAsset">();
	}
	static class UMainQuestDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainQuestDBAsset>();
	}
};
static_assert(alignof(UMainQuestDBAsset) == 0x000008, "Wrong alignment on UMainQuestDBAsset");
static_assert(sizeof(UMainQuestDBAsset) == 0x000078, "Wrong size on UMainQuestDBAsset");
static_assert(offsetof(UMainQuestDBAsset, DBMap) == 0x000028, "Member 'UMainQuestDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.PhotoModeCharacterInterface
// 0x0000 (0x0028 - 0x0028)
class IPhotoModeCharacterInterface final : public IInterface
{
public:
	bool BeginPhotoMode();
	bool EndPhotoMode();
	class FName GetPhotoModeDitherDataName();
	class UCapsuleComponent* GetPhotoModeManualOverlapCapsule();
	class USkeletalMeshComponent* GetPhotoModeSkeletalMesh();
	bool IsPhotoModeManualOverlap();
	bool PhotoModeTick();
	bool SetPhotoModeDither(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhotoModeCharacterInterface">();
	}
	static class IPhotoModeCharacterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPhotoModeCharacterInterface>();
	}
};
static_assert(alignof(IPhotoModeCharacterInterface) == 0x000008, "Wrong alignment on IPhotoModeCharacterInterface");
static_assert(sizeof(IPhotoModeCharacterInterface) == 0x000028, "Wrong size on IPhotoModeCharacterInterface");

// Class BattlePrototype.ActivityManager
// 0x00D8 (0x0100 - 0x0028)
class UActivityManager final : public UObject
{
public:
	uint8                                         Pad_2475[0x58];                                    // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ProgressIDTable_Yuito;                             // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ProgressIDTable_Kasane;                            // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2476[0x70];                                    // 0x0090(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndAdditionalEpisodeActivity(class FName bondsID, EGameActivityOutcome Outcome);
	void EndBondsEpisodeActivity(EPlayerID PlayerId, EPlayerID TargetID, int32 ProgressId, EGameActivityOutcome Outcome);
	void EndMainEpisodeActivity(EPlayerID PlayerId, int32 ProgressId, EGameActivityOutcome Outcome);
	void ResumeAdditionalEpisodeActivity(class FName bondsID);
	void ResumeBondsEpisodeActivity(EPlayerID PlayerId, EPlayerID TargetID, int32 ProgressId);
	void ResumeMainEpisodeActivity(EPlayerID PlayerId, int32 ProgressId);
	void SetDebugDrawFlag(bool IsDraw, EDebugGameActivityDisplayFlag Type);
	void SetDisableFlag(EGameActivityDisableFlag Type, bool IsDisable);
	void StartAdditionalEpisodeActivity(class FName bondsID);
	void StartMainEpisodeActivity(EPlayerID PlayerId, int32 ProgressId);
	void StartNewGame(EPlayerID PlayerId, int32 ProgressId);
	void Update();
	void UpdateBondsEpisodeActivity(EPlayerID PlayerId, EPlayerID TargetID, int32 ProgressId);
	void UpdateMainEpisodeActivity(EPlayerID PlayerId, int32 beforeProgressID, int32 NextProgressID);
	void WaitUntilComplete();

	EPlayerID GetMainCharacter(int32 SelectedScenario) const;
	bool IsDisableFlag(EGameActivityDisableFlag Type) const;
	bool IsExistAdditionalEpisodeActivity(class FName bondsID) const;
	bool IsExistBondsEpisodeActivity(EPlayerID PlayerId, int32 ProgressId) const;
	bool IsExsistDebugDrawFlag(EDebugGameActivityDisplayFlag Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivityManager">();
	}
	static class UActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivityManager>();
	}
};
static_assert(alignof(UActivityManager) == 0x000008, "Wrong alignment on UActivityManager");
static_assert(sizeof(UActivityManager) == 0x000100, "Wrong size on UActivityManager");
static_assert(offsetof(UActivityManager, ProgressIDTable_Yuito) == 0x000080, "Member 'UActivityManager::ProgressIDTable_Yuito' has a wrong offset!");
static_assert(offsetof(UActivityManager, ProgressIDTable_Kasane) == 0x000088, "Member 'UActivityManager::ProgressIDTable_Kasane' has a wrong offset!");

// Class BattlePrototype.PlatformGameActivityFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlatformGameActivityFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformGameActivityFunctionLibrary">();
	}
	static class UPlatformGameActivityFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformGameActivityFunctionLibrary>();
	}
};
static_assert(alignof(UPlatformGameActivityFunctionLibrary) == 0x000008, "Wrong alignment on UPlatformGameActivityFunctionLibrary");
static_assert(sizeof(UPlatformGameActivityFunctionLibrary) == 0x000028, "Wrong size on UPlatformGameActivityFunctionLibrary");

// Class BattlePrototype.PlatformUserIdFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlatformUserIdFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetGamerTag(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformUserIdFunctionLibrary">();
	}
	static class UPlatformUserIdFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformUserIdFunctionLibrary>();
	}
};
static_assert(alignof(UPlatformUserIdFunctionLibrary) == 0x000008, "Wrong alignment on UPlatformUserIdFunctionLibrary");
static_assert(sizeof(UPlatformUserIdFunctionLibrary) == 0x000028, "Wrong size on UPlatformUserIdFunctionLibrary");

// Class BattlePrototype.PlayerAIEvaluateLocationComponent
// 0x0528 (0x05F8 - 0x00D0)
class UPlayerAIEvaluateLocationComponent : public URSAsyncTaskActorComponent
{
public:
	EAIBattleRange                                Range_Type;                                        // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2486[0x3];                                     // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RANGE_NEAR;                                        // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range_Middle;                                      // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RANGE_FAR;                                         // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width_Near;                                        // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width_Far;                                         // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_Init;                                     // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetActor;                              // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_NotTargetActor;                           // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_AttackActor;                              // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_Friend;                                   // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetFront;                              // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetSide;                               // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetBack;                               // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetActorBehind;                        // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_TargetActorInfront;                       // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority_CurrentLocation;                          // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2487[0x4];                                     // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchUpdateEvaluateLocation;                    // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2488[0x4D0];                                   // 0x0128(0x04D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginEvaluate();
	bool CheckKeepOutArea(const struct FVector& Location);
	void ClearActorData();
	void DebugDrawEvaluationLocation();
	void EndEvaluate();
	bool GetHighPriorityLocation(struct FVector* OutLocation);
	bool GetHighPriorityLocationByRange(struct FVector* OutLocation, EAIBattleRange battleRange);
	bool GetLocationPriorityRank(int32* OutRank, struct FVector* OutLocation, const struct FVector& Location);
	bool GetNearLocation(struct FVector* OutLocation, const struct FVector& Location);
	bool GetOtherHighPriorityLocation(struct FVector* OutLocation, int32 Rank);
	void RegisterActorData(EEvaluateActorType ActorType, EEvaluateActorStatus ActorStatus, const struct FVector& Location, const struct FVector& ForwardDir, float Radius, bool bLockOn);
	void SetIgnoreKeepOutArea(bool bIgnore);
	void SetParameter(const struct FPlayerAIParameter& Parameter);

	float GetAIBattleRange(EAIBattleRange Range) const;
	EAIBattleRange GetAIBattleRangeType() const;
	EAIBattleRange GetLocationRangeType(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAIEvaluateLocationComponent">();
	}
	static class UPlayerAIEvaluateLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAIEvaluateLocationComponent>();
	}
};
static_assert(alignof(UPlayerAIEvaluateLocationComponent) == 0x000008, "Wrong alignment on UPlayerAIEvaluateLocationComponent");
static_assert(sizeof(UPlayerAIEvaluateLocationComponent) == 0x0005F8, "Wrong size on UPlayerAIEvaluateLocationComponent");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Range_Type) == 0x0000D0, "Member 'UPlayerAIEvaluateLocationComponent::Range_Type' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, RANGE_NEAR) == 0x0000D4, "Member 'UPlayerAIEvaluateLocationComponent::RANGE_NEAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Range_Middle) == 0x0000D8, "Member 'UPlayerAIEvaluateLocationComponent::Range_Middle' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, RANGE_FAR) == 0x0000DC, "Member 'UPlayerAIEvaluateLocationComponent::RANGE_FAR' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Width_Near) == 0x0000E0, "Member 'UPlayerAIEvaluateLocationComponent::Width_Near' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Width_Far) == 0x0000E4, "Member 'UPlayerAIEvaluateLocationComponent::Width_Far' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_Init) == 0x0000E8, "Member 'UPlayerAIEvaluateLocationComponent::Priority_Init' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetActor) == 0x0000EC, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_NotTargetActor) == 0x0000F0, "Member 'UPlayerAIEvaluateLocationComponent::Priority_NotTargetActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_AttackActor) == 0x0000F4, "Member 'UPlayerAIEvaluateLocationComponent::Priority_AttackActor' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_Friend) == 0x0000F8, "Member 'UPlayerAIEvaluateLocationComponent::Priority_Friend' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetFront) == 0x0000FC, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetFront' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetSide) == 0x000100, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetSide' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetBack) == 0x000104, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetBack' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetActorBehind) == 0x000108, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetActorBehind' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_TargetActorInfront) == 0x00010C, "Member 'UPlayerAIEvaluateLocationComponent::Priority_TargetActorInfront' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, Priority_CurrentLocation) == 0x000110, "Member 'UPlayerAIEvaluateLocationComponent::Priority_CurrentLocation' has a wrong offset!");
static_assert(offsetof(UPlayerAIEvaluateLocationComponent, DispatchUpdateEvaluateLocation) == 0x000118, "Member 'UPlayerAIEvaluateLocationComponent::DispatchUpdateEvaluateLocation' has a wrong offset!");

// Class BattlePrototype.PlayerAnimControllerComponent
// 0x0158 (0x0238 - 0x00E0)
class UPlayerAnimControllerComponent final : public UAnimControllerComponent
{
public:
	TWeakObjectPtr<class URSPlayerAnimInstance>   _animBP;                                           // 0x00E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchChangeAnimKind;                            // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchChangeWalkRunStateKind;                    // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRequestParticleEffect;                     // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageStarted;                            // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageEnded;                              // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _SprintWalkSpeedRate;                              // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WALK_SPEED;                                        // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RUN_SPEED;                                         // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AJITO_RUN_SPEED;                                   // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RUN_TO_WALK_DELAY;                                 // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RUN_TO_WALK_INTERP;                                // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WALK_TO_RUN_INTERP;                                // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WALK_TO_RUN_INTERP_TOWN;                           // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DISABLE_TOWN_RUN_TIMER;                            // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2493[0x4];                                     // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _bNotifyEnableMove;                                // 0x0170(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableAction;                              // 0x0180(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableAttack;                              // 0x0190(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnablePsychic;                             // 0x01A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnablePsychicEx;                           // 0x01B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableAirJump;                             // 0x01C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableBrainCrash;                          // 0x01D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableWeaponCharge;                        // 0x01E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _bNotifyEnableWalkStop;                            // 0x01F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2494[0x38];                                    // 0x0200(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlayerAnimControllerComponent* GetPlayerAnimControllerComponentFromActor(class AActor* Actor);

	void BeginPlayPublic();
	void ClearAllCancelFlag();
	float GetRigidbodyAlpha();
	bool IsNotifyEnableAttackOptionNotComboEnd();
	void OnChangeAnimKind(EPlayerAnimKind NewAnimKind, EPlayerAnimKind OldAnimKind);
	void OnChangeWalkRunStateKind(EPlayerWalkRunStateKind NewKind);
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageStarted(class UAnimMontage* Montage);
	void OnRequestParticleEffect(class URequestParticleEffectArgs* Args);
	void ReceiveNotifyEnableAction(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableAirJump(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableAttack(bool bEnable, bool bNotComboEnd, class FName ClaimantName);
	void ReceiveNotifyEnableBrainCrash(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableMove(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnablePsychic(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnablePsychicEx(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableWalkStop(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyEnableWeaponCharge(bool bEnable, class FName ClaimantName);
	void ReceiveNotifyInputAttack(bool bEnable);
	void ReceiveNotifyInputDodge(bool bEnable);
	void ReceiveNotifyInputPsychic(bool bEnable);
	void RequestAnim(EPlayerAnimKind Kind, int32 Param, bool bFlying);
	void RequestAttack(class UAnimMontage* AnimMontage, float InPlayRate, class FName StartSectionName);
	void RequestBattleIdle(bool IsStart);
	void RequestStep(const struct FVector& StepDirection, EPlayerAnimDir Dir, int32 Param, bool bFlying);
	void SetAimRotator(const struct FRotator& Rotator);
	void SetAjitoFlag(bool bAjito);
	void SetBattleEm1500(bool bBattle);
	void SetLeftStickPower(float Power, float PrevDiff);
	void SetRigidbodyAlpha(float Alpha, float LerpTime);
	void SetTalkMode(bool bTalk);
	void SetUniquePsychicAim(bool bFlag);
	void SetupAnimBP();
	void SetUpperAction(bool bSet);
	void UpdateWalkSpeed(float DeltaSeconds);

	float GetBaseWalkSpeed() const;
	float GetWalkRunMoveScale() const;
	EPlayerWalkRunStateKind GetWalkRunStateKind() const;
	bool IsAnimAnyAttack() const;
	bool IsAnimAttack() const;
	bool IsAnimBrake() const;
	bool IsAnimDamage() const;
	bool IsAnimDead() const;
	bool IsAnimEndBattle() const;
	bool IsAnimFall() const;
	bool IsAnimIdleWalkRun() const;
	bool IsAnimJump() const;
	bool IsAnimKind(EPlayerAnimKind Kind) const;
	bool IsAnimLand() const;
	bool IsAnimPsychic() const;
	bool IsAnimSideStep() const;
	bool IsAnimSprint() const;
	bool IsAnimStartBattle() const;
	bool IsAnimStep() const;
	bool IsAnimStepEnd() const;
	bool IsASAnimPlayEnd(EPlayerAnimKind Kind) const;
	bool IsASNodePlayEnd() const;
	bool IsAttackInputAccept(int32 AttackId) const;
	bool IsCheckIdle() const;
	bool IsExistAnimRequest() const;
	bool IsNotifyEnableAction() const;
	bool IsNotifyEnableAirJump() const;
	bool IsNotifyEnableAttack() const;
	bool IsNotifyEnableBrainCrash() const;
	bool IsNotifyEnableMove() const;
	bool IsNotifyEnablePsychic() const;
	bool IsNotifyEnablePsychicEx() const;
	bool IsNotifyEnableWalkStop() const;
	bool IsNotifyEnableWeaponCharge() const;
	bool IsNotifyInputAttack() const;
	bool IsNotifyInputDodge() const;
	bool IsNotifyInputPsychic() const;
	bool IsPsychicCaptureNoMotionAction() const;
	bool IsRunningAnimStateForAIMove() const;
	bool IsUpperAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAnimControllerComponent">();
	}
	static class UPlayerAnimControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAnimControllerComponent>();
	}
};
static_assert(alignof(UPlayerAnimControllerComponent) == 0x000008, "Wrong alignment on UPlayerAnimControllerComponent");
static_assert(sizeof(UPlayerAnimControllerComponent) == 0x000238, "Wrong size on UPlayerAnimControllerComponent");
static_assert(offsetof(UPlayerAnimControllerComponent, _animBP) == 0x0000E0, "Member 'UPlayerAnimControllerComponent::_animBP' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchChangeAnimKind) == 0x0000E8, "Member 'UPlayerAnimControllerComponent::DispatchChangeAnimKind' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchChangeWalkRunStateKind) == 0x0000F8, "Member 'UPlayerAnimControllerComponent::DispatchChangeWalkRunStateKind' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchRequestParticleEffect) == 0x000108, "Member 'UPlayerAnimControllerComponent::DispatchRequestParticleEffect' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchMontageStarted) == 0x000118, "Member 'UPlayerAnimControllerComponent::DispatchMontageStarted' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchMontageBlendingOut) == 0x000128, "Member 'UPlayerAnimControllerComponent::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DispatchMontageEnded) == 0x000138, "Member 'UPlayerAnimControllerComponent::DispatchMontageEnded' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _SprintWalkSpeedRate) == 0x000148, "Member 'UPlayerAnimControllerComponent::_SprintWalkSpeedRate' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, WALK_SPEED) == 0x00014C, "Member 'UPlayerAnimControllerComponent::WALK_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, RUN_SPEED) == 0x000150, "Member 'UPlayerAnimControllerComponent::RUN_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, AJITO_RUN_SPEED) == 0x000154, "Member 'UPlayerAnimControllerComponent::AJITO_RUN_SPEED' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, RUN_TO_WALK_DELAY) == 0x000158, "Member 'UPlayerAnimControllerComponent::RUN_TO_WALK_DELAY' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, RUN_TO_WALK_INTERP) == 0x00015C, "Member 'UPlayerAnimControllerComponent::RUN_TO_WALK_INTERP' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, WALK_TO_RUN_INTERP) == 0x000160, "Member 'UPlayerAnimControllerComponent::WALK_TO_RUN_INTERP' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, WALK_TO_RUN_INTERP_TOWN) == 0x000164, "Member 'UPlayerAnimControllerComponent::WALK_TO_RUN_INTERP_TOWN' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, DISABLE_TOWN_RUN_TIMER) == 0x000168, "Member 'UPlayerAnimControllerComponent::DISABLE_TOWN_RUN_TIMER' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableMove) == 0x000170, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableMove' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableAction) == 0x000180, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableAction' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableAttack) == 0x000190, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableAttack' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnablePsychic) == 0x0001A0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnablePsychic' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnablePsychicEx) == 0x0001B0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnablePsychicEx' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableAirJump) == 0x0001C0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableAirJump' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableBrainCrash) == 0x0001D0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableBrainCrash' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableWeaponCharge) == 0x0001E0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableWeaponCharge' has a wrong offset!");
static_assert(offsetof(UPlayerAnimControllerComponent, _bNotifyEnableWalkStop) == 0x0001F0, "Member 'UPlayerAnimControllerComponent::_bNotifyEnableWalkStop' has a wrong offset!");

// Class BattlePrototype.PlayerAsyncScriptComponent
// 0x0F98 (0x1068 - 0x00D0)
class UPlayerAsyncScriptComponent final : public URSAsyncTaskActorComponent
{
public:
	float                                         CheckMoveWallHeight;                               // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckMoveWall_CheckForwardLength;                  // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckMoveWall_CheckBackLength;                     // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckMoveWall_CheckSideLengthShort;                // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckMoveWall_CheckSideLength;                     // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A6[0xF5C];                                   // 0x00E4(0x0F5C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     TempOutHitResultAsync;                             // 0x1040(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FHitResult>                     TempOutHitResultAsyncSubFunc;                      // 0x1050(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24A7[0x8];                                     // 0x1060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAsyncResult();
	void DebugDispResult(const TArray<EPlayerCollisionCheckType>& DispList);
	const struct FPlayerCollisionCheckResult GetAsyncResult(EPlayerCollisionCheckType Type);
	bool IsFallAbleGround();
	void SetCheckParameter(const struct FPlayerAsyncParameter& InParameter);
	void SetEnableAsync(bool bAsync);
	bool SyncResult();

	struct FVector GetAssyncResult_PlayerAICheckGoalLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAsyncScriptComponent">();
	}
	static class UPlayerAsyncScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAsyncScriptComponent>();
	}
};
static_assert(alignof(UPlayerAsyncScriptComponent) == 0x000008, "Wrong alignment on UPlayerAsyncScriptComponent");
static_assert(sizeof(UPlayerAsyncScriptComponent) == 0x001068, "Wrong size on UPlayerAsyncScriptComponent");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWallHeight) == 0x0000D0, "Member 'UPlayerAsyncScriptComponent::CheckMoveWallHeight' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWall_CheckForwardLength) == 0x0000D4, "Member 'UPlayerAsyncScriptComponent::CheckMoveWall_CheckForwardLength' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWall_CheckBackLength) == 0x0000D8, "Member 'UPlayerAsyncScriptComponent::CheckMoveWall_CheckBackLength' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWall_CheckSideLengthShort) == 0x0000DC, "Member 'UPlayerAsyncScriptComponent::CheckMoveWall_CheckSideLengthShort' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, CheckMoveWall_CheckSideLength) == 0x0000E0, "Member 'UPlayerAsyncScriptComponent::CheckMoveWall_CheckSideLength' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, TempOutHitResultAsync) == 0x001040, "Member 'UPlayerAsyncScriptComponent::TempOutHitResultAsync' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncScriptComponent, TempOutHitResultAsyncSubFunc) == 0x001050, "Member 'UPlayerAsyncScriptComponent::TempOutHitResultAsyncSubFunc' has a wrong offset!");

// Class BattlePrototype.PlayerCopyInterface
// 0x0000 (0x0028 - 0x0028)
class IPlayerCopyInterface final : public IInterface
{
public:
	bool IsExistPlayerCopy();
	bool IsPlayerCopy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCopyInterface">();
	}
	static class IPlayerCopyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerCopyInterface>();
	}
};
static_assert(alignof(IPlayerCopyInterface) == 0x000008, "Wrong alignment on IPlayerCopyInterface");
static_assert(sizeof(IPlayerCopyInterface) == 0x000028, "Wrong size on IPlayerCopyInterface");

// Class BattlePrototype.HardenStartParameter
// 0x0010 (0x0040 - 0x0030)
class UHardenStartParameter final : public UDataAsset
{
public:
	struct FLinearColor                           EmissiveColor;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HardenStartParameter">();
	}
	static class UHardenStartParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHardenStartParameter>();
	}
};
static_assert(alignof(UHardenStartParameter) == 0x000008, "Wrong alignment on UHardenStartParameter");
static_assert(sizeof(UHardenStartParameter) == 0x000040, "Wrong size on UHardenStartParameter");
static_assert(offsetof(UHardenStartParameter, EmissiveColor) == 0x000030, "Member 'UHardenStartParameter::EmissiveColor' has a wrong offset!");

// Class BattlePrototype.PlayerENpcBaseComponent
// 0x0008 (0x00C8 - 0x00C0)
class UPlayerENpcBaseComponent : public UActorComponent
{
public:
	bool                                          bReactionChance;                                   // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A9[0x7];                                     // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool SetHitTrigger_CallFromCPP(bool bIsHitTrigger);
	bool StartReactionChance_CallFromCPP();

	bool IsReactionChanceCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerENpcBaseComponent">();
	}
	static class UPlayerENpcBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerENpcBaseComponent>();
	}
};
static_assert(alignof(UPlayerENpcBaseComponent) == 0x000008, "Wrong alignment on UPlayerENpcBaseComponent");
static_assert(sizeof(UPlayerENpcBaseComponent) == 0x0000C8, "Wrong size on UPlayerENpcBaseComponent");
static_assert(offsetof(UPlayerENpcBaseComponent, bReactionChance) == 0x0000C0, "Member 'UPlayerENpcBaseComponent::bReactionChance' has a wrong offset!");

// Class BattlePrototype.PlayerHeightGradationComponent
// 0x0010 (0x00D0 - 0x00C0)
class UPlayerHeightGradationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_24AA[0x10];                                    // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGradation(class UMeshComponent* Mesh, const TArray<struct FHeightGradationSettings>& SettingsArray);
	void ResetGradation(class UMeshComponent* Mesh, const TArray<struct FHeightGradationSettings>& SettingsArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerHeightGradationComponent">();
	}
	static class UPlayerHeightGradationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerHeightGradationComponent>();
	}
};
static_assert(alignof(UPlayerHeightGradationComponent) == 0x000008, "Wrong alignment on UPlayerHeightGradationComponent");
static_assert(sizeof(UPlayerHeightGradationComponent) == 0x0000D0, "Wrong size on UPlayerHeightGradationComponent");

// Class BattlePrototype.PlayerInputBaseComponent
// 0x0498 (0x0558 - 0x00C0)
class UPlayerInputBaseComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchTrigger_Attack;                            // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_AttackLongPress;                   // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_Attack;                            // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_AttackSub;                         // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_AttackSubLongPress;                // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_AttackSub;                         // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_LaunchAttack;                      // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_LaunchAttack;                      // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BackStepAttack;                    // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_BackStepAttack;                    // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Dodge;                             // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Jump;                              // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_TargetLock;                        // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_TargetChange;                      // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_TargetChangeLeft;                  // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_TargetChangeRight;                 // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ReadySAS;                          // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_ReadySAS;                          // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Dispatch_ReadySAS;                                 // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Dispatch_SasSelectSlow;                            // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_UpSAS;                             // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_DownSAS;                           // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_LeftSAS;                           // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_RightSAS;                          // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_OffSAS;                            // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_SASHologramAttack;                 // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_SASHologramAttack;                 // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_SASHologramAttackManual;           // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_UpCombinationVision;               // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_DownCombinationVision;             // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_LeftCombinationVision;             // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_RightCombinationVision;            // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ChangeSASSet;                      // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Psychic;                           // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_Psychic;                           // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_SpecialPsychic;                    // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_SpecialPsychic;                    // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainFieldPsychicUp;               // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainFieldPsychicLeft;             // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainFieldPsychicRight;            // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_BrainFieldPsychicRight;            // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_PsychicField;                      // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_PsychicField;                      // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainCrash;                        // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_MapGimmick;                        // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_MapGimmick;                        // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_BrainField;                        // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Intercept;                         // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_UseItem;                           // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ItemSelectLeft;                    // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ItemSelectRight;                   // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_Ressurect;                         // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchRelease_Ressurect;                         // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchTrigger_ResetCamera;                       // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         LONG_ATTACK_INPUT_TIME;                            // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LONG_ATTACK_INPUT_TIME_AERIAL;                     // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DOUBLE_INPUT_INTERVAL;                             // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SAS_SELECT_SLOW_DELAY_TIME;                        // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SAS_SELECT_SLOW_TIME;                              // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24AB[0x124];                                   // 0x0434(0x0124)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRestriction(EPlayerInputRestrictionType Restriction);
	void CheckChangeSasSetOption();
	void ClearInput(bool bButtonOnly);
	void ClearPrecedeInput();
	void ClearPrecedeInputDodge();
	void ForceEndSasSelectSlow();
	struct FVector2D GetLeftStickPrevInputDiff();
	bool IsMouseInputRightStick();
	void ReleaseButton(ERSGamepadInputName Button);
	void ResetChangeSasSetDoubleInput();
	void SetAI(bool bAI);
	void SetBrainFieldMode(bool bBrainField);
	void SetButton(ERSGamepadInputName Button);
	void SetEnableSasSelectSlow(bool bEnable);
	void SetInputType(EPlayerInputType Type);
	void SetLeftStick(float X, float Y);
	void SetRightStick(float X, float Y);
	void SetTalkMode(bool bTalk);
	void SetTutorial(bool bTutorial);
	void SubRestriction(EPlayerInputRestrictionType Restriction);
	void TutorialRestrictAttackAll(bool bRestrict);
	void TutorialRestrictAttackSub(bool bRestrict);
	void TutorialRestrictLaunchAttack(bool bRestrict);
	void TutorialRestrictPsychic(bool bRestrict);
	void Update(float DeltaSeconds);

	EPlayerInputType GetInputType() const;
	float GetLeftStickX(bool bRaw) const;
	float GetLeftStickY(bool bRaw) const;
	float GetLongPressAttackInputTime() const;
	void GetMoveStick(float* OutX, float* OutY, float* OutPower) const;
	struct FVector GetPrecedeInputDodgeStick() const;
	float GetPrevLeftStickX(bool bRaw) const;
	float GetPrevLeftStickY(bool bRaw) const;
	float GetRightStickX(bool bRaw) const;
	float GetRightStickY(bool bRaw) const;
	EPlayerInputSASReadyType GetSasReadyType() const;
	bool IsKeyboard() const;
	bool IsLeftStickInput(float Power, bool bRaw) const;
	bool IsLeftStickRun() const;
	bool IsLeftStickZero(bool bRaw) const;
	bool IsOn(ERSGamepadInputName Button) const;
	bool IsOnAttack() const;
	bool IsOnAttackSub() const;
	bool IsOnDodge() const;
	bool IsOnJump() const;
	bool IsOnPsychicObjectUnique() const;
	bool IsOnReadyCombinationVision() const;
	bool IsOnReadySAS() const;
	bool IsOnReadyTargetChange() const;
	bool IsOnResurrect() const;
	bool IsOnRideAccel() const;
	bool IsOnUniqueCharge() const;
	bool IsOnUniqueCircle() const;
	bool IsOnWakeUp() const;
	bool IsPrecedeInputDodge() const;
	bool IsPrecedeInputJump() const;
	bool IsPrecedeInputPsychic() const;
	bool IsPrecedeInputResurrect() const;
	bool IsPrecedeInputUseItem() const;
	bool IsRelease(ERSGamepadInputName Button) const;
	bool IsReleaseAttack() const;
	bool IsReleaseAttackSub() const;
	bool IsReleaseBackStepAttack() const;
	bool IsReleaseBrainFieldPsychicRight() const;
	bool IsReleaseDodge() const;
	bool IsReleaseJump() const;
	bool IsReleaseLaunchAttack() const;
	bool IsReleaseMapGimmick() const;
	bool IsReleaseReadySAS() const;
	bool IsReleaseSASHologramAttack() const;
	bool IsRestriction(EPlayerInputRestrictionType Restriction) const;
	bool IsRightStickInput(float Power, bool bRaw) const;
	bool IsRightStickZero(bool bRaw) const;
	bool IsTrg(ERSGamepadInputName Button) const;
	bool IsTrgAttack() const;
	bool IsTrgAttackSub() const;
	bool IsTrgBackStepAttack() const;
	bool IsTrgBrainCrash() const;
	bool IsTrgBrainField() const;
	bool IsTrgBrainFieldPsychicLeft() const;
	bool IsTrgBrainFieldPsychicRight() const;
	bool IsTrgBrainFieldPsychicUp() const;
	bool IsTrgChangeSASSet() const;
	bool IsTrgCrashVision() const;
	bool IsTrgDodge() const;
	bool IsTrgDownCombinationVision() const;
	bool IsTrgDownSAS() const;
	bool IsTrgIntercept() const;
	bool IsTrgItemSelectLeft() const;
	bool IsTrgItemSelectRight() const;
	bool IsTrgItemUse() const;
	bool IsTrgJump() const;
	bool IsTrgLaunchAttack() const;
	bool IsTrgLeftCombinationVision() const;
	bool IsTrgLeftSAS() const;
	bool IsTrgMapGimmick() const;
	bool IsTrgPsychicObjectNormal() const;
	bool IsTrgPsychicObjectUnique() const;
	bool IsTrgReadySAS() const;
	bool IsTrgRecovery() const;
	bool IsTrgResetCamera() const;
	bool IsTrgResurrect() const;
	bool IsTrgRideAccel() const;
	bool IsTrgRideAttack() const;
	bool IsTrgRightCombinationVision() const;
	bool IsTrgRightSAS() const;
	bool IsTrgSASHologramAttack() const;
	bool IsTrgSASHologramAttackManual() const;
	bool IsTrgSASOffAll() const;
	bool IsTrgTargetChange() const;
	bool IsTrgTargetChangeLeft() const;
	bool IsTrgTargetChangeRight() const;
	bool IsTrgTargetLock(bool* OutTrgKeyboardRelease) const;
	bool IsTrgUniqueCharge() const;
	bool IsTrgUniqueCircle() const;
	bool IsTrgUniqueDischarge() const;
	bool IsTrgUniqueTriangle() const;
	bool IsTrgUpCombinationVision() const;
	bool IsTrgUpSAS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInputBaseComponent">();
	}
	static class UPlayerInputBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInputBaseComponent>();
	}
};
static_assert(alignof(UPlayerInputBaseComponent) == 0x000008, "Wrong alignment on UPlayerInputBaseComponent");
static_assert(sizeof(UPlayerInputBaseComponent) == 0x000558, "Wrong size on UPlayerInputBaseComponent");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Attack) == 0x0000C0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Attack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_AttackLongPress) == 0x0000D0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_AttackLongPress' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_Attack) == 0x0000E0, "Member 'UPlayerInputBaseComponent::DispatchRelease_Attack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_AttackSub) == 0x0000F0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_AttackSub' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_AttackSubLongPress) == 0x000100, "Member 'UPlayerInputBaseComponent::DispatchTrigger_AttackSubLongPress' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_AttackSub) == 0x000110, "Member 'UPlayerInputBaseComponent::DispatchRelease_AttackSub' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_LaunchAttack) == 0x000120, "Member 'UPlayerInputBaseComponent::DispatchTrigger_LaunchAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_LaunchAttack) == 0x000130, "Member 'UPlayerInputBaseComponent::DispatchRelease_LaunchAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BackStepAttack) == 0x000140, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BackStepAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_BackStepAttack) == 0x000150, "Member 'UPlayerInputBaseComponent::DispatchRelease_BackStepAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Dodge) == 0x000160, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Dodge' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Jump) == 0x000170, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Jump' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_TargetLock) == 0x000180, "Member 'UPlayerInputBaseComponent::DispatchTrigger_TargetLock' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_TargetChange) == 0x000190, "Member 'UPlayerInputBaseComponent::DispatchTrigger_TargetChange' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_TargetChangeLeft) == 0x0001A0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_TargetChangeLeft' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_TargetChangeRight) == 0x0001B0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_TargetChangeRight' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ReadySAS) == 0x0001C0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ReadySAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_ReadySAS) == 0x0001D0, "Member 'UPlayerInputBaseComponent::DispatchRelease_ReadySAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, Dispatch_ReadySAS) == 0x0001E0, "Member 'UPlayerInputBaseComponent::Dispatch_ReadySAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, Dispatch_SasSelectSlow) == 0x0001F0, "Member 'UPlayerInputBaseComponent::Dispatch_SasSelectSlow' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_UpSAS) == 0x000200, "Member 'UPlayerInputBaseComponent::DispatchTrigger_UpSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_DownSAS) == 0x000210, "Member 'UPlayerInputBaseComponent::DispatchTrigger_DownSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_LeftSAS) == 0x000220, "Member 'UPlayerInputBaseComponent::DispatchTrigger_LeftSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_RightSAS) == 0x000230, "Member 'UPlayerInputBaseComponent::DispatchTrigger_RightSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_OffSAS) == 0x000240, "Member 'UPlayerInputBaseComponent::DispatchTrigger_OffSAS' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_SASHologramAttack) == 0x000250, "Member 'UPlayerInputBaseComponent::DispatchTrigger_SASHologramAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_SASHologramAttack) == 0x000260, "Member 'UPlayerInputBaseComponent::DispatchRelease_SASHologramAttack' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_SASHologramAttackManual) == 0x000270, "Member 'UPlayerInputBaseComponent::DispatchTrigger_SASHologramAttackManual' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_UpCombinationVision) == 0x000280, "Member 'UPlayerInputBaseComponent::DispatchTrigger_UpCombinationVision' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_DownCombinationVision) == 0x000290, "Member 'UPlayerInputBaseComponent::DispatchTrigger_DownCombinationVision' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_LeftCombinationVision) == 0x0002A0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_LeftCombinationVision' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_RightCombinationVision) == 0x0002B0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_RightCombinationVision' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ChangeSASSet) == 0x0002C0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ChangeSASSet' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Psychic) == 0x0002D0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Psychic' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_Psychic) == 0x0002E0, "Member 'UPlayerInputBaseComponent::DispatchRelease_Psychic' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_SpecialPsychic) == 0x0002F0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_SpecialPsychic' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_SpecialPsychic) == 0x000300, "Member 'UPlayerInputBaseComponent::DispatchRelease_SpecialPsychic' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainFieldPsychicUp) == 0x000310, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainFieldPsychicUp' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainFieldPsychicLeft) == 0x000320, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainFieldPsychicLeft' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainFieldPsychicRight) == 0x000330, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainFieldPsychicRight' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_BrainFieldPsychicRight) == 0x000340, "Member 'UPlayerInputBaseComponent::DispatchRelease_BrainFieldPsychicRight' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_PsychicField) == 0x000350, "Member 'UPlayerInputBaseComponent::DispatchTrigger_PsychicField' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_PsychicField) == 0x000360, "Member 'UPlayerInputBaseComponent::DispatchRelease_PsychicField' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainCrash) == 0x000370, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainCrash' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_MapGimmick) == 0x000380, "Member 'UPlayerInputBaseComponent::DispatchTrigger_MapGimmick' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_MapGimmick) == 0x000390, "Member 'UPlayerInputBaseComponent::DispatchRelease_MapGimmick' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_BrainField) == 0x0003A0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_BrainField' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Intercept) == 0x0003B0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Intercept' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_UseItem) == 0x0003C0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_UseItem' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ItemSelectLeft) == 0x0003D0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ItemSelectLeft' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ItemSelectRight) == 0x0003E0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ItemSelectRight' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_Ressurect) == 0x0003F0, "Member 'UPlayerInputBaseComponent::DispatchTrigger_Ressurect' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchRelease_Ressurect) == 0x000400, "Member 'UPlayerInputBaseComponent::DispatchRelease_Ressurect' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DispatchTrigger_ResetCamera) == 0x000410, "Member 'UPlayerInputBaseComponent::DispatchTrigger_ResetCamera' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, LONG_ATTACK_INPUT_TIME) == 0x000420, "Member 'UPlayerInputBaseComponent::LONG_ATTACK_INPUT_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, LONG_ATTACK_INPUT_TIME_AERIAL) == 0x000424, "Member 'UPlayerInputBaseComponent::LONG_ATTACK_INPUT_TIME_AERIAL' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, DOUBLE_INPUT_INTERVAL) == 0x000428, "Member 'UPlayerInputBaseComponent::DOUBLE_INPUT_INTERVAL' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, SAS_SELECT_SLOW_DELAY_TIME) == 0x00042C, "Member 'UPlayerInputBaseComponent::SAS_SELECT_SLOW_DELAY_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerInputBaseComponent, SAS_SELECT_SLOW_TIME) == 0x000430, "Member 'UPlayerInputBaseComponent::SAS_SELECT_SLOW_TIME' has a wrong offset!");

// Class BattlePrototype.PlayerJustDodgeComponent
// 0x0018 (0x00D8 - 0x00C0)
class UPlayerJustDodgeComponent : public UActorComponent
{
public:
	float                                         JUST_DODGE_TIME;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JUST_DODGE_GAMESPEED_RATE;                         // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JUST_DODGE_INVINSIBLE_TIME;                        // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JUST_DODGE_RADIUS;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JUST_DODGE_RADIUS_RANGEATTACK;                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24B4[0x4];                                     // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CalcJustDodge(class UCapsuleComponent* BaseCapsule, class UHitCheckComponent* HitCheck, const struct FVector& Offset, float CheckScale, float CheckRangeScale);
	bool CalcJustDodgeByLocation(const struct FVector& Location, const struct FVector& UpDir, const struct FVector& Offset, float Height, float Radius, class UHitCheckComponent* HitCheck, float CheckScale, float CheckRangeScale);
	bool CheckJustDodge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerJustDodgeComponent">();
	}
	static class UPlayerJustDodgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerJustDodgeComponent>();
	}
};
static_assert(alignof(UPlayerJustDodgeComponent) == 0x000008, "Wrong alignment on UPlayerJustDodgeComponent");
static_assert(sizeof(UPlayerJustDodgeComponent) == 0x0000D8, "Wrong size on UPlayerJustDodgeComponent");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_TIME) == 0x0000C0, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_GAMESPEED_RATE) == 0x0000C4, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_GAMESPEED_RATE' has a wrong offset!");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_INVINSIBLE_TIME) == 0x0000C8, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_INVINSIBLE_TIME' has a wrong offset!");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_RADIUS) == 0x0000CC, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_RADIUS' has a wrong offset!");
static_assert(offsetof(UPlayerJustDodgeComponent, JUST_DODGE_RADIUS_RANGEATTACK) == 0x0000D0, "Member 'UPlayerJustDodgeComponent::JUST_DODGE_RADIUS_RANGEATTACK' has a wrong offset!");

// Class BattlePrototype.PlayerManager
// 0x01C0 (0x03F0 - 0x0230)
class APlayerManager : public AActor
{
public:
	uint8                                         Pad_24B8[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ARSCharacterBase*>               _playerList;                                       // 0x0238(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               _extraPlayerList;                                  // 0x0248(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24B9[0x1];                                     // 0x0258(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerID                                     _BattleMemberMain;                                 // 0x0259(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPlayerID                                     _BattleMemberLeft;                                 // 0x025A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPlayerID                                     _BattleMemberRight;                                // 0x025B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24BA[0x4];                                     // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerInfo>                    _partyInfoList;                                    // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FCharactersParameterTable>      _partyParameterTableList;                          // 0x0270(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDelayLoadPlayerEquipData>      _delayLoadList;                                    // 0x0280(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             DispatchEquipWeaponDelegate;                       // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchEquipCostumeDelegate;                      // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDataTable*                             WeaponExtraAbilityDataTable;                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AccessoryExtendParameterDataTable;                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPartyPlayerCacheData>          _partyPlayerCache;                                 // 0x02C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             DispatchChangeDisableBattleActionFlag;             // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24BB[0x3C];                                    // 0x02E0(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNpcThinkAssistAttack;                             // 0x031C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24BC[0x3];                                     // 0x031D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBackupEquipWeapon>             EventBackupEquipWeapon;                            // 0x0320(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24BD[0x88];                                    // 0x0330(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AjitoTogetherDataTable;                            // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayerAddStatusByAjitoTogether> AjitoTogetherData;                                 // 0x03C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPlayerAddStatusByAjitoTogether> AjitoTogetherData_MainPlayer;                      // 0x03D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 PluginNpcAutoReviveCount;                          // 0x03E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddPartyMember(const struct FPlayerInfo& Info, const bool IsSaveDataLoadFlow);
	void AddPartyMemberByPreset(const struct FAddPartyPresetData& Preset, const bool IsCheckBattleMemberMain, bool bNotEquipSAS);
	void AddPluginNpcAutoReviveCount(EPlayerID PlayerId);
	void AjitoTogetherParameterRandomUp(EPlayerID NpcID, EAjitoTogetherUpKind* OutNpcUpKind, int32* OutNpcUpValue, EAjitoTogetherUpKind* OutPlayerUpKind, int32* OutPlayerUpValue);
	void AllDestroyPlayerCharacter();
	void AllPlayerCharacterTickStop();
	struct FCharactersParameterTable ApplyAjitoTogetherCharactersParameter(EPlayerID PlayerId, const struct FCharactersParameterTable& BaseData);
	float CalcLevelDifferentExpRate(int32 DifferentLevel);
	void ChangePlayerCharacter(ERSPartyPlayerKind Type, TSubclassOf<class ARSCharacterBase> PlayerClass);
	bool CheckRareArrangeItem();
	void ClearPartyMember();
	void ClearPlayerInfoBadStatus(EPlayerID ID);
	void ClearPlayerInfoDrive(EPlayerID ID);
	void ClearPlayerUseInfo();
	void ClearPluginNpcAutoReviveCount();
	class ARSCharacterBase* CreatePlayerCharacter(ERSPartyPlayerKind Type, TSubclassOf<class ARSCharacterBase> PlayerClass, const struct FVector& Location, const struct FRotator& Rotation);
	class ARSCharacterBase* CreatePlayerCharacterFromID(ERSPartyPlayerKind Type, EPlayerID ID, const struct FVector& Location, const struct FRotator& Rotation);
	void CreatePlayerCharacters(const class FString& PlayerStartName);
	void DebugDrawKeepOutArea();
	void DelayLoadPlayerEquip();
	void DestroyPlayerCharacter(ERSPartyPlayerKind Type);
	void DestroyPlayerCharacters();
	bool DoNotifyBattleSimulatorEnd(bool bMissionCancel);
	void EndEventDefaultWeapon(EPlayerID PlayerId);
	void EquipAccessory(EPlayerID ID, EPlayerAccessory Param_Index, int32 AccessoryId, bool bTempEquip);
	void EquipAttachment(EPlayerID ID, EPlayerAttachment Param_Index, int32 AttachmentId);
	void EquipCostume(EPlayerID ID, int32 CostumeId);
	void EquipWeapon(EPlayerID ID, int32 WeaponId, bool bTempEquip);
	void EquipWeaponSkin(EPlayerID ID, int32 WeaponId);
	void EventCutSceneAfterFunc();
	void EventDefaultWeapon(EPlayerID PlayerId);
	void EventRemvoeMembers(const TArray<EPlayerID>& IgnoreActorList, bool bDisableSAS);
	void EventReviveBattleMember();
	bool GetAccessoryEffect(float* OutValue, EPlayerID ID, EEffecacyType EffectType);
	bool GetAccessoryEffectSameEquipVisionSupport(float* OutOffsetAV, int32* OutOffsetPV, float* OutOffsetCV, int32* OutLotParam1, int32* OutLotParam2);
	void GetAccessoryEffectShoppingSupport(float* OutBuyRate, float* OutSellRate);
	int32 GetAccessoryEquipNum(EPlayerID PlayerId);
	bool GetAccessoryExtendParameter(TArray<float>* OutParameter, EPlayerID ID, EEffecacyType EffectType);
	int32 GetAjitoTogetherCount(EPlayerID PlayerId, EAjitoTogetherUpKind Kind);
	struct FPlayerAddStatusByAjitoTogether GetAjitoTogetherData(EPlayerID PlayerId);
	class ARSCharacterBase* GetBattleMemberActorFromID(EPlayerID ID);
	class ARSCharacterBase* GetBattleMemberActorFromKind(ERSPartyPlayerKind Kind);
	EPlayerID GetBattleMemberPlayerID(ERSPartyPlayerKind Kind);
	TArray<class ARSCharacterBase*> GetExtraPlayerList();
	int32 GetNpcAssistCountBadStatus();
	int32 GetNpcAssistCountHP();
	int32 GetNpcAssistCountRevive();
	TArray<struct FPlayerInfo> GetPartyInfoList();
	struct FPartyPlayerCacheData GetPartyPlayerCache(EPlayerID ID);
	TArray<EPlayerFacialAnim_Native> GetPhotoModeFacialList_Native(ERSPartyPlayerKind Kind);
	TSoftClassPtr<class UClass> GetPlayerBPSoftRef(EPlayerID PlayerId, bool bENPC, bool bMetamorphosis);
	bool GetPlayerCharacterParam(ERSPartyPlayerKind Type, struct FVector* Location, struct FRotator* Rotation);
	void GetPlayerWeaponActorListFromNative(class AActor* OwnerPlayer, EGetPlayerWeaponType Type, TArray<class AActor*>* WeaponList);
	void GetWeaponExtraAbilityDamageRate(float* OutDamageRate, float* OutPsychicDamageRate, float* OutCrashRate, EPlayerID PlayerId, class AActor* DamageActor);
	struct FWeaponExtraAbilityParameter GetWeaponExtraAbilityParameter(EPlayerID PlayerId, EWeaponExtraAbility Ability);
	void InitializeAll(const bool IsNoResetPartyInfo);
	bool IsCanSASUse_fromNative(E_SASButton Button);
	bool IsCreatePlayerCharacters();
	bool IsDriveUsedFlag();
	bool IsEnableAccessoryEffectSameEquipVisionSupport(EPlayerID NpcPlayerID);
	bool IsEnableAjitoTogetherEvent(EPlayerID TogetherPlayerID);
	bool IsEnablePhotoModePlayer(ERSPartyPlayerKind Kind);
	bool IsEquipHoodCostume(EPlayerID PlayerId);
	bool IsExistBattleMember(EPlayerID ID);
	bool IsHoodCostumeID(EPlayerID PlayerId, int32 CostumeId);
	bool IsPlayerInputTrgBrainField();
	bool IsPlayerStatus(ERSPartyPlayerKind Kind, EPlayerCommonStatus PlayerStatus);
	bool IsPluginNpcAutoReviveAble(EPlayerID PlayerId);
	bool IsVisiblePhotoModeHood_Native(ERSPartyPlayerKind Kind);
	void KpiAddNpcSupportAttack(EPlayerID ID);
	void KpiAddNpcSupportBrainField(EPlayerID ID);
	void KpiAddNpcSupportCover(EPlayerID ID);
	void KpiAddNpcSupportRevive(EPlayerID ID);
	void LocationChangeParameterReset();
	void MainPlayerAccessoryBackup(EPlayerID PlayerId);
	void NotifyBattleSimulatorEnd(bool bMissionCancel);
	void PlayerSetting(ERSPartyPlayerKind Kind, class ARSCharacterBase* Player);
	void PlayPhotoModeFacialAnim_Native(ERSPartyPlayerKind Kind, EPlayerFacialAnim_Native Anim);
	class ARSCharacterBase* ProtectedSpawnNotPartyPlayer(TSubclassOf<class ARSCharacterBase> PlayerClass, const struct FTransform& Transform, class AActor* CreateOwner);
	int32 ReCalcRemainingSkillPoint(EPlayerID ID);
	void RecoveryReserveMemberBadStatus();
	void RecoveryReserveMemberHP();
	void ReflectBattleMemberParameter();
	void ReflectBattleMemberParameterPersonal(EPlayerID PlayerId);
	void RegisterExtraPlayer(class ARSCharacterBase* ExtraPlayer);
	void RegisterKeepOutAreaBox(int32* OutRegisterId, const struct FVector& InMin, const struct FVector& InMax);
	void RegisterKeepOutAreaCircle(int32* OutRegisterId, const struct FVector& Location, float Radius);
	void RemovePartyMember(EPlayerID ID, bool bDestroy, bool bDequipAttachment, bool bDefaultCostume);
	void ReturnEventRemvoeMembers();
	void ReturnPartyMember(EPlayerID ID, const bool IsCheckBattleMemberMain);
	void SetAjitoTogetherCountDirect(EPlayerID PlayerId, int32 CountHP, int32 CountAttack, int32 CountPsychic, int32 CountDefence);
	void SetBattleEndReserveMemberStatus(float ReviveHPRate);
	void SetBattleMember(ERSPartyPlayerKind Kind, EPlayerID ID, bool bSpawn);
	bool SetBattleMemberCore(ERSPartyPlayerKind Kind, EPlayerID ID, bool bSpawn);
	void SetBattleMemberToEmpty(EPlayerID ID);
	void SetDisableBattleActionFlag(bool bDisable);
	void SetDriveUsedFlag(bool bFlag);
	void SetLevelDifferentExpRate(const struct FLevelDifferentExpRateData& Data);
	void SetPartyMemberInfo(EPlayerID ID, const struct FPlayerInfo& Info, bool bDelayLoad);
	void SetPhotoModeHood_Native(ERSPartyPlayerKind Kind, bool bVisible);
	void SetPlayerAIOrder(EPlayerID ID, EPlayerAIOrder Order);
	void SetPlayerParameter(EPlayerID ID, const struct FCharactersParameterTable& Table, bool bMaxHP);
	void SwapPartyMemberInfo(int32 First, int32 Second);
	void UnregisterExtraPlayer(class ARSCharacterBase* ExtraPlayer);
	void UnregisterKeepOutArea(int32 RegisterId);
	void UpdateLastSallyTime(EPlayerID ID, const int32 PlayBrainTalkTimeMin);
	void UpdateLastUseSasTime(EPlayerID ID, const bool IsPlayBrainTalk);
	struct FCharactersParameterTable UpdatePlayerParameter(EPlayerID PlayerId, bool bMaxHP);
	void UpdatLastNoSallyTime(EPlayerID ID, const int32 PlayBrainTalkTimeMin);

	struct FCharactersParameterTable GetCharactersParameterTable(EPlayerID ID) const;
	struct FPlayerInfo GetPartyMemberInfo(EPlayerID ID) const;
	class ARSCharacterBase* GetPlayer(ERSPartyPlayerKind Kind) const;
	const TArray<class ARSCharacterBase*> GetPlayerList() const;
	int32 GetPlayerNum() const;
	int32 GetPlayerUseCount(EPlayerID ID) const;
	float GetPlayerUseTime(EPlayerID ID) const;
	bool IsDisableBattleActionFlag() const;
	bool IsExecNpcReviveDirection_CallFromCPP() const;
	bool IsExecResurrect_CallFromCPP() const;
	bool IsExistPartyMember(EPlayerID ID) const;
	bool IsNpcThinkAssistAttackCPP() const;
	bool IsPlayingDead_CallFromCPP() const;
	bool IsPlayingDeadRecover_CallFromCPP() const;
	bool IsPlayingRecover_CallFromCPP() const;
	bool NeedsStatusAssist() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerManager">();
	}
	static class APlayerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerManager>();
	}
};
static_assert(alignof(APlayerManager) == 0x000008, "Wrong alignment on APlayerManager");
static_assert(sizeof(APlayerManager) == 0x0003F0, "Wrong size on APlayerManager");
static_assert(offsetof(APlayerManager, _playerList) == 0x000238, "Member 'APlayerManager::_playerList' has a wrong offset!");
static_assert(offsetof(APlayerManager, _extraPlayerList) == 0x000248, "Member 'APlayerManager::_extraPlayerList' has a wrong offset!");
static_assert(offsetof(APlayerManager, _BattleMemberMain) == 0x000259, "Member 'APlayerManager::_BattleMemberMain' has a wrong offset!");
static_assert(offsetof(APlayerManager, _BattleMemberLeft) == 0x00025A, "Member 'APlayerManager::_BattleMemberLeft' has a wrong offset!");
static_assert(offsetof(APlayerManager, _BattleMemberRight) == 0x00025B, "Member 'APlayerManager::_BattleMemberRight' has a wrong offset!");
static_assert(offsetof(APlayerManager, _partyInfoList) == 0x000260, "Member 'APlayerManager::_partyInfoList' has a wrong offset!");
static_assert(offsetof(APlayerManager, _partyParameterTableList) == 0x000270, "Member 'APlayerManager::_partyParameterTableList' has a wrong offset!");
static_assert(offsetof(APlayerManager, _delayLoadList) == 0x000280, "Member 'APlayerManager::_delayLoadList' has a wrong offset!");
static_assert(offsetof(APlayerManager, DispatchEquipWeaponDelegate) == 0x000290, "Member 'APlayerManager::DispatchEquipWeaponDelegate' has a wrong offset!");
static_assert(offsetof(APlayerManager, DispatchEquipCostumeDelegate) == 0x0002A0, "Member 'APlayerManager::DispatchEquipCostumeDelegate' has a wrong offset!");
static_assert(offsetof(APlayerManager, WeaponExtraAbilityDataTable) == 0x0002B0, "Member 'APlayerManager::WeaponExtraAbilityDataTable' has a wrong offset!");
static_assert(offsetof(APlayerManager, AccessoryExtendParameterDataTable) == 0x0002B8, "Member 'APlayerManager::AccessoryExtendParameterDataTable' has a wrong offset!");
static_assert(offsetof(APlayerManager, _partyPlayerCache) == 0x0002C0, "Member 'APlayerManager::_partyPlayerCache' has a wrong offset!");
static_assert(offsetof(APlayerManager, DispatchChangeDisableBattleActionFlag) == 0x0002D0, "Member 'APlayerManager::DispatchChangeDisableBattleActionFlag' has a wrong offset!");
static_assert(offsetof(APlayerManager, bNpcThinkAssistAttack) == 0x00031C, "Member 'APlayerManager::bNpcThinkAssistAttack' has a wrong offset!");
static_assert(offsetof(APlayerManager, EventBackupEquipWeapon) == 0x000320, "Member 'APlayerManager::EventBackupEquipWeapon' has a wrong offset!");
static_assert(offsetof(APlayerManager, AjitoTogetherDataTable) == 0x0003B8, "Member 'APlayerManager::AjitoTogetherDataTable' has a wrong offset!");
static_assert(offsetof(APlayerManager, AjitoTogetherData) == 0x0003C0, "Member 'APlayerManager::AjitoTogetherData' has a wrong offset!");
static_assert(offsetof(APlayerManager, AjitoTogetherData_MainPlayer) == 0x0003D0, "Member 'APlayerManager::AjitoTogetherData_MainPlayer' has a wrong offset!");
static_assert(offsetof(APlayerManager, PluginNpcAutoReviveCount) == 0x0003E0, "Member 'APlayerManager::PluginNpcAutoReviveCount' has a wrong offset!");

// Class BattlePrototype.PlayerMeshSetupComponent
// 0x0010 (0x00D0 - 0x00C0)
class UPlayerMeshSetupComponent final : public UActorComponent
{
public:
	uint8                                         Pad_24F1[0x10];                                    // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoSetup(class UMeshComponent* Mesh, TSubclassOf<class UPlayerRenderSettings> RenderSettingsClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMeshSetupComponent">();
	}
	static class UPlayerMeshSetupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMeshSetupComponent>();
	}
};
static_assert(alignof(UPlayerMeshSetupComponent) == 0x000008, "Wrong alignment on UPlayerMeshSetupComponent");
static_assert(sizeof(UPlayerMeshSetupComponent) == 0x0000D0, "Wrong size on UPlayerMeshSetupComponent");

// Class BattlePrototype.PlayerRessurectComponent
// 0x0048 (0x0108 - 0x00C0)
class UPlayerRessurectComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchResurrectSuccess;                          // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RessurectTime;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseTimeRate;                                  // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RessurectRange;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RessurectHeight;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RessurectAngle;                                    // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconOffsetZ;                                       // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F2[0x20];                                    // 0x00E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateRessurectIcon(class AActor* DeadPlayer);
	void BeginRessurect(float TimeRate);
	void DeactivateRessurectIcon();
	float GetDistanceSquared2D();
	class UUIResurrectionGauge* GetUI();
	bool IsEnableRessurect();
	bool IsExecRessurect();
	void SetVisibleWidget(bool Visible);
	void SuspendRessurect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerRessurectComponent">();
	}
	static class UPlayerRessurectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerRessurectComponent>();
	}
};
static_assert(alignof(UPlayerRessurectComponent) == 0x000008, "Wrong alignment on UPlayerRessurectComponent");
static_assert(sizeof(UPlayerRessurectComponent) == 0x000108, "Wrong size on UPlayerRessurectComponent");
static_assert(offsetof(UPlayerRessurectComponent, DispatchResurrectSuccess) == 0x0000C0, "Member 'UPlayerRessurectComponent::DispatchResurrectSuccess' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, RessurectTime) == 0x0000D0, "Member 'UPlayerRessurectComponent::RessurectTime' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, DecreaseTimeRate) == 0x0000D4, "Member 'UPlayerRessurectComponent::DecreaseTimeRate' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, RessurectRange) == 0x0000D8, "Member 'UPlayerRessurectComponent::RessurectRange' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, RessurectHeight) == 0x0000DC, "Member 'UPlayerRessurectComponent::RessurectHeight' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, RessurectAngle) == 0x0000E0, "Member 'UPlayerRessurectComponent::RessurectAngle' has a wrong offset!");
static_assert(offsetof(UPlayerRessurectComponent, IconOffsetZ) == 0x0000E4, "Member 'UPlayerRessurectComponent::IconOffsetZ' has a wrong offset!");

// Class BattlePrototype.UIHealthControl
// 0x0060 (0x03E8 - 0x0388)
class UUIHealthControl : public UUIBase
{
public:
	uint8                                         Pad_24F3[0x60];                                    // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsUnlockPlayerChara(EPlayerID CharaID);
	void ResetFlagFirstSet();
	void SetHp(float Max, float Current);
	void SetHpDirect(float Max, float Current);
	void SetIcon(int32 Param_Index, class UImage* Icon);
	void SetIcon1(class UImage* Icon, int32 Param_Index);
	void SetIcon2(class UImage* Icon, int32 Param_Index);
	void SetIconDraw(int32 Param_Index, bool IsDraw);
	void SetIconType(int32 Type);
	void SetNotHealAnimationFlag(bool IsNotAnimation);
	void SetPlayerName(EPlayerID CharaID, class UTextBlock* Text);
	void SetProgressBar(class UImage* Base, class UImage* Override, class UImage* base_add);
	void SetTextHP(class UTextBlock* TextMaxHP, class UTextBlock* TextCurrentHP);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	int32 GetBadStateNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHealthControl">();
	}
	static class UUIHealthControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHealthControl>();
	}
};
static_assert(alignof(UUIHealthControl) == 0x000008, "Wrong alignment on UUIHealthControl");
static_assert(sizeof(UUIHealthControl) == 0x0003E8, "Wrong size on UUIHealthControl");

// Class BattlePrototype.UIVitalityEN01
// 0x0030 (0x0418 - 0x03E8)
class UUIVitalityEN01 : public UUIHealthControl
{
public:
	uint8                                         Pad_24F9[0x30];                                    // 0x03E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageIcon1, class UImage* ImageIcon2, class UImage* ImageIcon3, class UImage* ImageIcon4, class UImage* ImageIcon5, class UTextBlock* TextBossName, class UImage* ImageBarNormal, class UImage* ImageBarOverride, class UImage* ImageBarAdd);
	void SetLevel(int32 Level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityEN01">();
	}
	static class UUIVitalityEN01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityEN01>();
	}
};
static_assert(alignof(UUIVitalityEN01) == 0x000008, "Wrong alignment on UUIVitalityEN01");
static_assert(sizeof(UUIVitalityEN01) == 0x000418, "Wrong size on UUIVitalityEN01");

// Class BattlePrototype.PlayerScriptComponent
// 0x0650 (0x0710 - 0x00C0)
class UPlayerScriptComponent final : public UActorComponent
{
public:
	uint8                                         Pad_24FA[0x90];                                    // 0x00C0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSASEffectState                        SAS_Fire;                                          // 0x0150(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Metal;                                         // 0x0168(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_SeeThrough;                                    // 0x0180(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Telepo;                                        // 0x0198(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Stealth;                                       // 0x01B0(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Electric;                                      // 0x01C8(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Copy;                                          // 0x01E0(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Accelerator;                                   // 0x01F8(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Psychic_ch0100;                                // 0x0210(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Psychic_ch0200;                                // 0x0228(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FSASEffectState                        SAS_Invalid;                                       // 0x0240(0x0018)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_24FB[0x88];                                    // 0x0258(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        _LocationHistroy;                                  // 0x02E0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ConfusionStickParam_InputTimeMin;                  // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionStickParam_InputTimeMax;                  // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionStickParam_IntervalMin;                   // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionStickParam_IntervalMax;                   // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionAttackParam_IntervalMin;                  // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionAttackParam_IntervalMax;                  // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionAttackParam_Rate;                         // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConfusionPsychicParam_Rate;                        // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FC[0x28];                                    // 0x0310(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchSkillRegenerateHP;                         // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FD[0x18];                                    // 0x0348(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NeonNotifyTimeMax;                                 // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FE[0x4];                                     // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URSParticleSystemComponentBase> NeonNotifyParticleComponentClass;                  // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        NeonNotifyParticle_DriveMax;                       // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        NeonNotifyParticle_Dying;                          // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        NeonNotifyParticle_ActionFailed;                   // 0x0380(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NeonNotifyParticleAttach_SocketName;               // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NeonNotifyParticleAttach_Offset;                   // 0x0390(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FF[0x14];                                    // 0x039C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchUpdateBrainField;                          // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBrainFieldState;                           // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBrainFieldIntervalEnd;                     // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchLunaticBrainTalk;                          // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBrainFieldPsychicGaugeChange;              // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchBackGroundStuck;                           // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2500[0x168];                                   // 0x0410(0x0168)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrainFieldPsychicGaugeDirectionData> PsychicGaugeDirectionData;                         // 0x0578(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2501[0x10];                                    // 0x0588(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerID>                             BrainFieldHelpedPlayerList;                        // 0x0598(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2502[0xF8];                                    // 0x05A8(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchBrainTalkHitCount;                         // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Param_BrainTalkHitCount;                           // 0x06B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param_BrainTalkHitCountClearIntarval;              // 0x06B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<E_SASKindNative>                       BrainTalkHitCountCheckSASList;                     // 0x06B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2503[0x10];                                    // 0x06C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BRAINFIELDPSYCHIC_BOSS_RATE;                       // 0x06D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2504[0x4];                                     // 0x06DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AvoidWallCountMax;                                 // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StagnationCheckLocationThreshold;                  // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StagnationResetTime;                               // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2505[0x24];                                    // 0x06EC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ActionState_CommonTransition(EPlayerActionKind* NextAction, int32* NextParam);
	void AddActionStatus(EPlayerActionStatus Status);
	void AddBrainFieldHelpExtraTime();
	void AddFlyingDodgeCount();
	void AddPlayerStatus(EPlayerCommonStatus Status);
	void AddUpperActionStatus(EPlayerUpperActionStatus Status);
	void ApplySASEffectActive(E_SASKindNative Kind, bool bActivate);
	void ApplySASEffectPassive(E_SASKindNative Kind);
	void ApplySASEffectPassiveAll();
	void ApplySASEffectPassiveAllLinkAble();
	void BeginBrainField();
	void BeginConfusionStick();
	void BeginNeonNotify(EPlayerNeonNotifyType Type);
	void BrainTalk_AddHitCount(bool bNoDamage);
	void BrainTalk_CheckSASHitCount(bool bCheck, E_SASKindNative Kind);
	void BrainTalk_ClearHitCount();
	bool CalcAccumulationByAttack_ForPlayer(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, float& RefCrashCapCheckRate, class AActor* DefenseActor, EHCSkillAttackType AttackType, bool bCopyActor, const struct FHCSkillCommonInfo& SkillInfo, float COPY_REACTION_RATE, float COPY_BADSTATUS_RATE);
	bool CalcAccumulationByDefence_ForPlayer(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, float& RefCrashCapCheckRate, class AActor* AttackActor, bool IsSuperArmor);
	float CalcCritical_ForPlayer(float Critical, class AActor* DefenseActor, bool IsEnpc, class AActor* TargetActor, bool bAssassinAttack);
	bool CalcDamageByAttack_ForHero(float& RefPhysicsDamage, float& RefObjDamage, float& RefFlameDamage, float& RefElectricDamage, float& RefCriticalDamageRate, class AActor* DefenseActor);
	float CalcFinalDamageByAttack_ForHero(float Damage, class AActor* DefenseActor, const struct FHCSkillCommonInfo& SkillInfo, bool bSkill_PinchStatusUp, float Skill_DownDamageUp, float Skill_PinchAttackUpRate);
	float CalcFinalDamageByAttack_ForPlayer(float Damage, class AActor* DefenseActor, const struct FHCSkillCommonInfo& SkillInfo, float COPY_ATTACK_RATE, float NPC_ATTACK_DAMAGE_RATE);
	float CalcFinalDamageByDefence_ForHero(float Damage, class AActor* AttackActor, bool bSkill_PinchStatusUp, float Skill_PinchDamageDownRate, float Skill_BrainFieldDamageCut);
	float CalcFinalDamageByDefence_ForPlayer(float Damage, class AActor* AttackActor, float NPC_DEFENCE_DAMAGE_RATE);
	EPlayerID CheckBrainFieldHelpPlayer();
	TArray<EFindTargetBrainTalkType> CheckFindBrainTalk(class ARSCharacterBase* TargetActor);
	void CheckFixCameraFinish(const struct FVector2D& FixCameraLeftStick, bool bLockTarget);
	void ClearActionStatus();
	void ClearExcludeLotPlayer(EFriendLotType LotType);
	void ClearFlyingDodgeCount();
	void ClearPlayerStatus();
	void ClearUpperActionStatus();
	void DebugBrainFieldHelpForceSuccess(bool bSet);
	void DebugBrainFieldHelpPlayerFix(EPlayerID FixPlayerID);
	void DebugCoverDamagePrintLog(bool bOutput);
	void DebugInfiniteBrainField(bool bSet);
	void DebugLotPlayerTest(EFriendLotType LotType, int32 Count);
	void DebugNoBrainFieldHelp(bool bSet);
	void DisableBrainFieldLunaticBrainTalk(bool bDisable);
	void DisableRegenerateHP();
	void EnableRegenerateHP(float RegenerateHPRate, float IntervalTime);
	void EndBrainField();
	void EndConfusionStick();
	void EndNeonNotify();
	void EventDirectBrainFieldWarning();
	void ExcludeLotPlayer(EPlayerID ID, EFriendLotType LotType);
	void ForceSettingConfusionStick(float InputTime);
	float GetBrainFieldGameOverTimeRate();
	class FName GetBrainFieldHelpBrainTalkID();
	int32 GetBrainFieldHelpedCount();
	float GetBrainFieldRemainTime();
	float GetBrainFieldTimeRate();
	int32 GetBrainFieldWarningCount();
	void GetConfusionStickInput(bool* bOverwriteInput, struct FVector2D* StickInput);
	bool GetIsDead_Native();
	TArray<struct FVector> GetLocationHistory();
	void GetPlayerAccessoryExtendParameter(EEffecacyType EffectType, bool* bOutEquip, TArray<float>* OutParameter);
	struct FSASEffectState GetSASEffectState(E_SASKindNative Kind);
	void Initialize(bool bNpc, class UCharacterMovementComponent* CharaMoveComp, class UPlayerAnimControllerComponent* AnimControllerComp, class UCharactersParameterComponent* CharactersParameterComp, class URSStateManageComponent* StateManageComp, class URSStateManageComponent* UpperStateManageComp, class UPlayerInputBaseComponent* PlayerInputComp, class UAttackInputComponent* AttackInputComp, class UPlayerAsyncScriptComponent* PlayerAsyncComp, class UMoveInputComponent* MoveInputComp, class UPlayerCameraComponent* PlayerCameraComp);
	bool IsActiveBrainFieldGameOverTimer();
	bool IsOverwriteAttackAutoAim();
	bool IsSubAttackButtonAttack(const struct FHCSkillCommonInfo& SkillInfo);
	bool LotAssassinAttackLevelOffset(EAssassinAttackHit EffectiveType, int32 OwnerLevel, int32 TargetLevel, bool bSeeThrough, const struct FAssassinAttackData& CalcData);
	EPlayerID LotFriendPlayer(EFriendLotType LotType, bool bDebugSuccess);
	void MainTick(float DeltaSeconds);
	void NextBrainFieldState();
	void OnBeginAvoidWall(const struct FVector& InLocation);
	bool OverwriteAttackCollisionInfo_ForHero(struct FHCCollisionCommonInfo& RefCommonInfo, struct FHCSkillCommonInfo& RefSkill, float SkillWeaponCrashScale, float SkillPsychicCrashScale, float SkillDriveCrashScale, float NPC_HERO_CRASH_RATE, bool bExJustDodgeFlag, float ExJustDodgeAttackRate, float ExJustDodgeCrashRate, float Skill_AerialAttackPsychicGaugeUp);
	bool OverwriteAttackCollisionInfo_ForPlayer(struct FHCCollisionCommonInfo& RefCommonInfo, struct FHCSkillCommonInfo& RefSkill, bool bAddTelepoAttack);
	void PauseBrainFieldTimer(bool bPause);
	void PostTick(float DeltaSeconds);
	void PreTick(float DeltaSeconds);
	void ResetHistory();
	void ResetStagnation();
	void SetAttackFlyingEnd();
	void SetBattling(bool bBattle);
	void SetBrainFieldData(const struct FPlayerBrainFieldData& InData, const struct FPlayerBrainFieldData& InFirstBrainFieldData, const struct FPlayerBrainFieldHelpData& InHelpData, const TArray<struct FBrainFieldPsychicGaugeDirectionData>& PsychicGaugeData);
	void SetBrainFieldExtraTime(float ExtraTime);
	void SetBrainFieldState(EPlayerBrainFieldState State);
	void SetCombinationVisionPenalty(bool bSet);
	void SetCombinationVisionPenaltyDamageRate(float Rate);
	void SetFlyingActionLimitDistance(float LimitDistance);
	void SetIgnoreFallTimer(float IgnoreTime);
	void SetLotFriendData(EFriendLotType LotType, const struct FFriendLotData& Data);
	void SetMaxFlyingDodgeCount(int32 Count);
	void SetPauseTimer(bool bPause);
	void SetRestrictStagnationCheck(bool bRestrict);
	void SetRunSpeedRate(float InRate);
	void SubActionStatus(EPlayerActionStatus Status);
	void SubPlayerStatus(EPlayerCommonStatus Status);
	void SubUpperActionStatus(EPlayerUpperActionStatus Status);
	void UpdateBrainField(float DeltaSeconds);
	void UpdateBrainFieldInterval(float DeltaSeconds);
	void UpdateCameraRotate(float DeltaSeconds, const struct FVector2D& FixCameraLeftStick, bool bLockTarget, bool bDisableCameraControl, bool bUseCutCamera, bool bUniqueObjectInput);
	void UpdateDisableAction();
	void UpdateEnableActionCommon();
	void UpdateMoveInputTrigger(bool bEnableAddMove, float MaxSpeedScale, float MoveInputScale, float MoveDeadEndDistance);

	float CalcAccessoryBadStatusRate(float Value, float Rate) const;
	EPlayerBrainFieldDanger GetBrainFieldDangerLV() const;
	EPlayerID GetBrainFieldHelpPlayer() const;
	EPlayerBrainFieldState GetBrainFieldState() const;
	struct FRotator GetCameraRotation() const;
	void GetPlayerAccessoryEffect(EEffecacyType EffectType, bool* bOutEquip, float* OutParam) const;
	class UPlayerAnimControllerComponent* GetPlayerAnimController() const;
	struct FVector GetRecentAverageVelocity() const;
	const struct FSASEffectState GetSASEffectStateConst(E_SASKindNative Kind) const;
	bool IsActionStatus(EPlayerActionStatus Status) const;
	bool IsActiveSAS(E_SASKindNative Kind) const;
	bool IsBattling() const;
	bool IsBossBattle() const;
	bool IsBrainFieldInterval() const;
	bool IsDisableAction() const;
	bool IsDisableActionDodge(bool bIgnoreBadStatus) const;
	bool IsEnableActionAttack() const;
	bool IsEnableActionBrainCrash() const;
	bool IsEnableActionBrainFieldClose() const;
	bool IsEnableActionBrainFieldOpen() const;
	bool IsEnableActionChangeBattle() const;
	bool IsEnableActionCommon() const;
	bool IsEnableActionDamage() const;
	bool IsEnableActionDodge(bool bIgnoreBadStatus) const;
	bool IsEnableActionIdleWalkRun(bool bIgnoreExecTelepo) const;
	bool IsEnableActionJump() const;
	bool IsEnableActionPsychic(bool bPsychicEx) const;
	bool IsEnableActionSprint() const;
	bool IsEnableActionUseItem() const;
	bool IsEnableDriveFullDirection() const;
	bool IsEnableNpcAssist() const;
	bool IsEnableSAS() const;
	void IsEnableSASEffect(E_SASKindNative Kind, ESASEffect Effect, bool* OutEnable, float* OutParam0, float* OutParam1, float* OutParam2, float* OutParam3) const;
	bool IsInitializedSASEffectFixParam(E_SASKindNative Kind) const;
	bool IsPlayerInAerial() const;
	bool IsPlayerStatus(EPlayerCommonStatus Status) const;
	bool IsRestrictStagnationCheck() const;
	bool IsRunningAnimStateForAIMove() const;
	bool IsRunOrSprint() const;
	bool IsSearchAbleActionIcon() const;
	bool IsStagnation(bool bCheckLocation, const struct FVector& InCurrentLocation) const;
	bool IsUpperActionStatus(EPlayerUpperActionStatus Status) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScriptComponent">();
	}
	static class UPlayerScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScriptComponent>();
	}
};
static_assert(alignof(UPlayerScriptComponent) == 0x000008, "Wrong alignment on UPlayerScriptComponent");
static_assert(sizeof(UPlayerScriptComponent) == 0x000710, "Wrong size on UPlayerScriptComponent");
static_assert(offsetof(UPlayerScriptComponent, SAS_Fire) == 0x000150, "Member 'UPlayerScriptComponent::SAS_Fire' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Metal) == 0x000168, "Member 'UPlayerScriptComponent::SAS_Metal' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_SeeThrough) == 0x000180, "Member 'UPlayerScriptComponent::SAS_SeeThrough' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Telepo) == 0x000198, "Member 'UPlayerScriptComponent::SAS_Telepo' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Stealth) == 0x0001B0, "Member 'UPlayerScriptComponent::SAS_Stealth' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Electric) == 0x0001C8, "Member 'UPlayerScriptComponent::SAS_Electric' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Copy) == 0x0001E0, "Member 'UPlayerScriptComponent::SAS_Copy' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Accelerator) == 0x0001F8, "Member 'UPlayerScriptComponent::SAS_Accelerator' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Psychic_ch0100) == 0x000210, "Member 'UPlayerScriptComponent::SAS_Psychic_ch0100' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Psychic_ch0200) == 0x000228, "Member 'UPlayerScriptComponent::SAS_Psychic_ch0200' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, SAS_Invalid) == 0x000240, "Member 'UPlayerScriptComponent::SAS_Invalid' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, _LocationHistroy) == 0x0002E0, "Member 'UPlayerScriptComponent::_LocationHistroy' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionStickParam_InputTimeMin) == 0x0002F0, "Member 'UPlayerScriptComponent::ConfusionStickParam_InputTimeMin' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionStickParam_InputTimeMax) == 0x0002F4, "Member 'UPlayerScriptComponent::ConfusionStickParam_InputTimeMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionStickParam_IntervalMin) == 0x0002F8, "Member 'UPlayerScriptComponent::ConfusionStickParam_IntervalMin' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionStickParam_IntervalMax) == 0x0002FC, "Member 'UPlayerScriptComponent::ConfusionStickParam_IntervalMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionAttackParam_IntervalMin) == 0x000300, "Member 'UPlayerScriptComponent::ConfusionAttackParam_IntervalMin' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionAttackParam_IntervalMax) == 0x000304, "Member 'UPlayerScriptComponent::ConfusionAttackParam_IntervalMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionAttackParam_Rate) == 0x000308, "Member 'UPlayerScriptComponent::ConfusionAttackParam_Rate' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, ConfusionPsychicParam_Rate) == 0x00030C, "Member 'UPlayerScriptComponent::ConfusionPsychicParam_Rate' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchSkillRegenerateHP) == 0x000338, "Member 'UPlayerScriptComponent::DispatchSkillRegenerateHP' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyTimeMax) == 0x000360, "Member 'UPlayerScriptComponent::NeonNotifyTimeMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticleComponentClass) == 0x000368, "Member 'UPlayerScriptComponent::NeonNotifyParticleComponentClass' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticle_DriveMax) == 0x000370, "Member 'UPlayerScriptComponent::NeonNotifyParticle_DriveMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticle_Dying) == 0x000378, "Member 'UPlayerScriptComponent::NeonNotifyParticle_Dying' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticle_ActionFailed) == 0x000380, "Member 'UPlayerScriptComponent::NeonNotifyParticle_ActionFailed' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticleAttach_SocketName) == 0x000388, "Member 'UPlayerScriptComponent::NeonNotifyParticleAttach_SocketName' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, NeonNotifyParticleAttach_Offset) == 0x000390, "Member 'UPlayerScriptComponent::NeonNotifyParticleAttach_Offset' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchUpdateBrainField) == 0x0003B0, "Member 'UPlayerScriptComponent::DispatchUpdateBrainField' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchBrainFieldState) == 0x0003C0, "Member 'UPlayerScriptComponent::DispatchBrainFieldState' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchBrainFieldIntervalEnd) == 0x0003D0, "Member 'UPlayerScriptComponent::DispatchBrainFieldIntervalEnd' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchLunaticBrainTalk) == 0x0003E0, "Member 'UPlayerScriptComponent::DispatchLunaticBrainTalk' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchBrainFieldPsychicGaugeChange) == 0x0003F0, "Member 'UPlayerScriptComponent::DispatchBrainFieldPsychicGaugeChange' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchBackGroundStuck) == 0x000400, "Member 'UPlayerScriptComponent::DispatchBackGroundStuck' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, PsychicGaugeDirectionData) == 0x000578, "Member 'UPlayerScriptComponent::PsychicGaugeDirectionData' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, BrainFieldHelpedPlayerList) == 0x000598, "Member 'UPlayerScriptComponent::BrainFieldHelpedPlayerList' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, DispatchBrainTalkHitCount) == 0x0006A0, "Member 'UPlayerScriptComponent::DispatchBrainTalkHitCount' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, Param_BrainTalkHitCount) == 0x0006B0, "Member 'UPlayerScriptComponent::Param_BrainTalkHitCount' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, Param_BrainTalkHitCountClearIntarval) == 0x0006B4, "Member 'UPlayerScriptComponent::Param_BrainTalkHitCountClearIntarval' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, BrainTalkHitCountCheckSASList) == 0x0006B8, "Member 'UPlayerScriptComponent::BrainTalkHitCountCheckSASList' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, BRAINFIELDPSYCHIC_BOSS_RATE) == 0x0006D8, "Member 'UPlayerScriptComponent::BRAINFIELDPSYCHIC_BOSS_RATE' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, AvoidWallCountMax) == 0x0006E0, "Member 'UPlayerScriptComponent::AvoidWallCountMax' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, StagnationCheckLocationThreshold) == 0x0006E4, "Member 'UPlayerScriptComponent::StagnationCheckLocationThreshold' has a wrong offset!");
static_assert(offsetof(UPlayerScriptComponent, StagnationResetTime) == 0x0006E8, "Member 'UPlayerScriptComponent::StagnationResetTime' has a wrong offset!");

// Class BattlePrototype.PlayerWeaponChargeComponent
// 0x0030 (0x00F0 - 0x00C0)
class UPlayerWeaponChargeComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchChangeLevel;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<float>                                 ChargeTimeList;                                    // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252D[0x10];                                    // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndCharge();
	void ResetCharge();
	void StartCharge(TArray<float>& TimeList);

	int32 GetChargeLevel() const;
	bool IsCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerWeaponChargeComponent">();
	}
	static class UPlayerWeaponChargeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerWeaponChargeComponent>();
	}
};
static_assert(alignof(UPlayerWeaponChargeComponent) == 0x000008, "Wrong alignment on UPlayerWeaponChargeComponent");
static_assert(sizeof(UPlayerWeaponChargeComponent) == 0x0000F0, "Wrong size on UPlayerWeaponChargeComponent");
static_assert(offsetof(UPlayerWeaponChargeComponent, DispatchChangeLevel) == 0x0000C0, "Member 'UPlayerWeaponChargeComponent::DispatchChangeLevel' has a wrong offset!");
static_assert(offsetof(UPlayerWeaponChargeComponent, ChargeTimeList) == 0x0000D0, "Member 'UPlayerWeaponChargeComponent::ChargeTimeList' has a wrong offset!");

// Class BattlePrototype.UIVitalityPLBase
// 0x0080 (0x0468 - 0x03E8)
class UUIVitalityPLBase : public UUIHealthControl
{
public:
	uint8                                         Pad_252E[0x30];                                    // 0x03E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterVitalityDataAsset*            WaveDesignerDataAsset;                             // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_252F[0x30];                                    // 0x0420(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GaugeWidth_;                                       // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2530[0x4];                                     // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       GaugeMaterialInstDynamics_;                        // 0x0458(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CreateDynamicGaugeMaterial();
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageIcon1, class UImage* ImageIcon2, class UImage* ImageIcon3, class UImage* ImageIcon4, class UImage* ImageIcon5, class UImage* ImageBarNormal, class UImage* ImageBarOverride, class UImage* ImageBarAdd, class UTextBlock* TextPlayerName, class UTextBlock* _textMaxHP, class UTextBlock* _textCurrentHP);
	void InitializeThisParam(class UImage* ImageIcon1, class UImage* ImageIcon2, class UImage* ImageIcon3, class UImage* ImageIcon4, class UImage* ImageIcon5, class UTextBlock* TextPlayerName, class UTextBlock* _textMaxHP, class UTextBlock* _textCurrentHP);
	void SetName(EPlayerID CharaID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityPLBase">();
	}
	static class UUIVitalityPLBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityPLBase>();
	}
};
static_assert(alignof(UUIVitalityPLBase) == 0x000008, "Wrong alignment on UUIVitalityPLBase");
static_assert(sizeof(UUIVitalityPLBase) == 0x000468, "Wrong size on UUIVitalityPLBase");
static_assert(offsetof(UUIVitalityPLBase, WaveDesignerDataAsset) == 0x000418, "Member 'UUIVitalityPLBase::WaveDesignerDataAsset' has a wrong offset!");
static_assert(offsetof(UUIVitalityPLBase, GaugeWidth_) == 0x000450, "Member 'UUIVitalityPLBase::GaugeWidth_' has a wrong offset!");
static_assert(offsetof(UUIVitalityPLBase, GaugeMaterialInstDynamics_) == 0x000458, "Member 'UUIVitalityPLBase::GaugeMaterialInstDynamics_' has a wrong offset!");

// Class BattlePrototype.UIVitalityPL02
// 0x0000 (0x0468 - 0x0468)
class UUIVitalityPL02 : public UUIVitalityPLBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityPL02">();
	}
	static class UUIVitalityPL02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityPL02>();
	}
};
static_assert(alignof(UUIVitalityPL02) == 0x000008, "Wrong alignment on UUIVitalityPL02");
static_assert(sizeof(UUIVitalityPL02) == 0x000468, "Wrong size on UUIVitalityPL02");

// Class BattlePrototype.PostProcessManager
// 0x0008 (0x0238 - 0x0230)
class APostProcessManager : public AActor
{
public:
	uint8                                         Pad_2531[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterPostProcess(class UPostProcessComponent* InComponent);
	void UnregisterPostProcess(class UPostProcessComponent* InComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessManager">();
	}
	static class APostProcessManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APostProcessManager>();
	}
};
static_assert(alignof(APostProcessManager) == 0x000008, "Wrong alignment on APostProcessManager");
static_assert(sizeof(APostProcessManager) == 0x000238, "Wrong size on APostProcessManager");

// Class BattlePrototype.PostProcessParam
// 0x0028 (0x0058 - 0x0030)
class UPostProcessParam final : public UDataAsset
{
public:
	float                                         VisionFogSeeThroughFog;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1020;                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1200;                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1210;                 // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1300;                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1400;                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em8300;                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_np1100;                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisionFogSeeThroughFogList_em1130;                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2532[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessParam">();
	}
	static class UPostProcessParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPostProcessParam>();
	}
};
static_assert(alignof(UPostProcessParam) == 0x000008, "Wrong alignment on UPostProcessParam");
static_assert(sizeof(UPostProcessParam) == 0x000058, "Wrong size on UPostProcessParam");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFog) == 0x000030, "Member 'UPostProcessParam::VisionFogSeeThroughFog' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1020) == 0x000034, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1020' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1200) == 0x000038, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1200' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1210) == 0x00003C, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1210' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1300) == 0x000040, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1300' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1400) == 0x000044, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1400' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em8300) == 0x000048, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em8300' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_np1100) == 0x00004C, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_np1100' has a wrong offset!");
static_assert(offsetof(UPostProcessParam, VisionFogSeeThroughFogList_em1130) == 0x000050, "Member 'UPostProcessParam::VisionFogSeeThroughFogList_em1130' has a wrong offset!");

// Class BattlePrototype.PresentData
// 0x0010 (0x0038 - 0x0028)
class UPresentData final : public UObject
{
public:
	class UDataTable*                             PresentData_;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             PresentLocationData_;                              // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool GetPresentEventData(struct FPresentEventDataCell* PresentEventData, class FName ItemId, class FName FromCharaID, class FName ForCharaID);
	void LoadPresentDataTable(const class FString& PresentDataPath, const class FString& PresentLocationDatapath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentData">();
	}
	static class UPresentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentData>();
	}
};
static_assert(alignof(UPresentData) == 0x000008, "Wrong alignment on UPresentData");
static_assert(sizeof(UPresentData) == 0x000038, "Wrong size on UPresentData");
static_assert(offsetof(UPresentData, PresentData_) == 0x000028, "Member 'UPresentData::PresentData_' has a wrong offset!");
static_assert(offsetof(UPresentData, PresentLocationData_) == 0x000030, "Member 'UPresentData::PresentLocationData_' has a wrong offset!");

// Class BattlePrototype.UIWorldMap
// 0x0010 (0x0398 - 0x0388)
class UUIWorldMap : public UUIBase
{
public:
	uint8                                         Pad_2534[0x8];                                     // 0x0388(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFlagOpenDirect;                                   // 0x0390(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2535[0x7];                                     // 0x0391(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCursorMemory();
	void GetCurrentAreaID(int32* AreaId);
	void GetCurrentLocationID(int32* LocationId);
	void GetCurrentLocationName(class FString* Param_Name);
	void GetCurrentPortalID(int32* PortalID);
	void GetCurrentPortalName(class FName* Param_Name);
	void GetLocationName(int32 Param_Index, class FString* Param_Name);
	void GetPortalName(int32 Param_Index, class FName* Param_Name);
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	bool IsChange();
	bool IsDecide();
	void SetDebugUnlockFlag(bool UnlockFlag);
	void UpdateWorldMapMouseFocus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWorldMap">();
	}
	static class UUIWorldMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWorldMap>();
	}
};
static_assert(alignof(UUIWorldMap) == 0x000008, "Wrong alignment on UUIWorldMap");
static_assert(sizeof(UUIWorldMap) == 0x000398, "Wrong size on UUIWorldMap");
static_assert(offsetof(UUIWorldMap, bFlagOpenDirect) == 0x000390, "Member 'UUIWorldMap::bFlagOpenDirect' has a wrong offset!");

// Class BattlePrototype.PresentInfoParam
// 0x00A8 (0x00D0 - 0x0028)
class UPresentInfoParam final : public UObject
{
public:
	TMap<EPlayerID, struct FPresentCheckArray>    PresentInfoData_ch0100;                            // 0x0028(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EPlayerID, struct FPresentCheckArray>    PresentInfoData_ch0200;                            // 0x0078(0x0050)(NativeAccessSpecifierPrivate)
	class URSGameInstance*                        GameInstance;                                      // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetPresentInfoList(EPlayerID SendCharId, EPlayerID RecvCharID, TArray<struct FPresentInfoData>* GetList, bool IncludeEvent);
	bool IsPresentedFirstTime(EPlayerID SendCharId, EPlayerID RecvCharID, class FName ItemId, bool* IsFirstTime);
	void Reset();
	bool UpdatePresentInfo(EPlayerID SendCharId, EPlayerID RecvCharID, class FName ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentInfoParam">();
	}
	static class UPresentInfoParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentInfoParam>();
	}
};
static_assert(alignof(UPresentInfoParam) == 0x000008, "Wrong alignment on UPresentInfoParam");
static_assert(sizeof(UPresentInfoParam) == 0x0000D0, "Wrong size on UPresentInfoParam");
static_assert(offsetof(UPresentInfoParam, PresentInfoData_ch0100) == 0x000028, "Member 'UPresentInfoParam::PresentInfoData_ch0100' has a wrong offset!");
static_assert(offsetof(UPresentInfoParam, PresentInfoData_ch0200) == 0x000078, "Member 'UPresentInfoParam::PresentInfoData_ch0200' has a wrong offset!");
static_assert(offsetof(UPresentInfoParam, GameInstance) == 0x0000C8, "Member 'UPresentInfoParam::GameInstance' has a wrong offset!");

// Class BattlePrototype.ProjectiveGeomBPFunctions
// 0x0000 (0x0028 - 0x0028)
class UProjectiveGeomBPFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector4 GetDeprojectionMatrix(class APlayerController* PlayerController);
	static struct FVector4 GetViewRect(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectiveGeomBPFunctions">();
	}
	static class UProjectiveGeomBPFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectiveGeomBPFunctions>();
	}
};
static_assert(alignof(UProjectiveGeomBPFunctions) == 0x000008, "Wrong alignment on UProjectiveGeomBPFunctions");
static_assert(sizeof(UProjectiveGeomBPFunctions) == 0x000028, "Wrong size on UProjectiveGeomBPFunctions");

// Class BattlePrototype.WakeUpEventForPostureBase
// 0x0050 (0x0280 - 0x0230)
class AWakeUpEventForPostureBase final : public AActor
{
public:
	uint8                                         Pad_253F[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsDoBeginPlay;                                     // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2540[0x7];                                     // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          EventBoxComponent;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ScenarioFlagRowName;                               // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInnerRange;                                      // 0x0250(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2541[0x3];                                     // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EventStartWaitTime;                                // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Direction;                                         // 0x0258(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectionAcceptRange;                              // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveAcceptRange;                                   // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ConditionEnableElapsedTime;                        // 0x026C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2542[0x10];                                    // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DoEvent();
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakeUpEventForPostureBase">();
	}
	static class AWakeUpEventForPostureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWakeUpEventForPostureBase>();
	}
};
static_assert(alignof(AWakeUpEventForPostureBase) == 0x000008, "Wrong alignment on AWakeUpEventForPostureBase");
static_assert(sizeof(AWakeUpEventForPostureBase) == 0x000280, "Wrong size on AWakeUpEventForPostureBase");
static_assert(offsetof(AWakeUpEventForPostureBase, IsDoBeginPlay) == 0x000238, "Member 'AWakeUpEventForPostureBase::IsDoBeginPlay' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, EventBoxComponent) == 0x000240, "Member 'AWakeUpEventForPostureBase::EventBoxComponent' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, ScenarioFlagRowName) == 0x000248, "Member 'AWakeUpEventForPostureBase::ScenarioFlagRowName' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, IsInnerRange) == 0x000250, "Member 'AWakeUpEventForPostureBase::IsInnerRange' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, EventStartWaitTime) == 0x000254, "Member 'AWakeUpEventForPostureBase::EventStartWaitTime' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, Direction) == 0x000258, "Member 'AWakeUpEventForPostureBase::Direction' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, DirectionAcceptRange) == 0x000264, "Member 'AWakeUpEventForPostureBase::DirectionAcceptRange' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, MoveAcceptRange) == 0x000268, "Member 'AWakeUpEventForPostureBase::MoveAcceptRange' has a wrong offset!");
static_assert(offsetof(AWakeUpEventForPostureBase, ConditionEnableElapsedTime) == 0x00026C, "Member 'AWakeUpEventForPostureBase::ConditionEnableElapsedTime' has a wrong offset!");

// Class BattlePrototype.PsychicObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IPsychicObjectInterface final : public IInterface
{
public:
	bool CheckPsychicObjectIdC(BattlePrototype::EPsychicObjectID CheckId);
	bool CheckPsychicObjectSimulateC(const struct FVector& PosPly);
	bool GetDebrisEffect(EEffectObjectDebrisType* Type, class UMaterialInterface** OverrideMaterial);
	bool GetDebrisEffectData(class UParticleSystem** ParticleTemplate, class UMaterialInterface** OverrideMaterial);
	bool GetPsychicObjectSimulateControlDistanceSqC(float* DistSq);
	EPsychicObjectSizeType GetPsychicObjectSize();
	struct FVector GetUniqueObjectCameraLookAtPos(float LookAtRate);
	struct FRotator GetUniqueObjectCameraOwnerRotation();
	struct FVector GetUnqObjCamTargetPos();
	struct FVector GetUnqObjMoveVelocity();
	bool InitializeCopyPsychicObject();
	bool IsBrainFieldObjectC();
	bool IsCopyPsychicObject();
	bool IsFloatObjectC();
	bool IsPsychicObjectActiveC();
	bool IsPsychicObjectInUseC();
	bool IsPsychicObjectRegisterableC();
	bool IsPsychicObjectRenderC();
	bool IsPsychicObjectSimulateC();
	bool IsPsychicObjectSimulateControlEnableC();
	bool IsPsychicObjectTickC();
	bool IsSwingType();
	bool IsSwingTypeC();
	bool IsUniqueObject();
	bool IsUniqueObjectC();
	bool RequestEndUniqueObjectState(class AActor* PActor);
	bool ResetPsychicObjectArrangeTransformC();
	bool SetBrainFieldObjectC(bool Flag);
	bool SetDuelPoleType(bool bDuelType);
	void SetMaterialParameter(class FName ParamName, float ParamValue);
	bool SetPsychicObjectActiveC(bool Flag);
	bool SetPsychicObjectEventC(bool bStart, bool bTick, bool bVisibility);
	bool SetPsychicObjectInUseC(bool Flag);
	bool SetPsychicObjectRenderC(bool Flag);
	bool SetPsychicObjectSimulateControlC(bool Flag);
	bool SetPsychicObjectTickC(class FName RefName, bool Flag);
	bool SetSwingTypeC(bool Flag);
	void SetTownSetting(bool Flag);
	bool SetUniqueObjectC(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectInterface">();
	}
	static class IPsychicObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPsychicObjectInterface>();
	}
};
static_assert(alignof(IPsychicObjectInterface) == 0x000008, "Wrong alignment on IPsychicObjectInterface");
static_assert(sizeof(IPsychicObjectInterface) == 0x000028, "Wrong size on IPsychicObjectInterface");

// Class BattlePrototype.PsychicObjectManagerAsyncComponent
// 0x00C8 (0x0198 - 0x00D0)
class UPsychicObjectManagerAsyncComponent : public URSAsyncTaskActorComponent
{
public:
	bool                                          bAsyncTack;                                        // 0x00D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254A[0x6F];                                    // 0x00D1(0x006F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTickControlEnable;                                // 0x0140(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimulateControl;                                  // 0x0141(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTickControlPrevAsync;                             // 0x0142(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTickControlTickAsync;                             // 0x0143(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickControlDistanceSq;                             // 0x0144(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickControlActorNum;                               // 0x0148(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TickControlChangeNum;                              // 0x014C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBrainField;                                       // 0x0150(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254B[0x3];                                     // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActorNum;                                          // 0x0154(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ActorIndex;                                        // 0x0158(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254C[0x34];                                    // 0x015C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRenderCheckEnable;                                // 0x0190(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRenderCheckPrevAsync;                             // 0x0191(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRenderCheckTickAsync;                             // 0x0192(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugPrintTickControl;                            // 0x0193(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254D[0x4];                                     // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetRenderCheckActor(int32 Param_Index);
	int32 GetRenderCheckActorListLen();
	void RenderCheckPrevAsync();
	void RenderCheckTickAsync();
	void SetRenderCheckActor(bool Flag, class AActor* PActor);
	void SetRenderCheckEnable(bool Flag);
	void SetTickControlBrainField(bool Flag);
	void SetTickControlEnable(bool Flag);
	void SetTickControlParameter(float ActiveDistance, int32 ActorNumPerFrame, int32 ChangeNumPerFrame);
	void SetTickReference(const class FString& RefName, bool Flag);
	void TickControlPrevAsync();
	void TickControlTickAsync();
	void UpdatePlayerPos();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectManagerAsyncComponent">();
	}
	static class UPsychicObjectManagerAsyncComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychicObjectManagerAsyncComponent>();
	}
};
static_assert(alignof(UPsychicObjectManagerAsyncComponent) == 0x000008, "Wrong alignment on UPsychicObjectManagerAsyncComponent");
static_assert(sizeof(UPsychicObjectManagerAsyncComponent) == 0x000198, "Wrong size on UPsychicObjectManagerAsyncComponent");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bAsyncTack) == 0x0000D0, "Member 'UPsychicObjectManagerAsyncComponent::bAsyncTack' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bTickControlEnable) == 0x000140, "Member 'UPsychicObjectManagerAsyncComponent::bTickControlEnable' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bSimulateControl) == 0x000141, "Member 'UPsychicObjectManagerAsyncComponent::bSimulateControl' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bTickControlPrevAsync) == 0x000142, "Member 'UPsychicObjectManagerAsyncComponent::bTickControlPrevAsync' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bTickControlTickAsync) == 0x000143, "Member 'UPsychicObjectManagerAsyncComponent::bTickControlTickAsync' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, TickControlDistanceSq) == 0x000144, "Member 'UPsychicObjectManagerAsyncComponent::TickControlDistanceSq' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, TickControlActorNum) == 0x000148, "Member 'UPsychicObjectManagerAsyncComponent::TickControlActorNum' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, TickControlChangeNum) == 0x00014C, "Member 'UPsychicObjectManagerAsyncComponent::TickControlChangeNum' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bBrainField) == 0x000150, "Member 'UPsychicObjectManagerAsyncComponent::bBrainField' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, ActorNum) == 0x000154, "Member 'UPsychicObjectManagerAsyncComponent::ActorNum' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, ActorIndex) == 0x000158, "Member 'UPsychicObjectManagerAsyncComponent::ActorIndex' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bRenderCheckEnable) == 0x000190, "Member 'UPsychicObjectManagerAsyncComponent::bRenderCheckEnable' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bRenderCheckPrevAsync) == 0x000191, "Member 'UPsychicObjectManagerAsyncComponent::bRenderCheckPrevAsync' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bRenderCheckTickAsync) == 0x000192, "Member 'UPsychicObjectManagerAsyncComponent::bRenderCheckTickAsync' has a wrong offset!");
static_assert(offsetof(UPsychicObjectManagerAsyncComponent, bDebugPrintTickControl) == 0x000193, "Member 'UPsychicObjectManagerAsyncComponent::bDebugPrintTickControl' has a wrong offset!");

// Class BattlePrototype.UISASGauge
// 0x0020 (0x03A8 - 0x0388)
class UUISASGauge final : public UUIBase
{
public:
	uint8                                         Pad_2551[0x20];                                    // 0x0388(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimGauge_0_100, class UOverlay* Overlay);
	void SetButton(E_SASButton Button);
	void SetIconScale(const struct FVector2D& Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASGauge">();
	}
	static class UUISASGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASGauge>();
	}
};
static_assert(alignof(UUISASGauge) == 0x000008, "Wrong alignment on UUISASGauge");
static_assert(sizeof(UUISASGauge) == 0x0003A8, "Wrong size on UUISASGauge");

// Class BattlePrototype.PsychicObjectSearchInterface
// 0x0000 (0x0028 - 0x0028)
class IPsychicObjectSearchInterface final : public IInterface
{
public:
	bool GetSearchHeight(float* HeightMin, float* HeightMax);
	int32 GetSearchPoint();
	struct FVector GetSearchPos();
	float GetSearchRadius();
	float GetSearchSizeValue();
	bool IsSearchable();
	bool IsSearchMapGimmick();
	bool IsSearchUnique();
	bool IsSkipCheckRendered();
	bool SetEffectFocus(bool Flag);
	void SetSearchPoint(int32 Point);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychicObjectSearchInterface">();
	}
	static class IPsychicObjectSearchInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPsychicObjectSearchInterface>();
	}
};
static_assert(alignof(IPsychicObjectSearchInterface) == 0x000008, "Wrong alignment on IPsychicObjectSearchInterface");
static_assert(sizeof(IPsychicObjectSearchInterface) == 0x000028, "Wrong size on IPsychicObjectSearchInterface");

// Class BattlePrototype.UISaveLoad
// 0x0120 (0x04A8 - 0x0388)
class UUISaveLoad : public UUIBase
{
public:
	FMulticastInlineDelegateProperty_             M_OnEventInitializeStart;                          // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void(bool Menudata, int32 Slot)>    M_OnEventSelectStart;                              // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              ListElementSize;                                   // 0x03A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x03B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2553[0x4];                                     // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x03B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2554[0x58];                                    // 0x03C0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGame*                            M_pAutoSave;                                       // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pAutoSaveLoadScreenParamManager;                 // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pSave;                                           // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadScreenParamManager;                     // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           ScrollBoxParent;                                   // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUISaveLoadChoice*                      M_SaveLoadChoice;                                  // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSHUDBase*                             M_pRSHudBase;                                      // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSTitleManager*                        M_pTitleManager;                                   // 0x0450(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDScrollBox*                          ScrollBox;                                         // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGuide*                               UGuide;                                            // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       LastAnimation;                                     // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_info_Win_out;                                // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_info_Win_in;                                 // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_info_Win;                                    // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_out;                                         // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_in;                                          // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_default_none;                                // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_default_;                                    // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	ESaveLoad GetCurrentMode();
	ESaveLoadSubType GetCurrentSubMode();
	void InitializeAnime(class UWidgetAnimation* Info_Win_out, class UWidgetAnimation* Info_Win_in, class UWidgetAnimation* Info_Win, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeList(class UCanvasPanel* Param_ScrollBoxParent, class UREDScrollBox* Param_ScrollBox);
	void InitializeSaveLoad(class UUIGuide* Param_UGuide, class UUISaveLoadChoice* SaveLoadChoice);
	bool IsClearChara(int32 SlotNo, bool* Yuito, bool* Kasane);
	bool IsSaved();
	bool IsSavedError();
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void SetTitleManager(class ARSTitleManager* Ptitlemanager);
	void Start(ESaveLoad ModeType, ESaveLoadSubType SubModeType);
	void UpdateStateSaveLoad(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoad">();
	}
	static class UUISaveLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoad>();
	}
};
static_assert(alignof(UUISaveLoad) == 0x000008, "Wrong alignment on UUISaveLoad");
static_assert(sizeof(UUISaveLoad) == 0x0004A8, "Wrong size on UUISaveLoad");
static_assert(offsetof(UUISaveLoad, M_OnEventInitializeStart) == 0x000388, "Member 'UUISaveLoad::M_OnEventInitializeStart' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_OnEventSelectStart) == 0x000398, "Member 'UUISaveLoad::M_OnEventSelectStart' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ListElementSize) == 0x0003A8, "Member 'UUISaveLoad::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ListOffsetSize) == 0x0003B0, "Member 'UUISaveLoad::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ListIndexClass) == 0x0003B8, "Member 'UUISaveLoad::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pAutoSave) == 0x000418, "Member 'UUISaveLoad::M_pAutoSave' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pAutoSaveLoadScreenParamManager) == 0x000420, "Member 'UUISaveLoad::M_pAutoSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pSave) == 0x000428, "Member 'UUISaveLoad::M_pSave' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pSaveLoadScreenParamManager) == 0x000430, "Member 'UUISaveLoad::M_pSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ScrollBoxParent) == 0x000438, "Member 'UUISaveLoad::ScrollBoxParent' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_SaveLoadChoice) == 0x000440, "Member 'UUISaveLoad::M_SaveLoadChoice' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pRSHudBase) == 0x000448, "Member 'UUISaveLoad::M_pRSHudBase' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, M_pTitleManager) == 0x000450, "Member 'UUISaveLoad::M_pTitleManager' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, ScrollBox) == 0x000458, "Member 'UUISaveLoad::ScrollBox' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, UGuide) == 0x000460, "Member 'UUISaveLoad::UGuide' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, LastAnimation) == 0x000468, "Member 'UUISaveLoad::LastAnimation' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_info_Win_out) == 0x000470, "Member 'UUISaveLoad::Anime_info_Win_out' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_info_Win_in) == 0x000478, "Member 'UUISaveLoad::Anime_info_Win_in' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_info_Win) == 0x000480, "Member 'UUISaveLoad::Anime_info_Win' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_out) == 0x000488, "Member 'UUISaveLoad::Anime_out' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_in) == 0x000490, "Member 'UUISaveLoad::Anime_in' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_default_none) == 0x000498, "Member 'UUISaveLoad::Anime_default_none' has a wrong offset!");
static_assert(offsetof(UUISaveLoad, Anime_default_) == 0x0004A0, "Member 'UUISaveLoad::Anime_default_' has a wrong offset!");

// Class BattlePrototype.PsychokinesisedComponent
// 0x0000 (0x00C0 - 0x00C0)
class UPsychokinesisedComponent final : public UActorComponent
{
public:
	static void GetAxisAndAngleFromRotator(struct FVector* Axis, float* AngleDegree, const struct FRotator& Rot);
	static void MakeRotatorAxisAndAngle(struct FRotator* OutRot, const struct FVector& Axis, float AngleDegree);

	void CalcAngularVelocityToTarget(struct FVector* AngularVelocity, class USceneComponent* DirectionComp, const struct FVector& TargetLocation);
	void DebugDrawRotator(const struct FRotator& Rot, const struct FVector& CenterPos, float Radius);
	void MoveRootComponent(const struct FVector& Delta, struct FHitResult* OutHit, bool bSweep, bool bTeleport);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PsychokinesisedComponent">();
	}
	static class UPsychokinesisedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPsychokinesisedComponent>();
	}
};
static_assert(alignof(UPsychokinesisedComponent) == 0x000008, "Wrong alignment on UPsychokinesisedComponent");
static_assert(sizeof(UPsychokinesisedComponent) == 0x0000C0, "Wrong size on UPsychokinesisedComponent");

// Class BattlePrototype.QuestData
// 0x0030 (0x0058 - 0x0028)
class UQuestData final : public UObject
{
public:
	class UDataTable*                             RefMainDataAsset;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RefSubDataAsset;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RefBondsDataAsset;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDataTable>                 FinderMain;                                        // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMainQuestDBAsset*                      MainQuestDataAsset;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBondsEpisodeDBAsset*                   BondsQuestDataAsset;                               // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool LoadDataAsset(const class FString& MainDTPath, const class FString& SubDTPath, const class FString& bondsDTPath);
	bool LoadDataAsset_Bonds(const class FString& DataPath);
	bool LoadDataAsset_Main(const class FString& DataPath);
	bool LoadDataAsset_Sub(const class FString& DataPath);
	bool UnloadDataTable();
	bool UnloadDataTable_Bonds();
	bool UnloadDataTable_Main();
	bool UnloadDataTable_Sub();

	class UBondsEpisodeDBAsset* GetBondsEpisodeData() const;
	int32 GetBondsEpisodeDataNum() const;
	class UMainQuestDBAsset* GetMainQuestData() const;
	int32 GetMainQuestDataNum() const;
	class UDataTable* GetSubQuestData() const;
	int32 GetSubQuestDataNum() const;
	bool IsValidBondsDB() const;
	bool IsValidDB() const;
	bool IsValidMainDB() const;
	bool IsValidSubDB() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestData">();
	}
	static class UQuestData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestData>();
	}
};
static_assert(alignof(UQuestData) == 0x000008, "Wrong alignment on UQuestData");
static_assert(sizeof(UQuestData) == 0x000058, "Wrong size on UQuestData");
static_assert(offsetof(UQuestData, RefMainDataAsset) == 0x000028, "Member 'UQuestData::RefMainDataAsset' has a wrong offset!");
static_assert(offsetof(UQuestData, RefSubDataAsset) == 0x000030, "Member 'UQuestData::RefSubDataAsset' has a wrong offset!");
static_assert(offsetof(UQuestData, RefBondsDataAsset) == 0x000038, "Member 'UQuestData::RefBondsDataAsset' has a wrong offset!");
static_assert(offsetof(UQuestData, FinderMain) == 0x000040, "Member 'UQuestData::FinderMain' has a wrong offset!");
static_assert(offsetof(UQuestData, MainQuestDataAsset) == 0x000048, "Member 'UQuestData::MainQuestDataAsset' has a wrong offset!");
static_assert(offsetof(UQuestData, BondsQuestDataAsset) == 0x000050, "Member 'UQuestData::BondsQuestDataAsset' has a wrong offset!");

// Class BattlePrototype.UIShop
// 0x12010 (0x12398 - 0x0388)
class UUIShop : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255E[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AUIShop3DManager>           BGModelClass;                                      // 0x03A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255F[0x10];                                    // 0x03A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIShop3DManager*                       BGModel;                                           // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2560[0x11FD8];                                 // 0x03C0(0x11FD8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(int32 Param_Index, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeItemCategory(int32 Category, class UUIBase* Widget, class UImage* ImageSeparator, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimUnselect, class UTextBlock* TextCategory);
	void InitializeModeTab(int32 Mode, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UTextBlock* TextBuySell);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimInfoWindow, class UWidgetAnimation* AnimInfoWindowIn, class UWidgetAnimation* AnimInfoWindowOut, class UWidgetAnimation* AnimChange1, class UWidgetAnimation* AnimChange2, class UCanvasPanel* ScrollBoxParent, class UREDScrollBox* ScrollBox, class UUIItemTrade* UIItemTrade, class UUIShopGetContents* UiGetContents, class UUIShopItemDetails* UIShopItemDetails, class UOverlay* UiPaymentParent, class UUIShopPayment* UIShopPayment, class UUIShopChoice* UiChoice, class UUIShopPartyStatus* UiPartyStatus, class UUIGuide* UIGuide, class UTextBlock* TextTitle, class UTextBlock* TextIndexItem, class UTextBlock* TextIndexHaveNum, class UTextBlock* TextIndexPrice, class UTextBlock* TextIndexBuySellNum, class UTextBlock* TextHelp, class UBorder* ShopListColor, class UBorder* ShopGoldSet);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void Start(int32 ShopId, int32 TradeShopId, EShopMode Mode);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShop">();
	}
	static class UUIShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShop>();
	}
};
static_assert(alignof(UUIShop) == 0x000008, "Wrong alignment on UUIShop");
static_assert(sizeof(UUIShop) == 0x012398, "Wrong size on UUIShop");
static_assert(offsetof(UUIShop, ListElementSize) == 0x000388, "Member 'UUIShop::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIShop, ListOffsetSize) == 0x000390, "Member 'UUIShop::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIShop, ListIndexClass) == 0x000398, "Member 'UUIShop::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUIShop, BGModelClass) == 0x0003A0, "Member 'UUIShop::BGModelClass' has a wrong offset!");
static_assert(offsetof(UUIShop, BGModel) == 0x0003B8, "Member 'UUIShop::BGModel' has a wrong offset!");

// Class BattlePrototype.SubQuestDBAsset
// 0x0050 (0x0078 - 0x0028)
class USubQuestDBAsset final : public UObject
{
public:
	TMap<class FName, struct FSubQuestDBDataCell> DBMap;                                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	void Convert();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubQuestDBAsset">();
	}
	static class USubQuestDBAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubQuestDBAsset>();
	}
};
static_assert(alignof(USubQuestDBAsset) == 0x000008, "Wrong alignment on USubQuestDBAsset");
static_assert(sizeof(USubQuestDBAsset) == 0x000078, "Wrong size on USubQuestDBAsset");
static_assert(offsetof(USubQuestDBAsset, DBMap) == 0x000028, "Member 'USubQuestDBAsset::DBMap' has a wrong offset!");

// Class BattlePrototype.QuestParamManager
// 0x0108 (0x0130 - 0x0028)
class UQuestParamManager final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnChangeNoticeUiStateDelegate_;                    // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeQuestActiveUiStateDelegate_;               // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FQuestParams>                   QuestParams_;                                      // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FConditionQuestParams>          SubQuestParams_;                                   // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FProgressRateQuestParams>       bondsQuestParams_;                                 // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveMainQuest_;                                  // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveSubQuest_;                                   // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ActiveSubQuestKasane_;                             // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2566[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NeedItemSubQuestNumber_;                           // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 NeedKillEnemySubQuestNumber_;                      // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2567[0x10];                                    // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SubQuestRowNames_;                                 // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           bondsQuestRowNames_;                               // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2568[0x20];                                    // 0x00D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDrivemode_;                                       // 0x00F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2569[0x37];                                    // 0x00F9(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeToProgressAllQuest();
	bool CheckDLCQuestContentCheck(class FName QuestId);
	bool CheckFinishedDLCBonds(EPlayerID HeroID, EPlayerID TargetID, int32 DlcNumber);
	bool CheckNeedItem(class FName ItemId);
	bool CheckPlayingDLCBondsNow();
	void CheckSubQuestsStateNotOrder();
	bool CheckSubQuestSuitableNowPlayer(int32 QuestNumber);
	int32 GetActiveSubQuestNumber();
	class FName GetBondsEpisodeIDFromNumber(int32 Number);
	int32 GetBondsQuestNumberFromID(class FName QuestId);
	int32 GetBondsQuestProgressRate(int32 QuestNumber);
	EQuestProgressState GetBondsQuestState(int32 QuestNumber);
	class FName GetIDFromSubQuestNumber(int32 QuestNumber);
	void GetItem(class FName ItemName, int32 ItemNum);
	class FName GetMainQuestIDFromNumber(int32 QuestNumber);
	int32 GetMainQuestNumberFromID(class FName QuestId);
	EQuestProgressState GetMainQuestState(int32 QuestNumber);
	TArray<int32> GetQuestSortID(EQuestType QuestTyp, ESortType SortType, int32 ActiveNumber);
	int32 GetSubQuestNumberAchieved(const class FName& QuestId, const class FName& TargetID);
	int32 GetSubQuestNumberFromID(class FName QuestId);
	EQuestProgressState GetSubQuestState(int32 QuestNumber);
	void InitAtExNewGame(EPlayerID MainPlayerID);
	void InitData(class URSGameInstance* GameInst);
	void InProgressBondsQuest(int32 bondsQuestNumber);
	void InProgressSubQuest(int32 SubQuestNumber);
	bool IsBondsQuestRelatedToThePlayer(int32 QuestNumber);
	bool IsQuestEnemy(class FName EnemyName);
	bool IsSubQuestRelatedToThePlayer(int32 QuestNumber);
	bool IsTargetEnemyForActiveSubQuest(const class FString& EnemyName);
	bool IsUnlockContentBondsEpisode(class FName Key, int32 ContentNumber);
	bool IsUnlockContentMainQuest(class FName Key, int32 ContentNumber);
	void KillEnemy(class FName EnemyName, const struct FHCHitResult& HcResult, EPsychicObjectUniqueType PoType, int32 KillNum, bool bBrainCrashMulti, EPlayerID HoloPlayerID);
	void SetActiveSubQuestNumber(int32 SubQuestNumber);
	void SetBondsQuestProgressRate(int32 QuestNumber, int32 Rate);
	void SetBondsQuestState(int32 QuestNumber, EQuestProgressState State);
	void SetMainQuestState(int32 QuestNumber, EQuestProgressState State);
	void SetNewIcon(EQuestType QType, int32 QuestNumber, bool Flg);
	void SetSubQuestState(int32 QuestNumber, EQuestProgressState State);
	void ThrowSubQuestNotification(class FName QuestId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestParamManager">();
	}
	static class UQuestParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestParamManager>();
	}
};
static_assert(alignof(UQuestParamManager) == 0x000008, "Wrong alignment on UQuestParamManager");
static_assert(sizeof(UQuestParamManager) == 0x000130, "Wrong size on UQuestParamManager");
static_assert(offsetof(UQuestParamManager, OnChangeNoticeUiStateDelegate_) == 0x000028, "Member 'UQuestParamManager::OnChangeNoticeUiStateDelegate_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, OnChangeQuestActiveUiStateDelegate_) == 0x000038, "Member 'UQuestParamManager::OnChangeQuestActiveUiStateDelegate_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, QuestParams_) == 0x000048, "Member 'UQuestParamManager::QuestParams_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, SubQuestParams_) == 0x000058, "Member 'UQuestParamManager::SubQuestParams_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, bondsQuestParams_) == 0x000068, "Member 'UQuestParamManager::bondsQuestParams_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, ActiveMainQuest_) == 0x000078, "Member 'UQuestParamManager::ActiveMainQuest_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, ActiveSubQuest_) == 0x00007C, "Member 'UQuestParamManager::ActiveSubQuest_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, ActiveSubQuestKasane_) == 0x000080, "Member 'UQuestParamManager::ActiveSubQuestKasane_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, NeedItemSubQuestNumber_) == 0x000088, "Member 'UQuestParamManager::NeedItemSubQuestNumber_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, NeedKillEnemySubQuestNumber_) == 0x000098, "Member 'UQuestParamManager::NeedKillEnemySubQuestNumber_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, SubQuestRowNames_) == 0x0000B8, "Member 'UQuestParamManager::SubQuestRowNames_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, bondsQuestRowNames_) == 0x0000C8, "Member 'UQuestParamManager::bondsQuestRowNames_' has a wrong offset!");
static_assert(offsetof(UQuestParamManager, bDrivemode_) == 0x0000F8, "Member 'UQuestParamManager::bDrivemode_' has a wrong offset!");

// Class BattlePrototype.UIShopGetListIndex
// 0x0050 (0x03D8 - 0x0388)
class UUIShopGetListIndex : public UUIBase
{
public:
	uint8                                         Pad_2580[0x50];                                    // 0x0388(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimDefaultLock, class UWidgetAnimation* AnimSelectLock, class UWidgetAnimation* AnimSelectInLock, class UImage* ImageNewIcon, class UTextBlock* TextItemName);
	void SetProgressIcon(int32 Progress);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopGetListIndex">();
	}
	static class UUIShopGetListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopGetListIndex>();
	}
};
static_assert(alignof(UUIShopGetListIndex) == 0x000008, "Wrong alignment on UUIShopGetListIndex");
static_assert(sizeof(UUIShopGetListIndex) == 0x0003D8, "Wrong size on UUIShopGetListIndex");

// Class BattlePrototype.RadialBlurManager
// 0x0070 (0x02A0 - 0x0230)
class ARadialBlurManager : public AActor
{
public:
	uint8                                         Pad_2581[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsPlaying;                                         // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2582[0x7];                                     // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRadialBlurData                        AdditionalBlurParameter;                           // 0x0248(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           MPC;                                               // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           MPCC;                                              // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2583[0x10];                                    // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetPlaying();
	void Play(int32 Priority, class UCurveVector* CurveData, const struct FVector& Location, const struct FLinearColor& ColorModuate, bool Force);
	void PlayPresetColorModulate(int32 Priority, class UCurveVector* CurveData, const struct FVector& Location, ENotifyRadialBlurModulateType PresetColorType, bool Force);
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadialBlurManager">();
	}
	static class ARadialBlurManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARadialBlurManager>();
	}
};
static_assert(alignof(ARadialBlurManager) == 0x000008, "Wrong alignment on ARadialBlurManager");
static_assert(sizeof(ARadialBlurManager) == 0x0002A0, "Wrong size on ARadialBlurManager");
static_assert(offsetof(ARadialBlurManager, IsPlaying) == 0x000240, "Member 'ARadialBlurManager::IsPlaying' has a wrong offset!");
static_assert(offsetof(ARadialBlurManager, AdditionalBlurParameter) == 0x000248, "Member 'ARadialBlurManager::AdditionalBlurParameter' has a wrong offset!");
static_assert(offsetof(ARadialBlurManager, MPC) == 0x000280, "Member 'ARadialBlurManager::MPC' has a wrong offset!");
static_assert(offsetof(ARadialBlurManager, MPCC) == 0x000288, "Member 'ARadialBlurManager::MPCC' has a wrong offset!");

// Class BattlePrototype.REDebugLines
// 0x0038 (0x0268 - 0x0230)
class UREDebugLines final : public UUserWidget
{
public:
	struct FVector2D                              M_AbsolutePosition;                                // 0x0230(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_AbsoluteSize;                                    // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Topleft;                                           // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Topright;                                          // 0x0248(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              bottomleft;                                        // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              bottomright;                                       // 0x0258(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_Circle;                                          // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2588[0x7];                                     // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCircle(bool Circle);
	void SetClippingZone(const struct FVector2D& Param_Topleft, const struct FVector2D& Param_Topright, const struct FVector2D& Param_bottomleft, const struct FVector2D& Param_bottomright);
	void SetHitData(const struct FVector2D& Pos, const struct FVector2D& Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDebugLines">();
	}
	static class UREDebugLines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDebugLines>();
	}
};
static_assert(alignof(UREDebugLines) == 0x000008, "Wrong alignment on UREDebugLines");
static_assert(sizeof(UREDebugLines) == 0x000268, "Wrong size on UREDebugLines");
static_assert(offsetof(UREDebugLines, M_AbsolutePosition) == 0x000230, "Member 'UREDebugLines::M_AbsolutePosition' has a wrong offset!");
static_assert(offsetof(UREDebugLines, M_AbsoluteSize) == 0x000238, "Member 'UREDebugLines::M_AbsoluteSize' has a wrong offset!");
static_assert(offsetof(UREDebugLines, Topleft) == 0x000240, "Member 'UREDebugLines::Topleft' has a wrong offset!");
static_assert(offsetof(UREDebugLines, Topright) == 0x000248, "Member 'UREDebugLines::Topright' has a wrong offset!");
static_assert(offsetof(UREDebugLines, bottomleft) == 0x000250, "Member 'UREDebugLines::bottomleft' has a wrong offset!");
static_assert(offsetof(UREDebugLines, bottomright) == 0x000258, "Member 'UREDebugLines::bottomright' has a wrong offset!");
static_assert(offsetof(UREDebugLines, M_Circle) == 0x000260, "Member 'UREDebugLines::M_Circle' has a wrong offset!");

// Class BattlePrototype.REDHorizonFlipbookWidget
// 0x00D0 (0x0308 - 0x0238)
class UREDHorizonFlipbookWidget final : public UHorizonFlipbookWidget
{
public:
	bool                                          FlagMouse;                                         // 0x0238(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2589[0x3];                                     // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRedMouseArgument                      MouseCallArgument;                                 // 0x023C(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetPos;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MouseHitOffsetSize;                                // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugMouseHitDisp;                                 // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258A[0x7];                                     // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             M_FlipBookFocusMouse;                              // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_FlipBookUnFocusMouse;                            // 0x0270(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             M_FlipBookDownMouse;                               // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_258B[0x18];                                    // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIBase>                 M_ParentUIBase;                                    // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UREDebugLines*                          M_DebugDraw;                                       // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258C[0x50];                                    // 0x02B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckRectangle();
	bool CheckRectangleCore(const struct FVector2D& Position);
	struct FVector2D GetAbsolutePosition();
	struct FVector2D GetAbsoluteSize();
	void RedFlipBookDown__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedFlipBookFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void RedFlipBookUnFocus__DelegateSignature(const struct FRedMouseArgument& Argument, class UObject* PWidget);
	void SetMouseDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);
	void SetMouseMode(bool Mousemode, int32 InputLevel);
	void SetParentUIBase(class UUIBase* PUiBase);

	bool GetMouseDisable() const;
	int32 GetMouseInputLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDHorizonFlipbookWidget">();
	}
	static class UREDHorizonFlipbookWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDHorizonFlipbookWidget>();
	}
};
static_assert(alignof(UREDHorizonFlipbookWidget) == 0x000008, "Wrong alignment on UREDHorizonFlipbookWidget");
static_assert(sizeof(UREDHorizonFlipbookWidget) == 0x000308, "Wrong size on UREDHorizonFlipbookWidget");
static_assert(offsetof(UREDHorizonFlipbookWidget, FlagMouse) == 0x000238, "Member 'UREDHorizonFlipbookWidget::FlagMouse' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, MouseCallArgument) == 0x00023C, "Member 'UREDHorizonFlipbookWidget::MouseCallArgument' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, MouseHitOffsetPos) == 0x000248, "Member 'UREDHorizonFlipbookWidget::MouseHitOffsetPos' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, MouseHitOffsetSize) == 0x000250, "Member 'UREDHorizonFlipbookWidget::MouseHitOffsetSize' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, DebugMouseHitDisp) == 0x000258, "Member 'UREDHorizonFlipbookWidget::DebugMouseHitDisp' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_FlipBookFocusMouse) == 0x000260, "Member 'UREDHorizonFlipbookWidget::M_FlipBookFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_FlipBookUnFocusMouse) == 0x000270, "Member 'UREDHorizonFlipbookWidget::M_FlipBookUnFocusMouse' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_FlipBookDownMouse) == 0x000280, "Member 'UREDHorizonFlipbookWidget::M_FlipBookDownMouse' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_ParentUIBase) == 0x0002A8, "Member 'UREDHorizonFlipbookWidget::M_ParentUIBase' has a wrong offset!");
static_assert(offsetof(UREDHorizonFlipbookWidget, M_DebugDraw) == 0x0002B0, "Member 'UREDHorizonFlipbookWidget::M_DebugDraw' has a wrong offset!");

// Class BattlePrototype.UILetterBoxMask
// 0x0010 (0x0398 - 0x0388)
class UUILetterBoxMask : public UUIBase
{
public:
	uint8                                         Pad_2592[0x10];                                    // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UImage* Image1, class UImage* Image2);
	void SetResolution();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILetterBoxMask">();
	}
	static class UUILetterBoxMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILetterBoxMask>();
	}
};
static_assert(alignof(UUILetterBoxMask) == 0x000008, "Wrong alignment on UUILetterBoxMask");
static_assert(sizeof(UUILetterBoxMask) == 0x000398, "Wrong size on UUILetterBoxMask");

// Class BattlePrototype.REDImageBase
// 0x0028 (0x0238 - 0x0210)
class UREDImageBase final : public UImage
{
public:
	TArray<struct FREDLocalizeImageParam>         LocalizedParamList;                                // 0x0210(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FREDLocalizeImageParam                 DefaultParam;                                      // 0x0220(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2593[0x4];                                     // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDImageBase">();
	}
	static class UREDImageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDImageBase>();
	}
};
static_assert(alignof(UREDImageBase) == 0x000008, "Wrong alignment on UREDImageBase");
static_assert(sizeof(UREDImageBase) == 0x000238, "Wrong size on UREDImageBase");
static_assert(offsetof(UREDImageBase, LocalizedParamList) == 0x000210, "Member 'UREDImageBase::LocalizedParamList' has a wrong offset!");
static_assert(offsetof(UREDImageBase, DefaultParam) == 0x000220, "Member 'UREDImageBase::DefaultParam' has a wrong offset!");

// Class BattlePrototype.REDLuaScriptComponent
// 0x0058 (0x0118 - 0x00C0)
class UREDLuaScriptComponent final : public UActorComponent
{
public:
	class UObject*                                M_parent;                                          // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2594[0x8];                                     // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      M_PlayerController;                                // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2595[0x8];                                     // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_AnimationActor;                                  // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2596[0x8];                                     // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pWaitAnimMontageActor;                           // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           M_pWaitAnimMontageMontage;                         // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            M_pStaticCutsceneBG_ParticleSpeedUpCurveData;      // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2597[0x8];                                     // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEventAsset*                            M_pWaitLoadAsset;                                  // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CreateContextRED(class UObject* Parent, bool IsRun);
	void SetAnimationActor(class UObject* Object);
	void SetIsEndMotion(bool IsEndMotion);
	void SetPlayerController(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDLuaScriptComponent">();
	}
	static class UREDLuaScriptComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDLuaScriptComponent>();
	}
};
static_assert(alignof(UREDLuaScriptComponent) == 0x000008, "Wrong alignment on UREDLuaScriptComponent");
static_assert(sizeof(UREDLuaScriptComponent) == 0x000118, "Wrong size on UREDLuaScriptComponent");
static_assert(offsetof(UREDLuaScriptComponent, M_parent) == 0x0000C0, "Member 'UREDLuaScriptComponent::M_parent' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_PlayerController) == 0x0000D0, "Member 'UREDLuaScriptComponent::M_PlayerController' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_AnimationActor) == 0x0000E0, "Member 'UREDLuaScriptComponent::M_AnimationActor' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_pWaitAnimMontageActor) == 0x0000F0, "Member 'UREDLuaScriptComponent::M_pWaitAnimMontageActor' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_pWaitAnimMontageMontage) == 0x0000F8, "Member 'UREDLuaScriptComponent::M_pWaitAnimMontageMontage' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_pStaticCutsceneBG_ParticleSpeedUpCurveData) == 0x000100, "Member 'UREDLuaScriptComponent::M_pStaticCutsceneBG_ParticleSpeedUpCurveData' has a wrong offset!");
static_assert(offsetof(UREDLuaScriptComponent, M_pWaitLoadAsset) == 0x000110, "Member 'UREDLuaScriptComponent::M_pWaitLoadAsset' has a wrong offset!");

// Class BattlePrototype.UIMiniMap
// 0x0150 (0x04D8 - 0x0388)
class UUIMiniMap : public UUIBase
{
public:
	class FName                                   M_SceneName;                                       // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ConfigMiniMapDisp;                                 // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ConfigMiniMapScale;                                // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ConfigMiniMapRotate;                               // 0x0392(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2599[0x1];                                     // 0x0393(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_limit;                                           // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABP_UI_SceneMap*                        M_ParentSceneMap;                                  // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMiniMainQuestGoal*                   M_MainQuestGoalWidgete;                            // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMiniSubQuestGoal*                    M_SubQuestGoalWidgete;                             // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMiniBondsQuestGoal*                  M_BondsQuestGoalWidgete;                           // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_VectorCenter;                                    // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_VectorNorthRadios;                               // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_VectorQuestIconRadios;                           // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_DebugFlagNative;                                 // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259A[0xE7];                                    // 0x03D1(0x00E7)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pHudBase;                                        // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerController*                      M_PlayerController;                                // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUIMinimapDistance*>             M_MinimapDistanceData;                             // 0x04C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CloseMinimap();
	bool CreateMapSetting();
	void EndMinimapBrainField();
	void ForceLoadMap();
	void GetActiveSubquest(class FName* SubquestName, class FName* SubQuestID, bool* Flag);
	bool GetDebugFlagNative();
	TSubclassOf<class ABP_UI_SceneMap> GetMinimapRefalence(const class FString& Path);
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_, class UWidgetAnimation* Out_noise, class UWidgetAnimation* In_noise, class UWidgetAnimation* Default_noise);
	void InitializeDirectionImage(class UImage* Imagemain, class UImage* Imagekizuna);
	void InitializeImage(class UImage* Imagecamera, class UImage* Imageplayer);
	void InitializeMinimap(class UOverlay* Allset);
	void InitializeMinimapDistance(class UUIMinimapDistance* Distance, int32 Num);
	void InitializeNorthWidget(class UUserWidget* Widgetnorthring, class UUserWidget* Widgetnorthicon, class UUserWidget* Widgetnorthstring);
	void InitializePlayerWidget(class UUserWidget* Widgetcamera, class UUserWidget* Widgetplayer);
	bool InitIcon_Etc_Native();
	bool IsBrainField();
	bool MapOpenListSetting(int32 AreaNo);
	bool MinimapMaterialBrainfield(bool Flag);
	void OnAfterChangeProgress();
	void OpenMinimap();
	bool ReleaseMapSetting();
	void SetBrainField(bool Flag);
	bool SetDirectionDest();
	void SetDirectionDestNative();
	bool SetDirectionDestSubQuest(class FName SubquestTitle, class FName SubQuestID, bool Flag);
	void SetDistanceReset();
	void SetDistanceSetting(EUIMinmapDistanceIcon Icontype);
	void SetThumbnail(int32 Icon);
	bool SetWidgetCameraThumbnail(const class UObject* WorldContextObject, class UImage* Image, int32 Param_Index);
	bool SetWidgetPlayerThumbnail(const class UObject* WorldContextObject, class UImage* Image, int32 Param_Index);
	void StartMinimapBrainField();
	bool UpdateConfigSetting();
	void UpdateStateMinimap(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniMap">();
	}
	static class UUIMiniMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniMap>();
	}
};
static_assert(alignof(UUIMiniMap) == 0x000008, "Wrong alignment on UUIMiniMap");
static_assert(sizeof(UUIMiniMap) == 0x0004D8, "Wrong size on UUIMiniMap");
static_assert(offsetof(UUIMiniMap, M_SceneName) == 0x000388, "Member 'UUIMiniMap::M_SceneName' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, ConfigMiniMapDisp) == 0x000390, "Member 'UUIMiniMap::ConfigMiniMapDisp' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, ConfigMiniMapScale) == 0x000391, "Member 'UUIMiniMap::ConfigMiniMapScale' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, ConfigMiniMapRotate) == 0x000392, "Member 'UUIMiniMap::ConfigMiniMapRotate' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_limit) == 0x000394, "Member 'UUIMiniMap::M_limit' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_ParentSceneMap) == 0x000398, "Member 'UUIMiniMap::M_ParentSceneMap' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_MainQuestGoalWidgete) == 0x0003A0, "Member 'UUIMiniMap::M_MainQuestGoalWidgete' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_SubQuestGoalWidgete) == 0x0003A8, "Member 'UUIMiniMap::M_SubQuestGoalWidgete' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_BondsQuestGoalWidgete) == 0x0003B0, "Member 'UUIMiniMap::M_BondsQuestGoalWidgete' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_VectorCenter) == 0x0003B8, "Member 'UUIMiniMap::M_VectorCenter' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_VectorNorthRadios) == 0x0003C0, "Member 'UUIMiniMap::M_VectorNorthRadios' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_VectorQuestIconRadios) == 0x0003C8, "Member 'UUIMiniMap::M_VectorQuestIconRadios' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_DebugFlagNative) == 0x0003D0, "Member 'UUIMiniMap::M_DebugFlagNative' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_pHudBase) == 0x0004B8, "Member 'UUIMiniMap::M_pHudBase' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_PlayerController) == 0x0004C0, "Member 'UUIMiniMap::M_PlayerController' has a wrong offset!");
static_assert(offsetof(UUIMiniMap, M_MinimapDistanceData) == 0x0004C8, "Member 'UUIMiniMap::M_MinimapDistanceData' has a wrong offset!");

// Class BattlePrototype.REDScrollBoxElement
// 0x0040 (0x0270 - 0x0230)
class UREDScrollBoxElement : public UUserWidget
{
public:
	uint8                                         Pad_25A1[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            Widget;                                            // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25A2[0x28];                                    // 0x0248(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector2D GetAbsolutePosition();
	struct FVector2D GetAbsoluteSize();
	bool GetHitWidget();
	class UREDScrollBoxElement* GetThis();
	void InitializeThis(class UOverlay* Overlay, class USpacer* Spacer);
	void SelfInitialize();
	void SetMouseDisable(bool Flag);
	void SetMouseInputDisable(bool Flag);
	void SetMouseInputLevel(int32 InputLevel);

	bool GetMouseDisable() const;
	bool GetMouseInputDisable() const;
	int32 GetMouseInputLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDScrollBoxElement">();
	}
	static class UREDScrollBoxElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDScrollBoxElement>();
	}
};
static_assert(alignof(UREDScrollBoxElement) == 0x000008, "Wrong alignment on UREDScrollBoxElement");
static_assert(sizeof(UREDScrollBoxElement) == 0x000270, "Wrong size on UREDScrollBoxElement");
static_assert(offsetof(UREDScrollBoxElement, Widget) == 0x000240, "Member 'UREDScrollBoxElement::Widget' has a wrong offset!");

// Class BattlePrototype.RedSettings
// 0x0030 (0x0058 - 0x0028)
class URedSettings final : public UObject
{
public:
	class FString                                 Purpose;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleFloatRequireRestart;                         // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClampedIntSetting;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StringMaterialAssetReference;                      // 0x0040(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RedSettings">();
	}
	static class URedSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<URedSettings>();
	}
};
static_assert(alignof(URedSettings) == 0x000008, "Wrong alignment on URedSettings");
static_assert(sizeof(URedSettings) == 0x000058, "Wrong size on URedSettings");
static_assert(offsetof(URedSettings, Purpose) == 0x000028, "Member 'URedSettings::Purpose' has a wrong offset!");
static_assert(offsetof(URedSettings, SampleFloatRequireRestart) == 0x000038, "Member 'URedSettings::SampleFloatRequireRestart' has a wrong offset!");
static_assert(offsetof(URedSettings, ClampedIntSetting) == 0x00003C, "Member 'URedSettings::ClampedIntSetting' has a wrong offset!");
static_assert(offsetof(URedSettings, StringMaterialAssetReference) == 0x000040, "Member 'URedSettings::StringMaterialAssetReference' has a wrong offset!");

// Class BattlePrototype.UITitleFirstConfirmChildImage
// 0x0060 (0x0400 - 0x03A0)
class UUITitleFirstConfirmChildImage final : public UUITitleFirstConfirmChildBase
{
public:
	uint8                                         Pad_25A3[0x60];                                    // 0x03A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UImage* ImageEulaFull_1, class UImage* ImageEulaFull_2, class UImage* ImageEulaHalf_1, class UImage* ImageEulaHalf_2, class UImage* ImagePrivacyPolicy, class UREDTextBlock* TextTitle, class UREDTextBlock* TextHelp, class UREDScrollBoxSimple* ScrollBox, class UUITitleFirstConfirmSelect2* UiSelect2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirmChildImage">();
	}
	static class UUITitleFirstConfirmChildImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirmChildImage>();
	}
};
static_assert(alignof(UUITitleFirstConfirmChildImage) == 0x000008, "Wrong alignment on UUITitleFirstConfirmChildImage");
static_assert(sizeof(UUITitleFirstConfirmChildImage) == 0x000400, "Wrong size on UUITitleFirstConfirmChildImage");

// Class BattlePrototype.REDTextBlock
// 0x0028 (0x02C8 - 0x02A0)
class UREDTextBlock final : public UTextBlock
{
public:
	TArray<struct FREDLocalizeTextParam>          FontSizeParamList;                                 // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FREDLocalizeTextParam                  DefaultParam;                                      // 0x02B0(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A4[0x4];                                     // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDTextBlock">();
	}
	static class UREDTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDTextBlock>();
	}
};
static_assert(alignof(UREDTextBlock) == 0x000008, "Wrong alignment on UREDTextBlock");
static_assert(sizeof(UREDTextBlock) == 0x0002C8, "Wrong size on UREDTextBlock");
static_assert(offsetof(UREDTextBlock, FontSizeParamList) == 0x0002A0, "Member 'UREDTextBlock::FontSizeParamList' has a wrong offset!");
static_assert(offsetof(UREDTextBlock, DefaultParam) == 0x0002B0, "Member 'UREDTextBlock::DefaultParam' has a wrong offset!");

// Class BattlePrototype.REDWidgetBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UREDWidgetBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ARSHUDBase* GetRSHudBase(class UObject* WorldContextObject);
	static void SetIcon(class UObject* WorldContextObject, class UImage* Image, EUI_UV_BUtton_N1 Button);
	static void SetIconBaseGamePad(class UObject* WorldContextObject, class UImage* Image, ERSGamepadInputName Button);
	static void SetIconGamePadL(class UObject* WorldContextObject, class UImage* Image, ERSGamepadInputName Button);
	static void SetIconGamePadM(class UObject* WorldContextObject, class UImage* Image, ERSGamepadInputName Button);
	static void UI_SetColorAction(class UImage* Image, int32 Param_Index);
	static void UI_SetThumbnail_Action(class UImage* Image, EActionIconType Param_Index, bool IsActive);
	static int32 UIGetIdIconSas(E_SASKindNative Sas);
	static int32 UIGetIdIconSasStatus(E_SASKindNative Sas, E_SASIconStatus Status);
	static void UISetThumbnailIconSas(class UImage* Image, int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"REDWidgetBPLibrary">();
	}
	static class UREDWidgetBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UREDWidgetBPLibrary>();
	}
};
static_assert(alignof(UREDWidgetBPLibrary) == 0x000008, "Wrong alignment on UREDWidgetBPLibrary");
static_assert(sizeof(UREDWidgetBPLibrary) == 0x000028, "Wrong size on UREDWidgetBPLibrary");

// Class BattlePrototype.RenderingManagerCoreComponent
// 0x0020 (0x00E0 - 0x00C0)
class URenderingManagerCoreComponent final : public UActorComponent
{
public:
	float                                         ShadeNoiseProgressScale;                           // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25AE[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MPC;                                               // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25AF[0x10];                                    // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderingManagerCoreComponent">();
	}
	static class URenderingManagerCoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderingManagerCoreComponent>();
	}
};
static_assert(alignof(URenderingManagerCoreComponent) == 0x000008, "Wrong alignment on URenderingManagerCoreComponent");
static_assert(sizeof(URenderingManagerCoreComponent) == 0x0000E0, "Wrong size on URenderingManagerCoreComponent");
static_assert(offsetof(URenderingManagerCoreComponent, ShadeNoiseProgressScale) == 0x0000C0, "Member 'URenderingManagerCoreComponent::ShadeNoiseProgressScale' has a wrong offset!");
static_assert(offsetof(URenderingManagerCoreComponent, MPC) == 0x0000C8, "Member 'URenderingManagerCoreComponent::MPC' has a wrong offset!");

// Class BattlePrototype.UITownName
// 0x0058 (0x03E0 - 0x0388)
class UUITownName : public UUIBase
{
public:
	float                                         DrawSecond;                                        // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B0[0x54];                                    // 0x038C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextLocationName, class UTextBlock* TextLocationName2, class UTextBlock* TextLocationName3, class UTextBlock* TextLocationName4);
	void Start(int32 LocationId);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITownName">();
	}
	static class UUITownName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITownName>();
	}
};
static_assert(alignof(UUITownName) == 0x000008, "Wrong alignment on UUITownName");
static_assert(sizeof(UUITownName) == 0x0003E0, "Wrong size on UUITownName");
static_assert(offsetof(UUITownName, DrawSecond) == 0x000388, "Member 'UUITownName::DrawSecond' has a wrong offset!");

// Class BattlePrototype.RequestParticleEffectArgs
// 0x0038 (0x0060 - 0x0028)
class URequestParticleEffectArgs final : public UObject
{
public:
	class FName                                   _CustomName;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _MeshComponent;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _PSTemplate;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _SocketName;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _LocationOffset;                                   // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _RotationOffset;                                   // 0x0054(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void Setup(class FName CustomName, class USceneComponent* MeshComponent, class UParticleSystem* PSTemplate, class FName SocketName, const struct FVector& LocationOffset, const struct FRotator& RotationOffset);
	class UParticleSystemComponent* StartParticleEffect();

	bool EqualsCustomName(class FName Param_Name) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RequestParticleEffectArgs">();
	}
	static class URequestParticleEffectArgs* GetDefaultObj()
	{
		return GetDefaultObjImpl<URequestParticleEffectArgs>();
	}
};
static_assert(alignof(URequestParticleEffectArgs) == 0x000008, "Wrong alignment on URequestParticleEffectArgs");
static_assert(sizeof(URequestParticleEffectArgs) == 0x000060, "Wrong size on URequestParticleEffectArgs");
static_assert(offsetof(URequestParticleEffectArgs, _CustomName) == 0x000028, "Member 'URequestParticleEffectArgs::_CustomName' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _MeshComponent) == 0x000030, "Member 'URequestParticleEffectArgs::_MeshComponent' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _PSTemplate) == 0x000038, "Member 'URequestParticleEffectArgs::_PSTemplate' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _SocketName) == 0x000040, "Member 'URequestParticleEffectArgs::_SocketName' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _LocationOffset) == 0x000048, "Member 'URequestParticleEffectArgs::_LocationOffset' has a wrong offset!");
static_assert(offsetof(URequestParticleEffectArgs, _RotationOffset) == 0x000054, "Member 'URequestParticleEffectArgs::_RotationOffset' has a wrong offset!");

// Class BattlePrototype.RevisionData
// 0x0020 (0x0048 - 0x0028)
class URevisionData final : public UObject
{
public:
	class FString                                 Revision;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 BuildDate;                                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class FString GetBuildConfigStr() const;
	class FString GetBuildDateStr() const;
	class FString GetRevisionStr() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevisionData">();
	}
	static class URevisionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevisionData>();
	}
};
static_assert(alignof(URevisionData) == 0x000008, "Wrong alignment on URevisionData");
static_assert(sizeof(URevisionData) == 0x000048, "Wrong size on URevisionData");
static_assert(offsetof(URevisionData, Revision) == 0x000028, "Member 'URevisionData::Revision' has a wrong offset!");
static_assert(offsetof(URevisionData, BuildDate) == 0x000038, "Member 'URevisionData::BuildDate' has a wrong offset!");

// Class BattlePrototype.RSActorPsychicObjectBase
// 0x0000 (0x0230 - 0x0230)
class ARSActorPsychicObjectBase final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorPsychicObjectBase">();
	}
	static class ARSActorPsychicObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSActorPsychicObjectBase>();
	}
};
static_assert(alignof(ARSActorPsychicObjectBase) == 0x000008, "Wrong alignment on ARSActorPsychicObjectBase");
static_assert(sizeof(ARSActorPsychicObjectBase) == 0x000230, "Wrong size on ARSActorPsychicObjectBase");

// Class BattlePrototype.RSActorComponentSystemBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentSystemBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentSystemBase">();
	}
	static class URSActorComponentSystemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentSystemBase>();
	}
};
static_assert(alignof(URSActorComponentSystemBase) == 0x000008, "Wrong alignment on URSActorComponentSystemBase");
static_assert(sizeof(URSActorComponentSystemBase) == 0x0000C0, "Wrong size on URSActorComponentSystemBase");

// Class BattlePrototype.RSActorComponentEnemyBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentEnemyBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentEnemyBase">();
	}
	static class URSActorComponentEnemyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentEnemyBase>();
	}
};
static_assert(alignof(URSActorComponentEnemyBase) == 0x000008, "Wrong alignment on URSActorComponentEnemyBase");
static_assert(sizeof(URSActorComponentEnemyBase) == 0x0000C0, "Wrong size on URSActorComponentEnemyBase");

// Class BattlePrototype.RSActorComponentBackgroundBase
// 0x0000 (0x00C0 - 0x00C0)
class URSActorComponentBackgroundBase final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSActorComponentBackgroundBase">();
	}
	static class URSActorComponentBackgroundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSActorComponentBackgroundBase>();
	}
};
static_assert(alignof(URSActorComponentBackgroundBase) == 0x000008, "Wrong alignment on URSActorComponentBackgroundBase");
static_assert(sizeof(URSActorComponentBackgroundBase) == 0x0000C0, "Wrong size on URSActorComponentBackgroundBase");

// Class BattlePrototype.RSAjitoAnimBaseInstance
// 0x0010 (0x0630 - 0x0620)
class URSAjitoAnimBaseInstance final : public UASAnimInstance
{
public:
	uint8                                         Pad_25B2[0x10];                                    // 0x0620(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAjitoAnimBaseInstance">();
	}
	static class URSAjitoAnimBaseInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAjitoAnimBaseInstance>();
	}
};
static_assert(alignof(URSAjitoAnimBaseInstance) == 0x000010, "Wrong alignment on URSAjitoAnimBaseInstance");
static_assert(sizeof(URSAjitoAnimBaseInstance) == 0x000630, "Wrong size on URSAjitoAnimBaseInstance");

// Class BattlePrototype.RSAjitoAnimInstanceInterface
// 0x0000 (0x0028 - 0x0028)
class IRSAjitoAnimInstanceInterface final : public IInterface
{
public:
	bool RequestState(EAjitoMemberState State);
	bool ResetState();
	bool SetASAnimationSet(class UASAnimationSet* AnimationSet);
	bool SetASStateMachine(class UASStateMachine* StateMachine);
	bool SetLookAtPlayer(bool IsLookAt);
	bool SetPlayerFacePos(const struct FVector& PlayerFacePos);
	bool UseOverrideAnim(bool IsOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAjitoAnimInstanceInterface">();
	}
	static class IRSAjitoAnimInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSAjitoAnimInstanceInterface>();
	}
};
static_assert(alignof(IRSAjitoAnimInstanceInterface) == 0x000008, "Wrong alignment on IRSAjitoAnimInstanceInterface");
static_assert(sizeof(IRSAjitoAnimInstanceInterface) == 0x000028, "Wrong size on IRSAjitoAnimInstanceInterface");

// Class BattlePrototype.RSArrangeEventPlaneActor
// 0x0000 (0x0230 - 0x0230)
class ARSArrangeEventPlaneActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSArrangeEventPlaneActor">();
	}
	static class ARSArrangeEventPlaneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSArrangeEventPlaneActor>();
	}
};
static_assert(alignof(ARSArrangeEventPlaneActor) == 0x000008, "Wrong alignment on ARSArrangeEventPlaneActor");
static_assert(sizeof(ARSArrangeEventPlaneActor) == 0x000230, "Wrong size on ARSArrangeEventPlaneActor");

// Class BattlePrototype.RSAtomCuePlayNotifyBase
// 0x0008 (0x0040 - 0x0038)
class URSAtomCuePlayNotifyBase : public UAnimNotify
{
public:
	class USoundAtomCue*                          M_pSound;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnSetEditorSound(class USoundAtomCue* Sound) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAtomCuePlayNotifyBase">();
	}
	static class URSAtomCuePlayNotifyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAtomCuePlayNotifyBase>();
	}
};
static_assert(alignof(URSAtomCuePlayNotifyBase) == 0x000008, "Wrong alignment on URSAtomCuePlayNotifyBase");
static_assert(sizeof(URSAtomCuePlayNotifyBase) == 0x000040, "Wrong size on URSAtomCuePlayNotifyBase");
static_assert(offsetof(URSAtomCuePlayNotifyBase, M_pSound) == 0x000038, "Member 'URSAtomCuePlayNotifyBase::M_pSound' has a wrong offset!");

// Class BattlePrototype.RSAtomCuePlayNotifyStateBase
// 0x0008 (0x0038 - 0x0030)
class URSAtomCuePlayNotifyStateBase : public UAnimNotifyState
{
public:
	class USoundAtomCue*                          M_pSound;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnSetEditorSound(class USoundAtomCue* Sound) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAtomCuePlayNotifyStateBase">();
	}
	static class URSAtomCuePlayNotifyStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAtomCuePlayNotifyStateBase>();
	}
};
static_assert(alignof(URSAtomCuePlayNotifyStateBase) == 0x000008, "Wrong alignment on URSAtomCuePlayNotifyStateBase");
static_assert(sizeof(URSAtomCuePlayNotifyStateBase) == 0x000038, "Wrong size on URSAtomCuePlayNotifyStateBase");
static_assert(offsetof(URSAtomCuePlayNotifyStateBase, M_pSound) == 0x000030, "Member 'URSAtomCuePlayNotifyStateBase::M_pSound' has a wrong offset!");

// Class BattlePrototype.RSAtomStatics
// 0x0000 (0x0028 - 0x0028)
class URSAtomStatics final : public UBlueprintFunctionLibrary
{
public:
	static float GetCueSheetVolume(const class FString& SheetName, const bool IsForceGet);
	static float GetNonPlayerCueSheetVolumeParam();
	static void PauseAudioOutputRS(bool bPause);
	static void PlayOneShotSoundAtLocationRS(class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, const struct FVector& Location, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static void PlaySoundAtLocationRS(class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* PlaySoundAttachedRS(TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static void RemoveAllCueSheetVolume();
	static void RemoveCueSheetVolume(const class FString& SheetName);
	static void SetCueSheetVolume(const class FString& SheetName, const float Volume);
	static void SetIsCueSheetVolumeEnable(const bool Flag);
	static void SetNonPlayerCueSheetVolumeParam(const float Volume);
	static class URSAtomComponentBase* SpawnSound2DRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, float PitchMultiplier, float StartTime, bool bPersistAcrossLevelTransition, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* SpawnSoundAtLocationLoadedSheetRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* SpawnSoundAtLocationRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* SpawnSoundAttachedLoadedSheetRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);
	static class URSAtomComponentBase* SpawnSoundAttachedRS(TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bAutoActivate, class UObject* Creator, EFilterCallbackType FilterCallbackType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAtomStatics">();
	}
	static class URSAtomStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAtomStatics>();
	}
};
static_assert(alignof(URSAtomStatics) == 0x000008, "Wrong alignment on URSAtomStatics");
static_assert(sizeof(URSAtomStatics) == 0x000028, "Wrong size on URSAtomStatics");

// Class BattlePrototype.UICodeListIndex
// 0x0050 (0x03D8 - 0x0388)
class UUICodeListIndex : public UUIBase
{
public:
	uint8                                         Pad_25CC[0x50];                                    // 0x0388(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimDefaultClear, class UWidgetAnimation* AnimSelectClear, class UWidgetAnimation* AnimSelectInClear, class UImage* ImageNewIcon, class UTextBlock* TextName);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICodeListIndex">();
	}
	static class UUICodeListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICodeListIndex>();
	}
};
static_assert(alignof(UUICodeListIndex) == 0x000008, "Wrong alignment on UUICodeListIndex");
static_assert(sizeof(UUICodeListIndex) == 0x0003D8, "Wrong size on UUICodeListIndex");

// Class BattlePrototype.RSAutoTestBase
// 0x0070 (0x02A0 - 0x0230)
class ARSAutoTestBase : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnTestPrepare;                                     // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTestStart;                                       // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTestFinished;                                    // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ERSAutoTestResult                             Result;                                            // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDelayGCInTest;                                  // 0x0261(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25CD[0x2];                                     // 0x0262(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreparationTimeLimit;                              // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLimit;                                         // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25CE[0x4];                                     // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TimesUpMessage;                                    // 0x0270(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ERSAutoTestResult                             TimesUpResult;                                     // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRunning;                                        // 0x0289(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25CF[0x2];                                     // 0x028A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalTime;                                         // 0x028C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         TestArgs;                                          // 0x0290(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void FinishTest(ERSAutoTestResult TestResult, const class FString& Message);
	bool IsReady();
	void ReceivePrepareTest();
	void ReceiveStartTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAutoTestBase">();
	}
	static class ARSAutoTestBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSAutoTestBase>();
	}
};
static_assert(alignof(ARSAutoTestBase) == 0x000008, "Wrong alignment on ARSAutoTestBase");
static_assert(sizeof(ARSAutoTestBase) == 0x0002A0, "Wrong size on ARSAutoTestBase");
static_assert(offsetof(ARSAutoTestBase, OnTestPrepare) == 0x000230, "Member 'ARSAutoTestBase::OnTestPrepare' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, OnTestStart) == 0x000240, "Member 'ARSAutoTestBase::OnTestStart' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, OnTestFinished) == 0x000250, "Member 'ARSAutoTestBase::OnTestFinished' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, Result) == 0x000260, "Member 'ARSAutoTestBase::Result' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, bIsDelayGCInTest) == 0x000261, "Member 'ARSAutoTestBase::bIsDelayGCInTest' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, PreparationTimeLimit) == 0x000264, "Member 'ARSAutoTestBase::PreparationTimeLimit' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TimeLimit) == 0x000268, "Member 'ARSAutoTestBase::TimeLimit' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TimesUpMessage) == 0x000270, "Member 'ARSAutoTestBase::TimesUpMessage' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TimesUpResult) == 0x000288, "Member 'ARSAutoTestBase::TimesUpResult' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, bIsRunning) == 0x000289, "Member 'ARSAutoTestBase::bIsRunning' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TotalTime) == 0x00028C, "Member 'ARSAutoTestBase::TotalTime' has a wrong offset!");
static_assert(offsetof(ARSAutoTestBase, TestArgs) == 0x000290, "Member 'ARSAutoTestBase::TestArgs' has a wrong offset!");

// Class BattlePrototype.Wp0200AnimInstance
// 0x0180 (0x03F0 - 0x0270)
class UWp0200AnimInstance : public UAnimInstance
{
public:
	TWeakObjectPtr<class USceneComponent>         OwnerMeshComponent;                                // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WeaponScale;                                       // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location0;                                         // 0x0284(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation0;                                         // 0x0290(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale0;                                            // 0x029C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location1;                                         // 0x02A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation1;                                         // 0x02B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale1;                                            // 0x02C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location2;                                         // 0x02CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation2;                                         // 0x02D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale2;                                            // 0x02E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location3;                                         // 0x02F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation3;                                         // 0x02FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale3;                                            // 0x0308(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location4;                                         // 0x0314(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation4;                                         // 0x0320(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale4;                                            // 0x032C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location5;                                         // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation5;                                         // 0x0344(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale5;                                            // 0x0350(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location6;                                         // 0x035C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation6;                                         // 0x0368(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale6;                                            // 0x0374(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location7;                                         // 0x0380(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation7;                                         // 0x038C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale7;                                            // 0x0398(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location8;                                         // 0x03A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation8;                                         // 0x03B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale8;                                            // 0x03BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location9;                                         // 0x03C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation9;                                         // 0x03D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale9;                                            // 0x03E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D1[0x4];                                     // 0x03EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Wp0200AnimInstance">();
	}
	static class UWp0200AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWp0200AnimInstance>();
	}
};
static_assert(alignof(UWp0200AnimInstance) == 0x000010, "Wrong alignment on UWp0200AnimInstance");
static_assert(sizeof(UWp0200AnimInstance) == 0x0003F0, "Wrong size on UWp0200AnimInstance");
static_assert(offsetof(UWp0200AnimInstance, OwnerMeshComponent) == 0x000270, "Member 'UWp0200AnimInstance::OwnerMeshComponent' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, WeaponScale) == 0x000278, "Member 'UWp0200AnimInstance::WeaponScale' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location0) == 0x000284, "Member 'UWp0200AnimInstance::Location0' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation0) == 0x000290, "Member 'UWp0200AnimInstance::Rotation0' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale0) == 0x00029C, "Member 'UWp0200AnimInstance::Scale0' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location1) == 0x0002A8, "Member 'UWp0200AnimInstance::Location1' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation1) == 0x0002B4, "Member 'UWp0200AnimInstance::Rotation1' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale1) == 0x0002C0, "Member 'UWp0200AnimInstance::Scale1' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location2) == 0x0002CC, "Member 'UWp0200AnimInstance::Location2' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation2) == 0x0002D8, "Member 'UWp0200AnimInstance::Rotation2' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale2) == 0x0002E4, "Member 'UWp0200AnimInstance::Scale2' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location3) == 0x0002F0, "Member 'UWp0200AnimInstance::Location3' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation3) == 0x0002FC, "Member 'UWp0200AnimInstance::Rotation3' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale3) == 0x000308, "Member 'UWp0200AnimInstance::Scale3' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location4) == 0x000314, "Member 'UWp0200AnimInstance::Location4' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation4) == 0x000320, "Member 'UWp0200AnimInstance::Rotation4' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale4) == 0x00032C, "Member 'UWp0200AnimInstance::Scale4' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location5) == 0x000338, "Member 'UWp0200AnimInstance::Location5' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation5) == 0x000344, "Member 'UWp0200AnimInstance::Rotation5' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale5) == 0x000350, "Member 'UWp0200AnimInstance::Scale5' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location6) == 0x00035C, "Member 'UWp0200AnimInstance::Location6' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation6) == 0x000368, "Member 'UWp0200AnimInstance::Rotation6' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale6) == 0x000374, "Member 'UWp0200AnimInstance::Scale6' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location7) == 0x000380, "Member 'UWp0200AnimInstance::Location7' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation7) == 0x00038C, "Member 'UWp0200AnimInstance::Rotation7' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale7) == 0x000398, "Member 'UWp0200AnimInstance::Scale7' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location8) == 0x0003A4, "Member 'UWp0200AnimInstance::Location8' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation8) == 0x0003B0, "Member 'UWp0200AnimInstance::Rotation8' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale8) == 0x0003BC, "Member 'UWp0200AnimInstance::Scale8' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Location9) == 0x0003C8, "Member 'UWp0200AnimInstance::Location9' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Rotation9) == 0x0003D4, "Member 'UWp0200AnimInstance::Rotation9' has a wrong offset!");
static_assert(offsetof(UWp0200AnimInstance, Scale9) == 0x0003E0, "Member 'UWp0200AnimInstance::Scale9' has a wrong offset!");

// Class BattlePrototype.RSAutoTestMeasurePerfLevel
// 0x0000 (0x02A0 - 0x02A0)
class ARSAutoTestMeasurePerfLevel final : public ARSAutoTestBase
{
public:
	void AddCheckpointRecord(const class FString& LocationName);
	void BeginUnitRecording(const class FString& CheckpointName, int32 Angle);
	void EndUnitRecording();
	bool WriteCsvFile(const class FString& LogFileName);
	bool WriteErrorCsvFile(const class FString& LogFileName, const class FString& LocationName, const class FString& ErrorMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAutoTestMeasurePerfLevel">();
	}
	static class ARSAutoTestMeasurePerfLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSAutoTestMeasurePerfLevel>();
	}
};
static_assert(alignof(ARSAutoTestMeasurePerfLevel) == 0x000008, "Wrong alignment on ARSAutoTestMeasurePerfLevel");
static_assert(sizeof(ARSAutoTestMeasurePerfLevel) == 0x0002A0, "Wrong size on ARSAutoTestMeasurePerfLevel");

// Class BattlePrototype.RSBootManager
// 0x0060 (0x0290 - 0x0230)
class ARSBootManager final : public AActor
{
public:
	uint8                                         Pad_25D5[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             M_OnEventSaveLoadError;                            // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D6[0xD];                                     // 0x0248(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	EBootLevelFlow                                M_BootFlow;                                        // 0x0255(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25D7[0x2];                                     // 0x0256(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pRSHudBase;                                      // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pSaveGameSystem;                                 // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserParamManager*                      UserParamManager;                                  // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatabaseManager*                       DatabaseManager;                                   // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadSystemParamManager;                     // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25D8[0x10];                                    // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EBootLevelFlow GetBootFlow();
	bool IsCheckStorageSpace();
	bool IsExistSaveData();
	void SetBootFlow(EBootLevelFlow Flow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSBootManager">();
	}
	static class ARSBootManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSBootManager>();
	}
};
static_assert(alignof(ARSBootManager) == 0x000008, "Wrong alignment on ARSBootManager");
static_assert(sizeof(ARSBootManager) == 0x000290, "Wrong size on ARSBootManager");
static_assert(offsetof(ARSBootManager, M_OnEventSaveLoadError) == 0x000238, "Member 'ARSBootManager::M_OnEventSaveLoadError' has a wrong offset!");
static_assert(offsetof(ARSBootManager, M_BootFlow) == 0x000255, "Member 'ARSBootManager::M_BootFlow' has a wrong offset!");
static_assert(offsetof(ARSBootManager, M_pRSHudBase) == 0x000258, "Member 'ARSBootManager::M_pRSHudBase' has a wrong offset!");
static_assert(offsetof(ARSBootManager, M_pSaveGameSystem) == 0x000260, "Member 'ARSBootManager::M_pSaveGameSystem' has a wrong offset!");
static_assert(offsetof(ARSBootManager, UserParamManager) == 0x000268, "Member 'ARSBootManager::UserParamManager' has a wrong offset!");
static_assert(offsetof(ARSBootManager, DatabaseManager) == 0x000270, "Member 'ARSBootManager::DatabaseManager' has a wrong offset!");
static_assert(offsetof(ARSBootManager, M_pSaveLoadSystemParamManager) == 0x000278, "Member 'ARSBootManager::M_pSaveLoadSystemParamManager' has a wrong offset!");

// Class BattlePrototype.RSCableAnimInstance
// 0x0090 (0x0300 - 0x0270)
class URSCableAnimInstance : public UAnimInstance
{
public:
	struct FVector                                Gravity;                                           // 0x0270(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D9[0x4];                                     // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimNode_RigidBodyRedCustomInterpolateInfo RigidBodyInterplateInfo;                           // 0x0280(0x0018)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TimeDilation;                                      // 0x0298(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DA[0x4];                                     // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCableAdditiveBoneParam                AdditiveBoneParam;                                 // 0x02A0(0x0028)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	float                                         IdleRigidBlendSpeed;                               // 0x02C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRigidBlendRate;                                // 0x02CC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRotator>                       BoneRotator;                                       // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneNum;                                           // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERSCableAnimationState                        AnimationState;                                    // 0x02E4(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DB[0x3];                                     // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RigidIdlingSec;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DC[0x14];                                    // 0x02EC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeginOverrideGravity(ERSCableGravityType Type);
	bool EndOverrideGravity(ERSCableGravityType Type);
	void SetActive(bool NewActive);
	void SetBoneParam(const struct FCableAdditiveBoneParam& Param);
	void SetState(ERSCableAnimationState State);
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCableAnimInstance">();
	}
	static class URSCableAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCableAnimInstance>();
	}
};
static_assert(alignof(URSCableAnimInstance) == 0x000010, "Wrong alignment on URSCableAnimInstance");
static_assert(sizeof(URSCableAnimInstance) == 0x000300, "Wrong size on URSCableAnimInstance");
static_assert(offsetof(URSCableAnimInstance, Gravity) == 0x000270, "Member 'URSCableAnimInstance::Gravity' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, RigidBodyInterplateInfo) == 0x000280, "Member 'URSCableAnimInstance::RigidBodyInterplateInfo' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, TimeDilation) == 0x000298, "Member 'URSCableAnimInstance::TimeDilation' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, AdditiveBoneParam) == 0x0002A0, "Member 'URSCableAnimInstance::AdditiveBoneParam' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, IdleRigidBlendSpeed) == 0x0002C8, "Member 'URSCableAnimInstance::IdleRigidBlendSpeed' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, IdleRigidBlendRate) == 0x0002CC, "Member 'URSCableAnimInstance::IdleRigidBlendRate' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, BoneRotator) == 0x0002D0, "Member 'URSCableAnimInstance::BoneRotator' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, BoneNum) == 0x0002E0, "Member 'URSCableAnimInstance::BoneNum' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, AnimationState) == 0x0002E4, "Member 'URSCableAnimInstance::AnimationState' has a wrong offset!");
static_assert(offsetof(URSCableAnimInstance, RigidIdlingSec) == 0x0002E8, "Member 'URSCableAnimInstance::RigidIdlingSec' has a wrong offset!");

// Class BattlePrototype.RSCameraShake
// 0x0000 (0x0160 - 0x0160)
class URSCameraShake : public UCameraShake
{
public:
	bool                                          bNoEffectGlobalTimeDilation;                       // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DD[0x7];                                     // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCameraShake">();
	}
	static class URSCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCameraShake>();
	}
};
static_assert(alignof(URSCameraShake) == 0x000010, "Wrong alignment on URSCameraShake");
static_assert(sizeof(URSCameraShake) == 0x000160, "Wrong size on URSCameraShake");
static_assert(offsetof(URSCameraShake, bNoEffectGlobalTimeDilation) == 0x000158, "Member 'URSCameraShake::bNoEffectGlobalTimeDilation' has a wrong offset!");

// Class BattlePrototype.RSCapsuleComponent
// 0x0000 (0x0430 - 0x0430)
class URSCapsuleComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCapsuleComponent">();
	}
	static class URSCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCapsuleComponent>();
	}
};
static_assert(alignof(URSCapsuleComponent) == 0x000010, "Wrong alignment on URSCapsuleComponent");
static_assert(sizeof(URSCapsuleComponent) == 0x000430, "Wrong size on URSCapsuleComponent");

// Class BattlePrototype.RSCharaAnimationAccessor
// 0x0008 (0x0238 - 0x0230)
class ARSCharaAnimationAccessor final : public AActor
{
public:
	bool                                          IsSettingFaceAnimation;                            // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DE[0x7];                                     // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCharaAnimationAccessor">();
	}
	static class ARSCharaAnimationAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSCharaAnimationAccessor>();
	}
};
static_assert(alignof(ARSCharaAnimationAccessor) == 0x000008, "Wrong alignment on ARSCharaAnimationAccessor");
static_assert(sizeof(ARSCharaAnimationAccessor) == 0x000238, "Wrong size on ARSCharaAnimationAccessor");
static_assert(offsetof(ARSCharaAnimationAccessor, IsSettingFaceAnimation) == 0x000230, "Member 'ARSCharaAnimationAccessor::IsSettingFaceAnimation' has a wrong offset!");

// Class BattlePrototype.UIConfigKeyboardMouse
// 0x0060 (0x03E8 - 0x0388)
class UUIConfigKeyboardMouse : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DF[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E0[0x48];                                    // 0x03A0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UREDScrollBox* ScrollBox);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigKeyboardMouse">();
	}
	static class UUIConfigKeyboardMouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigKeyboardMouse>();
	}
};
static_assert(alignof(UUIConfigKeyboardMouse) == 0x000008, "Wrong alignment on UUIConfigKeyboardMouse");
static_assert(sizeof(UUIConfigKeyboardMouse) == 0x0003E8, "Wrong size on UUIConfigKeyboardMouse");
static_assert(offsetof(UUIConfigKeyboardMouse, ListElementSize) == 0x000388, "Member 'UUIConfigKeyboardMouse::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIConfigKeyboardMouse, ListOffsetSize) == 0x000390, "Member 'UUIConfigKeyboardMouse::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIConfigKeyboardMouse, ListIndexClass) == 0x000398, "Member 'UUIConfigKeyboardMouse::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.RSCharacterAnimInstance
// 0x0000 (0x0620 - 0x0620)
class URSCharacterAnimInstance : public UASAnimInstance
{
public:
	void ForceStopAllMontage(float BlendOut);
	class UAnimMontage* GetAnimMontageFromSlot(class FName SlotName);

	class FName DebugGetCurrentASNodeAssetName() const;
	bool DebugIsCurrentASNodeRootMotion() const;
	float GetCurrentASNodeAssetLength() const;
	float GetCurrentASNodeAssetPlayRate() const;
	float GetCurrentASNodeAssetTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCharacterAnimInstance">();
	}
	static class URSCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCharacterAnimInstance>();
	}
};
static_assert(alignof(URSCharacterAnimInstance) == 0x000010, "Wrong alignment on URSCharacterAnimInstance");
static_assert(sizeof(URSCharacterAnimInstance) == 0x000620, "Wrong size on URSCharacterAnimInstance");

// Class BattlePrototype.RSCharacterBase
// 0x02D0 (0x0900 - 0x0630)
class ARSCharacterBase : public AASCharacter
{
public:
	uint8                                         Pad_25E2[0x20];                                    // 0x0628(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchTick;                                      // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchStealth;                                   // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ECharacterHitPriority                         CharacterHitPriority;                              // 0x0668(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E3[0x3];                                     // 0x0669(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterHitTimeSliceNum;                          // 0x066C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHCHitResult>                   DamageDataArray;                                   // 0x0670(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDirectAttackDamageParam>       DirectDamageDataArray;                             // 0x0680(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHCHitResult>                   DamageData_Temp;                                   // 0x0690(0x0010)(ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E4[0x20];                                    // 0x06A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class URSUniqueIdComponent*                   UniqueIdComponent;                                 // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterItemDropId;                               // 0x06C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CoreDropId;                                        // 0x06CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestCurveMoveCharacterMovement;                   // 0x06D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAnimationCurveMovement;                        // 0x06D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E5[0x2];                                     // 0x06D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimationCurveMovementSlotName;                    // 0x06D4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E6[0x14];                                    // 0x06DC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UFootStepComponent*                     FootStepComponent;                                 // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageArrayComponent*                  DamageArrayComponent;                              // 0x06F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageResponseComponent*               DamageResponseComponent;                           // 0x0700(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E7[0x20];                                    // 0x0708(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EFHitEffectPriority                           PriorityHitEffect;                                 // 0x0728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25E8[0x7];                                     // 0x0729(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MLoopSeKeyList;                                    // 0x0730(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25E9[0x8];                                     // 0x0740(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MReplaceSkillTable;                                // 0x0748(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25EA[0xA];                                     // 0x0750(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableNpcTarget;                                 // 0x075A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOnRestrictFlag;                               // 0x075B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLockOnRestrictTarget;                       // 0x075C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25EB[0x3];                                     // 0x075D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           NotTargetableList;                                 // 0x0760(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25EC[0x10];                                    // 0x0770(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MCh0200CvEffect_BoneName;                          // 0x0780(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MCh0200CvEffect_Scale;                             // 0x0788(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MCh0200CvEffect_CameraOffset;                      // 0x0794(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ARSCharacterBase*>               MTargetingList;                                    // 0x0798(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ARSCharacterBase*>               MAttackingList;                                    // 0x07A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEnemyGrade                                   MEnemyGrade;                                       // 0x07B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25ED[0x17];                                    // 0x07B9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECharacterAttribute>                   CharacterAttributeList;                            // 0x07D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25EE[0x2];                                     // 0x07E0(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeadBrainCrashOnly;                               // 0x07E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfinityCrashChance;                              // 0x07E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotAbleBrainCrashTarget;                          // 0x07E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25EF[0x3];                                     // 0x07E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SufferDamageBeforeHp;                              // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGuts;                                          // 0x07EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F0[0x1];                                     // 0x07ED(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeadPsychicObjComboOnly;                          // 0x07EE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadChaseAttackOnly;                              // 0x07EF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadLaunchAttackOnly;                             // 0x07F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadPhysicsAttackOnly;                            // 0x07F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeadPsychicObjOnly;                               // 0x07F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoDeadTutorial;                                   // 0x07F3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoDeadEvent;                                      // 0x07F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCrashChanceEvent;                               // 0x07F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmphasisCrashGauge;                             // 0x07F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F1[0x1];                                     // 0x07F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HPPercentOfDamageBefore;                           // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableDamageAddReaction;                         // 0x07FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableDamageAddShake;                            // 0x07FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F2[0x1];                                     // 0x07FE(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsHitInvincibleParts;                             // 0x07FF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F3[0x1];                                     // 0x0800(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EEnemyAttractType                             AttractType;                                       // 0x0801(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F4[0x2];                                     // 0x0802(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PsychicFieldDamageRateToBoss;                      // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MDownCapusleInterpSpeed;                           // 0x0808(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MDownCapsuleOriginalAttachName;                    // 0x080C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MDownCapsuleInterpAttachName;                      // 0x0814(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCapsuleOriginalHalfHeight;                    // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCapsuleInterpHalfHeight;                      // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCapsuleOriginalRadius;                        // 0x0824(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDownCapsuleInterpRadius;                          // 0x0828(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MDownCapsuleOriginalRelativeLocation;              // 0x082C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MDownCapsuleInterpRelativeLocation;                // 0x0838(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MDownCapsuleOriginalRelativeRotation;              // 0x0844(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MDownCapsuleInterpRelativeRotation;                // 0x0850(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F5[0x18];                                    // 0x085C(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableUro;                                        // 0x0874(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F6[0x3];                                     // 0x0875(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 MUroThesholds;                                     // 0x0878(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URSParticleSystemComponentBase*> MCameraDitherParticlArray;                         // 0x0888(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCapsuleComponent*>              MCameraDitherCheckComponentArray;                  // 0x0898(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterDitherDataAsset*              MCameraDitherDataAsset;                            // 0x08A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MDitherValue;                                      // 0x08B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F7[0x4];                                     // 0x08B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerScriptComponent*                 PlayerScriptCache;                                 // 0x08B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerAsyncScriptComponent*            PlayerAsyncScriptCache;                            // 0x08C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDriveComponent*                  PlayerDriveCache;                                  // 0x08C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnemyScriptComponent*                  EnemyScriptCache;                                  // 0x08D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMoveInputComponent*                    MoveInputCache;                                    // 0x08D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetSearchComponent*                 TargetSearchCache;                                 // 0x08E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHateTargetComponent*                   HateTargetCache;                                   // 0x08E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHPEventComponent*                      HPEventCache;                                      // 0x08F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitCheckReceiverComponent*             HitCheckReceiverCache;                             // 0x08F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddAttackingList(class ARSCharacterBase* AddCharacter);
	void AddTargetingList(class ARSCharacterBase* AddCharacter);
	float CalcUniqueDamage(const struct FHCHitResult& HitResult, float BaseDamage);
	bool CheckAttractSelf(const struct FHCHitResult& HitResult);
	bool CheckStrongCharacter(class ARSCharacterBase* CheckCharacter);
	bool CheckTargetableCharacter(const class ARSCharacterBase* Chara);
	bool CheckTargetableCharacterReason(ETargetFailedReason* OutReason, const class ARSCharacterBase* Chara, bool bNotLockTarget);
	void ClearDamageDataArray();
	void ClearLoopSeKeyList();
	void DisableCharacterHit();
	void DisableDamageHit();
	void EnableAbsoluteVisibilityTrace(bool bEnable);
	void EnableCharacterHit(float Time);
	void EnableDamageHit();
	void EndInterruptTelepoEffect();
	void EndInterruptTelepoEffectImmediately();
	void EndMotionEffect();
	void EndMotionEffectImmediately();
	void ForceApplyCameraDither(bool bMesh, bool bParticle);
	void ForceEndInterpDownCapsule(class UCapsuleComponent* CharaCapsule);
	bool GetAssumptionDataNamesNative(class UDataTable* DataTable, const class FString& LevelName, TArray<class FName>& ResultRowNames);
	TArray<class ARSCharacterBase*> GetAttackingList();
	class UPlayerScriptComponent* GetCachedPlayerScript();
	TArray<ECharacterAttribute> GetCharacterAttribute();
	TArray<class FName> GetLoopSeKeyList();
	float GetPsychicFieldDamageRateToBoss();
	TArray<class ARSCharacterBase*> GetTargetingList();
	bool IsDangerousNearRange();
	bool IsRegistLoopSe(class FName Param_Name);
	bool IsTargetRendered();
	bool OnAddedBattleMemberFromMenu();
	void OnBeLockOn();
	void OnDamageCalcArray();
	void OnFellOutOfWorld();
	void OnFinishSpawnWaitDelayTimer();
	bool PauseLoopSe(class FName Param_Name, float FadeTime, float FadeVolume);
	bool PlayLoopSe(class FName Param_Name, class USoundAtomCue* AtomCue, const struct FVector& Location, const struct FRotator& Rotation, float FadeTime, float FadeVolume, bool ForceFirstStart);
	void ProcDamageActorHit(const struct FHCHitResult& HitResult);
	void ProcDamageAfter(const TArray<struct FHCHitResult>& Result);
	struct FHCHitResult ProcDamageAssassinAttack(const struct FHCHitResult& HitResult);
	void ProcDamageBefore(bool IgnoreAutoSasMetal);
	void RegistCameraDitherParticlehandle(class URSParticleSystemComponentBase* Particle);
	void RegisterSignificanceManager();
	void RegisterSpecialDamageEffect(class URSParticleSystemComponentBase* Particle);
	void RequestApplyCameraDither(bool bMesh, bool bParticle);
	void ReserveDamageDirectAttack(bool bUseFixDamage, int32 FixDamage, const struct FHCHitResult& HitResult, bool IsForceCritical);
	void ResetCharacterHitOffset();
	void ResetInterruptTelepoEffectList();
	void ResetMotionEffectList();
	bool ResumeLoopSe(class FName Param_Name, float FadeTime, float FadeVolume);
	void SetAttractSelf(bool bAttract);
	void SetBrainCrashReceivePossible(bool Flag);
	void SetCameraDitherToMeshAndParticles(float DeitherValue, bool bIgnorMesh);
	void SetCameraStabilizeParameter(float DistLockHz, float DistRestoreHz, float DistLockVt, float DistRestoreVt);
	void SetDeadBrainCrashOnly(bool bEnable);
	void SetDisableDamageAddReaction(bool bDisable);
	void SetDisableDamageAddShake(bool bDisable);
	void SetDisableTarget(bool bDisable, const class FName& ClaimantName);
	void SetEnableLockOnRestrictTarget(bool bEnable);
	void SetEventCondition(bool bEvent);
	void SetGaugeDisappearInstantly(bool DisappearInstantly);
	void SetInfinityCrashChance(bool bEnable);
	void SetInterruptTelepoEffect(class URSParticleSystemComponentBase* Effect);
	void SetInVisionFog(bool bInFog);
	void SetLockOnRestrict(bool bRestrict);
	void SetMotionEffect(class URSParticleSystemComponentBase* Effect);
	void SetNoCollisionAndStopAiFade(bool bNoColAndStopAi, bool* Dummy);
	void SetNoCrashChanceByUseGuts(bool bEnable);
	void SetReplaceSkillTable(class UDataTable* SkillTable);
	void SetRootMotionScale(float Scale);
	void SetSkipRecoverHpAnime(bool bEnable);
	void SetStealthMode(bool bStealth);
	void SetTargetAbleStealthActor(bool bSearchAble);
	void SetUpdateRepop(bool UpdateRepop);
	void SetUseGuts(bool bUse);
	void SetVisionFogInternalLock(bool bFogInternalLock);
	void StartInterpDownCapsule(float InterpSpeed, class FName InterpAttachName, float InterpHalfHeight, float InterpRadius, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, const class UCapsuleComponent* CharaCapsule);
	void StartRestoreInterpDownCapsule(float InterpSpeed, const class UCapsuleComponent* CharaCapsule);
	bool StopLoopSe(class FName Param_Name, float FadeTime, float FadeVolume);
	void StopLoopSeAll(float FadeTime, float FadeVolume);
	void SubAttackingList(class ARSCharacterBase* SubCharacter);
	void SubTargetingList(class ARSCharacterBase* SubCharacter);
	void UnregisterSignificanceManager();
	void UpdateAnimationCurveMovement();
	float UpdateCameraDitherInner(float DeltaSeconds, bool UseDither, const class UCapsuleComponent* CheckComponent, float CheckDistance);
	void UpdateInterpDownCapsule(class UCapsuleComponent* CharaCapsule, float DeltaSec);

	bool CanAddAttackingList(const class ARSCharacterBase* NewCharacter) const;
	bool CanAddTargetingList(const class ARSCharacterBase* NewCharacter) const;
	TArray<class USkeletalMeshSocket*> GetActiveSocketList() const;
	float GetActorDeltaSecondsCPP() const;
	EAssassinAttackHit GetAssasinAttackHitType() const;
	EEnemyAttractType GetAttractType() const;
	float GetBrainCrashRange() const;
	class FName GetCh0200CvEffect_BoneName() const;
	float GetCh0200CvEffect_CameraOffset() const;
	struct FVector GetCh0200CvEffect_Scale() const;
	bool GetCharacterMovementGroundInfoSimple(struct FHitResult* Result) const;
	struct FVector GetCharacterMovementLocationSimple() const;
	class UCharactersParameterComponent* GetCharactersParameterComponent() const;
	const TArray<class ARSCharacterBase*> GetConstAttackingList() const;
	const TArray<class ARSCharacterBase*> GetConstTargetingList() const;
	int32 GetDamageDataArrayNum() const;
	int32 GetDirectDamageDataArrayNum() const;
	class FName GetEnemyDeadReplaceLogName() const;
	struct FEnemyFindChangeParam GetEnemyFindChangeParam() const;
	struct FVector GetEyePosition() const;
	struct FVector GetGroundLocationSimple(bool bIncludeObject) const;
	int32 GetGroupID() const;
	class UDataTable* GetReplaceSkillTable() const;
	float GetSignificanceResult() const;
	TArray<class FName> GetSkeletonSlotNames() const;
	ESpecialDamageTableType GetSpecialDamageTableType() const;
	int32 GetUniqueId() const;
	class FName GetUniqueName() const;
	bool IsAbsoluteVisibilityTrace() const;
	bool IsAttractSelf() const;
	bool IsBrainCrashAccess() const;
	bool IsBrainCrashReceivePossible() const;
	bool IsBrainCrashSuccess() const;
	bool IsCharacterBadStatusAttribute(EHCSkillAttribute Attr) const;
	bool IsCharacterBadStatusConfusion() const;
	bool IsCharacterBadStatusElectric() const;
	bool IsCharacterBadStatusFlame() const;
	bool IsCharacterBadStatusFlooded() const;
	bool IsCharacterBadStatusOil() const;
	bool IsCharacterDead() const;
	bool IsCrashMaxWithGuts() const;
	bool IsDeadBrainCrashOnly() const;
	bool IsDisableDamageAddReaction() const;
	bool IsDisableDamageAddShake() const;
	bool IsEnableCharacterHit() const;
	bool IsEnableDamageHit() const;
	bool IsEnableMetalMode() const;
	bool IsEventCondition() const;
	bool IsFallingCPP() const;
	bool IsFinishActorBeginPlay() const;
	bool IsFlyingCPP() const;
	bool IsFriendTeam(class UTeamComponent* Team) const;
	bool IsGaugeDisappearInstantly() const;
	bool IsGuardBadCondition(EHCSkillAttribute Attr) const;
	bool IsHitInvincibleParts() const;
	bool IsIgnoreVisionFog() const;
	bool IsInfinityCrashChance() const;
	bool IsInVisionFog() const;
	bool IsNoCrashChanceByUseGuts() const;
	bool IsNotAbleBrainCrashTarget() const;
	bool IsRivalTeam(class UTeamComponent* Team) const;
	bool IsSeeTarget(const class ARSCharacterBase* Target) const;
	bool IsSkipRecoverHpAnime() const;
	bool IsStealthMode() const;
	bool IsTargetable() const;
	bool IsTargetAbleStealthActor() const;
	bool IsUpdateRepop() const;
	bool IsUseGuts() const;
	bool IsVisionFogInternalLock() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCharacterBase">();
	}
	static class ARSCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSCharacterBase>();
	}
};
static_assert(alignof(ARSCharacterBase) == 0x000010, "Wrong alignment on ARSCharacterBase");
static_assert(sizeof(ARSCharacterBase) == 0x000900, "Wrong size on ARSCharacterBase");
static_assert(offsetof(ARSCharacterBase, DispatchTick) == 0x000648, "Member 'ARSCharacterBase::DispatchTick' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DispatchStealth) == 0x000658, "Member 'ARSCharacterBase::DispatchStealth' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CharacterHitPriority) == 0x000668, "Member 'ARSCharacterBase::CharacterHitPriority' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CharacterHitTimeSliceNum) == 0x00066C, "Member 'ARSCharacterBase::CharacterHitTimeSliceNum' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DamageDataArray) == 0x000670, "Member 'ARSCharacterBase::DamageDataArray' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DirectDamageDataArray) == 0x000680, "Member 'ARSCharacterBase::DirectDamageDataArray' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DamageData_Temp) == 0x000690, "Member 'ARSCharacterBase::DamageData_Temp' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, UniqueIdComponent) == 0x0006C0, "Member 'ARSCharacterBase::UniqueIdComponent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CharacterItemDropId) == 0x0006C8, "Member 'ARSCharacterBase::CharacterItemDropId' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CoreDropId) == 0x0006CC, "Member 'ARSCharacterBase::CoreDropId' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bTestCurveMoveCharacterMovement) == 0x0006D0, "Member 'ARSCharacterBase::bTestCurveMoveCharacterMovement' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bUseAnimationCurveMovement) == 0x0006D1, "Member 'ARSCharacterBase::bUseAnimationCurveMovement' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, AnimationCurveMovementSlotName) == 0x0006D4, "Member 'ARSCharacterBase::AnimationCurveMovementSlotName' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, FootStepComponent) == 0x0006F0, "Member 'ARSCharacterBase::FootStepComponent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DamageArrayComponent) == 0x0006F8, "Member 'ARSCharacterBase::DamageArrayComponent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, DamageResponseComponent) == 0x000700, "Member 'ARSCharacterBase::DamageResponseComponent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PriorityHitEffect) == 0x000728, "Member 'ARSCharacterBase::PriorityHitEffect' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MLoopSeKeyList) == 0x000730, "Member 'ARSCharacterBase::MLoopSeKeyList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MReplaceSkillTable) == 0x000748, "Member 'ARSCharacterBase::MReplaceSkillTable' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDisableNpcTarget) == 0x00075A, "Member 'ARSCharacterBase::bDisableNpcTarget' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bLockOnRestrictFlag) == 0x00075B, "Member 'ARSCharacterBase::bLockOnRestrictFlag' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bEnableLockOnRestrictTarget) == 0x00075C, "Member 'ARSCharacterBase::bEnableLockOnRestrictTarget' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, NotTargetableList) == 0x000760, "Member 'ARSCharacterBase::NotTargetableList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCh0200CvEffect_BoneName) == 0x000780, "Member 'ARSCharacterBase::MCh0200CvEffect_BoneName' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCh0200CvEffect_Scale) == 0x000788, "Member 'ARSCharacterBase::MCh0200CvEffect_Scale' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCh0200CvEffect_CameraOffset) == 0x000794, "Member 'ARSCharacterBase::MCh0200CvEffect_CameraOffset' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MTargetingList) == 0x000798, "Member 'ARSCharacterBase::MTargetingList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MAttackingList) == 0x0007A8, "Member 'ARSCharacterBase::MAttackingList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MEnemyGrade) == 0x0007B8, "Member 'ARSCharacterBase::MEnemyGrade' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, CharacterAttributeList) == 0x0007D0, "Member 'ARSCharacterBase::CharacterAttributeList' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadBrainCrashOnly) == 0x0007E2, "Member 'ARSCharacterBase::bDeadBrainCrashOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bInfinityCrashChance) == 0x0007E3, "Member 'ARSCharacterBase::bInfinityCrashChance' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bNotAbleBrainCrashTarget) == 0x0007E4, "Member 'ARSCharacterBase::bNotAbleBrainCrashTarget' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, SufferDamageBeforeHp) == 0x0007E8, "Member 'ARSCharacterBase::SufferDamageBeforeHp' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bUseGuts) == 0x0007EC, "Member 'ARSCharacterBase::bUseGuts' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadPsychicObjComboOnly) == 0x0007EE, "Member 'ARSCharacterBase::bDeadPsychicObjComboOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadChaseAttackOnly) == 0x0007EF, "Member 'ARSCharacterBase::bDeadChaseAttackOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadLaunchAttackOnly) == 0x0007F0, "Member 'ARSCharacterBase::bDeadLaunchAttackOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadPhysicsAttackOnly) == 0x0007F1, "Member 'ARSCharacterBase::bDeadPhysicsAttackOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDeadPsychicObjOnly) == 0x0007F2, "Member 'ARSCharacterBase::bDeadPsychicObjOnly' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bNoDeadTutorial) == 0x0007F3, "Member 'ARSCharacterBase::bNoDeadTutorial' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bNoDeadEvent) == 0x0007F4, "Member 'ARSCharacterBase::bNoDeadEvent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bNoCrashChanceEvent) == 0x0007F5, "Member 'ARSCharacterBase::bNoCrashChanceEvent' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bIsEmphasisCrashGauge) == 0x0007F6, "Member 'ARSCharacterBase::bIsEmphasisCrashGauge' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, HPPercentOfDamageBefore) == 0x0007F8, "Member 'ARSCharacterBase::HPPercentOfDamageBefore' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDisableDamageAddReaction) == 0x0007FC, "Member 'ARSCharacterBase::bDisableDamageAddReaction' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bDisableDamageAddShake) == 0x0007FD, "Member 'ARSCharacterBase::bDisableDamageAddShake' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bIsHitInvincibleParts) == 0x0007FF, "Member 'ARSCharacterBase::bIsHitInvincibleParts' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, AttractType) == 0x000801, "Member 'ARSCharacterBase::AttractType' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PsychicFieldDamageRateToBoss) == 0x000804, "Member 'ARSCharacterBase::PsychicFieldDamageRateToBoss' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapusleInterpSpeed) == 0x000808, "Member 'ARSCharacterBase::MDownCapusleInterpSpeed' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalAttachName) == 0x00080C, "Member 'ARSCharacterBase::MDownCapsuleOriginalAttachName' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpAttachName) == 0x000814, "Member 'ARSCharacterBase::MDownCapsuleInterpAttachName' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalHalfHeight) == 0x00081C, "Member 'ARSCharacterBase::MDownCapsuleOriginalHalfHeight' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpHalfHeight) == 0x000820, "Member 'ARSCharacterBase::MDownCapsuleInterpHalfHeight' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalRadius) == 0x000824, "Member 'ARSCharacterBase::MDownCapsuleOriginalRadius' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpRadius) == 0x000828, "Member 'ARSCharacterBase::MDownCapsuleInterpRadius' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalRelativeLocation) == 0x00082C, "Member 'ARSCharacterBase::MDownCapsuleOriginalRelativeLocation' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpRelativeLocation) == 0x000838, "Member 'ARSCharacterBase::MDownCapsuleInterpRelativeLocation' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleOriginalRelativeRotation) == 0x000844, "Member 'ARSCharacterBase::MDownCapsuleOriginalRelativeRotation' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDownCapsuleInterpRelativeRotation) == 0x000850, "Member 'ARSCharacterBase::MDownCapsuleInterpRelativeRotation' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, bEnableUro) == 0x000874, "Member 'ARSCharacterBase::bEnableUro' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MUroThesholds) == 0x000878, "Member 'ARSCharacterBase::MUroThesholds' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCameraDitherParticlArray) == 0x000888, "Member 'ARSCharacterBase::MCameraDitherParticlArray' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCameraDitherCheckComponentArray) == 0x000898, "Member 'ARSCharacterBase::MCameraDitherCheckComponentArray' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MCameraDitherDataAsset) == 0x0008A8, "Member 'ARSCharacterBase::MCameraDitherDataAsset' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MDitherValue) == 0x0008B0, "Member 'ARSCharacterBase::MDitherValue' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PlayerScriptCache) == 0x0008B8, "Member 'ARSCharacterBase::PlayerScriptCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PlayerAsyncScriptCache) == 0x0008C0, "Member 'ARSCharacterBase::PlayerAsyncScriptCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, PlayerDriveCache) == 0x0008C8, "Member 'ARSCharacterBase::PlayerDriveCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, EnemyScriptCache) == 0x0008D0, "Member 'ARSCharacterBase::EnemyScriptCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, MoveInputCache) == 0x0008D8, "Member 'ARSCharacterBase::MoveInputCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, TargetSearchCache) == 0x0008E0, "Member 'ARSCharacterBase::TargetSearchCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, HateTargetCache) == 0x0008E8, "Member 'ARSCharacterBase::HateTargetCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, HPEventCache) == 0x0008F0, "Member 'ARSCharacterBase::HPEventCache' has a wrong offset!");
static_assert(offsetof(ARSCharacterBase, HitCheckReceiverCache) == 0x0008F8, "Member 'ARSCharacterBase::HitCheckReceiverCache' has a wrong offset!");

// Class BattlePrototype.RSCheatManager
// 0x0008 (0x0080 - 0x0078)
class URSCheatManager final : public UCheatManager
{
public:
	uint8                                         Pad_2612[0x8];                                     // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetWidgetLayoutDispFlag();
	static bool IsHudDisp();
	static bool IsPerfMeterDisp();
	static bool IsPerfMeterValuePercentage();
	static bool IsPerfMeterWithStat();
	static bool IsSASParticleDisp();
	static bool IsTargetCursorDisp();

	void RSCAutoTest(const class FString& Args);
	void RSCDumpLevelActorStat(bool bWarningInvalidActor);
	void RSCDumpParticleInfo();
	void RSCDumpTopLevelWidget();
	void RSCHudInvisibleAll(bool bInvisible);
	void RSCSetAILevel(const class FString& Param_Name);
	void RSCSetBarrier(const class FString& Param_Name);
	void RSCSetBarrierInvincible(const class FString& Param_Name);
	void RSCSetBattlePlayerAIMode(const class FString& Param_Name);
	void RSCSetCombo(const class FString& Param_Name);
	void RSCToggleFreeCamera();
	void RSCWarp(const class FString& Param_Name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCheatManager">();
	}
	static class URSCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCheatManager>();
	}
};
static_assert(alignof(URSCheatManager) == 0x000008, "Wrong alignment on URSCheatManager");
static_assert(sizeof(URSCheatManager) == 0x000080, "Wrong size on URSCheatManager");

// Class BattlePrototype.UIConfigSelect2
// 0x00F0 (0x04F0 - 0x0400)
class UUIConfigSelect2 : public UUIConfigSelectBase
{
public:
	uint8                                         Pad_2613[0xF0];                                    // 0x0400(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut, class UTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelect2">();
	}
	static class UUIConfigSelect2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelect2>();
	}
};
static_assert(alignof(UUIConfigSelect2) == 0x000008, "Wrong alignment on UUIConfigSelect2");
static_assert(sizeof(UUIConfigSelect2) == 0x0004F0, "Wrong size on UUIConfigSelect2");

// Class BattlePrototype.RSCheckCollision
// 0x0000 (0x0028 - 0x0028)
class URSCheckCollision final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckCollisionBoxVsBoxByComponent(class UBoxComponent* Box0, class UBoxComponent* box1);
	static bool CheckCollisionBoxVsCapsuleByComponent(class UBoxComponent* Box0, class UCapsuleComponent* Capsule0);
	static bool CheckCollisionCapsule(struct FRSResultCapsule* Result, const struct FVector& StartLocation0, const struct FVector& EndLocation0, float Radius0, const struct FVector& StartLocation1, const struct FVector& EndLocation1, float Radius1);
	static bool CheckCollisionCapsuleByComponent(struct FRSResultCapsule* Result, class UCapsuleComponent* Capsule0, class UCapsuleComponent* Capsule1);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCheckCollision">();
	}
	static class URSCheckCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCheckCollision>();
	}
};
static_assert(alignof(URSCheckCollision) == 0x000008, "Wrong alignment on URSCheckCollision");
static_assert(sizeof(URSCheckCollision) == 0x000028, "Wrong size on URSCheckCollision");

// Class BattlePrototype.RSClassFinder
// 0x0008 (0x0030 - 0x0028)
class URSClassFinder final : public UObject
{
public:
	TSubclassOf<class AActor>                     SpawnClass;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void SetNextAsset(class FName ClassName, class FName AssetName);

	TSubclassOf<class AActor> GetClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSClassFinder">();
	}
	static class URSClassFinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSClassFinder>();
	}
};
static_assert(alignof(URSClassFinder) == 0x000008, "Wrong alignment on URSClassFinder");
static_assert(sizeof(URSClassFinder) == 0x000030, "Wrong size on URSClassFinder");
static_assert(offsetof(URSClassFinder, SpawnClass) == 0x000028, "Member 'URSClassFinder::SpawnClass' has a wrong offset!");

// Class BattlePrototype.RSCreditEventManager
// 0x0000 (0x0230 - 0x0230)
class ARSCreditEventManager final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCreditEventManager">();
	}
	static class ARSCreditEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSCreditEventManager>();
	}
};
static_assert(alignof(ARSCreditEventManager) == 0x000008, "Wrong alignment on ARSCreditEventManager");
static_assert(sizeof(ARSCreditEventManager) == 0x000230, "Wrong size on ARSCreditEventManager");

// Class BattlePrototype.UIShopPartyStatus
// 0x0060 (0x03E8 - 0x0388)
class UUIShopPartyStatus : public UUIBase
{
public:
	float                                         DefaultPositionY;                                  // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TradePositionY;                                    // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261A[0x58];                                    // 0x0390(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIcons(class UUIShopPartyStatusIcon* UiIcon1, class UUIShopPartyStatusIcon* UiIcon2, class UUIShopPartyStatusIcon* UiIcon3, class UUIShopPartyStatusIcon* UiIcon4, class UUIShopPartyStatusIcon* UiIcon5, class UUIShopPartyStatusIcon* UiIcon6, class UUIShopPartyStatusIcon* UiIcon7, class UUIShopPartyStatusIcon* UiIcon8, class UUIShopPartyStatusIcon* UiIcon9, class UUIShopPartyStatusIcon* UiIcon10);
	void InitializeThis(class UBorder* borderAllColor);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopPartyStatus">();
	}
	static class UUIShopPartyStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopPartyStatus>();
	}
};
static_assert(alignof(UUIShopPartyStatus) == 0x000008, "Wrong alignment on UUIShopPartyStatus");
static_assert(sizeof(UUIShopPartyStatus) == 0x0003E8, "Wrong size on UUIShopPartyStatus");
static_assert(offsetof(UUIShopPartyStatus, DefaultPositionY) == 0x000388, "Member 'UUIShopPartyStatus::DefaultPositionY' has a wrong offset!");
static_assert(offsetof(UUIShopPartyStatus, TradePositionY) == 0x00038C, "Member 'UUIShopPartyStatus::TradePositionY' has a wrong offset!");

// Class BattlePrototype.RSCrossSaveManager
// 0x0078 (0x00A8 - 0x0030)
class URSCrossSaveManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_261B[0x78];                                    // 0x0030(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCrossSaveManager">();
	}
	static class URSCrossSaveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCrossSaveManager>();
	}
};
static_assert(alignof(URSCrossSaveManager) == 0x000008, "Wrong alignment on URSCrossSaveManager");
static_assert(sizeof(URSCrossSaveManager) == 0x0000A8, "Wrong size on URSCrossSaveManager");

// Class BattlePrototype.RSCustomOperatorLib
// 0x0000 (0x0028 - 0x0028)
class URSCustomOperatorLib final : public UBlueprintFunctionLibrary
{
public:
	static int32 BitShiftLeft(int32 Value, int32 Shift);
	static int32 BitShiftRight(int32 Value, int32 Shift);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCustomOperatorLib">();
	}
	static class URSCustomOperatorLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCustomOperatorLib>();
	}
};
static_assert(alignof(URSCustomOperatorLib) == 0x000008, "Wrong alignment on URSCustomOperatorLib");
static_assert(sizeof(URSCustomOperatorLib) == 0x000028, "Wrong size on URSCustomOperatorLib");

// Class BattlePrototype.RSCvManager
// 0x0090 (0x0150 - 0x00C0)
class URSCvManager : public UActorComponent
{
public:
	class ARSSoundManager*                        M_pSoundManager;                                   // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCueSheetManager*                  M_pCueSheetManager;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayingEventType                             M_playingEventType;                                // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261C[0x7];                                     // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_playingChapterTag;                               // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_lastChapterTag;                                  // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_playingBondsEpisodeTag;                          // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_lastBondsEpisodeTag;                             // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_standbyTag;                                      // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_lastStandbyTag;                                  // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_voiceLanguage;                                   // 0x0138(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isInit;                                          // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isTitle;                                         // 0x0149(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261D[0x6];                                     // 0x014A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Finalize();
	class FString GetChapterStringFromProgressId(int32 ProgressId);
	class FString GetCueSheetName(class USoundAtomCue* Cue);
	class FString GetCueSheetNameFromCueSheet(class USoundAtomCueSheet* CueSheet);
	class USoundAtomCueSheet* GetFitLanguageCueSheetFromCueSheetManager(class USoundAtomCue* Sound);
	void Initialize();
	bool LoadCmnCueSheets();
	bool LoadCueSheet(class USoundAtomCueSheet* CueSheet);
	bool LoadCueSheetFromDtRef(const class FString& RowName);
	bool LoadSenarioCueSheet();
	void OnChangeEventStat();
	void OnChangeVoiceLanguage();
	void OnStartTitle();
	class URSAtomComponentBase* PlayVoice(class USoundAtomCue* Sound, bool IsAttache, bool IsAutoActivate, class USceneComponent* AttachToComponent, class FName AttachPointName, EFilterCallbackType FilterCallbackType);
	void SetMVarPlayingEventType();
	bool UnLoadCueSheet(class USoundAtomCueSheet* CueSheet);
	bool UnLoadCueSheetAll();
	bool UnLoadCueSheetFromDtRef(const class FString& RowName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSCvManager">();
	}
	static class URSCvManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSCvManager>();
	}
};
static_assert(alignof(URSCvManager) == 0x000008, "Wrong alignment on URSCvManager");
static_assert(sizeof(URSCvManager) == 0x000150, "Wrong size on URSCvManager");
static_assert(offsetof(URSCvManager, M_pSoundManager) == 0x0000C0, "Member 'URSCvManager::M_pSoundManager' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_pCueSheetManager) == 0x0000C8, "Member 'URSCvManager::M_pCueSheetManager' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_playingEventType) == 0x0000D0, "Member 'URSCvManager::M_playingEventType' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_playingChapterTag) == 0x0000D8, "Member 'URSCvManager::M_playingChapterTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_lastChapterTag) == 0x0000E8, "Member 'URSCvManager::M_lastChapterTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_playingBondsEpisodeTag) == 0x0000F8, "Member 'URSCvManager::M_playingBondsEpisodeTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_lastBondsEpisodeTag) == 0x000108, "Member 'URSCvManager::M_lastBondsEpisodeTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_standbyTag) == 0x000118, "Member 'URSCvManager::M_standbyTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_lastStandbyTag) == 0x000128, "Member 'URSCvManager::M_lastStandbyTag' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_voiceLanguage) == 0x000138, "Member 'URSCvManager::M_voiceLanguage' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_isInit) == 0x000148, "Member 'URSCvManager::M_isInit' has a wrong offset!");
static_assert(offsetof(URSCvManager, M_isTitle) == 0x000149, "Member 'URSCvManager::M_isTitle' has a wrong offset!");

// Class BattlePrototype.UITarget
// 0x0050 (0x03D8 - 0x0388)
class UUITarget : public UUIBase
{
public:
	uint8                                         Pad_2625[0x50];                                    // 0x0388(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Change();
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimChange, class UWidgetAnimation* AnimOut2, class USizeBox* SizeBox0, class USizeBox* SizeBoxAdd);
	void SetFlagDisturb(bool IsDisturb);
	void SetSize(float Size);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITarget">();
	}
	static class UUITarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITarget>();
	}
};
static_assert(alignof(UUITarget) == 0x000008, "Wrong alignment on UUITarget");
static_assert(sizeof(UUITarget) == 0x0003D8, "Wrong size on UUITarget");

// Class BattlePrototype.RSDPICustomScalingRule
// 0x0000 (0x0028 - 0x0028)
class URSDPICustomScalingRule final : public UDPICustomScalingRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSDPICustomScalingRule">();
	}
	static class URSDPICustomScalingRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSDPICustomScalingRule>();
	}
};
static_assert(alignof(URSDPICustomScalingRule) == 0x000008, "Wrong alignment on URSDPICustomScalingRule");
static_assert(sizeof(URSDPICustomScalingRule) == 0x000028, "Wrong size on URSDPICustomScalingRule");

// Class BattlePrototype.RSEditorCallbackActor
// 0x0000 (0x0230 - 0x0230)
class ARSEditorCallbackActor final : public AActor
{
public:
	void EventPostEditChangeProperty();
	void EventPostEditMove(bool bFinished);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEditorCallbackActor">();
	}
	static class ARSEditorCallbackActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSEditorCallbackActor>();
	}
};
static_assert(alignof(ARSEditorCallbackActor) == 0x000008, "Wrong alignment on ARSEditorCallbackActor");
static_assert(sizeof(ARSEditorCallbackActor) == 0x000230, "Wrong size on ARSEditorCallbackActor");

// Class BattlePrototype.RSEditorTickedActor
// 0x0008 (0x0238 - 0x0230)
class ARSEditorTickedActor final : public AActor
{
public:
	bool                                          bEnableEditorTick;                                 // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2626[0x7];                                     // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventPostEditChangeProperty();
	void EventPostEditMove(bool bFinished);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEditorTickedActor">();
	}
	static class ARSEditorTickedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSEditorTickedActor>();
	}
};
static_assert(alignof(ARSEditorTickedActor) == 0x000008, "Wrong alignment on ARSEditorTickedActor");
static_assert(sizeof(ARSEditorTickedActor) == 0x000238, "Wrong size on ARSEditorTickedActor");
static_assert(offsetof(ARSEditorTickedActor, bEnableEditorTick) == 0x000230, "Member 'ARSEditorTickedActor::bEnableEditorTick' has a wrong offset!");

// Class BattlePrototype.RSEffectFuncLibraryCPP
// 0x0000 (0x0028 - 0x0028)
class URSEffectFuncLibraryCPP final : public UBlueprintFunctionLibrary
{
public:
	static struct FRotator CalcDamageHitEffectRotation(class AActor* InActor, const struct FHCHitResult& InHitResult, const struct FVector& InEffectSpawnLocation);
	static void SpawnDamageHitEffectCPP(class AActor* Actor, const struct FHCHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEffectFuncLibraryCPP">();
	}
	static class URSEffectFuncLibraryCPP* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSEffectFuncLibraryCPP>();
	}
};
static_assert(alignof(URSEffectFuncLibraryCPP) == 0x000008, "Wrong alignment on URSEffectFuncLibraryCPP");
static_assert(sizeof(URSEffectFuncLibraryCPP) == 0x000028, "Wrong size on URSEffectFuncLibraryCPP");

// Class BattlePrototype.UITitleCrossSave_ConfirmWindow
// 0x0040 (0x03C8 - 0x0388)
class UUITitleCrossSave_ConfirmWindow final : public UUIBase
{
public:
	uint8                                         Pad_2627[0x40];                                    // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextMain, class UREDScrollBoxSimple* ScrollBox, class UUITitleCrossSave_ConfirmWindow_Parts_Select2* UiSelect2);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleCrossSave_ConfirmWindow">();
	}
	static class UUITitleCrossSave_ConfirmWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleCrossSave_ConfirmWindow>();
	}
};
static_assert(alignof(UUITitleCrossSave_ConfirmWindow) == 0x000008, "Wrong alignment on UUITitleCrossSave_ConfirmWindow");
static_assert(sizeof(UUITitleCrossSave_ConfirmWindow) == 0x0003C8, "Wrong size on UUITitleCrossSave_ConfirmWindow");

// Class BattlePrototype.RSEnemyAnimInstance
// 0x00F0 (0x0710 - 0x0620)
class URSEnemyAnimInstance final : public URSCharacterAnimInstance
{
public:
	EnemyAliveAnimKind                            _aliveAnimKind;                                    // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyMoveAnimKind                             _MoveAnimKind;                                     // 0x0621(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyAttackAnimKind                           _attackAnimKind;                                   // 0x0622(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyActionAnimKind                           _actionAnimKind;                                   // 0x0623(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemySwitchAnimKind                           _switchAnimKind;                                   // 0x0624(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyDamageAnimKind                           _damageAnimKind;                                   // 0x0625(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyDamageDownAnimKind                       _damageDownAnimKind;                               // 0x0626(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyBrainCrashAnimKind                       _brainCrashAnimKind;                               // 0x0627(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyDeadAnimKind                             _deadAnimKind;                                     // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyInitLayoutAnimKind                       _initLayoutAnimKind;                               // 0x0629(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyEventAnimKind                            _eventAnimKind;                                    // 0x062A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyCrashChanceAnimKind                      _crashChanceAnimKind;                              // 0x062B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EnemyKind                                     _EnemyKind;                                        // 0x062C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2628[0x3];                                     // 0x062D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _walkSpeed;                                        // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bBackMove;                                        // 0x0634(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bExcite;                                          // 0x0635(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bLanded;                                          // 0x0636(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bDamageAnimStateB;                                // 0x0637(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bDamageAnimLight2;                                // 0x0638(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bRequestFaintWakeup;                              // 0x0639(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bAttackFlg;                                       // 0x063A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2629[0x1];                                     // 0x063B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _blendSpaceData;                                   // 0x063C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _animRigidBodyIdlingSec;                           // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _animDynamicsIdlingSec;                            // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEvent;                                           // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262A[0x3];                                     // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _addDamageBlendWeightDefault;                      // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _addDamageBlendWeightCurrent;                      // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262B[0x4];                                     // 0x065C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x0660(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          _bEnableLookAt;                                    // 0x0670(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bFinishLookAtRotateZero;                          // 0x0671(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bLookFront;                                       // 0x0672(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262C[0x1];                                     // 0x0673(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lrRotateLimit;                                    // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _upRotateLimit;                                    // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _downRotateLimit;                                  // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lookAtFollowSpeed;                                // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _lookAtLocation;                                   // 0x0684(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _lookAtRotation;                                   // 0x0690(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _bEnableIK;                                        // 0x069C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262D[0x3];                                     // 0x069D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _IKAlpha;                                          // 0x06A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _IKDstAlpha;                                       // 0x06A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _IKAlphaChangeRate;                                // 0x06A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262E[0x4];                                     // 0x06AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTinyIKInfo>                    _tinyIKArray;                                      // 0x06B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftFootIKBoneName;                                // 0x06C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightFootIKBoneName;                               // 0x06C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootIKBlendRate;                                   // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FootIKOffset_Left;                                 // 0x06D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FootIKOffset_Right;                                // 0x06E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FootIKJointTargetLocation_Left;                    // 0x06EC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FootIKJointTargetLocation_Right;                   // 0x06F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bEnableBrainCrashEvent;                           // 0x0704(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262F[0xB];                                     // 0x0705(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttackEnd(EnemyAttackAnimKind Attack);
	bool CheckGoToIdleMove(bool bEndAnim);
	void DisableBrainCrashEvent();
	void DisableEnemyIK();
	void EnableBrainCrashEvent();
	void EnableEnemyIK();
	void FinishLookAt(bool bRotateZero);
	void RecvOnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void ResetDefaultAddDamageBlendWeight();
	void SetAddDamageBlendWeight(float Value);
	void SetIKAlpha(float Value);
	void SetIKDstAlpha(float Value);
	void StartLookAt(bool bResetRotate);
	void UpdateSpineRotateNative(struct FRotator& SpineRot, bool& UpdateSpineRot, bool EnableSpineRot, class ARSCharacterBase* TargetCharacter, class ARSCharacterBase* Owner, float RotateUpDownMin, float RotateUpDownMax, float RotateLRMax, float DeltaSeconds, float RotateSpeed);

	float GetAddDamageBlendWeight() const;
	float GetIKAlpha() const;
	float GetIKDstAlpha() const;
	bool IsEnableBrainCrashEvent() const;
	bool IsEnableEnemyIK() const;
	bool IsEnableLookAt() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEnemyAnimInstance">();
	}
	static class URSEnemyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSEnemyAnimInstance>();
	}
};
static_assert(alignof(URSEnemyAnimInstance) == 0x000010, "Wrong alignment on URSEnemyAnimInstance");
static_assert(sizeof(URSEnemyAnimInstance) == 0x000710, "Wrong size on URSEnemyAnimInstance");
static_assert(offsetof(URSEnemyAnimInstance, _aliveAnimKind) == 0x000620, "Member 'URSEnemyAnimInstance::_aliveAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _MoveAnimKind) == 0x000621, "Member 'URSEnemyAnimInstance::_MoveAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _attackAnimKind) == 0x000622, "Member 'URSEnemyAnimInstance::_attackAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _actionAnimKind) == 0x000623, "Member 'URSEnemyAnimInstance::_actionAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _switchAnimKind) == 0x000624, "Member 'URSEnemyAnimInstance::_switchAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _damageAnimKind) == 0x000625, "Member 'URSEnemyAnimInstance::_damageAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _damageDownAnimKind) == 0x000626, "Member 'URSEnemyAnimInstance::_damageDownAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _brainCrashAnimKind) == 0x000627, "Member 'URSEnemyAnimInstance::_brainCrashAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _deadAnimKind) == 0x000628, "Member 'URSEnemyAnimInstance::_deadAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _initLayoutAnimKind) == 0x000629, "Member 'URSEnemyAnimInstance::_initLayoutAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _eventAnimKind) == 0x00062A, "Member 'URSEnemyAnimInstance::_eventAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _crashChanceAnimKind) == 0x00062B, "Member 'URSEnemyAnimInstance::_crashChanceAnimKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _EnemyKind) == 0x00062C, "Member 'URSEnemyAnimInstance::_EnemyKind' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _walkSpeed) == 0x000630, "Member 'URSEnemyAnimInstance::_walkSpeed' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bBackMove) == 0x000634, "Member 'URSEnemyAnimInstance::_bBackMove' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bExcite) == 0x000635, "Member 'URSEnemyAnimInstance::_bExcite' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bLanded) == 0x000636, "Member 'URSEnemyAnimInstance::_bLanded' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bDamageAnimStateB) == 0x000637, "Member 'URSEnemyAnimInstance::_bDamageAnimStateB' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bDamageAnimLight2) == 0x000638, "Member 'URSEnemyAnimInstance::_bDamageAnimLight2' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bRequestFaintWakeup) == 0x000639, "Member 'URSEnemyAnimInstance::_bRequestFaintWakeup' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bAttackFlg) == 0x00063A, "Member 'URSEnemyAnimInstance::_bAttackFlg' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _blendSpaceData) == 0x00063C, "Member 'URSEnemyAnimInstance::_blendSpaceData' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _animRigidBodyIdlingSec) == 0x000648, "Member 'URSEnemyAnimInstance::_animRigidBodyIdlingSec' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _animDynamicsIdlingSec) == 0x00064C, "Member 'URSEnemyAnimInstance::_animDynamicsIdlingSec' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bEvent) == 0x000650, "Member 'URSEnemyAnimInstance::_bEvent' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _addDamageBlendWeightDefault) == 0x000654, "Member 'URSEnemyAnimInstance::_addDamageBlendWeightDefault' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _addDamageBlendWeightCurrent) == 0x000658, "Member 'URSEnemyAnimInstance::_addDamageBlendWeightCurrent' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, DispatchMontageBlendingOut) == 0x000660, "Member 'URSEnemyAnimInstance::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bEnableLookAt) == 0x000670, "Member 'URSEnemyAnimInstance::_bEnableLookAt' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bFinishLookAtRotateZero) == 0x000671, "Member 'URSEnemyAnimInstance::_bFinishLookAtRotateZero' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bLookFront) == 0x000672, "Member 'URSEnemyAnimInstance::_bLookFront' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _lrRotateLimit) == 0x000674, "Member 'URSEnemyAnimInstance::_lrRotateLimit' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _upRotateLimit) == 0x000678, "Member 'URSEnemyAnimInstance::_upRotateLimit' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _downRotateLimit) == 0x00067C, "Member 'URSEnemyAnimInstance::_downRotateLimit' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _lookAtFollowSpeed) == 0x000680, "Member 'URSEnemyAnimInstance::_lookAtFollowSpeed' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _lookAtLocation) == 0x000684, "Member 'URSEnemyAnimInstance::_lookAtLocation' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _lookAtRotation) == 0x000690, "Member 'URSEnemyAnimInstance::_lookAtRotation' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bEnableIK) == 0x00069C, "Member 'URSEnemyAnimInstance::_bEnableIK' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _IKAlpha) == 0x0006A0, "Member 'URSEnemyAnimInstance::_IKAlpha' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _IKDstAlpha) == 0x0006A4, "Member 'URSEnemyAnimInstance::_IKDstAlpha' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _IKAlphaChangeRate) == 0x0006A8, "Member 'URSEnemyAnimInstance::_IKAlphaChangeRate' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _tinyIKArray) == 0x0006B0, "Member 'URSEnemyAnimInstance::_tinyIKArray' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, LeftFootIKBoneName) == 0x0006C0, "Member 'URSEnemyAnimInstance::LeftFootIKBoneName' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, RightFootIKBoneName) == 0x0006C8, "Member 'URSEnemyAnimInstance::RightFootIKBoneName' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKBlendRate) == 0x0006D0, "Member 'URSEnemyAnimInstance::FootIKBlendRate' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKOffset_Left) == 0x0006D4, "Member 'URSEnemyAnimInstance::FootIKOffset_Left' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKOffset_Right) == 0x0006E0, "Member 'URSEnemyAnimInstance::FootIKOffset_Right' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKJointTargetLocation_Left) == 0x0006EC, "Member 'URSEnemyAnimInstance::FootIKJointTargetLocation_Left' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, FootIKJointTargetLocation_Right) == 0x0006F8, "Member 'URSEnemyAnimInstance::FootIKJointTargetLocation_Right' has a wrong offset!");
static_assert(offsetof(URSEnemyAnimInstance, _bEnableBrainCrashEvent) == 0x000704, "Member 'URSEnemyAnimInstance::_bEnableBrainCrashEvent' has a wrong offset!");

// Class BattlePrototype.RSEnemyNavArea
// 0x0000 (0x00C8 - 0x00C8)
class URSEnemyNavArea final : public UNavAreaMeta_SwitchByAgent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEnemyNavArea">();
	}
	static class URSEnemyNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSEnemyNavArea>();
	}
};
static_assert(alignof(URSEnemyNavArea) == 0x000008, "Wrong alignment on URSEnemyNavArea");
static_assert(sizeof(URSEnemyNavArea) == 0x0000C8, "Wrong size on URSEnemyNavArea");

// Class BattlePrototype.RSEnemyNavModifierVolume
// 0x0000 (0x0278 - 0x0278)
class ARSEnemyNavModifierVolume final : public ANavModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSEnemyNavModifierVolume">();
	}
	static class ARSEnemyNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSEnemyNavModifierVolume>();
	}
};
static_assert(alignof(ARSEnemyNavModifierVolume) == 0x000008, "Wrong alignment on ARSEnemyNavModifierVolume");
static_assert(sizeof(ARSEnemyNavModifierVolume) == 0x000278, "Wrong size on ARSEnemyNavModifierVolume");

// Class BattlePrototype.RSFishSplineBase
// 0x0090 (0x02C0 - 0x0230)
class ARSFishSplineBase final : public AActor
{
public:
	TArray<class UStaticMeshComponent*>           FishMeshes;                                        // 0x0230(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       FishMaterials;                                     // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        Offset;                                            // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        OffsetStart;                                       // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        OffsetEnd;                                         // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 TailRandom;                                        // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 PositionRandom;                                    // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHalfUpdate;                                 // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2633[0x1F];                                    // 0x02A1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyParamBPtoCPP(int32 LoopsPerMinute, float TailSpeed, float FishScale, float RandomiseOffset, int32 NumberOfFish);
	void RandomiseOffsetsCPP();
	void UpdateFishCPP(float Position, int32 FishIndex);
	void UpdateOffsetCPP(float Lerp);
	void UpdatePositionLoopCPP(float Lerp, float Tail, bool bForceUpdateAll);

	class USplineComponent* GetSplineComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSFishSplineBase">();
	}
	static class ARSFishSplineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSFishSplineBase>();
	}
};
static_assert(alignof(ARSFishSplineBase) == 0x000008, "Wrong alignment on ARSFishSplineBase");
static_assert(sizeof(ARSFishSplineBase) == 0x0002C0, "Wrong size on ARSFishSplineBase");
static_assert(offsetof(ARSFishSplineBase, FishMeshes) == 0x000230, "Member 'ARSFishSplineBase::FishMeshes' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, FishMaterials) == 0x000240, "Member 'ARSFishSplineBase::FishMaterials' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, Offset) == 0x000250, "Member 'ARSFishSplineBase::Offset' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, OffsetStart) == 0x000260, "Member 'ARSFishSplineBase::OffsetStart' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, OffsetEnd) == 0x000270, "Member 'ARSFishSplineBase::OffsetEnd' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, TailRandom) == 0x000280, "Member 'ARSFishSplineBase::TailRandom' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, PositionRandom) == 0x000290, "Member 'ARSFishSplineBase::PositionRandom' has a wrong offset!");
static_assert(offsetof(ARSFishSplineBase, bEnableHalfUpdate) == 0x0002A0, "Member 'ARSFishSplineBase::bEnableHalfUpdate' has a wrong offset!");

// Class BattlePrototype.RSFrameGrabberActor
// 0x0008 (0x0238 - 0x0230)
class ARSFrameGrabberActor final : public AActor
{
public:
	class URSFrameGrabberComponent*               FrameGrabberComponent;                             // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSFrameGrabberActor">();
	}
	static class ARSFrameGrabberActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSFrameGrabberActor>();
	}
};
static_assert(alignof(ARSFrameGrabberActor) == 0x000008, "Wrong alignment on ARSFrameGrabberActor");
static_assert(sizeof(ARSFrameGrabberActor) == 0x000238, "Wrong size on ARSFrameGrabberActor");
static_assert(offsetof(ARSFrameGrabberActor, FrameGrabberComponent) == 0x000230, "Member 'ARSFrameGrabberActor::FrameGrabberComponent' has a wrong offset!");

// Class BattlePrototype.RSFrameGrabberComponent
// 0x0010 (0x00D0 - 0x00C0)
class URSFrameGrabberComponent final : public UActorComponent
{
public:
	class UTextureRenderTarget2D*                 TextureTarget;                                     // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2635[0x8];                                     // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndGrab();
	class UTextureRenderTarget2D* GetTextureTarget();
	void GrabFrame(EFrameGrabType Type);
	void SetTextureTarget(class UTextureRenderTarget2D* Target);
	void StartGrab(EFrameGrabType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSFrameGrabberComponent">();
	}
	static class URSFrameGrabberComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSFrameGrabberComponent>();
	}
};
static_assert(alignof(URSFrameGrabberComponent) == 0x000008, "Wrong alignment on URSFrameGrabberComponent");
static_assert(sizeof(URSFrameGrabberComponent) == 0x0000D0, "Wrong size on URSFrameGrabberComponent");
static_assert(offsetof(URSFrameGrabberComponent, TextureTarget) == 0x0000C0, "Member 'URSFrameGrabberComponent::TextureTarget' has a wrong offset!");

// Class BattlePrototype.RSAutomationPerformaceHelper
// 0x0038 (0x0060 - 0x0028)
class URSAutomationPerformaceHelper final : public UObject
{
public:
	uint8                                         Pad_2636[0x38];                                    // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginRecording(const class FString& RecordName, float InGPUBudget, float InRenderThreadBudget, float InGameThreadBudget);
	void BeginRecordingBaseline(const class FString& RecordName);
	void BeginStatsFile(const class FString& RecordName);
	void EndRecording();
	void EndRecordingBaseline();
	void EndStatsFile();
	void OnAllTestsComplete();
	void OnBeginTests();
	void Sample(float DeltaSeconds);
	void StartCPUProfiling();
	void StopCPUProfiling();
	void Tick(float DeltaSeconds);
	void TriggerGPUTraceIfRecordFallsBelowBudget();
	void WriteLogFile(const class FString& CaptureDir, const class FString& CaptureExtension);

	bool IsCurrentRecordWithinGameThreadBudget() const;
	bool IsCurrentRecordWithinGPUBudget() const;
	bool IsCurrentRecordWithinRenderThreadBudget() const;
	bool IsRecording() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSAutomationPerformaceHelper">();
	}
	static class URSAutomationPerformaceHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSAutomationPerformaceHelper>();
	}
};
static_assert(alignof(URSAutomationPerformaceHelper) == 0x000008, "Wrong alignment on URSAutomationPerformaceHelper");
static_assert(sizeof(URSAutomationPerformaceHelper) == 0x000060, "Wrong size on URSAutomationPerformaceHelper");

// Class BattlePrototype.RSGameAccountManager
// 0x0020 (0x0050 - 0x0030)
class URSGameAccountManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2638[0x20];                                    // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameAccountManager">();
	}
	static class URSGameAccountManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGameAccountManager>();
	}
};
static_assert(alignof(URSGameAccountManager) == 0x000008, "Wrong alignment on URSGameAccountManager");
static_assert(sizeof(URSGameAccountManager) == 0x000050, "Wrong size on URSGameAccountManager");

// Class BattlePrototype.RSGameInstance
// 0x0370 (0x0508 - 0x0198)
class URSGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_2639[0x38];                                    // 0x0198(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARSCharacterBase>           _mainPlayerClass;                                  // 0x01D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSCharacterBase>           _leftPlayerClass;                                  // 0x01D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSCharacterBase>           _rightPlayerClass;                                 // 0x01E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _hitManagerClass;                                  // 0x01E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABrainCrashManager>         _brainCrashManagerClass;                           // 0x01F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ASASManager>                _sasManagerClass;                                  // 0x01F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APsychicObjectManager>      _psychicObjectManagerClass;                        // 0x0200(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URSAccountManager>          _accountManagerClass;                              // 0x0208(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSSoundManager>            _soundManagerClass;                                // 0x0210(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSParticleSystemManager>   _particleManagerClass;                             // 0x0218(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABlendableVolumeManager>    _StageSettingVolumeManagerClass;                   // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AEnemyManager>              _enemyManagerClass;                                // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _postProcessManagerClass;                          // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _renderTargetManagerClass;                         // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _brainFieldManagerClass;                           // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _radialBlurManagerClass;                           // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _eventManagerClass;                                // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayerManager>             _playerManagerClass;                               // 0x0258(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _sceneManagerClass;                                // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _levelManagerClass;                                // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _resourceManagerClass;                             // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABattleManager>             _battleManagerClass;                               // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABattlefieldManager>        _battlefieldManagerClass;                          // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AStageManager>              _stageManagerClass;                                // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ARSMovieManager>            _movieManagerClass;                                // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AInputManager>              _inputManagerClass;                                // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABrainTalkManager>          _brainTalkManagerClass;                            // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AGameMainManager>           _GameMainManagerClass;                             // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _gameSystemManagerClass;                           // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _inGameFlowClass;                                  // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AMapGimmickManager>         _mapGimmickManagerClass;                           // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ALC21MapGimmickManager>     _lc21MapGimmickManagerClass;                       // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _cosmosWebManagerClass;                            // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _triggerEffectManagerClass;                        // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABattleSimulatorManager>    _battleSimulatorManagerClass;                      // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URSShareUtilityManager>     _shareUtilityManagerClass;                         // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _debuggingGameActivityManagerClass;                // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        _Managers;                                         // 0x02F8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263A[0x18];                                    // 0x0308(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _finishMoveActorManager;                           // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_ReloadLevelName;                                 // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isUsesSteam;                                     // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263B[0x7];                                     // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInfoAtRetry                           M_retryParam;                                      // 0x0338(0x0020)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_263C[0x50];                                    // 0x0358(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             M_PlBPClassList;                                   // 0x03A8(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _debuggingManagerClass;                            // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _OutgameDebuggingManagerClass;                     // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AModelViewerBase>           _ModelViewerClass;                                 // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     _phychicObjectBaseClass;                           // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URevisionData*                          _RevisionData;                                     // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isForceCrcCheckError;                            // 0x03E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263D[0x7];                                     // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CosmosBaseURLBody;                                 // 0x03E8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosGetBaseURL;                                // 0x03F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosTimeout;                                   // 0x03F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_263E[0x6];                                     // 0x03FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CosmosUserID;                                      // 0x0400(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CosmosSessionID;                                   // 0x0410(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCosmosSysKpiParam>             CosmosSysKpiParam;                                 // 0x0420(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosEnvInitialized;                            // 0x0430(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosAgreeKpi;                                  // 0x0431(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCosmosSendAgreeKpi;                              // 0x0432(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceType                              _inputDeviceType;                                  // 0x0433(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugTodayYear;                                    // 0x0434(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugTodayMonth;                                   // 0x0438(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugTodayDay;                                     // 0x043C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBattleSimulatorSaveParams>     BattleSimulatorSaveParamsList;                     // 0x0440(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BattleSimulatorRareEnemyAppearanceNum;             // 0x0450(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 BattleSimulatorRareEnemySubjugationNum;            // 0x0460(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BattleSimulatorLevelInfosName;                     // 0x0470(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BattleSimulatorSceneArgs;                          // 0x0480(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleSimulatorRowName;                            // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ELibraryFlagType>                      TwoShotCheckFlags;                                 // 0x0498(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ELibraryFlagType>                      TwoShotReplacementFlags;                           // 0x04A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_263F[0x8];                                     // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           GamePauseClaimantList;                             // 0x04C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2640[0x38];                                    // 0x04D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void PrintLogBlueprintCallstack();

	void CreateAllManagers();
	void CreateEnemyManager();
	void CreateGameManagers();
	void CreateModelViewerManagers();
	void CreateOutGameManagers();
	void CreateResidentManagers();
	void CreateResidentSystem();
	void CreateSystem();
	void CreateSystemGameManager();
	void DestroyAllManagers();
	void DestroyGameManagers();
	void DestroyModelViewerManagers();
	void DestroyOutGameManagers();
	void DestroyResidentManagers();
	void DestroyResidentSystem();
	void DestroySystem();
	void EndInitializeCallback(EManagerTypeID ID, EManagerProcTiming Timing);
	void FinalizeAllManagers(EManagerProcTiming Timing);
	void FinalizeManagers(EManagerProcTiming Timing);
	class AActionManager* GetActionManager();
	class UAddContentManager* GetAddContentManager();
	class UAnimeInterlockingManager* GetAnimeInterlockingManager();
	class UDatabaseManager* GetDatabaseManager();
	class ADebuggingGameActivityManager* GetDebuggingGameActivityManager();
	class AIntroTutorialManager* GetIntroTutorialManager();
	class AStageManager* GetStageManager();
	bool InitializeAllManagers(EManagerProcTiming Timing);
	void InitializeAllManagersForPersistentLevel();
	void InitializeManagers(EManagerProcTiming Timing);
	bool IsForceCrcCheckError();
	bool IsReadyManagers();
	void LoadLevel(const class FName LevelName);
	void OnLoadLevelCompleteUnloadLevel(const class UObject* WorldContext);
	void ReloadLevel();
	void ResetIntroTutorialManager();
	void ResetRenderTarget();
	void SetGamePausedRS(bool bPaused, class FName ClaimantName, bool bPauseInputManager);
	void SetIntroTutorialManager(class AIntroTutorialManager* PManager);
	void SetIsForceCrcCheckError(const bool Flag);
	void SetIsUsesSteam(const bool Flag);
	void SetParticlePhotoMode(const bool Flag);
	void SetPhotoModeStartCameraPositionAxis(const struct FVector& CameraPos, const struct FVector& CameraUp, const struct FVector& CameraRight, const struct FRotator& CameraRot);
	void SetPPDistortion(bool Enable);
	void StartGameFlow();

	class UAchievementManager* GetAchievementManager() const;
	class UActivityManager* GetActivityManager() const;
	class UAddContentManager* GetAddContentManagerConst() const;
	class UAnimeInterlockingManager* GetAnimeInterlockingManagerConst() const;
	class AArrangeItemManager* GetArrangeItemManager() const;
	class ABattlefieldManager* GetBattlefieldManager() const;
	class ABattleManager* GetBattleManager() const;
	class ABattleSimulatorManager* GetBattleSimulatorManager() const;
	class ABrainCrashManager* GetBrainCrashManager() const;
	class AActor* GetBrainFieldManager() const;
	class ABrainTalkManager* GetBrainTalkManager() const;
	class UCalcMemoryManager* GetCalcMemoryManager() const;
	class UClearGetterManager* GetClearGetterManager() const;
	class AActor* GetCosmosWebManager() const;
	class UDatabaseManager* GetDatabaseManagerConst() const;
	class AActor* GetDebuggingManager() const;
	class ADropItemManager* GetDropItemManager() const;
	class AEnemyManager* GetEnemyManager() const;
	class AActor* GetEventManager() const;
	class AActor* GetFinishMoveActorManager() const;
	class UFlagManager* GetFlagManager() const;
	class AGameMainManager* GetGameMainManager() const;
	class AActor* GetGameSystemManager() const;
	class AActor* GetHitManager() const;
	class AActor* GetInputManager() const;
	class ALC21MapGimmickManager* GetLC21MapGimmickManager() const;
	class AActor* GetLevelManager() const;
	class AMapGimmickManager* GetMapGimmickManager() const;
	class AMessageHudManager* GetMessageHudManager() const;
	class AModelViewerBase* GetModelViewerBase() const;
	class AActor* GetMovieManager() const;
	class AActor* GetOutgameDebuggingManager() const;
	class ARSParallelObjectManager* GetParallelObjectManager() const;
	class ARSParticleSystemManager* GetParticleManager() const;
	class APlayerManager* GetPlayerManager() const;
	class AActor* GetPostProcessManager() const;
	class APsychicObjectManager* GetPsychicObjectManager() const;
	class AActor* GetRadialBlurManager() const;
	class AActor* GetRenderTargetManager() const;
	class AActor* GetResourceManager() const;
	class URevisionData* GetRevisionData() const;
	class URSAccountManager* GetRSAccountManager() const;
	class ARSInGameFlow* GetRSInGameFlow() const;
	class ASASManager* GetSASManager() const;
	class USaveLoadParamClassManager* GetSaveLoadParamClassManager() const;
	class AActor* GetSceneManager() const;
	class URSShareUtilityManager* GetShareUtilityManager() const;
	class ARSSoundManager* GetSoundManager() const;
	class AStageManager* GetStageManagerConst() const;
	class ABlendableVolumeManager* GetStageSettingVolumeManager() const;
	class ATriggerEffectManager* GetTriggerEffectManager() const;
	class ATwoShotParamManager* GetTwoShotParamManager() const;
	class UUserParamManager* GetUserParamManager() const;
	class UXGameStreamingManager* GetXGameStreamingManager() const;
	bool IsCreatedGameManagers() const;
	bool IsCreatedManagers() const;
	bool IsCreatedResidentManagers() const;
	bool IsCreatedResidentSystem() const;
	bool IsCreatedSystem() const;
	bool IsUsesSteam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameInstance">();
	}
	static class URSGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGameInstance>();
	}
};
static_assert(alignof(URSGameInstance) == 0x000008, "Wrong alignment on URSGameInstance");
static_assert(sizeof(URSGameInstance) == 0x000508, "Wrong size on URSGameInstance");
static_assert(offsetof(URSGameInstance, _mainPlayerClass) == 0x0001D0, "Member 'URSGameInstance::_mainPlayerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _leftPlayerClass) == 0x0001D8, "Member 'URSGameInstance::_leftPlayerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _rightPlayerClass) == 0x0001E0, "Member 'URSGameInstance::_rightPlayerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _hitManagerClass) == 0x0001E8, "Member 'URSGameInstance::_hitManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _brainCrashManagerClass) == 0x0001F0, "Member 'URSGameInstance::_brainCrashManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _sasManagerClass) == 0x0001F8, "Member 'URSGameInstance::_sasManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _psychicObjectManagerClass) == 0x000200, "Member 'URSGameInstance::_psychicObjectManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _accountManagerClass) == 0x000208, "Member 'URSGameInstance::_accountManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _soundManagerClass) == 0x000210, "Member 'URSGameInstance::_soundManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _particleManagerClass) == 0x000218, "Member 'URSGameInstance::_particleManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _StageSettingVolumeManagerClass) == 0x000220, "Member 'URSGameInstance::_StageSettingVolumeManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _enemyManagerClass) == 0x000228, "Member 'URSGameInstance::_enemyManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _postProcessManagerClass) == 0x000230, "Member 'URSGameInstance::_postProcessManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _renderTargetManagerClass) == 0x000238, "Member 'URSGameInstance::_renderTargetManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _brainFieldManagerClass) == 0x000240, "Member 'URSGameInstance::_brainFieldManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _radialBlurManagerClass) == 0x000248, "Member 'URSGameInstance::_radialBlurManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _eventManagerClass) == 0x000250, "Member 'URSGameInstance::_eventManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _playerManagerClass) == 0x000258, "Member 'URSGameInstance::_playerManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _sceneManagerClass) == 0x000260, "Member 'URSGameInstance::_sceneManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _levelManagerClass) == 0x000268, "Member 'URSGameInstance::_levelManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _resourceManagerClass) == 0x000270, "Member 'URSGameInstance::_resourceManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _battleManagerClass) == 0x000278, "Member 'URSGameInstance::_battleManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _battlefieldManagerClass) == 0x000280, "Member 'URSGameInstance::_battlefieldManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _stageManagerClass) == 0x000288, "Member 'URSGameInstance::_stageManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _movieManagerClass) == 0x000290, "Member 'URSGameInstance::_movieManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _inputManagerClass) == 0x000298, "Member 'URSGameInstance::_inputManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _brainTalkManagerClass) == 0x0002A0, "Member 'URSGameInstance::_brainTalkManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _GameMainManagerClass) == 0x0002A8, "Member 'URSGameInstance::_GameMainManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _gameSystemManagerClass) == 0x0002B0, "Member 'URSGameInstance::_gameSystemManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _inGameFlowClass) == 0x0002B8, "Member 'URSGameInstance::_inGameFlowClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _mapGimmickManagerClass) == 0x0002C0, "Member 'URSGameInstance::_mapGimmickManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _lc21MapGimmickManagerClass) == 0x0002C8, "Member 'URSGameInstance::_lc21MapGimmickManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _cosmosWebManagerClass) == 0x0002D0, "Member 'URSGameInstance::_cosmosWebManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _triggerEffectManagerClass) == 0x0002D8, "Member 'URSGameInstance::_triggerEffectManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _battleSimulatorManagerClass) == 0x0002E0, "Member 'URSGameInstance::_battleSimulatorManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _shareUtilityManagerClass) == 0x0002E8, "Member 'URSGameInstance::_shareUtilityManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _debuggingGameActivityManagerClass) == 0x0002F0, "Member 'URSGameInstance::_debuggingGameActivityManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _Managers) == 0x0002F8, "Member 'URSGameInstance::_Managers' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _finishMoveActorManager) == 0x000320, "Member 'URSGameInstance::_finishMoveActorManager' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_ReloadLevelName) == 0x000328, "Member 'URSGameInstance::M_ReloadLevelName' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_isUsesSteam) == 0x000330, "Member 'URSGameInstance::M_isUsesSteam' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_retryParam) == 0x000338, "Member 'URSGameInstance::M_retryParam' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_PlBPClassList) == 0x0003A8, "Member 'URSGameInstance::M_PlBPClassList' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _debuggingManagerClass) == 0x0003B8, "Member 'URSGameInstance::_debuggingManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _OutgameDebuggingManagerClass) == 0x0003C0, "Member 'URSGameInstance::_OutgameDebuggingManagerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _ModelViewerClass) == 0x0003C8, "Member 'URSGameInstance::_ModelViewerClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _phychicObjectBaseClass) == 0x0003D0, "Member 'URSGameInstance::_phychicObjectBaseClass' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _RevisionData) == 0x0003D8, "Member 'URSGameInstance::_RevisionData' has a wrong offset!");
static_assert(offsetof(URSGameInstance, M_isForceCrcCheckError) == 0x0003E0, "Member 'URSGameInstance::M_isForceCrcCheckError' has a wrong offset!");
static_assert(offsetof(URSGameInstance, CosmosBaseURLBody) == 0x0003E8, "Member 'URSGameInstance::CosmosBaseURLBody' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosGetBaseURL) == 0x0003F8, "Member 'URSGameInstance::IsCosmosGetBaseURL' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosTimeout) == 0x0003F9, "Member 'URSGameInstance::IsCosmosTimeout' has a wrong offset!");
static_assert(offsetof(URSGameInstance, CosmosUserID) == 0x000400, "Member 'URSGameInstance::CosmosUserID' has a wrong offset!");
static_assert(offsetof(URSGameInstance, CosmosSessionID) == 0x000410, "Member 'URSGameInstance::CosmosSessionID' has a wrong offset!");
static_assert(offsetof(URSGameInstance, CosmosSysKpiParam) == 0x000420, "Member 'URSGameInstance::CosmosSysKpiParam' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosEnvInitialized) == 0x000430, "Member 'URSGameInstance::IsCosmosEnvInitialized' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosAgreeKpi) == 0x000431, "Member 'URSGameInstance::IsCosmosAgreeKpi' has a wrong offset!");
static_assert(offsetof(URSGameInstance, IsCosmosSendAgreeKpi) == 0x000432, "Member 'URSGameInstance::IsCosmosSendAgreeKpi' has a wrong offset!");
static_assert(offsetof(URSGameInstance, _inputDeviceType) == 0x000433, "Member 'URSGameInstance::_inputDeviceType' has a wrong offset!");
static_assert(offsetof(URSGameInstance, DebugTodayYear) == 0x000434, "Member 'URSGameInstance::DebugTodayYear' has a wrong offset!");
static_assert(offsetof(URSGameInstance, DebugTodayMonth) == 0x000438, "Member 'URSGameInstance::DebugTodayMonth' has a wrong offset!");
static_assert(offsetof(URSGameInstance, DebugTodayDay) == 0x00043C, "Member 'URSGameInstance::DebugTodayDay' has a wrong offset!");
static_assert(offsetof(URSGameInstance, BattleSimulatorSaveParamsList) == 0x000440, "Member 'URSGameInstance::BattleSimulatorSaveParamsList' has a wrong offset!");
static_assert(offsetof(URSGameInstance, BattleSimulatorRareEnemyAppearanceNum) == 0x000450, "Member 'URSGameInstance::BattleSimulatorRareEnemyAppearanceNum' has a wrong offset!");
static_assert(offsetof(URSGameInstance, BattleSimulatorRareEnemySubjugationNum) == 0x000460, "Member 'URSGameInstance::BattleSimulatorRareEnemySubjugationNum' has a wrong offset!");
static_assert(offsetof(URSGameInstance, BattleSimulatorLevelInfosName) == 0x000470, "Member 'URSGameInstance::BattleSimulatorLevelInfosName' has a wrong offset!");
static_assert(offsetof(URSGameInstance, BattleSimulatorSceneArgs) == 0x000480, "Member 'URSGameInstance::BattleSimulatorSceneArgs' has a wrong offset!");
static_assert(offsetof(URSGameInstance, BattleSimulatorRowName) == 0x000490, "Member 'URSGameInstance::BattleSimulatorRowName' has a wrong offset!");
static_assert(offsetof(URSGameInstance, TwoShotCheckFlags) == 0x000498, "Member 'URSGameInstance::TwoShotCheckFlags' has a wrong offset!");
static_assert(offsetof(URSGameInstance, TwoShotReplacementFlags) == 0x0004A8, "Member 'URSGameInstance::TwoShotReplacementFlags' has a wrong offset!");
static_assert(offsetof(URSGameInstance, GamePauseClaimantList) == 0x0004C0, "Member 'URSGameInstance::GamePauseClaimantList' has a wrong offset!");

// Class BattlePrototype.RSGameModeBase
// 0x0010 (0x0328 - 0x0318)
class ARSGameModeBase : public AGameMode
{
public:
	uint8                                         Pad_2643[0x10];                                    // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void LogFlowCheck(const class FString& LogString);
	static void LogFlowCheck_IsValid(bool IsValid, const class FString& ValidString, const class FString& InvalidString);

	class AActor* FindPlayerStartByName(const class FString& TagName);
	bool IsDevelopment();
	bool IsGameFlowLevel(const class UObject* WorldContextObject);
	void OnPostInitGame(const class FString& CurrentLevelName);
	void OnPreStartPlay(const class FString& CurrentLevelName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameModeBase">();
	}
	static class ARSGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSGameModeBase>();
	}
};
static_assert(alignof(ARSGameModeBase) == 0x000008, "Wrong alignment on ARSGameModeBase");
static_assert(sizeof(ARSGameModeBase) == 0x000328, "Wrong size on ARSGameModeBase");

// Class BattlePrototype.RSGameMode
// 0x0010 (0x0338 - 0x0328)
class ARSGameMode : public ARSGameModeBase
{
public:
	uint8                                         Pad_2646[0x10];                                    // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTimerReleaseLoadingScreen();
	void OnTimerReleaseLoadingScreen2();
	void StopLoadingScreenSlate2();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameMode">();
	}
	static class ARSGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSGameMode>();
	}
};
static_assert(alignof(ARSGameMode) == 0x000008, "Wrong alignment on ARSGameMode");
static_assert(sizeof(ARSGameMode) == 0x000338, "Wrong size on ARSGameMode");

// Class BattlePrototype.RSGamepadEvent
// 0x0020 (0x0048 - 0x0028)
class URSGamepadEvent final : public UObject
{
public:
	uint8                                         Pad_2647[0x2];                                     // 0x0028(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RawOn;                                             // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOn;                                              // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnTrigger;                                       // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnRepTrigger;                                    // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOffTrigger;                                      // 0x002E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2648[0x1];                                     // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisValue;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AxisMouseWheelValue;                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatSec;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstRepeatSec;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2649[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGamepadEvent">();
	}
	static class URSGamepadEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGamepadEvent>();
	}
};
static_assert(alignof(URSGamepadEvent) == 0x000008, "Wrong alignment on URSGamepadEvent");
static_assert(sizeof(URSGamepadEvent) == 0x000048, "Wrong size on URSGamepadEvent");
static_assert(offsetof(URSGamepadEvent, RawOn) == 0x00002A, "Member 'URSGamepadEvent::RawOn' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, IsOn) == 0x00002B, "Member 'URSGamepadEvent::IsOn' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, IsOnTrigger) == 0x00002C, "Member 'URSGamepadEvent::IsOnTrigger' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, IsOnRepTrigger) == 0x00002D, "Member 'URSGamepadEvent::IsOnRepTrigger' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, IsOffTrigger) == 0x00002E, "Member 'URSGamepadEvent::IsOffTrigger' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, AxisValue) == 0x000030, "Member 'URSGamepadEvent::AxisValue' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, AxisMouseWheelValue) == 0x000034, "Member 'URSGamepadEvent::AxisMouseWheelValue' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, Timer) == 0x000038, "Member 'URSGamepadEvent::Timer' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, RepeatSec) == 0x00003C, "Member 'URSGamepadEvent::RepeatSec' has a wrong offset!");
static_assert(offsetof(URSGamepadEvent, FirstRepeatSec) == 0x000040, "Member 'URSGamepadEvent::FirstRepeatSec' has a wrong offset!");

// Class BattlePrototype.RSGamepadLayout
// 0x2250 (0x2278 - 0x0028)
class URSGamepadLayout final : public UObject
{
public:
	ERSGamepadLayoutType                          Layout;                                            // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264A[0x57];                                    // 0x0029(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Enabled;                                           // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264B[0xD57];                                   // 0x0081(0x0D57)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             UEOnPushR1Event;                                   // 0x0DD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushR2Event;                                   // 0x0DE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushR3Event;                                   // 0x0DF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushL1Event;                                   // 0x0E08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushL2Event;                                   // 0x0E18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushL3Event;                                   // 0x0E28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushRUPEvent;                                  // 0x0E38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushRDOWNEvent;                                // 0x0E48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushRLEFTEvent;                                // 0x0E58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushRRIGHTEvent;                               // 0x0E68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPAD_UPEvent;                              // 0x0E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPAD_DOWNEvent;                            // 0x0E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPAD_LEFTEvent;                            // 0x0E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPAD_RIGHTEvent;                           // 0x0EA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPADEMU_UPEvent;                           // 0x0EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPADEMU_DOWNEvent;                         // 0x0EC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPADEMU_LEFTEvent;                         // 0x0ED8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDPADEMU_RIGHTEvent;                        // 0x0EE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSELECTEvent;                               // 0x0EF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSTARTEvent;                                // 0x0F08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushDECIDEEvent;                               // 0x0F18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCANCELEvent;                               // 0x0F28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSELEFTEvent;                            // 0x0F38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSERIGHTEvent;                           // 0x0F48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSEMIDDLEEvent;                          // 0x0F58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSEWHEELUPEvent;                         // 0x0F68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOUSEWHEELDOWNEvent;                       // 0x0F78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOVE_FORWARDEvent;                         // 0x0F88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOVE_BACKWARDEvent;                        // 0x0F98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOVE_LEFTEvent;                            // 0x0FA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushMOVE_RIGHTEvent;                           // 0x0FB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushACTIONEvent;                               // 0x0FC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSTEP_DASHEvent;                            // 0x0FD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushWEAPON_ATTACKEvent;                        // 0x0FE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushWEAPON_ATTACK_SUBEvent;                    // 0x0FF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushJUMPEvent;                                 // 0x1008(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushPSYCHICEvent;                              // 0x1018(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushPSYCHIC_SPECIALEvent;                      // 0x1028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushBRAINFIELDEvent;                           // 0x1038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushPSYCHICFIELDEvent;                         // 0x1048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCAMERA_RESETEvent;                         // 0x1058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushLOCK_ONEvent;                              // 0x1068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushLOCK_ON_SWITCH_LEvent;                     // 0x1078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushLOCK_ON_SWITCH_REvent;                     // 0x1088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushASSAULT_VISIONEvent;                       // 0x1098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSASMENU_PAGESWITCHEvent;                   // 0x10A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSASMENU_OPENCLOSEEvent;                    // 0x10B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSAS_ACTION_UEvent;                         // 0x10C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSAS_ACTION_DEvent;                         // 0x10D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSAS_ACTION_LEvent;                         // 0x10E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSAS_ACTION_REvent;                         // 0x10F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushSTOP_SASEvent;                             // 0x1108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCVMENU_OPENCLOSEEvent;                     // 0x1118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCV_ACTION_UEvent;                          // 0x1128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCV_ACTION_DEvent;                          // 0x1138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCV_ACTION_LEvent;                          // 0x1148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushCV_ACTION_REvent;                          // 0x1158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushITEM_SELECT_LEvent;                        // 0x1168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushITEM_SELECT_REvent;                        // 0x1178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushITEM_USEEvent;                             // 0x1188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushOPEN_MENUEvent;                            // 0x1198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushOPEN_DETAILMAPEvent;                       // 0x11A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushOPEN_WORLDMAPEvent;                        // 0x11B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushACTION2Event;                              // 0x11C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushOPEN_BRAIN_MESSAGEEvent;                   // 0x11D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnPushOPEN_PHOTOMODEEvent;                       // 0x11E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseR1Event;                                // 0x11F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseR2Event;                                // 0x1208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseR3Event;                                // 0x1218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseL1Event;                                // 0x1228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseL2Event;                                // 0x1238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseL3Event;                                // 0x1248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseRUPEvent;                               // 0x1258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseRDOWNEvent;                             // 0x1268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseRLEFTEvent;                             // 0x1278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseRRIGHTEvent;                            // 0x1288(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPAD_UPEvent;                           // 0x1298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPAD_DOWNEvent;                         // 0x12A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPAD_LEFTEvent;                         // 0x12B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPAD_RIGHTEvent;                        // 0x12C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPADEMU_UPEvent;                        // 0x12D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPADEMU_DOWNEvent;                      // 0x12E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPADEMU_LEFTEvent;                      // 0x12F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDPADEMU_RIGHTEvent;                     // 0x1308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSELECTEvent;                            // 0x1318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSTARTEvent;                             // 0x1328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseDECIDEEvent;                            // 0x1338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCANCELEvent;                            // 0x1348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSELEFTEvent;                         // 0x1358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSERIGHTEvent;                        // 0x1368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSEMIDDLEEvent;                       // 0x1378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSEWHEELUPEvent;                      // 0x1388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOUSEWHEELDOWNEvent;                    // 0x1398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOVE_FORWARDEvent;                      // 0x13A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOVE_BACKWARDEvent;                     // 0x13B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOVE_LEFTEvent;                         // 0x13C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseMOVE_RIGHTEvent;                        // 0x13D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseACTIONEvent;                            // 0x13E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSTEP_DASHEvent;                         // 0x13F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseWEAPON_ATTACKEvent;                     // 0x1408(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseWEAPON_ATTACK_SUBEvent;                 // 0x1418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseJUMPEvent;                              // 0x1428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleasePSYCHICEvent;                           // 0x1438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleasePSYCHIC_SPECIALEvent;                   // 0x1448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseBRAINFIELDEvent;                        // 0x1458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleasePSYCHICFIELDEvent;                      // 0x1468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCAMERA_RESETEvent;                      // 0x1478(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseLOCK_ONEvent;                           // 0x1488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseLOCK_ON_SWITCH_LEvent;                  // 0x1498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseLOCK_ON_SWITCH_REvent;                  // 0x14A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseASSAULT_VISIONEvent;                    // 0x14B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSASMENU_PAGESWITCHEvent;                // 0x14C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSASMENU_OPENCLOSEEvent;                 // 0x14D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSAS_ACTION_UEvent;                      // 0x14E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSAS_ACTION_DEvent;                      // 0x14F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSAS_ACTION_LEvent;                      // 0x1508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSAS_ACTION_REvent;                      // 0x1518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseSTOP_SASEvent;                          // 0x1528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCVMENU_OPENCLOSEEvent;                  // 0x1538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCV_ACTION_UEvent;                       // 0x1548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCV_ACTION_DEvent;                       // 0x1558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCV_ACTION_LEvent;                       // 0x1568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseCV_ACTION_REvent;                       // 0x1578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseITEM_SELECT_LEvent;                     // 0x1588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseITEM_SELECT_REvent;                     // 0x1598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseITEM_USEEvent;                          // 0x15A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseOPEN_MENUEvent;                         // 0x15B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseOPEN_DETAILMAPEvent;                    // 0x15C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseOPEN_WORLDMAPEvent;                     // 0x15D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseACTION2Event;                           // 0x15E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseOPEN_BRAIN_MESSAGEEvent;                // 0x15F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UEOnReleaseOPEN_PHOTOMODEEvent;                    // 0x1608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressR1Event;                                    // 0x1618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressR2Event;                                    // 0x1628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressR3Event;                                    // 0x1638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressL1Event;                                    // 0x1648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressL2Event;                                    // 0x1658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressL3Event;                                    // 0x1668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressRUPEvent;                                   // 0x1678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressRDOWNEvent;                                 // 0x1688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressRLEFTEvent;                                 // 0x1698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressRRIGHTEvent;                                // 0x16A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPAD_UPEvent;                               // 0x16B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPAD_DOWNEvent;                             // 0x16C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPAD_LEFTEvent;                             // 0x16D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPAD_RIGHTEvent;                            // 0x16E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPADEMU_UPEvent;                            // 0x16F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPADEMU_DOWNEvent;                          // 0x1708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPADEMU_LEFTEvent;                          // 0x1718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDPADEMU_RIGHTEvent;                         // 0x1728(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSELECTEvent;                                // 0x1738(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSTARTEvent;                                 // 0x1748(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressDECIDEEvent;                                // 0x1758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCANCELEvent;                                // 0x1768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSELEFTEvent;                             // 0x1778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSERIGHTEvent;                            // 0x1788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSEMIDDLEEvent;                           // 0x1798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSEWHEELUPEvent;                          // 0x17A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOUSEWHEELDOWNEvent;                        // 0x17B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOVE_FORWARDEvent;                          // 0x17C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOVE_BACKWARDEvent;                         // 0x17D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOVE_LEFTEvent;                             // 0x17E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressMOVE_RIGHTEvent;                            // 0x17F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressACTIONEvent;                                // 0x1808(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSTEP_DASHEvent;                             // 0x1818(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressWEAPON_ATTACKEvent;                         // 0x1828(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressWEAPON_ATTACK_SUBEvent;                     // 0x1838(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressJUMPEvent;                                  // 0x1848(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressPSYCHICEvent;                               // 0x1858(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressPSYCHIC_SPECIALEvent;                       // 0x1868(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressBRAINFIELDEvent;                            // 0x1878(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressPSYCHICFIELDEvent;                          // 0x1888(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCAMERA_RESETEvent;                          // 0x1898(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressLOCK_ONEvent;                               // 0x18A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressLOCK_ON_SWITCH_LEvent;                      // 0x18B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressLOCK_ON_SWITCH_REvent;                      // 0x18C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressASSAULT_VISIONEvent;                        // 0x18D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSASMENU_PAGESWITCHEvent;                    // 0x18E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSASMENU_OPENCLOSEEvent;                     // 0x18F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSAS_ACTION_UEvent;                          // 0x1908(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSAS_ACTION_DEvent;                          // 0x1918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSAS_ACTION_LEvent;                          // 0x1928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSAS_ACTION_REvent;                          // 0x1938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressSTOP_SASEvent;                              // 0x1948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCVMENU_OPENCLOSEEvent;                      // 0x1958(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCV_ACTION_UEvent;                           // 0x1968(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCV_ACTION_DEvent;                           // 0x1978(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCV_ACTION_LEvent;                           // 0x1988(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressCV_ACTION_REvent;                           // 0x1998(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressITEM_SELECT_LEvent;                         // 0x19A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressITEM_SELECT_REvent;                         // 0x19B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressITEM_USEEvent;                              // 0x19C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressOPEN_MENUEvent;                             // 0x19D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressOPEN_DETAILMAPEvent;                        // 0x19E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressOPEN_WORLDMAPEvent;                         // 0x19F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressACTION2Event;                               // 0x1A08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressOPEN_BRAIN_MESSAGEEvent;                    // 0x1A18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressOPEN_PHOTOMODEEvent;                        // 0x1A28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerR1Event;                                  // 0x1A38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerR2Event;                                  // 0x1A48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerR3Event;                                  // 0x1A58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerL1Event;                                  // 0x1A68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerL2Event;                                  // 0x1A78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerL3Event;                                  // 0x1A88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerRUPEvent;                                 // 0x1A98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerRDOWNEvent;                               // 0x1AA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerRLEFTEvent;                               // 0x1AB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerRRIGHTEvent;                              // 0x1AC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPAD_UPEvent;                             // 0x1AD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPAD_DOWNEvent;                           // 0x1AE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPAD_LEFTEvent;                           // 0x1AF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPAD_RIGHTEvent;                          // 0x1B08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPADEMU_UPEvent;                          // 0x1B18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPADEMU_DOWNEvent;                        // 0x1B28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPADEMU_LEFTEvent;                        // 0x1B38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDPADEMU_RIGHTEvent;                       // 0x1B48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSELECTEvent;                              // 0x1B58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSTARTEvent;                               // 0x1B68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerDECIDEEvent;                              // 0x1B78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCANCELEvent;                              // 0x1B88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSELEFTEvent;                           // 0x1B98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSERIGHTEvent;                          // 0x1BA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSEMIDDLEEvent;                         // 0x1BB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSEWHEELUPEvent;                        // 0x1BC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOUSEWHEELDOWNEvent;                      // 0x1BD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOVE_FORWARDEvent;                        // 0x1BE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOVE_BACKWARDEvent;                       // 0x1BF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOVE_LEFTEvent;                           // 0x1C08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerMOVE_RIGHTEvent;                          // 0x1C18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerACTIONEvent;                              // 0x1C28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSTEP_DASHEvent;                           // 0x1C38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerWEAPON_ATTACKEvent;                       // 0x1C48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerWEAPON_ATTACK_SUBEvent;                   // 0x1C58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerJUMPEvent;                                // 0x1C68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerPSYCHICEvent;                             // 0x1C78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerPSYCHIC_SPECIALEvent;                     // 0x1C88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerBRAINFIELDEvent;                          // 0x1C98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerPSYCHICFIELDEvent;                        // 0x1CA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCAMERA_RESETEvent;                        // 0x1CB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerLOCK_ONEvent;                             // 0x1CC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerLOCK_ON_SWITCH_LEvent;                    // 0x1CD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerLOCK_ON_SWITCH_REvent;                    // 0x1CE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerASSAULT_VISIONEvent;                      // 0x1CF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSASMENU_PAGESWITCHEvent;                  // 0x1D08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSASMENU_OPENCLOSEEvent;                   // 0x1D18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSAS_ACTION_UEvent;                        // 0x1D28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSAS_ACTION_DEvent;                        // 0x1D38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSAS_ACTION_LEvent;                        // 0x1D48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSAS_ACTION_REvent;                        // 0x1D58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerSTOP_SASEvent;                            // 0x1D68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCVMENU_OPENCLOSEEvent;                    // 0x1D78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCV_ACTION_UEvent;                         // 0x1D88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCV_ACTION_DEvent;                         // 0x1D98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCV_ACTION_LEvent;                         // 0x1DA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerCV_ACTION_REvent;                         // 0x1DB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerITEM_SELECT_LEvent;                       // 0x1DC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerITEM_SELECT_REvent;                       // 0x1DD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerITEM_USEEvent;                            // 0x1DE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerOPEN_MENUEvent;                           // 0x1DF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerOPEN_DETAILMAPEvent;                      // 0x1E08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerOPEN_WORLDMAPEvent;                       // 0x1E18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerACTION2Event;                             // 0x1E28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerOPEN_BRAIN_MESSAGEEvent;                  // 0x1E38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerOPEN_PHOTOMODEEvent;                      // 0x1E48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerR1Event;                               // 0x1E58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerR2Event;                               // 0x1E68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerR3Event;                               // 0x1E78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerL1Event;                               // 0x1E88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerL2Event;                               // 0x1E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerL3Event;                               // 0x1EA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerRUPEvent;                              // 0x1EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerRDOWNEvent;                            // 0x1EC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerRLEFTEvent;                            // 0x1ED8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerRRIGHTEvent;                           // 0x1EE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPAD_UPEvent;                          // 0x1EF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPAD_DOWNEvent;                        // 0x1F08(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPAD_LEFTEvent;                        // 0x1F18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPAD_RIGHTEvent;                       // 0x1F28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPADEMU_UPEvent;                       // 0x1F38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPADEMU_DOWNEvent;                     // 0x1F48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPADEMU_LEFTEvent;                     // 0x1F58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDPADEMU_RIGHTEvent;                    // 0x1F68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSELECTEvent;                           // 0x1F78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSTARTEvent;                            // 0x1F88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerDECIDEEvent;                           // 0x1F98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCANCELEvent;                           // 0x1FA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSELEFTEvent;                        // 0x1FB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSERIGHTEvent;                       // 0x1FC8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSEMIDDLEEvent;                      // 0x1FD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSEWHEELUPEvent;                     // 0x1FE8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOUSEWHEELDOWNEvent;                   // 0x1FF8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOVE_FORWARDEvent;                     // 0x2008(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOVE_BACKWARDEvent;                    // 0x2018(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOVE_LEFTEvent;                        // 0x2028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerMOVE_RIGHTEvent;                       // 0x2038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerACTIONEvent;                           // 0x2048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSTEP_DASHEvent;                        // 0x2058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerWEAPON_ATTACKEvent;                    // 0x2068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerWEAPON_ATTACK_SUBEvent;                // 0x2078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerJUMPEvent;                             // 0x2088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerPSYCHICEvent;                          // 0x2098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerPSYCHIC_SPECIALEvent;                  // 0x20A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerBRAINFIELDEvent;                       // 0x20B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerPSYCHICFIELDEvent;                     // 0x20C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCAMERA_RESETEvent;                     // 0x20D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerLOCK_ONEvent;                          // 0x20E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerLOCK_ON_SWITCH_LEvent;                 // 0x20F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerLOCK_ON_SWITCH_REvent;                 // 0x2108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerASSAULT_VISIONEvent;                   // 0x2118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSASMENU_PAGESWITCHEvent;               // 0x2128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSASMENU_OPENCLOSEEvent;                // 0x2138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSAS_ACTION_UEvent;                     // 0x2148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSAS_ACTION_DEvent;                     // 0x2158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSAS_ACTION_LEvent;                     // 0x2168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSAS_ACTION_REvent;                     // 0x2178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerSTOP_SASEvent;                         // 0x2188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCVMENU_OPENCLOSEEvent;                 // 0x2198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCV_ACTION_UEvent;                      // 0x21A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCV_ACTION_DEvent;                      // 0x21B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCV_ACTION_LEvent;                      // 0x21C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerCV_ACTION_REvent;                      // 0x21D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerITEM_SELECT_LEvent;                    // 0x21E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerITEM_SELECT_REvent;                    // 0x21F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerITEM_USEEvent;                         // 0x2208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerOPEN_MENUEvent;                        // 0x2218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerOPEN_DETAILMAPEvent;                   // 0x2228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerOPEN_WORLDMAPEvent;                    // 0x2238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerACTION2Event;                          // 0x2248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerOPEN_BRAIN_MESSAGEEvent;               // 0x2258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRepTriggerOPEN_PHOTOMODEEvent;                   // 0x2268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	class URSGamepadEvent* GetKeyEvent(const ERSGamepadInputName InputName);
	void SetDisable();
	void SetEnable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGamepadLayout">();
	}
	static class URSGamepadLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGamepadLayout>();
	}
};
static_assert(alignof(URSGamepadLayout) == 0x000008, "Wrong alignment on URSGamepadLayout");
static_assert(sizeof(URSGamepadLayout) == 0x002278, "Wrong size on URSGamepadLayout");
static_assert(offsetof(URSGamepadLayout, Layout) == 0x000028, "Member 'URSGamepadLayout::Layout' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, Enabled) == 0x000080, "Member 'URSGamepadLayout::Enabled' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushR1Event) == 0x000DD8, "Member 'URSGamepadLayout::UEOnPushR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushR2Event) == 0x000DE8, "Member 'URSGamepadLayout::UEOnPushR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushR3Event) == 0x000DF8, "Member 'URSGamepadLayout::UEOnPushR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushL1Event) == 0x000E08, "Member 'URSGamepadLayout::UEOnPushL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushL2Event) == 0x000E18, "Member 'URSGamepadLayout::UEOnPushL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushL3Event) == 0x000E28, "Member 'URSGamepadLayout::UEOnPushL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushRUPEvent) == 0x000E38, "Member 'URSGamepadLayout::UEOnPushRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushRDOWNEvent) == 0x000E48, "Member 'URSGamepadLayout::UEOnPushRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushRLEFTEvent) == 0x000E58, "Member 'URSGamepadLayout::UEOnPushRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushRRIGHTEvent) == 0x000E68, "Member 'URSGamepadLayout::UEOnPushRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPAD_UPEvent) == 0x000E78, "Member 'URSGamepadLayout::UEOnPushDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPAD_DOWNEvent) == 0x000E88, "Member 'URSGamepadLayout::UEOnPushDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPAD_LEFTEvent) == 0x000E98, "Member 'URSGamepadLayout::UEOnPushDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPAD_RIGHTEvent) == 0x000EA8, "Member 'URSGamepadLayout::UEOnPushDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPADEMU_UPEvent) == 0x000EB8, "Member 'URSGamepadLayout::UEOnPushDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPADEMU_DOWNEvent) == 0x000EC8, "Member 'URSGamepadLayout::UEOnPushDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPADEMU_LEFTEvent) == 0x000ED8, "Member 'URSGamepadLayout::UEOnPushDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDPADEMU_RIGHTEvent) == 0x000EE8, "Member 'URSGamepadLayout::UEOnPushDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSELECTEvent) == 0x000EF8, "Member 'URSGamepadLayout::UEOnPushSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSTARTEvent) == 0x000F08, "Member 'URSGamepadLayout::UEOnPushSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushDECIDEEvent) == 0x000F18, "Member 'URSGamepadLayout::UEOnPushDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCANCELEvent) == 0x000F28, "Member 'URSGamepadLayout::UEOnPushCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSELEFTEvent) == 0x000F38, "Member 'URSGamepadLayout::UEOnPushMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSERIGHTEvent) == 0x000F48, "Member 'URSGamepadLayout::UEOnPushMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSEMIDDLEEvent) == 0x000F58, "Member 'URSGamepadLayout::UEOnPushMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSEWHEELUPEvent) == 0x000F68, "Member 'URSGamepadLayout::UEOnPushMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOUSEWHEELDOWNEvent) == 0x000F78, "Member 'URSGamepadLayout::UEOnPushMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOVE_FORWARDEvent) == 0x000F88, "Member 'URSGamepadLayout::UEOnPushMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOVE_BACKWARDEvent) == 0x000F98, "Member 'URSGamepadLayout::UEOnPushMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOVE_LEFTEvent) == 0x000FA8, "Member 'URSGamepadLayout::UEOnPushMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushMOVE_RIGHTEvent) == 0x000FB8, "Member 'URSGamepadLayout::UEOnPushMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushACTIONEvent) == 0x000FC8, "Member 'URSGamepadLayout::UEOnPushACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSTEP_DASHEvent) == 0x000FD8, "Member 'URSGamepadLayout::UEOnPushSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushWEAPON_ATTACKEvent) == 0x000FE8, "Member 'URSGamepadLayout::UEOnPushWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushWEAPON_ATTACK_SUBEvent) == 0x000FF8, "Member 'URSGamepadLayout::UEOnPushWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushJUMPEvent) == 0x001008, "Member 'URSGamepadLayout::UEOnPushJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushPSYCHICEvent) == 0x001018, "Member 'URSGamepadLayout::UEOnPushPSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushPSYCHIC_SPECIALEvent) == 0x001028, "Member 'URSGamepadLayout::UEOnPushPSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushBRAINFIELDEvent) == 0x001038, "Member 'URSGamepadLayout::UEOnPushBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushPSYCHICFIELDEvent) == 0x001048, "Member 'URSGamepadLayout::UEOnPushPSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCAMERA_RESETEvent) == 0x001058, "Member 'URSGamepadLayout::UEOnPushCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushLOCK_ONEvent) == 0x001068, "Member 'URSGamepadLayout::UEOnPushLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushLOCK_ON_SWITCH_LEvent) == 0x001078, "Member 'URSGamepadLayout::UEOnPushLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushLOCK_ON_SWITCH_REvent) == 0x001088, "Member 'URSGamepadLayout::UEOnPushLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushASSAULT_VISIONEvent) == 0x001098, "Member 'URSGamepadLayout::UEOnPushASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSASMENU_PAGESWITCHEvent) == 0x0010A8, "Member 'URSGamepadLayout::UEOnPushSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSASMENU_OPENCLOSEEvent) == 0x0010B8, "Member 'URSGamepadLayout::UEOnPushSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSAS_ACTION_UEvent) == 0x0010C8, "Member 'URSGamepadLayout::UEOnPushSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSAS_ACTION_DEvent) == 0x0010D8, "Member 'URSGamepadLayout::UEOnPushSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSAS_ACTION_LEvent) == 0x0010E8, "Member 'URSGamepadLayout::UEOnPushSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSAS_ACTION_REvent) == 0x0010F8, "Member 'URSGamepadLayout::UEOnPushSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushSTOP_SASEvent) == 0x001108, "Member 'URSGamepadLayout::UEOnPushSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCVMENU_OPENCLOSEEvent) == 0x001118, "Member 'URSGamepadLayout::UEOnPushCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCV_ACTION_UEvent) == 0x001128, "Member 'URSGamepadLayout::UEOnPushCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCV_ACTION_DEvent) == 0x001138, "Member 'URSGamepadLayout::UEOnPushCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCV_ACTION_LEvent) == 0x001148, "Member 'URSGamepadLayout::UEOnPushCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushCV_ACTION_REvent) == 0x001158, "Member 'URSGamepadLayout::UEOnPushCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushITEM_SELECT_LEvent) == 0x001168, "Member 'URSGamepadLayout::UEOnPushITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushITEM_SELECT_REvent) == 0x001178, "Member 'URSGamepadLayout::UEOnPushITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushITEM_USEEvent) == 0x001188, "Member 'URSGamepadLayout::UEOnPushITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushOPEN_MENUEvent) == 0x001198, "Member 'URSGamepadLayout::UEOnPushOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushOPEN_DETAILMAPEvent) == 0x0011A8, "Member 'URSGamepadLayout::UEOnPushOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushOPEN_WORLDMAPEvent) == 0x0011B8, "Member 'URSGamepadLayout::UEOnPushOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushACTION2Event) == 0x0011C8, "Member 'URSGamepadLayout::UEOnPushACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushOPEN_BRAIN_MESSAGEEvent) == 0x0011D8, "Member 'URSGamepadLayout::UEOnPushOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnPushOPEN_PHOTOMODEEvent) == 0x0011E8, "Member 'URSGamepadLayout::UEOnPushOPEN_PHOTOMODEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseR1Event) == 0x0011F8, "Member 'URSGamepadLayout::UEOnReleaseR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseR2Event) == 0x001208, "Member 'URSGamepadLayout::UEOnReleaseR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseR3Event) == 0x001218, "Member 'URSGamepadLayout::UEOnReleaseR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseL1Event) == 0x001228, "Member 'URSGamepadLayout::UEOnReleaseL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseL2Event) == 0x001238, "Member 'URSGamepadLayout::UEOnReleaseL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseL3Event) == 0x001248, "Member 'URSGamepadLayout::UEOnReleaseL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseRUPEvent) == 0x001258, "Member 'URSGamepadLayout::UEOnReleaseRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseRDOWNEvent) == 0x001268, "Member 'URSGamepadLayout::UEOnReleaseRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseRLEFTEvent) == 0x001278, "Member 'URSGamepadLayout::UEOnReleaseRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseRRIGHTEvent) == 0x001288, "Member 'URSGamepadLayout::UEOnReleaseRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPAD_UPEvent) == 0x001298, "Member 'URSGamepadLayout::UEOnReleaseDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPAD_DOWNEvent) == 0x0012A8, "Member 'URSGamepadLayout::UEOnReleaseDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPAD_LEFTEvent) == 0x0012B8, "Member 'URSGamepadLayout::UEOnReleaseDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPAD_RIGHTEvent) == 0x0012C8, "Member 'URSGamepadLayout::UEOnReleaseDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPADEMU_UPEvent) == 0x0012D8, "Member 'URSGamepadLayout::UEOnReleaseDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPADEMU_DOWNEvent) == 0x0012E8, "Member 'URSGamepadLayout::UEOnReleaseDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPADEMU_LEFTEvent) == 0x0012F8, "Member 'URSGamepadLayout::UEOnReleaseDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDPADEMU_RIGHTEvent) == 0x001308, "Member 'URSGamepadLayout::UEOnReleaseDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSELECTEvent) == 0x001318, "Member 'URSGamepadLayout::UEOnReleaseSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSTARTEvent) == 0x001328, "Member 'URSGamepadLayout::UEOnReleaseSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseDECIDEEvent) == 0x001338, "Member 'URSGamepadLayout::UEOnReleaseDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCANCELEvent) == 0x001348, "Member 'URSGamepadLayout::UEOnReleaseCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSELEFTEvent) == 0x001358, "Member 'URSGamepadLayout::UEOnReleaseMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSERIGHTEvent) == 0x001368, "Member 'URSGamepadLayout::UEOnReleaseMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSEMIDDLEEvent) == 0x001378, "Member 'URSGamepadLayout::UEOnReleaseMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSEWHEELUPEvent) == 0x001388, "Member 'URSGamepadLayout::UEOnReleaseMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOUSEWHEELDOWNEvent) == 0x001398, "Member 'URSGamepadLayout::UEOnReleaseMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOVE_FORWARDEvent) == 0x0013A8, "Member 'URSGamepadLayout::UEOnReleaseMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOVE_BACKWARDEvent) == 0x0013B8, "Member 'URSGamepadLayout::UEOnReleaseMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOVE_LEFTEvent) == 0x0013C8, "Member 'URSGamepadLayout::UEOnReleaseMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseMOVE_RIGHTEvent) == 0x0013D8, "Member 'URSGamepadLayout::UEOnReleaseMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseACTIONEvent) == 0x0013E8, "Member 'URSGamepadLayout::UEOnReleaseACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSTEP_DASHEvent) == 0x0013F8, "Member 'URSGamepadLayout::UEOnReleaseSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseWEAPON_ATTACKEvent) == 0x001408, "Member 'URSGamepadLayout::UEOnReleaseWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseWEAPON_ATTACK_SUBEvent) == 0x001418, "Member 'URSGamepadLayout::UEOnReleaseWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseJUMPEvent) == 0x001428, "Member 'URSGamepadLayout::UEOnReleaseJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleasePSYCHICEvent) == 0x001438, "Member 'URSGamepadLayout::UEOnReleasePSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleasePSYCHIC_SPECIALEvent) == 0x001448, "Member 'URSGamepadLayout::UEOnReleasePSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseBRAINFIELDEvent) == 0x001458, "Member 'URSGamepadLayout::UEOnReleaseBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleasePSYCHICFIELDEvent) == 0x001468, "Member 'URSGamepadLayout::UEOnReleasePSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCAMERA_RESETEvent) == 0x001478, "Member 'URSGamepadLayout::UEOnReleaseCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseLOCK_ONEvent) == 0x001488, "Member 'URSGamepadLayout::UEOnReleaseLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseLOCK_ON_SWITCH_LEvent) == 0x001498, "Member 'URSGamepadLayout::UEOnReleaseLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseLOCK_ON_SWITCH_REvent) == 0x0014A8, "Member 'URSGamepadLayout::UEOnReleaseLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseASSAULT_VISIONEvent) == 0x0014B8, "Member 'URSGamepadLayout::UEOnReleaseASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSASMENU_PAGESWITCHEvent) == 0x0014C8, "Member 'URSGamepadLayout::UEOnReleaseSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSASMENU_OPENCLOSEEvent) == 0x0014D8, "Member 'URSGamepadLayout::UEOnReleaseSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSAS_ACTION_UEvent) == 0x0014E8, "Member 'URSGamepadLayout::UEOnReleaseSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSAS_ACTION_DEvent) == 0x0014F8, "Member 'URSGamepadLayout::UEOnReleaseSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSAS_ACTION_LEvent) == 0x001508, "Member 'URSGamepadLayout::UEOnReleaseSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSAS_ACTION_REvent) == 0x001518, "Member 'URSGamepadLayout::UEOnReleaseSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseSTOP_SASEvent) == 0x001528, "Member 'URSGamepadLayout::UEOnReleaseSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCVMENU_OPENCLOSEEvent) == 0x001538, "Member 'URSGamepadLayout::UEOnReleaseCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCV_ACTION_UEvent) == 0x001548, "Member 'URSGamepadLayout::UEOnReleaseCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCV_ACTION_DEvent) == 0x001558, "Member 'URSGamepadLayout::UEOnReleaseCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCV_ACTION_LEvent) == 0x001568, "Member 'URSGamepadLayout::UEOnReleaseCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseCV_ACTION_REvent) == 0x001578, "Member 'URSGamepadLayout::UEOnReleaseCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseITEM_SELECT_LEvent) == 0x001588, "Member 'URSGamepadLayout::UEOnReleaseITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseITEM_SELECT_REvent) == 0x001598, "Member 'URSGamepadLayout::UEOnReleaseITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseITEM_USEEvent) == 0x0015A8, "Member 'URSGamepadLayout::UEOnReleaseITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseOPEN_MENUEvent) == 0x0015B8, "Member 'URSGamepadLayout::UEOnReleaseOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseOPEN_DETAILMAPEvent) == 0x0015C8, "Member 'URSGamepadLayout::UEOnReleaseOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseOPEN_WORLDMAPEvent) == 0x0015D8, "Member 'URSGamepadLayout::UEOnReleaseOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseACTION2Event) == 0x0015E8, "Member 'URSGamepadLayout::UEOnReleaseACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseOPEN_BRAIN_MESSAGEEvent) == 0x0015F8, "Member 'URSGamepadLayout::UEOnReleaseOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, UEOnReleaseOPEN_PHOTOMODEEvent) == 0x001608, "Member 'URSGamepadLayout::UEOnReleaseOPEN_PHOTOMODEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressR1Event) == 0x001618, "Member 'URSGamepadLayout::OnPressR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressR2Event) == 0x001628, "Member 'URSGamepadLayout::OnPressR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressR3Event) == 0x001638, "Member 'URSGamepadLayout::OnPressR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressL1Event) == 0x001648, "Member 'URSGamepadLayout::OnPressL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressL2Event) == 0x001658, "Member 'URSGamepadLayout::OnPressL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressL3Event) == 0x001668, "Member 'URSGamepadLayout::OnPressL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressRUPEvent) == 0x001678, "Member 'URSGamepadLayout::OnPressRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressRDOWNEvent) == 0x001688, "Member 'URSGamepadLayout::OnPressRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressRLEFTEvent) == 0x001698, "Member 'URSGamepadLayout::OnPressRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressRRIGHTEvent) == 0x0016A8, "Member 'URSGamepadLayout::OnPressRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPAD_UPEvent) == 0x0016B8, "Member 'URSGamepadLayout::OnPressDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPAD_DOWNEvent) == 0x0016C8, "Member 'URSGamepadLayout::OnPressDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPAD_LEFTEvent) == 0x0016D8, "Member 'URSGamepadLayout::OnPressDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPAD_RIGHTEvent) == 0x0016E8, "Member 'URSGamepadLayout::OnPressDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPADEMU_UPEvent) == 0x0016F8, "Member 'URSGamepadLayout::OnPressDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPADEMU_DOWNEvent) == 0x001708, "Member 'URSGamepadLayout::OnPressDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPADEMU_LEFTEvent) == 0x001718, "Member 'URSGamepadLayout::OnPressDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDPADEMU_RIGHTEvent) == 0x001728, "Member 'URSGamepadLayout::OnPressDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSELECTEvent) == 0x001738, "Member 'URSGamepadLayout::OnPressSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSTARTEvent) == 0x001748, "Member 'URSGamepadLayout::OnPressSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressDECIDEEvent) == 0x001758, "Member 'URSGamepadLayout::OnPressDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCANCELEvent) == 0x001768, "Member 'URSGamepadLayout::OnPressCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSELEFTEvent) == 0x001778, "Member 'URSGamepadLayout::OnPressMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSERIGHTEvent) == 0x001788, "Member 'URSGamepadLayout::OnPressMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSEMIDDLEEvent) == 0x001798, "Member 'URSGamepadLayout::OnPressMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSEWHEELUPEvent) == 0x0017A8, "Member 'URSGamepadLayout::OnPressMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOUSEWHEELDOWNEvent) == 0x0017B8, "Member 'URSGamepadLayout::OnPressMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOVE_FORWARDEvent) == 0x0017C8, "Member 'URSGamepadLayout::OnPressMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOVE_BACKWARDEvent) == 0x0017D8, "Member 'URSGamepadLayout::OnPressMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOVE_LEFTEvent) == 0x0017E8, "Member 'URSGamepadLayout::OnPressMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressMOVE_RIGHTEvent) == 0x0017F8, "Member 'URSGamepadLayout::OnPressMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressACTIONEvent) == 0x001808, "Member 'URSGamepadLayout::OnPressACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSTEP_DASHEvent) == 0x001818, "Member 'URSGamepadLayout::OnPressSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressWEAPON_ATTACKEvent) == 0x001828, "Member 'URSGamepadLayout::OnPressWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressWEAPON_ATTACK_SUBEvent) == 0x001838, "Member 'URSGamepadLayout::OnPressWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressJUMPEvent) == 0x001848, "Member 'URSGamepadLayout::OnPressJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressPSYCHICEvent) == 0x001858, "Member 'URSGamepadLayout::OnPressPSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressPSYCHIC_SPECIALEvent) == 0x001868, "Member 'URSGamepadLayout::OnPressPSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressBRAINFIELDEvent) == 0x001878, "Member 'URSGamepadLayout::OnPressBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressPSYCHICFIELDEvent) == 0x001888, "Member 'URSGamepadLayout::OnPressPSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCAMERA_RESETEvent) == 0x001898, "Member 'URSGamepadLayout::OnPressCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressLOCK_ONEvent) == 0x0018A8, "Member 'URSGamepadLayout::OnPressLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressLOCK_ON_SWITCH_LEvent) == 0x0018B8, "Member 'URSGamepadLayout::OnPressLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressLOCK_ON_SWITCH_REvent) == 0x0018C8, "Member 'URSGamepadLayout::OnPressLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressASSAULT_VISIONEvent) == 0x0018D8, "Member 'URSGamepadLayout::OnPressASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSASMENU_PAGESWITCHEvent) == 0x0018E8, "Member 'URSGamepadLayout::OnPressSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSASMENU_OPENCLOSEEvent) == 0x0018F8, "Member 'URSGamepadLayout::OnPressSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSAS_ACTION_UEvent) == 0x001908, "Member 'URSGamepadLayout::OnPressSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSAS_ACTION_DEvent) == 0x001918, "Member 'URSGamepadLayout::OnPressSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSAS_ACTION_LEvent) == 0x001928, "Member 'URSGamepadLayout::OnPressSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSAS_ACTION_REvent) == 0x001938, "Member 'URSGamepadLayout::OnPressSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressSTOP_SASEvent) == 0x001948, "Member 'URSGamepadLayout::OnPressSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCVMENU_OPENCLOSEEvent) == 0x001958, "Member 'URSGamepadLayout::OnPressCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCV_ACTION_UEvent) == 0x001968, "Member 'URSGamepadLayout::OnPressCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCV_ACTION_DEvent) == 0x001978, "Member 'URSGamepadLayout::OnPressCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCV_ACTION_LEvent) == 0x001988, "Member 'URSGamepadLayout::OnPressCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressCV_ACTION_REvent) == 0x001998, "Member 'URSGamepadLayout::OnPressCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressITEM_SELECT_LEvent) == 0x0019A8, "Member 'URSGamepadLayout::OnPressITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressITEM_SELECT_REvent) == 0x0019B8, "Member 'URSGamepadLayout::OnPressITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressITEM_USEEvent) == 0x0019C8, "Member 'URSGamepadLayout::OnPressITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressOPEN_MENUEvent) == 0x0019D8, "Member 'URSGamepadLayout::OnPressOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressOPEN_DETAILMAPEvent) == 0x0019E8, "Member 'URSGamepadLayout::OnPressOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressOPEN_WORLDMAPEvent) == 0x0019F8, "Member 'URSGamepadLayout::OnPressOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressACTION2Event) == 0x001A08, "Member 'URSGamepadLayout::OnPressACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressOPEN_BRAIN_MESSAGEEvent) == 0x001A18, "Member 'URSGamepadLayout::OnPressOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnPressOPEN_PHOTOMODEEvent) == 0x001A28, "Member 'URSGamepadLayout::OnPressOPEN_PHOTOMODEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerR1Event) == 0x001A38, "Member 'URSGamepadLayout::OnTriggerR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerR2Event) == 0x001A48, "Member 'URSGamepadLayout::OnTriggerR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerR3Event) == 0x001A58, "Member 'URSGamepadLayout::OnTriggerR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerL1Event) == 0x001A68, "Member 'URSGamepadLayout::OnTriggerL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerL2Event) == 0x001A78, "Member 'URSGamepadLayout::OnTriggerL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerL3Event) == 0x001A88, "Member 'URSGamepadLayout::OnTriggerL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerRUPEvent) == 0x001A98, "Member 'URSGamepadLayout::OnTriggerRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerRDOWNEvent) == 0x001AA8, "Member 'URSGamepadLayout::OnTriggerRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerRLEFTEvent) == 0x001AB8, "Member 'URSGamepadLayout::OnTriggerRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerRRIGHTEvent) == 0x001AC8, "Member 'URSGamepadLayout::OnTriggerRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPAD_UPEvent) == 0x001AD8, "Member 'URSGamepadLayout::OnTriggerDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPAD_DOWNEvent) == 0x001AE8, "Member 'URSGamepadLayout::OnTriggerDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPAD_LEFTEvent) == 0x001AF8, "Member 'URSGamepadLayout::OnTriggerDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPAD_RIGHTEvent) == 0x001B08, "Member 'URSGamepadLayout::OnTriggerDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPADEMU_UPEvent) == 0x001B18, "Member 'URSGamepadLayout::OnTriggerDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPADEMU_DOWNEvent) == 0x001B28, "Member 'URSGamepadLayout::OnTriggerDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPADEMU_LEFTEvent) == 0x001B38, "Member 'URSGamepadLayout::OnTriggerDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDPADEMU_RIGHTEvent) == 0x001B48, "Member 'URSGamepadLayout::OnTriggerDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSELECTEvent) == 0x001B58, "Member 'URSGamepadLayout::OnTriggerSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSTARTEvent) == 0x001B68, "Member 'URSGamepadLayout::OnTriggerSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerDECIDEEvent) == 0x001B78, "Member 'URSGamepadLayout::OnTriggerDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCANCELEvent) == 0x001B88, "Member 'URSGamepadLayout::OnTriggerCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSELEFTEvent) == 0x001B98, "Member 'URSGamepadLayout::OnTriggerMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSERIGHTEvent) == 0x001BA8, "Member 'URSGamepadLayout::OnTriggerMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSEMIDDLEEvent) == 0x001BB8, "Member 'URSGamepadLayout::OnTriggerMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSEWHEELUPEvent) == 0x001BC8, "Member 'URSGamepadLayout::OnTriggerMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOUSEWHEELDOWNEvent) == 0x001BD8, "Member 'URSGamepadLayout::OnTriggerMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOVE_FORWARDEvent) == 0x001BE8, "Member 'URSGamepadLayout::OnTriggerMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOVE_BACKWARDEvent) == 0x001BF8, "Member 'URSGamepadLayout::OnTriggerMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOVE_LEFTEvent) == 0x001C08, "Member 'URSGamepadLayout::OnTriggerMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerMOVE_RIGHTEvent) == 0x001C18, "Member 'URSGamepadLayout::OnTriggerMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerACTIONEvent) == 0x001C28, "Member 'URSGamepadLayout::OnTriggerACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSTEP_DASHEvent) == 0x001C38, "Member 'URSGamepadLayout::OnTriggerSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerWEAPON_ATTACKEvent) == 0x001C48, "Member 'URSGamepadLayout::OnTriggerWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerWEAPON_ATTACK_SUBEvent) == 0x001C58, "Member 'URSGamepadLayout::OnTriggerWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerJUMPEvent) == 0x001C68, "Member 'URSGamepadLayout::OnTriggerJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerPSYCHICEvent) == 0x001C78, "Member 'URSGamepadLayout::OnTriggerPSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerPSYCHIC_SPECIALEvent) == 0x001C88, "Member 'URSGamepadLayout::OnTriggerPSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerBRAINFIELDEvent) == 0x001C98, "Member 'URSGamepadLayout::OnTriggerBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerPSYCHICFIELDEvent) == 0x001CA8, "Member 'URSGamepadLayout::OnTriggerPSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCAMERA_RESETEvent) == 0x001CB8, "Member 'URSGamepadLayout::OnTriggerCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerLOCK_ONEvent) == 0x001CC8, "Member 'URSGamepadLayout::OnTriggerLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerLOCK_ON_SWITCH_LEvent) == 0x001CD8, "Member 'URSGamepadLayout::OnTriggerLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerLOCK_ON_SWITCH_REvent) == 0x001CE8, "Member 'URSGamepadLayout::OnTriggerLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerASSAULT_VISIONEvent) == 0x001CF8, "Member 'URSGamepadLayout::OnTriggerASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSASMENU_PAGESWITCHEvent) == 0x001D08, "Member 'URSGamepadLayout::OnTriggerSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSASMENU_OPENCLOSEEvent) == 0x001D18, "Member 'URSGamepadLayout::OnTriggerSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSAS_ACTION_UEvent) == 0x001D28, "Member 'URSGamepadLayout::OnTriggerSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSAS_ACTION_DEvent) == 0x001D38, "Member 'URSGamepadLayout::OnTriggerSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSAS_ACTION_LEvent) == 0x001D48, "Member 'URSGamepadLayout::OnTriggerSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSAS_ACTION_REvent) == 0x001D58, "Member 'URSGamepadLayout::OnTriggerSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerSTOP_SASEvent) == 0x001D68, "Member 'URSGamepadLayout::OnTriggerSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCVMENU_OPENCLOSEEvent) == 0x001D78, "Member 'URSGamepadLayout::OnTriggerCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCV_ACTION_UEvent) == 0x001D88, "Member 'URSGamepadLayout::OnTriggerCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCV_ACTION_DEvent) == 0x001D98, "Member 'URSGamepadLayout::OnTriggerCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCV_ACTION_LEvent) == 0x001DA8, "Member 'URSGamepadLayout::OnTriggerCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerCV_ACTION_REvent) == 0x001DB8, "Member 'URSGamepadLayout::OnTriggerCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerITEM_SELECT_LEvent) == 0x001DC8, "Member 'URSGamepadLayout::OnTriggerITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerITEM_SELECT_REvent) == 0x001DD8, "Member 'URSGamepadLayout::OnTriggerITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerITEM_USEEvent) == 0x001DE8, "Member 'URSGamepadLayout::OnTriggerITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerOPEN_MENUEvent) == 0x001DF8, "Member 'URSGamepadLayout::OnTriggerOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerOPEN_DETAILMAPEvent) == 0x001E08, "Member 'URSGamepadLayout::OnTriggerOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerOPEN_WORLDMAPEvent) == 0x001E18, "Member 'URSGamepadLayout::OnTriggerOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerACTION2Event) == 0x001E28, "Member 'URSGamepadLayout::OnTriggerACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerOPEN_BRAIN_MESSAGEEvent) == 0x001E38, "Member 'URSGamepadLayout::OnTriggerOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnTriggerOPEN_PHOTOMODEEvent) == 0x001E48, "Member 'URSGamepadLayout::OnTriggerOPEN_PHOTOMODEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerR1Event) == 0x001E58, "Member 'URSGamepadLayout::OnRepTriggerR1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerR2Event) == 0x001E68, "Member 'URSGamepadLayout::OnRepTriggerR2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerR3Event) == 0x001E78, "Member 'URSGamepadLayout::OnRepTriggerR3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerL1Event) == 0x001E88, "Member 'URSGamepadLayout::OnRepTriggerL1Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerL2Event) == 0x001E98, "Member 'URSGamepadLayout::OnRepTriggerL2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerL3Event) == 0x001EA8, "Member 'URSGamepadLayout::OnRepTriggerL3Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerRUPEvent) == 0x001EB8, "Member 'URSGamepadLayout::OnRepTriggerRUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerRDOWNEvent) == 0x001EC8, "Member 'URSGamepadLayout::OnRepTriggerRDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerRLEFTEvent) == 0x001ED8, "Member 'URSGamepadLayout::OnRepTriggerRLEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerRRIGHTEvent) == 0x001EE8, "Member 'URSGamepadLayout::OnRepTriggerRRIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPAD_UPEvent) == 0x001EF8, "Member 'URSGamepadLayout::OnRepTriggerDPAD_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPAD_DOWNEvent) == 0x001F08, "Member 'URSGamepadLayout::OnRepTriggerDPAD_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPAD_LEFTEvent) == 0x001F18, "Member 'URSGamepadLayout::OnRepTriggerDPAD_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPAD_RIGHTEvent) == 0x001F28, "Member 'URSGamepadLayout::OnRepTriggerDPAD_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPADEMU_UPEvent) == 0x001F38, "Member 'URSGamepadLayout::OnRepTriggerDPADEMU_UPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPADEMU_DOWNEvent) == 0x001F48, "Member 'URSGamepadLayout::OnRepTriggerDPADEMU_DOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPADEMU_LEFTEvent) == 0x001F58, "Member 'URSGamepadLayout::OnRepTriggerDPADEMU_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDPADEMU_RIGHTEvent) == 0x001F68, "Member 'URSGamepadLayout::OnRepTriggerDPADEMU_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSELECTEvent) == 0x001F78, "Member 'URSGamepadLayout::OnRepTriggerSELECTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSTARTEvent) == 0x001F88, "Member 'URSGamepadLayout::OnRepTriggerSTARTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerDECIDEEvent) == 0x001F98, "Member 'URSGamepadLayout::OnRepTriggerDECIDEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCANCELEvent) == 0x001FA8, "Member 'URSGamepadLayout::OnRepTriggerCANCELEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSELEFTEvent) == 0x001FB8, "Member 'URSGamepadLayout::OnRepTriggerMOUSELEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSERIGHTEvent) == 0x001FC8, "Member 'URSGamepadLayout::OnRepTriggerMOUSERIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSEMIDDLEEvent) == 0x001FD8, "Member 'URSGamepadLayout::OnRepTriggerMOUSEMIDDLEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSEWHEELUPEvent) == 0x001FE8, "Member 'URSGamepadLayout::OnRepTriggerMOUSEWHEELUPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOUSEWHEELDOWNEvent) == 0x001FF8, "Member 'URSGamepadLayout::OnRepTriggerMOUSEWHEELDOWNEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOVE_FORWARDEvent) == 0x002008, "Member 'URSGamepadLayout::OnRepTriggerMOVE_FORWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOVE_BACKWARDEvent) == 0x002018, "Member 'URSGamepadLayout::OnRepTriggerMOVE_BACKWARDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOVE_LEFTEvent) == 0x002028, "Member 'URSGamepadLayout::OnRepTriggerMOVE_LEFTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerMOVE_RIGHTEvent) == 0x002038, "Member 'URSGamepadLayout::OnRepTriggerMOVE_RIGHTEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerACTIONEvent) == 0x002048, "Member 'URSGamepadLayout::OnRepTriggerACTIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSTEP_DASHEvent) == 0x002058, "Member 'URSGamepadLayout::OnRepTriggerSTEP_DASHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerWEAPON_ATTACKEvent) == 0x002068, "Member 'URSGamepadLayout::OnRepTriggerWEAPON_ATTACKEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerWEAPON_ATTACK_SUBEvent) == 0x002078, "Member 'URSGamepadLayout::OnRepTriggerWEAPON_ATTACK_SUBEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerJUMPEvent) == 0x002088, "Member 'URSGamepadLayout::OnRepTriggerJUMPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerPSYCHICEvent) == 0x002098, "Member 'URSGamepadLayout::OnRepTriggerPSYCHICEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerPSYCHIC_SPECIALEvent) == 0x0020A8, "Member 'URSGamepadLayout::OnRepTriggerPSYCHIC_SPECIALEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerBRAINFIELDEvent) == 0x0020B8, "Member 'URSGamepadLayout::OnRepTriggerBRAINFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerPSYCHICFIELDEvent) == 0x0020C8, "Member 'URSGamepadLayout::OnRepTriggerPSYCHICFIELDEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCAMERA_RESETEvent) == 0x0020D8, "Member 'URSGamepadLayout::OnRepTriggerCAMERA_RESETEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerLOCK_ONEvent) == 0x0020E8, "Member 'URSGamepadLayout::OnRepTriggerLOCK_ONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerLOCK_ON_SWITCH_LEvent) == 0x0020F8, "Member 'URSGamepadLayout::OnRepTriggerLOCK_ON_SWITCH_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerLOCK_ON_SWITCH_REvent) == 0x002108, "Member 'URSGamepadLayout::OnRepTriggerLOCK_ON_SWITCH_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerASSAULT_VISIONEvent) == 0x002118, "Member 'URSGamepadLayout::OnRepTriggerASSAULT_VISIONEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSASMENU_PAGESWITCHEvent) == 0x002128, "Member 'URSGamepadLayout::OnRepTriggerSASMENU_PAGESWITCHEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSASMENU_OPENCLOSEEvent) == 0x002138, "Member 'URSGamepadLayout::OnRepTriggerSASMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSAS_ACTION_UEvent) == 0x002148, "Member 'URSGamepadLayout::OnRepTriggerSAS_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSAS_ACTION_DEvent) == 0x002158, "Member 'URSGamepadLayout::OnRepTriggerSAS_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSAS_ACTION_LEvent) == 0x002168, "Member 'URSGamepadLayout::OnRepTriggerSAS_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSAS_ACTION_REvent) == 0x002178, "Member 'URSGamepadLayout::OnRepTriggerSAS_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerSTOP_SASEvent) == 0x002188, "Member 'URSGamepadLayout::OnRepTriggerSTOP_SASEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCVMENU_OPENCLOSEEvent) == 0x002198, "Member 'URSGamepadLayout::OnRepTriggerCVMENU_OPENCLOSEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCV_ACTION_UEvent) == 0x0021A8, "Member 'URSGamepadLayout::OnRepTriggerCV_ACTION_UEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCV_ACTION_DEvent) == 0x0021B8, "Member 'URSGamepadLayout::OnRepTriggerCV_ACTION_DEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCV_ACTION_LEvent) == 0x0021C8, "Member 'URSGamepadLayout::OnRepTriggerCV_ACTION_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerCV_ACTION_REvent) == 0x0021D8, "Member 'URSGamepadLayout::OnRepTriggerCV_ACTION_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerITEM_SELECT_LEvent) == 0x0021E8, "Member 'URSGamepadLayout::OnRepTriggerITEM_SELECT_LEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerITEM_SELECT_REvent) == 0x0021F8, "Member 'URSGamepadLayout::OnRepTriggerITEM_SELECT_REvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerITEM_USEEvent) == 0x002208, "Member 'URSGamepadLayout::OnRepTriggerITEM_USEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerOPEN_MENUEvent) == 0x002218, "Member 'URSGamepadLayout::OnRepTriggerOPEN_MENUEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerOPEN_DETAILMAPEvent) == 0x002228, "Member 'URSGamepadLayout::OnRepTriggerOPEN_DETAILMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerOPEN_WORLDMAPEvent) == 0x002238, "Member 'URSGamepadLayout::OnRepTriggerOPEN_WORLDMAPEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerACTION2Event) == 0x002248, "Member 'URSGamepadLayout::OnRepTriggerACTION2Event' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerOPEN_BRAIN_MESSAGEEvent) == 0x002258, "Member 'URSGamepadLayout::OnRepTriggerOPEN_BRAIN_MESSAGEEvent' has a wrong offset!");
static_assert(offsetof(URSGamepadLayout, OnRepTriggerOPEN_PHOTOMODEEvent) == 0x002268, "Member 'URSGamepadLayout::OnRepTriggerOPEN_PHOTOMODEEvent' has a wrong offset!");

// Class BattlePrototype.RSGameViewportClient
// 0x0000 (0x0330 - 0x0330)
class URSGameViewportClient final : public UGameViewportClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGameViewportClient">();
	}
	static class URSGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGameViewportClient>();
	}
};
static_assert(alignof(URSGameViewportClient) == 0x000008, "Wrong alignment on URSGameViewportClient");
static_assert(sizeof(URSGameViewportClient) == 0x000330, "Wrong size on URSGameViewportClient");

// Class BattlePrototype.UIBrainCrashGauge
// 0x0098 (0x0420 - 0x0388)
class UUIBrainCrashGauge : public UUIBase
{
public:
	uint8                                         Pad_264D[0x50];                                    // 0x0388(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSCharacterBase*                       M_pTarget;                                         // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_264E[0x40];                                    // 0x03E0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetGaugeTimerRate(float* Rate);
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimFull, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimDecision2, class UImage* ImageGaugeAdd, class UImage* ImageGaugeNormal);
	bool IsBossMiniGauge();
	void SetBg(class UImage* PImage);
	void SetTarget(class ARSCharacterBase* Target, bool IsBossGauge);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainCrashGauge">();
	}
	static class UUIBrainCrashGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainCrashGauge>();
	}
};
static_assert(alignof(UUIBrainCrashGauge) == 0x000008, "Wrong alignment on UUIBrainCrashGauge");
static_assert(sizeof(UUIBrainCrashGauge) == 0x000420, "Wrong size on UUIBrainCrashGauge");
static_assert(offsetof(UUIBrainCrashGauge, M_pTarget) == 0x0003D8, "Member 'UUIBrainCrashGauge::M_pTarget' has a wrong offset!");

// Class BattlePrototype.RSGeneralFuncLib
// 0x0000 (0x0028 - 0x0028)
class URSGeneralFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static class UActorComponent* AddActorComponent(class AActor* Actor, class UClass* ComponentClass);
	static void CharacterMoveSmooth(class ACharacter* InCharacter, const struct FVector& InVelocity, const float DeltaSeconds);
	static void ClearUnusedRenderTargets(class UObject* WorldContextObject);
	static void ClearViewStateMIDPool(class UObject* WorldContextObject);
	static void GetChildrenMeshComponents(TArray<class UMeshComponent*>* OutMeshComps, class USceneComponent* TargetComponent, bool IncludeAllDescendants);
	static float GetPrimitiveBoundsScale(class UPrimitiveComponent* Primitive);
	static class FString GetRedSettingPurpose();
	static bool HasCelLookMaterialActor(class AActor* Actor);
	static bool HasCelLookMaterialComponent(class UMeshComponent* Mesh);
	static bool HasMaterialParent(class UMaterialInterface* TestMaterial, class UMaterialInterface* CheckMaterial);
	static bool HasRedEnemyMaterialActor(class AActor* Actor);
	static bool HasRedEnemyMaterialComponent(class UMeshComponent* Mesh);
	static bool IsBodySimulatingPhysics(class UPrimitiveComponent* Primitive);
	static bool IsEditor();
	static bool IsInDisplayScreen(const class APlayerController* PC, const struct FVector& TargetPos);
	static bool IsPlayMovieCapture();
	static bool IsPlaySimulate();
	static bool IsVisibleMaterial(class USkinnedMeshComponent* Mesh, int32 MaterialID);
	static TArray<int32> SearchMeshCompMaterialExcludeSlotName(class UMeshComponent* Mesh, const class FString& Param_Name, bool IsCaseCheck);
	static TArray<int32> SearchMeshCompMaterialFromSlotName(class UMeshComponent* Mesh, const class FString& Param_Name, bool IsCaseCheck);
	static TArray<int32> SearchMeshMaterialFromSlotName(class USkinnedMeshComponent* Mesh, const class FString& Param_Name, bool IsCaseCheck);
	static void SetCellLightingParamter(float LightPower, float LightSunnyMax);
	static void SetEnableFrameRateSmoothing(class UObject* WorldContextObject, bool bEnable);
	static void SetScalarParameter(class USkinnedMeshComponent* Mesh, int32 MaterialIndex, class FName ParameterName, float Value, bool CreateDynamicMaterial);
	static void SetScalarParameterAll(class UMeshComponent* Mesh, class FName ParameterName, float Value, bool CreateDynamicMaterial);
	static void SetScalarParameterAllArray(class UMeshComponent* Mesh, const TArray<class FName>& ParameterName, const TArray<float>& Value, bool CreateDynamicMaterial);
	static void SetScalarParameterArrayExcludeSlotName(class UMeshComponent* Mesh, class FName SlotName, bool IsCaseCheck, const TArray<class FName>& ParameterName, const TArray<float>& Value, bool CreateDynamicMaterial);
	static void SetScalarParameterArrayFromIndexList(class UMeshComponent* Mesh, const TArray<int32>& MaterialSlotIndexList, const TArray<class FName>& ParameterName, const TArray<float>& Value, bool CreateDynamicMaterial);
	static void SetScalarParameterArrayFromSlotName(class UMeshComponent* Mesh, class FName SlotName, bool IsCaseCheck, const TArray<class FName>& ParameterName, const TArray<float>& Value, bool CreateDynamicMaterial);
	static void SetScalarParameterFromSlotName(class USkinnedMeshComponent* Mesh, const class FString& SlotName, class FName ParameterName, float Value, bool IsCaseCheck, bool CreateDynamicMaterial);
	static void SetTextureParameterAll(class UMeshComponent* Mesh, class FName ParameterName, class UTexture* Value, bool CreateDynamicMaterial);
	static void SetTextureParameterAllArray(class UMeshComponent* Mesh, const TArray<class FName>& ParameterName, const TArray<class UTexture*>& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterAll(class UMeshComponent* Mesh, class FName ParameterName, const struct FLinearColor& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterAllArray(class UMeshComponent* Mesh, const TArray<class FName>& ParameterName, const TArray<struct FLinearColor>& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterArrayExcludeSlotName(class UMeshComponent* Mesh, class FName SlotName, bool IsCaseCheck, const TArray<class FName>& ParameterName, const TArray<struct FLinearColor>& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterArrayFromIndexList(class UMeshComponent* Mesh, const TArray<int32>& MaterialSlotIndexList, const TArray<class FName>& ParameterName, const TArray<struct FLinearColor>& Value, bool CreateDynamicMaterial);
	static void SetVectorParameterArrayFromSlotName(class UMeshComponent* Mesh, class FName SlotName, bool IsCaseCheck, const TArray<class FName>& ParameterName, const TArray<struct FLinearColor>& Value, bool CreateDynamicMaterial);
	static void SetVisibleMaterial(class USkinnedMeshComponent* Mesh, int32 MaterialID, bool bShow, int32 LodIndex);
	static void SetVisibleMaterialAll(class USkinnedMeshComponent* Mesh, bool bShow);
	static void SetVisibleMaterialAllLODs(class USkinnedMeshComponent* Mesh, int32 MaterialID, bool bShow);
	static void SetVisibleMaterialAllLODsFromSlotName(class USkinnedMeshComponent* Mesh, const class FString& Param_Name, bool bShow, bool IsCaseCheck);
	static void SetVisibleMaterialFromSlotName(class USkinnedMeshComponent* Mesh, const class FString& Param_Name, bool bShow, int32 LodIndex, bool IsCaseCheck);
	static void ShrinkActorArray(const TArray<class AActor*>& InActors, TArray<class AActor*>* OutActors);
	static void WorldPhysicsIdling(class UObject* WorldContextObject, float IdlingSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGeneralFuncLib">();
	}
	static class URSGeneralFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSGeneralFuncLib>();
	}
};
static_assert(alignof(URSGeneralFuncLib) == 0x000008, "Wrong alignment on URSGeneralFuncLib");
static_assert(sizeof(URSGeneralFuncLib) == 0x000028, "Wrong size on URSGeneralFuncLib");

// Class BattlePrototype.RSGoalActorBase
// 0x0000 (0x0230 - 0x0230)
class ARSGoalActorBase : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSGoalActorBase">();
	}
	static class ARSGoalActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSGoalActorBase>();
	}
};
static_assert(alignof(ARSGoalActorBase) == 0x000008, "Wrong alignment on ARSGoalActorBase");
static_assert(sizeof(ARSGoalActorBase) == 0x000230, "Wrong size on ARSGoalActorBase");

// Class BattlePrototype.RSHUDBase
// 0x04C8 (0x07E8 - 0x0320)
class ARSHUDBase : public AHUD
{
public:
	uint8                                         Pad_2678[0x30];                                    // 0x0320(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundAtomCue*>                  SEArray;                                           // 0x0350(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pAtomComponentClass;                             // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUILetterBoxMaskClass;                           // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILetterBoxMask*                       UILetterBoxMask;                                   // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUIFadeClass;                                    // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIFade*                                UIFadeArray[0x2];                                  // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUIGeneralChoiceClass;                           // 0x0390(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGeneralChoice*                       UIGeneralChoice;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUISystemNoticeChoiceClass;                      // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGeneralChoice*                       UISystemNoticeChoice;                              // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUITipsClass;                                    // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITips*                                UITips;                                            // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUISystemMessageClass;                           // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIInfoWindow*                          UISystemMessage;                                   // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIActionIcon*>                  ActionIconArray;                                   // 0x03D0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InitFlag;                                          // 0x03E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2679[0x9];                                     // 0x03E1(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DebugDrawMessageFlag;                              // 0x03EA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_267A[0x5];                                     // 0x03EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pUIMouseClass;                                   // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMouse*                               UIMouse;                                           // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pUIScarletLogoClsss;                             // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIScarletLogo*                         M_pUIScarletLogo;                                  // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIBase*>                        ManageWidgetList;                                  // 0x0410(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentTickUnit;                                   // 0x0420(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_267B[0x4];                                     // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUINoticeQuest*                         NoticeQuest;                                       // 0x0428(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUINoticeQuestReward*                   NoticeQuestReward;                                 // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_267C[0x17C];                                   // 0x0438(0x017C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InputLevel;                                        // 0x05B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_267D[0x30];                                    // 0x05B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIMenuBattleControl*                   HUD_battle_menu;                                   // 0x05E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESubMenuType                                  CurrentSubMenu;                                    // 0x05F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_267E[0x1];                                     // 0x05F1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ERSGamepadLayoutType                          PrevInputManagerLayoutType;                        // 0x05F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PrevGameViewRenderLayer;                           // 0x05F3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StateSubMenu;                                      // 0x05F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           RestrictOpenMenuClaimantList;                      // 0x05F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           RestrictOpenTipsClaimantList;                      // 0x0608(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_267F[0x18];                                    // 0x0618(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIDetailMap*                           WidgetDetailMap;                                   // 0x0630(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIWorldMap*                            WidgetWorldMap;                                    // 0x0638(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WorldMapStartParam;                                // 0x0640(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WorldMapOpenFlag;                                  // 0x0644(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2680[0x3];                                     // 0x0645(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIShop*                                WidgetShop;                                        // 0x0648(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICode*                                WidgetCode;                                        // 0x0650(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIMainContents*                        WidgetParty;                                       // 0x0658(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUISaveLoad*                            WidgetSaveLoad;                                    // 0x0660(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPresent*                             WidgetPresent;                                     // 0x0668(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPresentNext*                         WidgetPresentNext;                                 // 0x0670(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIAreaHere*                            WidgetAreaHere;                                    // 0x0678(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIAreaNext*                            WidgetAreaNext;                                    // 0x0680(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUICredit*                              WidgetCredit;                                      // 0x0688(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITutoOperation*                       WidgetOperation;                                   // 0x0690(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBrainTalk*                           WidgetBrainTalk;                                   // 0x0698(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVisionSimulator*                     WidgetVisionSimulator;                             // 0x06A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVisionSimulatorResult*               WidgetVisionSimulatorResult;                       // 0x06A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVisionSimulatorStartEnd*             WidgetVisionSimulatorStartEnd;                     // 0x06B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIPhotoMode*                           WidgetPhotoMode;                                   // 0x06B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2681[0x10];                                    // 0x06C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ActiveResurrectIconList;                           // 0x06D0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsTitleOutGame;                                    // 0x06E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2682[0x7];                                     // 0x06E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APhotoModeCamera*                       M_PhotoModeCameraActor;                            // 0x06E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsPhotoMode;                                     // 0x06F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsOutGamePhotoMode;                              // 0x06F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_IsCameraCutPhotoMode;                            // 0x06F2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2683[0x1];                                     // 0x06F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_StorePhotoModeBeforeAA;                          // 0x06F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_StorePhotoModeBeforeFlagPlayUI;                  // 0x06F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2684[0x7];                                     // 0x06F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUIConfigBrightness>        M_pConfigClassBrightness;                          // 0x0700(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigChoice>            M_pConfigClassChoice;                              // 0x0708(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigController>        M_pConfigClassController;                          // 0x0710(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelect2>           M_pConfigClassSelect2;                             // 0x0718(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelect3>           M_pConfigClassSelect3;                             // 0x0720(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelect5>           M_pConfigClassSelect5;                             // 0x0728(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelectMulti>       M_pConfigClassSelectMulti;                         // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIConfigSelectSlider>      M_pConfigClassSelectSlider;                        // 0x0738(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIBase>                    M_pTabClassParts4;                                 // 0x0740(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIBase>                    M_pTabClassParts5;                                 // 0x0748(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUIBase>                    M_pTabClassParts6;                                 // 0x0750(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigBrightness*                    M_pConfigBrightness;                               // 0x0758(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigChoice*                        M_pConfigChoice;                                   // 0x0760(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigController*                    M_pConfigController;                               // 0x0768(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelect2*                       M_pConfigSelect2;                                  // 0x0770(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelect3*                       M_pConfigSelect3;                                  // 0x0778(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelect5*                       M_pSConfigelect5;                                  // 0x0780(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelectMulti*                   M_pConfigSelectMulti;                              // 0x0788(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIConfigSelectSlider*                  M_pConfigSelectSlider;                             // 0x0790(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBase*                                M_pTabParts4;                                      // 0x0798(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBase*                                M_pTabParts5;                                      // 0x07A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIBase*                                M_pTabParts6;                                      // 0x07A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2685[0x8];                                     // 0x07B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ReturnFromPartyMenu;                               // 0x07B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ReturnFromPhotoMode;                               // 0x07C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2686[0x3];                                     // 0x07D8(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DebugIsDrawInvalidationInfo;                       // 0x07DB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2687[0x4];                                     // 0x07DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pDebugDrawClass;                                 // 0x07E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UUIActionIcon* AddActionIcon();
	bool CanPlayCutScene_FromNative(const bool IsTipsCheck);
	bool ChangeSoundState(ESoundState State);
	void ChangeStaffRollSpeed(float Speed);
	void CheckEndAllMessage(bool* IsEnd, bool FlagCheckClose);
	bool CheckEndChoiceMessage();
	void CheckEndMessage(int32 MessageIndex, bool* IsEnd);
	void CheckInput(class UUIBase* Widget, EUIInputButton ButtonType, EUIInputType InputType, bool* IsInput);
	bool CheckInputPhotoMode();
	bool CheckSubQuestReward();
	int32 CheckSubQuestRewardResult();
	void CloseBrainTalkFromNative();
	bool CloseMessage();
	bool CloseMessageGuide();
	bool CloseMinimap(bool Force);
	void CloseScarletLogo();
	bool CloseStartBondsQuest(class FName bondsQuestId);
	bool CloseStartSubQuest(class FName SubQuestID);
	void CloseSystemMessage();
	bool CloseTutoOperation();
	bool CloseTutoTips();
	void DEBUG_PRINT(const class FText& Message, float PosX, float PosY, const struct FLinearColor& Color, const struct FVector2D& Scale);
	void DebugChangeVisible(bool Visibleflag);
	void DebugDrawInvalidationWidget();
	int32 DrawChoiceMessage(int32 ChoiceNum, const class FString& Choice0, const class FString& Choice1, const class FString& Choice2, const class FString& Choice3, const class FString& Choice4, int32 DefaultIndex, int32 CancelIndex, float DrawSecond, bool IsEnableCancel, bool IsWaitMode);
	int32 DrawMessage(const class FString& Talker, const class FString& Message, int32 WindowType, float DrawSecond, bool IsEnableSkip, class URSAtomComponentBase* Voice, bool IsSkipVoiceEnd, bool IsWaitMode);
	bool EndLoading();
	bool EndMinimapBrainField();
	bool EndPhotoMode();
	void EndPhotoModeOutGame();
	void EndStaffRoll();
	void EndSubMenu();
	void FadeIn(bool IsUnderCaption, float Second);
	void FadeInBlack(bool IsUnderCaption, float Second);
	void FadeInDefineColor(EUIFadeColorType Color, bool IsUnderCaption, float Second);
	void FadeInFreeColor(const struct FLinearColor& Color, bool IsUnderCaption, float Second);
	void FadeInWhite(bool IsUnderCaption, float Second);
	void FadeOutBlack(bool IsUnderCaption, float Second);
	void FadeOutDefineColor(EUIFadeColorType Color, bool IsUnderCaption, float Second);
	void FadeOutFreeColor(const struct FLinearColor& Color, bool IsUnderCaption, float Second);
	void FadeOutWhite(bool IsUnderCaption, float Second);
	void ForceEndGeneralChoice();
	struct FVector2D GetAnalogStickL(class UUIBase* Widget);
	struct FVector2D GetAnalogStickR(class UUIBase* Widget);
	void GetChoiceResult(int32 MessageIndex, int32* Result);
	bool GetDebugDispUserTag();
	class FString GetDebugMinimapAreaSetting();
	bool GetDebugMinimapCreateMapDisable();
	bool GetDebugMinimapIconEnemyTickDisable();
	bool GetDebugMinimapIconFootTickDisable();
	bool GetDebugMinimapIconNpcTickDisable();
	bool GetDebugMinimapIconTickDisable();
	bool GetDebugMinimapIconUpdateAdjust();
	bool GetDebugMinimapMaterialTickDisable();
	bool GetDebugMinimapTickDisable();
	bool GetDebugMinimapTraceTickDisable();
	int32 GetDebugSaveLoadMenuSetting();
	struct FVector2D GetDebugViewportSize();
	bool GetEnablePartyMenu();
	float GetFadeAlpha(bool IsUnderCaption);
	int32 GetGeneralChoiceResult();
	int32 GetInputLevel();
	void GetLastChoiceResult(int32* Result);
	class URSAtomComponentBase* GetMessageVoice();
	bool GetMouseDispIcon();
	bool GetMouseDispRectangle();
	bool GetOverlapEventInvalidFlag();
	bool GetReserveShopMenu();
	class FName GetResultVisionSimulatorSelect();
	bool Init();
	void InitCreateScarletLogo();
	void InitFade();
	void InitMouseCursor();
	bool IsBrainTalkFinishedWait();
	bool IsCameraCutPhotoMode();
	bool IsCanceledVisionSimulatorSelect();
	bool IsCancelGeneralChoice();
	bool IsCurrentMessageWithChoices();
	bool IsCurrentMessageWithVoice();
	bool IsCustomTimeDilationAccelerate(float* CurrentCustomTimeDilation);
	bool IsEnableOpenMenu();
	bool IsEnableOpenPhotoMode();
	bool IsEnableOpenTips();
	bool IsEndGameOverFromNative();
	bool IsEndGeneralChoice();
	bool IsEndStaffRoll();
	bool IsEndSubMenu(ESubMenuType SubMenuType);
	bool IsEndSystemMessage();
	bool IsEndVisionSimulatorSelect();
	bool IsEventFinishWaitMode_AfterCounter();
	bool IsFoucusMouse();
	void IsFoundCustomTimeDilationRegistName_FromNative(const class FString& RegistName, bool* IsFound, float* CurrentCustomTimeDilation);
	bool IslockInputSubMenu();
	bool IsOpenLoadingUI();
	bool IsOpenSubMenu();
	bool IsOutGameHudMain();
	bool IsOutGamePhotoMode();
	bool IsPhotoMode();
	bool IsPlayBrainTuto();
	bool IsSavedSaveLoadMenu();
	bool IsSavedSaveLoadMenuError();
	bool IsTutoOperation();
	bool IsTutoTips();
	bool IsValidMessageVoiceToMessageBuffer();
	void LoadResidentWidget();
	void LockDetailMapWarning();
	void LockInputSubMenu();
	float MiniTipsStartDraw(EHelpTutorial TipsID);
	bool MiniTipsStopDraw(EHelpTutorial TipsID);
	bool MiniTipsSuccessStartDraw();
	bool MiniTipsSuccessStopDraw();
	bool NextBrainTalkMessage(const int32 Param_Index);
	void OnAvoid();
	void OnInitialized();
	bool OnTitleBack();
	void OpenBrainTalkFromNative(const int32 CharacterId, const int32 ExpressionID, const class FString& MessageID, const float DrawSecond);
	bool OpenBrainTuto();
	bool OpenMinimap(bool Force);
	void OpenScarletLogo();
	bool OpenStartBondsQuest(class FName bondsQuestId);
	bool OpenStartSubQuest(class FName SubQuestID);
	void OpenSystemMessage(const class FString& SystemMessage, bool IsWarning, bool IsGuide, bool IsFade);
	void OpenWorldMap();
	void PauseBrainTalkForEventFromNative(const bool IsPause);
	void PauseTutoOperation();
	bool PlayDecideAnimeBrainTuto();
	bool ProcBattleMenu();
	void ReleaseVisionSimulatorResult();
	void ReleaseVisionSimulatorStartEnd();
	bool RemoveActionIcon(class UUIActionIcon* ActionIcon);
	void RemoveCustomTimeDilation_FromNative(const class FString& Param_Name);
	void RemoveDiscoverIndexList(int32 Param_Index);
	void RemoveFromManageWidget(class UUIBase* Widget);
	void ResetCustomTimeDilationAccelerateInValidSettings();
	void ResetWeaponMenuDefaultCursor();
	void RestrictOpenMenu(bool bRestrict, class FName ClaimantName);
	void RestrictOpenTips(bool bRestrict, class FName ClaimantName);
	void ResumeTutoOperation();
	void SasSetChangePageReady(bool ReadyFlagL, bool ReadyFlagR);
	void SetBPFoucusMouse();
	void SetBPUnFoucusMouse();
	void SetBrainMapCursorCorrectArea(float Area);
	void SetBrainMapCursorCorrectSpeed(float Speed);
	void SetBrainMapCursorSpeed(float Speed);
	void SetBrainMessageDefaultThread(class FName ThreadTitle);
	void SetCameraCutPhotoMode(bool Flag);
	void SetCustomTimeDilation_FromNative(const class FString& Param_Name, float CurrentCustomTimeDilation);
	void SetDebugDispUserTag(bool Dispflag);
	void SetDebugKeyboard(bool IsEnable);
	void SetDebugMinimapAreaSetting(const class FString& SettingAreaName);
	void SetDebugSaveLoadMenuSetting(int32 SettingIndex);
	void SetDebugWorldmapUnlockFlag(bool UnlockFlag);
	void SetEnablePartyMenu(bool EnableFlag);
	void SetGuideVisibleSysMess(bool IsGuide);
	bool SetLogBrainFieldAddTime();
	bool SetLogGetItem(const class FString& ItemName, int32 ItemNum, const float _drawTime);
	bool SetLogGetMoneyFromNative(int32 GetMoney, const float _drawTime);
	bool SetLogItemOverFlow(const class FString& ItemName, const float _drawTime);
	bool SetLogUpdateGoal();
	void SetMouseCursorShow(bool Showflag, bool Foceshow);
	void SetMouseCursorUse(bool Useflag);
	void SetMouseDispIcon(bool Icondisp);
	void SetMouseDispRectangle(bool Dispflag);
	void SetMouseEnableMainTab(bool Flag);
	void SetOpenBrainMessage();
	void SetOpenDetailMap();
	void SetOpenMainMenu();
	void SetOpenWorldMap();
	void SetOutGame(bool IsOutGame);
	void SetOverlapEventInvalidFlag(bool Enable);
	void SetPartyMenuViewerMode(bool IsViewerMode);
	void SetPlayBattleUI(bool FlagPlay);
	void SetReserveShopMenu(bool IsReserve);
	void SetTDebugInvisibleAll(bool IsInvisible);
	void SetVisibleActionUI(bool FlagVisible);
	bool SetVisionSimulatorTimerDraw(bool IsDraw);
	void SetWeaponMenuDefaultCursor(EPlayerID CharaID, bool IsVisual);
	bool SkipMessage();
	bool StartAreaHere(int32 LocationId, int32 AreaId, int32 PortalID);
	bool StartAreaNext(int32 LocationId, int32 AreaId, int32 PortalID, bool IsWorldMap);
	bool StartAutoSaveIcon();
	void StartBossName(const class FString& bossId, EBossNameMode Mode, float FreeFixedDrawSecond);
	void StartBrainMessageMenu(bool IsAutoMode);
	bool StartCharaName(const class FString& CharaID);
	bool StartCode();
	void StartEventFinishWaitMode_AfterCounter();
	void StartGeneralChoice1(const class FString& TextMain, const class FString& TextIndex, bool Cancelable, int32 CancelIndex, bool IsFade);
	void StartGeneralChoice2(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, bool Cancelable, int32 CancelIndex, bool IsFade);
	void StartGeneralChoice3(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, const class FString& TextIndex3, bool Cancelable, int32 CancelIndex, bool IsFade);
	void StartGeneralChoice4(const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, const class FString& TextIndex3, const class FString& TextIndex4, bool Cancelable, int32 CancelIndex, bool IsFade);
	bool StartKeyword();
	bool StartLoading(bool IsFadeWhite);
	bool StartMessageGuide(bool FlagSkip, bool FlagPhotoMode);
	bool StartMinimapBrainField();
	bool StartPhotoMode();
	void StartPhotoModeOutGame();
	void StartPhotoModeUI();
	bool StartSasWindowNative(EPlayerID Target, bool IsEx1, bool IsEx2);
	void StartStaffRoll(float Speed);
	void StartSubMenu(ESubMenuType SubMenuType, int32 Parameter, int32 Parameter2);
	bool StartSubQuestReward(class FName SubQuestID);
	bool StartTownName(int32 LocationId);
	bool StartTutoOperation(class FName HelpTutoID);
	bool StartTutoTips(EHelpTutorial TutoID, bool NotPauseControll, bool NotCloseOfPause, bool IsFade);
	void StartVisionSimulatorEnd();
	bool StartVisionSimulatorResult(bool IsCheckMode, class FName MissionTitle);
	void StartVisionSimulatorSelect();
	void StartVisionSimulatorStart();
	bool StopAutoSaveIcon();
	void StopBrainTalkVoiceFromNative();
	void TDebugDrawWidgetLayout();
	void UnloadResidentWidget();
	void UnlockDetailMapWarning();
	void UnLockInputSubMenu();
	bool UpdateItemMenuUI();

	float GetBrainMapCursorCorrectArea() const;
	float GetBrainMapCursorCorrectSpeed() const;
	float GetBrainMapCursorSpeed() const;
	class UClass* GetDebugDrawClass() const;
	bool GetDebugKeyboard() const;
	bool GetDebugWorldmapUnlockFlag() const;
	EInputDeviceType GetIconDeviceType() const;
	class FName GetResultCode() const;
	class FString GetResultKeyword() const;
	bool IsBattleMenuInitialized() const;
	bool IsBrainField() const;
	bool IsCanceledCode() const;
	bool IsCancelKeyword() const;
	bool IsChangedIconDeviceType() const;
	bool IsDrawMessageGuide() const;
	bool IsDrawMessageSkipGuide() const;
	bool IsDrawMiniTipsSuccess() const;
	bool IsEndCode() const;
	bool IsEndKeyword() const;
	bool IsEndPhotoModeUI() const;
	bool IsEndVisionSimulatorEnd() const;
	bool IsEndVisionSimulatorResult() const;
	bool IsEndVisionSimulatorStart() const;
	bool IsFade() const;
	bool IsFadeAnimation() const;
	bool IsLogMessageEmpty() const;
	bool IsOpenedCode() const;
	bool IsPartyMenuViewerMode() const;
	bool IsPhotoModeOutlineSetting() const;
	bool IsPlayMessageOpenAnimationNative() const;
	bool IsPlaySasWindowNative() const;
	bool IsTDebugInvisibleAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSHUDBase">();
	}
	static class ARSHUDBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSHUDBase>();
	}
};
static_assert(alignof(ARSHUDBase) == 0x000008, "Wrong alignment on ARSHUDBase");
static_assert(sizeof(ARSHUDBase) == 0x0007E8, "Wrong size on ARSHUDBase");
static_assert(offsetof(ARSHUDBase, SEArray) == 0x000350, "Member 'ARSHUDBase::SEArray' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pAtomComponentClass) == 0x000360, "Member 'ARSHUDBase::M_pAtomComponentClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUILetterBoxMaskClass) == 0x000368, "Member 'ARSHUDBase::M_pUILetterBoxMaskClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UILetterBoxMask) == 0x000370, "Member 'ARSHUDBase::UILetterBoxMask' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIFadeClass) == 0x000378, "Member 'ARSHUDBase::M_pUIFadeClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UIFadeArray) == 0x000380, "Member 'ARSHUDBase::UIFadeArray' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIGeneralChoiceClass) == 0x000390, "Member 'ARSHUDBase::M_pUIGeneralChoiceClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UIGeneralChoice) == 0x000398, "Member 'ARSHUDBase::UIGeneralChoice' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUISystemNoticeChoiceClass) == 0x0003A0, "Member 'ARSHUDBase::M_pUISystemNoticeChoiceClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UISystemNoticeChoice) == 0x0003A8, "Member 'ARSHUDBase::UISystemNoticeChoice' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUITipsClass) == 0x0003B0, "Member 'ARSHUDBase::M_pUITipsClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UITips) == 0x0003B8, "Member 'ARSHUDBase::UITips' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUISystemMessageClass) == 0x0003C0, "Member 'ARSHUDBase::M_pUISystemMessageClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UISystemMessage) == 0x0003C8, "Member 'ARSHUDBase::UISystemMessage' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, ActionIconArray) == 0x0003D0, "Member 'ARSHUDBase::ActionIconArray' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, InitFlag) == 0x0003E0, "Member 'ARSHUDBase::InitFlag' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, DebugDrawMessageFlag) == 0x0003EA, "Member 'ARSHUDBase::DebugDrawMessageFlag' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIMouseClass) == 0x0003F0, "Member 'ARSHUDBase::M_pUIMouseClass' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, UIMouse) == 0x0003F8, "Member 'ARSHUDBase::UIMouse' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIScarletLogoClsss) == 0x000400, "Member 'ARSHUDBase::M_pUIScarletLogoClsss' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pUIScarletLogo) == 0x000408, "Member 'ARSHUDBase::M_pUIScarletLogo' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, ManageWidgetList) == 0x000410, "Member 'ARSHUDBase::ManageWidgetList' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, CurrentTickUnit) == 0x000420, "Member 'ARSHUDBase::CurrentTickUnit' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, NoticeQuest) == 0x000428, "Member 'ARSHUDBase::NoticeQuest' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, NoticeQuestReward) == 0x000430, "Member 'ARSHUDBase::NoticeQuestReward' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, InputLevel) == 0x0005B4, "Member 'ARSHUDBase::InputLevel' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, HUD_battle_menu) == 0x0005E8, "Member 'ARSHUDBase::HUD_battle_menu' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, CurrentSubMenu) == 0x0005F0, "Member 'ARSHUDBase::CurrentSubMenu' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, PrevInputManagerLayoutType) == 0x0005F2, "Member 'ARSHUDBase::PrevInputManagerLayoutType' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, PrevGameViewRenderLayer) == 0x0005F3, "Member 'ARSHUDBase::PrevGameViewRenderLayer' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, StateSubMenu) == 0x0005F4, "Member 'ARSHUDBase::StateSubMenu' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, RestrictOpenMenuClaimantList) == 0x0005F8, "Member 'ARSHUDBase::RestrictOpenMenuClaimantList' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, RestrictOpenTipsClaimantList) == 0x000608, "Member 'ARSHUDBase::RestrictOpenTipsClaimantList' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetDetailMap) == 0x000630, "Member 'ARSHUDBase::WidgetDetailMap' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetWorldMap) == 0x000638, "Member 'ARSHUDBase::WidgetWorldMap' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WorldMapStartParam) == 0x000640, "Member 'ARSHUDBase::WorldMapStartParam' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WorldMapOpenFlag) == 0x000644, "Member 'ARSHUDBase::WorldMapOpenFlag' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetShop) == 0x000648, "Member 'ARSHUDBase::WidgetShop' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetCode) == 0x000650, "Member 'ARSHUDBase::WidgetCode' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetParty) == 0x000658, "Member 'ARSHUDBase::WidgetParty' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetSaveLoad) == 0x000660, "Member 'ARSHUDBase::WidgetSaveLoad' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetPresent) == 0x000668, "Member 'ARSHUDBase::WidgetPresent' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetPresentNext) == 0x000670, "Member 'ARSHUDBase::WidgetPresentNext' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetAreaHere) == 0x000678, "Member 'ARSHUDBase::WidgetAreaHere' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetAreaNext) == 0x000680, "Member 'ARSHUDBase::WidgetAreaNext' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetCredit) == 0x000688, "Member 'ARSHUDBase::WidgetCredit' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetOperation) == 0x000690, "Member 'ARSHUDBase::WidgetOperation' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetBrainTalk) == 0x000698, "Member 'ARSHUDBase::WidgetBrainTalk' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetVisionSimulator) == 0x0006A0, "Member 'ARSHUDBase::WidgetVisionSimulator' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetVisionSimulatorResult) == 0x0006A8, "Member 'ARSHUDBase::WidgetVisionSimulatorResult' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetVisionSimulatorStartEnd) == 0x0006B0, "Member 'ARSHUDBase::WidgetVisionSimulatorStartEnd' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, WidgetPhotoMode) == 0x0006B8, "Member 'ARSHUDBase::WidgetPhotoMode' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, ActiveResurrectIconList) == 0x0006D0, "Member 'ARSHUDBase::ActiveResurrectIconList' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, IsTitleOutGame) == 0x0006E0, "Member 'ARSHUDBase::IsTitleOutGame' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_PhotoModeCameraActor) == 0x0006E8, "Member 'ARSHUDBase::M_PhotoModeCameraActor' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_IsPhotoMode) == 0x0006F0, "Member 'ARSHUDBase::M_IsPhotoMode' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_IsOutGamePhotoMode) == 0x0006F1, "Member 'ARSHUDBase::M_IsOutGamePhotoMode' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_IsCameraCutPhotoMode) == 0x0006F2, "Member 'ARSHUDBase::M_IsCameraCutPhotoMode' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_StorePhotoModeBeforeAA) == 0x0006F4, "Member 'ARSHUDBase::M_StorePhotoModeBeforeAA' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_StorePhotoModeBeforeFlagPlayUI) == 0x0006F8, "Member 'ARSHUDBase::M_StorePhotoModeBeforeFlagPlayUI' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassBrightness) == 0x000700, "Member 'ARSHUDBase::M_pConfigClassBrightness' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassChoice) == 0x000708, "Member 'ARSHUDBase::M_pConfigClassChoice' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassController) == 0x000710, "Member 'ARSHUDBase::M_pConfigClassController' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelect2) == 0x000718, "Member 'ARSHUDBase::M_pConfigClassSelect2' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelect3) == 0x000720, "Member 'ARSHUDBase::M_pConfigClassSelect3' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelect5) == 0x000728, "Member 'ARSHUDBase::M_pConfigClassSelect5' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelectMulti) == 0x000730, "Member 'ARSHUDBase::M_pConfigClassSelectMulti' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigClassSelectSlider) == 0x000738, "Member 'ARSHUDBase::M_pConfigClassSelectSlider' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabClassParts4) == 0x000740, "Member 'ARSHUDBase::M_pTabClassParts4' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabClassParts5) == 0x000748, "Member 'ARSHUDBase::M_pTabClassParts5' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabClassParts6) == 0x000750, "Member 'ARSHUDBase::M_pTabClassParts6' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigBrightness) == 0x000758, "Member 'ARSHUDBase::M_pConfigBrightness' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigChoice) == 0x000760, "Member 'ARSHUDBase::M_pConfigChoice' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigController) == 0x000768, "Member 'ARSHUDBase::M_pConfigController' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigSelect2) == 0x000770, "Member 'ARSHUDBase::M_pConfigSelect2' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigSelect3) == 0x000778, "Member 'ARSHUDBase::M_pConfigSelect3' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pSConfigelect5) == 0x000780, "Member 'ARSHUDBase::M_pSConfigelect5' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigSelectMulti) == 0x000788, "Member 'ARSHUDBase::M_pConfigSelectMulti' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pConfigSelectSlider) == 0x000790, "Member 'ARSHUDBase::M_pConfigSelectSlider' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabParts4) == 0x000798, "Member 'ARSHUDBase::M_pTabParts4' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabParts5) == 0x0007A0, "Member 'ARSHUDBase::M_pTabParts5' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pTabParts6) == 0x0007A8, "Member 'ARSHUDBase::M_pTabParts6' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, ReturnFromPartyMenu) == 0x0007B8, "Member 'ARSHUDBase::ReturnFromPartyMenu' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, ReturnFromPhotoMode) == 0x0007C8, "Member 'ARSHUDBase::ReturnFromPhotoMode' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, DebugIsDrawInvalidationInfo) == 0x0007DB, "Member 'ARSHUDBase::DebugIsDrawInvalidationInfo' has a wrong offset!");
static_assert(offsetof(ARSHUDBase, M_pDebugDrawClass) == 0x0007E0, "Member 'ARSHUDBase::M_pDebugDrawClass' has a wrong offset!");

// Class BattlePrototype.UIBrainTalk
// 0x00F0 (0x0478 - 0x0388)
class UUIBrainTalk : public UUIBase
{
public:
	uint8                                         Pad_26BF[0x58];                                    // 0x0388(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtomComponent*                         Voice;                                             // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C0[0x10];                                    // 0x03E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_isVoicePlayWait;                                 // 0x03F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C1[0x7F];                                    // 0x03F9(0x007F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture* GetFaceTexture(int32 Param_Index);
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextBrainTalk, class UImage* IconFont, class UImage* FaceB, class UMaterialInstanceConstant* MaterialFontNormal, class UMaterialInstanceConstant* MaterialFontNoize);
	void IsEndTalk(bool* IsEnd);
	void PauseBrainTalkVoice(const bool IsPause);
	void PlayBrainTalkVoice();
	void SetBrainTalkMessage(int32 CharacterId, int32 ExpressionID, const class FString& Message, class UAtomComponent* Param_Voice, float DrawSecond, const bool IsReserve);
	void SetBugMode(bool IsBug);
	void SetIsVoicePlayWait(bool Flag);
	bool SetupTextSize();
	void StopBrainTalkVoice();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainTalk">();
	}
	static class UUIBrainTalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainTalk>();
	}
};
static_assert(alignof(UUIBrainTalk) == 0x000008, "Wrong alignment on UUIBrainTalk");
static_assert(sizeof(UUIBrainTalk) == 0x000478, "Wrong size on UUIBrainTalk");
static_assert(offsetof(UUIBrainTalk, Voice) == 0x0003E0, "Member 'UUIBrainTalk::Voice' has a wrong offset!");
static_assert(offsetof(UUIBrainTalk, M_isVoicePlayWait) == 0x0003F8, "Member 'UUIBrainTalk::M_isVoicePlayWait' has a wrong offset!");

// Class BattlePrototype.RSInGameFlow
// 0x0018 (0x0248 - 0x0230)
class ARSInGameFlow final : public AActor
{
public:
	uint8                                         Pad_26C4[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInGameFlowType                               _currentType;                                      // 0x0240(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C5[0x7];                                     // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(class URSGameInstance* GameInst);
	void SetCurrentFlowType(EInGameFlowType Type);

	EInGameFlowType GetCurrentFlowType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSInGameFlow">();
	}
	static class ARSInGameFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSInGameFlow>();
	}
};
static_assert(alignof(ARSInGameFlow) == 0x000008, "Wrong alignment on ARSInGameFlow");
static_assert(sizeof(ARSInGameFlow) == 0x000248, "Wrong size on ARSInGameFlow");
static_assert(offsetof(ARSInGameFlow, _gameInstance) == 0x000238, "Member 'ARSInGameFlow::_gameInstance' has a wrong offset!");
static_assert(offsetof(ARSInGameFlow, _currentType) == 0x000240, "Member 'ARSInGameFlow::_currentType' has a wrong offset!");

// Class BattlePrototype.InputManager
// 0x02A0 (0x04D0 - 0x0230)
class AInputManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_26C6[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERSGamepadLayoutType                          CurrentLayout;                                     // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C7[0x3];                                     // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThresholdStickAnalogToDigital;                     // 0x023C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCrossButtonDecide;                               // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C8[0x7];                                     // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             KeyboardPressEvent;                                // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             KeyboardReleasedEvent;                             // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChangeInputTypeEvent;                              // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ChangeInputTypeWithMouseEvent;                     // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C9[0x18];                                    // 0x0288(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaMouseX;                                       // 0x02A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaMouseY;                                       // 0x02A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMouseControll;                                    // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreMouseControll;                                 // 0x02A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26CA[0x2];                                     // 0x02AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RawRStickX;                                        // 0x02AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawRStickY;                                        // 0x02B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26CB[0x204];                                   // 0x02B4(0x0204)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PauseClaimantList;                                 // 0x04B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26CC[0x8];                                     // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetectionDeltaMouseMove(float XPos, float YPos);
	void Finalize();
	float GetAxisValue(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	ERSGamepadLayoutType GetCurrentLayoutType();
	class URSGamepadLayout* GetGamepadLayout(const ERSGamepadLayoutType Layout);
	EInputDeviceType GetInputDeviceType();
	struct FVector2D GetMouseMove();
	float GetMouseWheelAxisValue(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	bool GetOnPress(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	bool GetOnRepeatTrigger(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	bool GetOnTrigger(ERSGamepadLayoutType Layout, ERSGamepadInputName Pad);
	void GetRightStickAxisRawValue(float* RStickX, float* RStickY);
	ERSInputDeviceType GetRSCurrentInputDeviceType();
	ERSInputDeviceType GetRSCurrentInputDeviceTypeWithMouse();
	bool GetUseKey(const ERSGamepadInputName InputName, ERSInputDeviceType* UseKey, ERSGamepadInputName* PadInputName, class FName* KeyInputName);
	class FString GetVirtualKeyboardText();
	void Initialize();
	bool IsDInput(const ERSGamepadInputName InputName);
	bool IsInputPaused();
	bool IsMouseInputRightStick();
	bool IsMouseWheelItemSelect();
	void IsScreenOutMouse(bool IsOut);
	bool IsSteamInBigPictureMode();
	void MouseCursorOnOff();
	void OnConfigedAxisAction(const ERSGamepadInputName Pad, float Value);
	void OnConfigedKeyboardAction(const struct FKey& Key, bool IsPress);
	void OnConfigedPadAction(const ERSGamepadInputName Pad, bool IsPress, bool IsDInput);
	void OnConfigedPadActionAndKey(const ERSGamepadInputName Pad, bool IsPress, const struct FKey& Key);
	void OnInputAxisAction(const float Value, const ERSGamepadInputName Pad);
	void OnInputMouseAxisAction(const float Value, const ERSGamepadInputName Pad);
	void OnMouseInputConvertAction(const struct FKey& Key, bool Actflag);
	void OnPressAction(const ERSGamepadInputName Pad);
	void OnReleaseAction(const ERSGamepadInputName Pad);
	void ResetCurrentLayout();
	void SetCurrentLayoutType(const ERSGamepadLayoutType Layout);
	void SetDeltaMouseMoveRaw(float XDelta, float YDelta);
	void SetDisableChangeInputModeFlag(bool Flg);
	void SetInputPaused(bool bPaused, class FName ClaimantName);
	bool ShowVirtualKeyboard(const class FString& Text, const class FString& HintText, int32 KeyboardType);
	void StopSimpleController();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputManager">();
	}
	static class AInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInputManager>();
	}
};
static_assert(alignof(AInputManager) == 0x000008, "Wrong alignment on AInputManager");
static_assert(sizeof(AInputManager) == 0x0004D0, "Wrong size on AInputManager");
static_assert(offsetof(AInputManager, CurrentLayout) == 0x000238, "Member 'AInputManager::CurrentLayout' has a wrong offset!");
static_assert(offsetof(AInputManager, ThresholdStickAnalogToDigital) == 0x00023C, "Member 'AInputManager::ThresholdStickAnalogToDigital' has a wrong offset!");
static_assert(offsetof(AInputManager, IsCrossButtonDecide) == 0x000240, "Member 'AInputManager::IsCrossButtonDecide' has a wrong offset!");
static_assert(offsetof(AInputManager, KeyboardPressEvent) == 0x000248, "Member 'AInputManager::KeyboardPressEvent' has a wrong offset!");
static_assert(offsetof(AInputManager, KeyboardReleasedEvent) == 0x000258, "Member 'AInputManager::KeyboardReleasedEvent' has a wrong offset!");
static_assert(offsetof(AInputManager, ChangeInputTypeEvent) == 0x000268, "Member 'AInputManager::ChangeInputTypeEvent' has a wrong offset!");
static_assert(offsetof(AInputManager, ChangeInputTypeWithMouseEvent) == 0x000278, "Member 'AInputManager::ChangeInputTypeWithMouseEvent' has a wrong offset!");
static_assert(offsetof(AInputManager, DeltaMouseX) == 0x0002A0, "Member 'AInputManager::DeltaMouseX' has a wrong offset!");
static_assert(offsetof(AInputManager, DeltaMouseY) == 0x0002A4, "Member 'AInputManager::DeltaMouseY' has a wrong offset!");
static_assert(offsetof(AInputManager, bMouseControll) == 0x0002A8, "Member 'AInputManager::bMouseControll' has a wrong offset!");
static_assert(offsetof(AInputManager, bPreMouseControll) == 0x0002A9, "Member 'AInputManager::bPreMouseControll' has a wrong offset!");
static_assert(offsetof(AInputManager, RawRStickX) == 0x0002AC, "Member 'AInputManager::RawRStickX' has a wrong offset!");
static_assert(offsetof(AInputManager, RawRStickY) == 0x0002B0, "Member 'AInputManager::RawRStickY' has a wrong offset!");
static_assert(offsetof(AInputManager, PauseClaimantList) == 0x0004B8, "Member 'AInputManager::PauseClaimantList' has a wrong offset!");

// Class BattlePrototype.UICharaName
// 0x0040 (0x03C8 - 0x0388)
class UUICharaName : public UUIBase
{
public:
	float                                         DrawSecond;                                        // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26DA[0x3C];                                    // 0x038C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextCharaName, class UTextBlock* TextCharaName2);
	void Start(const class FString& CharaID);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaName">();
	}
	static class UUICharaName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaName>();
	}
};
static_assert(alignof(UUICharaName) == 0x000008, "Wrong alignment on UUICharaName");
static_assert(sizeof(UUICharaName) == 0x0003C8, "Wrong size on UUICharaName");
static_assert(offsetof(UUICharaName, DrawSecond) == 0x000388, "Member 'UUICharaName::DrawSecond' has a wrong offset!");

// Class BattlePrototype.RSLevelSequenceActor
// 0x0000 (0x02C0 - 0x02C0)
class ARSLevelSequenceActor final : public ALevelSequenceActor
{
public:
	void AddSpawnableTemplateTag(const TArray<class FName>& AddTags);
	void ChangeForceOwnerShipExternal(const TArray<class FText>& ObjNames);
	void ChangeForceOwnerShipExternalFromBinding(const TArray<struct FMovieSceneObjectBindingID>& ObjBindings);
	void ChangeForceOwnerShipExternalFromTagNames(const TArray<class FName>& TagNames);
	void ChangeForceOwnerShipInnerSequence(const TArray<class FText>& ObjNames);
	void ChangeForceOwnerShipInnerSequenceALL();
	void ChangeForceOwnerShipInnerSequenceFromBinding(const TArray<struct FMovieSceneObjectBindingID>& ObjBindings);
	void ChangeForceOwnerShipInnerSequenceFromTagNames(const TArray<class FName>& TagNames);
	void ForceUpdate(float DeltaTime);
	TArray<class AActor*> GetSequenceInSpawnedActorList();
	TArray<class AActor*> GetSequenceInSpawnedActorListFromClass(TSubclassOf<class AActor> ObjClass);
	void GetSequenceInSpawnedObjectList(TArray<class UObject*>* SpawnedObjects);
	struct FMovieSceneObjectBindingID GetSequenceObjectBindingID(const class FText& ObjName, const TArray<class FName>& ObjTags, bool* IsFind);
	void GetSequenceObjectBindingIDList(const TArray<class FText>& ObjNames, const TArray<class FName>& ObjTags, TArray<struct FMovieSceneObjectBindingID>* OutBindingIDList, bool* IsFind);
	void GetSequenceObjectBindingIDListFromClass(TSubclassOf<class AActor> ObjClass, TArray<struct FMovieSceneObjectBindingID>* OutBindingIDList, TArray<class FString>* OutNameList, bool* IsFind);
	void GetSequenceObjectBindingIDListFromClassAndMatchTexts(TSubclassOf<class AActor> ObjClass, const TArray<class FText>& PerfectMatchTexts, const TArray<class FText>& SuffixTexts, TArray<struct FMovieSceneObjectBindingID>* OutMatchBindingIDList, TArray<class FString>* OutMatchNameList, bool* IsFind);
	void RemoveIsActiveSectionForShotName(const class FText& ShotName);
	void RestartParticle(const TArray<struct FMovieSceneObjectBindingID>& BindingIDList, const TArray<class ASequencerParticle*>& ParticleList);
	void SetActiveCameraCutSection(bool IsActive);
	int32 SetActiveFromShotName(const class FText& ShotName, bool IsActive, bool IsContainName);
	void SetAnimationSlotNameToInString(class FName SlotName, const class FString& InString, const class FString& ExclusionInString);
	void SetBindingByObject(const struct FMovieSceneObjectBindingID& Binding, const TArray<class UObject*>& Objects, bool bAllowBindingsFromAsset);
	float SetEventSkipEndTimeForEventName(class FName SkipName, class FName EventName, bool* IsSuccess);
	void SetPlaybackHead();
	void SetShotSequence(class UMovieSceneSequence* Sequence, const class FText& ShotName);
	void SetupParticleBinding(const TArray<struct FMovieSceneObjectBindingID>& BindingIDList, const TArray<class ASequencerParticle*>& ParticleList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSLevelSequenceActor">();
	}
	static class ARSLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSLevelSequenceActor>();
	}
};
static_assert(alignof(ARSLevelSequenceActor) == 0x000008, "Wrong alignment on ARSLevelSequenceActor");
static_assert(sizeof(ARSLevelSequenceActor) == 0x0002C0, "Wrong size on ARSLevelSequenceActor");

// Class BattlePrototype.RSManaComponent
// 0x0000 (0x0250 - 0x0250)
class URSManaComponent final : public UManaComponent
{
public:
	void StopMovie();

	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSManaComponent">();
	}
	static class URSManaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSManaComponent>();
	}
};
static_assert(alignof(URSManaComponent) == 0x000008, "Wrong alignment on URSManaComponent");
static_assert(sizeof(URSManaComponent) == 0x000250, "Wrong size on URSManaComponent");

// Class BattlePrototype.RSMaterialLibrary
// 0x0000 (0x0028 - 0x0028)
class URSMaterialLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeCharacterMaterial(class UMeshComponent* MeshComp, class UMaterialInterface* BodyMat, class UMaterialInterface* BodyLUTMat, class UMaterialInterface* EyeMat, class UMaterialInterface* EyeLUTMat, class UMaterialInterface* HairMat, class UMaterialInterface* HairLUTMat, class UMaterialInterface* SkinMat, class UMaterialInterface* SkinLUTMat, class UMaterialInterface* OutlineMat, class UMaterialInterface* OutlineLUTMat, class UMaterialInterface* MaskMat, class UMaterialInterface* MaskLUTMat, class UMaterialInterface* Wire0Mat, class UMaterialInterface* Wire1Mat, class UMaterialInterface* HologramMat, class UMaterialInterface* HoodMat, class UMaterialInterface* SheathMat, class UMaterialInterface* OtherMat, class UMaterialInterface* OtherLUTMat, const TArray<class UMaterialInterface*>& BaseLUTMaterials);
	static void ClearOverrideMaterials(class UMeshComponent* Mesh);
	static void CopyNeonWireDepthParameterNative(class UObject* WorldContextObject, int32 WireMaterialIndex, class USkeletalMeshComponent* WireDepthComp, class UMaterialInstanceDynamic* WireMaterial, class USkeletalMeshComponent* TargetMeshComp);
	static class UMaterialInstanceDynamic* CopyNeonWireDepthParameterNative2(class UObject* WorldContextObject, int32 WireMaterialIndex, class USkeletalMeshComponent* WireDepthComp, class UMaterialInstanceDynamic* WireMaterial, class USkeletalMeshComponent* TargetMeshComp, class UMaterialInterface* HologramWireMaterial, class UMaterialInterface* WireDepthMaterial, class UMaterialInterface* HologramWireDepthMaterial);
	static void DumpMaterialParameterCollection(class UObject* WorldContextObject, class UObject* Collection);
	static void EnableMaterialPreSkinFacialNormalNative(class UObject* WorldContextObject, class USkeletalMeshComponent* SkelMeshComp, bool bEnabled, bool bIsEvent);
	static void EnableMaterialPreSkinFacialNormalNPCNative(class UObject* WorldContextObject, class ANpcSkeletalMeshActor* NPCActor, bool bEnabled, bool bIsEvent);
	static bool GetDefaultScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, float* ParameterValue);
	static bool GetDefaultVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, struct FLinearColor* ParameterValue);
	static class UMaterialInterface* GetMaterialFromPath(const class FString& Path, bool Load);
	static bool GetMaterialInstanceAllScalarParameterInfo(class UMaterialInstance* MaterialInstance, TArray<struct FMaterialParameterInfo>* Info);
	static bool GetMaterialInstanceAllVectorParameterInfo(class UMaterialInstance* MaterialInstance, TArray<struct FMaterialParameterInfo>* Info);
	static bool GetMaterialInstanceParameterGroupName(class UMaterialInstance* MaterialInstance, const struct FMaterialParameterInfo& ParameterInfo, class FName* OutGroup);
	static void GetMaterialOverrideParameters(class UMaterialInstance* MaterialInstance, struct FMaterialOverrideParameters* OutParam);
	static void GetMaterialOverrideParametersALLHierarchy(class UMaterialInstance* MaterialInstance, struct FMaterialOverrideParameters* OutParam);
	static bool GetMaterialStaticSwitch(class UMaterialInterface* Material, const class FName& ParameterName, bool& StaticSwitch);
	static void GetMeshMaterialOverrideParameters(class UMeshComponent* Mesh, struct FMeshMaterialOverrideParameters* OutParam);
	static bool GetRsScalarParameterValue(class UMaterialInstance* MaterialInstance, const class FName& ParameterName, float* OutValue);
	static bool GetRsTextureParameterValue(class UMaterialInstance* MaterialInstance, const class FName& ParameterName, class UTexture2D** OutValue);
	static bool GetRsVectorParameterValue(class UMaterialInstance* MaterialInstance, const class FName& ParameterName, struct FLinearColor* OutValue);
	static bool GetScalarParameterByIndex(class UMaterialInstanceDynamic* DynamicMaterial, int32 ParameterIndex, float* OutValue);
	static bool GetScalarParameterIndex(class UMaterialInstanceDynamic* DynamicMaterial, const class FName& ParameterName, int32* OutParameterIndex);
	static bool GetVectorParameterByIndex(class UMaterialInstanceDynamic* DynamicMaterial, int32 ParameterIndex, struct FLinearColor* OutValue);
	static bool GetVectorParameterIndex(class UMaterialInstanceDynamic* DynamicMaterial, const class FName& ParameterName, int32* OutParameterIndex);
	static void ResetMIDScalarParameterValue(const TArray<class UMeshComponent*>& MeshComps, const TArray<class FName>& ParameterNames);
	static void ResetMIDScalarParameterValueFromDefault(const TArray<class UMeshComponent*>& MeshComps, const TArray<class FName>& ParameterNames);
	static void SetMaterialOverrideParameters(class UMaterialInstanceDynamic* MaterialInstanceDynamic, const struct FMaterialOverrideParameters& OutParam, bool ClearParam);
	static void SetMeshMaterialOverrideParameters(class UMeshComponent* Mesh, const struct FMeshMaterialOverrideParameters& OverrideParam, bool ClearParam);
	static bool SetScalarParameterByIndex(class UMaterialInstanceDynamic* DynamicMaterial, int32 ParameterIndex, float Value);
	static bool SetVectorParameterByIndex(class UMaterialInstanceDynamic* DynamicMaterial, int32 ParameterIndex, const struct FLinearColor& Value);
	static void UpdateMaterialPreSkinFacialNormalToSlotsNative(class UObject* WorldContextObject, class USkeletalMeshComponent* SkelMeshComp, bool bIsEvent, const TArray<int32>& MaterialSlots);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMaterialLibrary">();
	}
	static class URSMaterialLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSMaterialLibrary>();
	}
};
static_assert(alignof(URSMaterialLibrary) == 0x000008, "Wrong alignment on URSMaterialLibrary");
static_assert(sizeof(URSMaterialLibrary) == 0x000028, "Wrong size on URSMaterialLibrary");

// Class BattlePrototype.RSMaterialStaticMeshComponent
// 0x0000 (0x04A0 - 0x04A0)
class URSMaterialStaticMeshComponent final : public UStaticMeshComponent
{
public:
	void SetMaterialMeshScalar(class FName ParameterName, float Value);
	void SetMaterialMeshVector(class FName ParameterName, const struct FLinearColor& Value);
	void SetupMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMaterialStaticMeshComponent">();
	}
	static class URSMaterialStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSMaterialStaticMeshComponent>();
	}
};
static_assert(alignof(URSMaterialStaticMeshComponent) == 0x000010, "Wrong alignment on URSMaterialStaticMeshComponent");
static_assert(sizeof(URSMaterialStaticMeshComponent) == 0x0004A0, "Wrong size on URSMaterialStaticMeshComponent");

// Class BattlePrototype.UICharaSelectParts
// 0x0020 (0x03A8 - 0x0388)
class UUICharaSelectParts final : public UUIBase
{
public:
	uint8                                         Pad_26FA[0x20];                                    // 0x0388(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Cursor_select, class UWidgetAnimation* Cursor_default_none, class UWidgetAnimation* Cursor_default);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaSelectParts">();
	}
	static class UUICharaSelectParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaSelectParts>();
	}
};
static_assert(alignof(UUICharaSelectParts) == 0x000008, "Wrong alignment on UUICharaSelectParts");
static_assert(sizeof(UUICharaSelectParts) == 0x0003A8, "Wrong size on UUICharaSelectParts");

// Class BattlePrototype.RSMathFuncLib
// 0x0000 (0x0028 - 0x0028)
class URSMathFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector ClosestPointOnInfiniteLine(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& Point);
	static struct FVector ClosestPointOnLine(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& Point);
	static bool LineBoxIntersection(const struct FBox& InBox, const struct FVector& Start, const struct FVector& End, struct FVector* HitLocation, struct FVector* HitNormal, float* HitLength);
	static float PointDistToLine(const struct FVector& Point, const struct FVector& Direction, const struct FVector& Origin, struct FVector* OutClosestPoint);
	static struct FVector2D RandomLocationInCircle(float Radius, int32 RetrayMax);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMathFuncLib">();
	}
	static class URSMathFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSMathFuncLib>();
	}
};
static_assert(alignof(URSMathFuncLib) == 0x000008, "Wrong alignment on URSMathFuncLib");
static_assert(sizeof(URSMathFuncLib) == 0x000028, "Wrong size on URSMathFuncLib");

// Class BattlePrototype.RSMovieManager
// 0x0068 (0x0298 - 0x0230)
class ARSMovieManager : public AActor
{
public:
	uint8                                         Pad_26FC[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnMoviePauseEvent;                                 // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UManaTexture*, int32>              ReleaseManaTextures;                               // 0x0248(0x0050)(NativeAccessSpecifierPrivate)

public:
	bool LoadMovieTexture(const class FString& Path);
	void ResetFlags(class UManaTexture* Mana);
	bool ResetManaComponentOtherNative();
	bool SetIndividualSetting(bool Flag);
	bool SetMovieImageTexture(class UImage* Image);
	bool SetMoviePrepareSetting();
	void SetMovieTextureAndPrepare(class UManaTexture* MovieTexture);
	void SetMovieTextureNative(class UManaTexture* MovieTexture, class UMaterialInstanceDynamic* ManaMaterial);
	void TextureRelease();

	class UManaTexture* GetManaTextureNative() const;
	EManaComponentStatus GetStatusNative() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSMovieManager">();
	}
	static class ARSMovieManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSMovieManager>();
	}
};
static_assert(alignof(ARSMovieManager) == 0x000008, "Wrong alignment on ARSMovieManager");
static_assert(sizeof(ARSMovieManager) == 0x000298, "Wrong size on ARSMovieManager");
static_assert(offsetof(ARSMovieManager, OnMoviePauseEvent) == 0x000238, "Member 'ARSMovieManager::OnMoviePauseEvent' has a wrong offset!");
static_assert(offsetof(ARSMovieManager, ReleaseManaTextures) == 0x000248, "Member 'ARSMovieManager::ReleaseManaTextures' has a wrong offset!");

// Class BattlePrototype.RSNavLinkProxy
// 0x0000 (0x0280 - 0x0280)
class ARSNavLinkProxy final : public ANavLinkProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSNavLinkProxy">();
	}
	static class ARSNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSNavLinkProxy>();
	}
};
static_assert(alignof(ARSNavLinkProxy) == 0x000008, "Wrong alignment on ARSNavLinkProxy");
static_assert(sizeof(ARSNavLinkProxy) == 0x000280, "Wrong size on ARSNavLinkProxy");

// Class BattlePrototype.UINexusDriveSAS
// 0x0040 (0x03C8 - 0x0388)
class UUINexusDriveSAS : public UUIBase
{
public:
	uint8                                         Pad_26FF[0x40];                                    // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDefaultCurrentTime();
	float GetDefaultStartTime();
	float GetUsingCurrentTime();
	float GetUsingStartTime();
	void InitializeThis(class UWidgetAnimation* PAnimDefault, class UWidgetAnimation* PAnimIn, class UWidgetAnimation* PAnimOut, class UWidgetAnimation* PAnimDecision, class UWidgetAnimation* PAnimUsing, class UWidgetAnimation* PAnimReturn);
	void SetEnableSasPlayer(bool IsEnable);
	bool SetNeonColor(int32 ID);
	void SetUsingCv(bool IsUsing);
	void SetUsingDriveNpc(bool IsUsing);
	void SetUsingSasPlayer(bool IsUsing);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINexusDriveSAS">();
	}
	static class UUINexusDriveSAS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINexusDriveSAS>();
	}
};
static_assert(alignof(UUINexusDriveSAS) == 0x000008, "Wrong alignment on UUINexusDriveSAS");
static_assert(sizeof(UUINexusDriveSAS) == 0x0003C8, "Wrong size on UUINexusDriveSAS");

// Class BattlePrototype.RSNewStaticNodeActor
// 0x0000 (0x0230 - 0x0230)
class ARSNewStaticNodeActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSNewStaticNodeActor">();
	}
	static class ARSNewStaticNodeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSNewStaticNodeActor>();
	}
};
static_assert(alignof(ARSNewStaticNodeActor) == 0x000008, "Wrong alignment on ARSNewStaticNodeActor");
static_assert(sizeof(ARSNewStaticNodeActor) == 0x000230, "Wrong size on ARSNewStaticNodeActor");

// Class BattlePrototype.RSNpcAnimInstance
// 0x0060 (0x0680 - 0x0620)
class URSNpcAnimInstance final : public UASAnimInstance
{
public:
	bool                                          IsNewTownPeople;                                   // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2701[0x7];                                     // 0x0621(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WaitMotionType;                                    // 0x0628(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UASAnimationSet*                        AnimationSet;                                      // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      FacialAnimation;                                   // 0x0640(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcAnimationKind                             NpcAnimKind;                                       // 0x0648(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLookAt;                                          // 0x0649(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSit;                                             // 0x064A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2702[0x1];                                     // 0x064B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAtPoint;                                       // 0x064C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseKawaiiPhysics;                                  // 0x0658(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2703[0x3];                                     // 0x0659(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyeXAxisValue;                                     // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeYAxisValue;                                     // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HeadRot;                                           // 0x0664(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2704[0xC];                                     // 0x0674(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAnimSequenceBase* GetAnimSequenceFromAnimationSet(const class FName& Key);
	void SetAnimation(ENpcAnimationKind AnimKind);
	void SetAnimationForce(ENpcAnimationKind AnimKind);
	void SetIsLookAt(bool Param_IsLookAt);
	void SetNpcIdleAnimation(class UAnimSequenceBase* IdleAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSNpcAnimInstance">();
	}
	static class URSNpcAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSNpcAnimInstance>();
	}
};
static_assert(alignof(URSNpcAnimInstance) == 0x000010, "Wrong alignment on URSNpcAnimInstance");
static_assert(sizeof(URSNpcAnimInstance) == 0x000680, "Wrong size on URSNpcAnimInstance");
static_assert(offsetof(URSNpcAnimInstance, IsNewTownPeople) == 0x000620, "Member 'URSNpcAnimInstance::IsNewTownPeople' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, WaitMotionType) == 0x000628, "Member 'URSNpcAnimInstance::WaitMotionType' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, AnimationSet) == 0x000638, "Member 'URSNpcAnimInstance::AnimationSet' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, FacialAnimation) == 0x000640, "Member 'URSNpcAnimInstance::FacialAnimation' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, NpcAnimKind) == 0x000648, "Member 'URSNpcAnimInstance::NpcAnimKind' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, IsLookAt) == 0x000649, "Member 'URSNpcAnimInstance::IsLookAt' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, IsSit) == 0x00064A, "Member 'URSNpcAnimInstance::IsSit' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, LookAtPoint) == 0x00064C, "Member 'URSNpcAnimInstance::LookAtPoint' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, UseKawaiiPhysics) == 0x000658, "Member 'URSNpcAnimInstance::UseKawaiiPhysics' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, EyeXAxisValue) == 0x00065C, "Member 'URSNpcAnimInstance::EyeXAxisValue' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, EyeYAxisValue) == 0x000660, "Member 'URSNpcAnimInstance::EyeYAxisValue' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, HeadRot) == 0x000664, "Member 'URSNpcAnimInstance::HeadRot' has a wrong offset!");
static_assert(offsetof(URSNpcAnimInstance, StartTime) == 0x000670, "Member 'URSNpcAnimInstance::StartTime' has a wrong offset!");

// Class BattlePrototype.RSOutGameMode
// 0x0078 (0x03A0 - 0x0328)
class alignas(0x10) ARSOutGameMode : public ARSGameModeBase
{
public:
	class USaveLoadScreenParamManager*            M_pAutoSaveLoadScreenParamManager;                 // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isAsyncConvertTrial2SaveDataRequest;             // 0x0330(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EConvertTrial2SaveDataAllResult               M_ConvertTrial2SaveDataAllResult;                  // 0x0331(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2705[0x6];                                     // 0x0332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGame*                            M_AsyncConvertTrial2SaveDataClass;                 // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2706[0x60];                                    // 0x0340(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ConvertTrial2SaveDataExec();
	bool IsWorkingAsyncConvertTrial2SaveData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSOutGameMode">();
	}
	static class ARSOutGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSOutGameMode>();
	}
};
static_assert(alignof(ARSOutGameMode) == 0x000010, "Wrong alignment on ARSOutGameMode");
static_assert(sizeof(ARSOutGameMode) == 0x0003A0, "Wrong size on ARSOutGameMode");
static_assert(offsetof(ARSOutGameMode, M_pAutoSaveLoadScreenParamManager) == 0x000328, "Member 'ARSOutGameMode::M_pAutoSaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(ARSOutGameMode, M_isAsyncConvertTrial2SaveDataRequest) == 0x000330, "Member 'ARSOutGameMode::M_isAsyncConvertTrial2SaveDataRequest' has a wrong offset!");
static_assert(offsetof(ARSOutGameMode, M_ConvertTrial2SaveDataAllResult) == 0x000331, "Member 'ARSOutGameMode::M_ConvertTrial2SaveDataAllResult' has a wrong offset!");
static_assert(offsetof(ARSOutGameMode, M_AsyncConvertTrial2SaveDataClass) == 0x000338, "Member 'ARSOutGameMode::M_AsyncConvertTrial2SaveDataClass' has a wrong offset!");

// Class BattlePrototype.RSParallelObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IRSParallelObjectInterface final : public IInterface
{
public:
	ERSParallelTiming GetParallelTiming();
	bool IsEnableParallelTick();
	void ParallelTick(float DeltaTime);
	void PostParallelTick();
	void PreParallelTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParallelObjectInterface">();
	}
	static class IRSParallelObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSParallelObjectInterface>();
	}
};
static_assert(alignof(IRSParallelObjectInterface) == 0x000008, "Wrong alignment on IRSParallelObjectInterface");
static_assert(sizeof(IRSParallelObjectInterface) == 0x000028, "Wrong size on IRSParallelObjectInterface");

// Class BattlePrototype.UINumberDamage
// 0x00E8 (0x0470 - 0x0388)
class UUINumberDamage : public UUIBase
{
public:
	uint8                                         Pad_2707[0xB8];                                    // 0x0388(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              FixedMove;                                         // 0x0440(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2708[0x28];                                    // 0x0448(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimEnemy, class UWidgetAnimation* AnimEnemyCritical, class UWidgetAnimation* AnimHeal, class UWidgetAnimation* AnimNoDamage, class UWidgetAnimation* AnimSasCritical, class UWidgetAnimation* AnimBrainCrashCritical, class UImage* Number_1_1000, class UImage* Number_1_100, class UImage* Number_1_10, class UImage* Number_1_1, class UImage* Number_3_1000, class UImage* Number_3_100, class UImage* Number_3_10, class UImage* Number_3_1, class UOverlay* OverlaySetParent, class UHorizontalBox* HorizontalBoxCritialSet, class UHorizontalBox* HorizontalBoxNormalSet, class UOverlay* OverlayNoDamageSet);
	void InitializeThisEx(class UWidgetAnimation* AnimEnemy, class UWidgetAnimation* AnimEnemyCritical, class UWidgetAnimation* AnimHeal, class UWidgetAnimation* AnimNoDamage, class UWidgetAnimation* AnimSasCritical, class UWidgetAnimation* AnimBrainCrashCritical, class UImage* Number_1_100000, class UImage* Number_1_10000, class UImage* Number_1_1000, class UImage* Number_1_100, class UImage* Number_1_10, class UImage* Number_1_1, class UImage* Number_3_100000, class UImage* Number_3_10000, class UImage* Number_3_1000, class UImage* Number_3_100, class UImage* Number_3_10, class UImage* Number_3_1, class UOverlay* OverlaySetParent, class UHorizontalBox* HorizontalBoxCritialSet, class UHorizontalBox* HorizontalBoxNormalSet, class UOverlay* OverlayNoDamageSet);
	void SetFlagBrainCrashCritical(bool IsBrainCrashCritical);
	void SetFlagCritical(bool IsCritical);
	void SetFlagHeal(bool IsHeal);
	void SetFlagNoDamage(bool IsNoDamage);
	void SetFlagPlayer(bool IsPlayer);
	void SetFlagSasCritical(bool IsSasCritical);
	void SetNumber(int32 Number);
	void SetPosition2D(const struct FVector2D& Position);
	void SetPosition3D(const struct FVector& Position, const struct FVector2D& Offset);
	void SetThumbnailNumebr1(class UImage* Image, int32 Value);
	void SetThumbnailNumebr3(class UImage* Image, int32 Value);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINumberDamage">();
	}
	static class UUINumberDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINumberDamage>();
	}
};
static_assert(alignof(UUINumberDamage) == 0x000008, "Wrong alignment on UUINumberDamage");
static_assert(sizeof(UUINumberDamage) == 0x000470, "Wrong size on UUINumberDamage");
static_assert(offsetof(UUINumberDamage, FixedMove) == 0x000440, "Member 'UUINumberDamage::FixedMove' has a wrong offset!");

// Class BattlePrototype.RSParallelObjectManageComponent
// 0x0068 (0x0128 - 0x00C0)
class URSParallelObjectManageComponent final : public UActorComponent
{
public:
	TMap<ERSParallelTiming, struct FParallelData> _ParallelTimingMap;                                // 0x00C0(0x0050)(NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UObject>>         _ReserveUnregisterObjectArray;                     // 0x0110(0x0010)(ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270B[0x8];                                     // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParallelObjectManageComponent">();
	}
	static class URSParallelObjectManageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSParallelObjectManageComponent>();
	}
};
static_assert(alignof(URSParallelObjectManageComponent) == 0x000008, "Wrong alignment on URSParallelObjectManageComponent");
static_assert(sizeof(URSParallelObjectManageComponent) == 0x000128, "Wrong size on URSParallelObjectManageComponent");
static_assert(offsetof(URSParallelObjectManageComponent, _ParallelTimingMap) == 0x0000C0, "Member 'URSParallelObjectManageComponent::_ParallelTimingMap' has a wrong offset!");
static_assert(offsetof(URSParallelObjectManageComponent, _ReserveUnregisterObjectArray) == 0x000110, "Member 'URSParallelObjectManageComponent::_ReserveUnregisterObjectArray' has a wrong offset!");

// Class BattlePrototype.RSParallelObjectManager
// 0x0018 (0x0248 - 0x0230)
class ARSParallelObjectManager final : public AActor
{
public:
	uint8                                         Pad_270C[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParallelObjectManageComponent*       _AfterPrePhysicsManageComponent;                   // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSParallelObjectManageComponent*       _AfterDuringPhysicsManageComponent;                // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool RegisterObject(class UObject* Object);
	void SetSingleThread(bool bSet);
	void UnregisterObject(class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParallelObjectManager">();
	}
	static class ARSParallelObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSParallelObjectManager>();
	}
};
static_assert(alignof(ARSParallelObjectManager) == 0x000008, "Wrong alignment on ARSParallelObjectManager");
static_assert(sizeof(ARSParallelObjectManager) == 0x000248, "Wrong size on ARSParallelObjectManager");
static_assert(offsetof(ARSParallelObjectManager, _AfterPrePhysicsManageComponent) == 0x000238, "Member 'ARSParallelObjectManager::_AfterPrePhysicsManageComponent' has a wrong offset!");
static_assert(offsetof(ARSParallelObjectManager, _AfterDuringPhysicsManageComponent) == 0x000240, "Member 'ARSParallelObjectManager::_AfterDuringPhysicsManageComponent' has a wrong offset!");

// Class BattlePrototype.RSParticleStatics
// 0x0000 (0x0028 - 0x0028)
class URSParticleStatics final : public UBlueprintFunctionLibrary
{
public:
	static void SpawnEmitteDeactiveSystem(class URSParticleSystemComponentBase* PSC);
	static class URSParticleSystemComponentBase* SpawnEmitterAtLocation(const class UObject* WorldContextObject, TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, ESequencerDilationOwner DilationOwner);
	static void SpawnEmitterAtLocationNoReturnComponent(const class UObject* WorldContextObject, TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, ESequencerDilationOwner DilationOwner);
	static class URSParticleSystemComponentBase* SpawnEmitterAtLocationOptional(const class UObject* WorldContextObject, TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, const TArray<struct FParticleSysParam>& InstanceParameters, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, ESequencerDilationOwner DilationOwner);
	static class URSParticleSystemComponentBase* SpawnEmitterAttached(TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, bool bForceConnectWorld, class URSParticleSystemComponentBase* PTurnUsePSC, bool bAttachLocationOnly, ESequencerDilationOwner DilationOwner);
	static void SpawnEmitterAttachedNoReturnComponent(TSubclassOf<class URSParticleSystemComponentBase> ComponentClass, class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, const bool IsActiveSystem, bool bAutoDestroy, const class UObject* Creator, bool bForceConnectWorld, class URSParticleSystemComponentBase* PTurnUsePSC, ESequencerDilationOwner DilationOwner);
	static void StartEmitterForSpawnedComponent(class URSParticleSystemComponentBase* PPSC, const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation, const struct FVector& SpawnScale, const bool IsActiveSystem, const class UObject* Creator, ESequencerDilationOwner DilationOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParticleStatics">();
	}
	static class URSParticleStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSParticleStatics>();
	}
};
static_assert(alignof(URSParticleStatics) == 0x000008, "Wrong alignment on URSParticleStatics");
static_assert(sizeof(URSParticleStatics) == 0x000028, "Wrong size on URSParticleStatics");

// Class BattlePrototype.UIPhotoMode
// 0x01A0 (0x0528 - 0x0388)
class UUIPhotoMode : public UUIBase
{
public:
	uint8                                         Pad_271C[0x1A0];                                   // 0x0388(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeHideOnShootList(const TArray<class UWidget*>& HideOnShootList);
	void InitializeThis(class UWidgetAnimation* AnimDefault1, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut1, class UWidgetAnimation* AnimOut2, class UWidgetAnimation* AnimChange1, class UWidgetAnimation* AnimChange2, class UUIPhotoModeParts* UIPhotoModeParts, class UUIPhotoModeIndex* UiPhotoModeIndex1, class UUIPhotoModeIndex* UiPhotoModeIndex2, class UUIPhotoModeIndex* UiPhotoModeIndex3, class UUIPhotoModeIndex* UiPhotoModeIndex4, class UUIPhotoModeIndex* UiPhotoModeIndex5, class UUIPhotoModeIndex* UiPhotoModeIndex6, class UUIPhotoModeIndex* UiPhotoModeIndex7, class UUIPhotoModeIndex* UiPhotoModeIndex8, class UUIPhotoModeIndex* UiPhotoModeIndex9, class USpacer* GuideSpacer, class USpacer* GuideSpacerMenuOnOnff, const TArray<class UOverlay*>& UiOverlayOperationGuideParentList);
	void InitializeUIOnOffParentList(const TArray<class UWidget*>& UIOnOffParentList);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPhotoMode">();
	}
	static class UUIPhotoMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPhotoMode>();
	}
};
static_assert(alignof(UUIPhotoMode) == 0x000008, "Wrong alignment on UUIPhotoMode");
static_assert(sizeof(UUIPhotoMode) == 0x000528, "Wrong size on UUIPhotoMode");

// Class BattlePrototype.RSParticleSystemComponentBase
// 0x0080 (0x0700 - 0x0680)
#pragma pack(push, 0x1)
class alignas(0x10) URSParticleSystemComponentBase : public UParticleSystemComponent
{
public:
	class AActor*                                 CreatorActor;                                      // 0x0678(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrailTime;                                         // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsApplyStageSetting;                               // 0x0684(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271D[0x73];                                    // 0x0685(0x0073)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UMaterialInstanceDynamic*> GetDynamicMaterialInstanceALL();
	class FName GetEmitterName(int32 Param_Index);
	int32 GetMaterialIndexFromEmitterName(class FName EmitterName);
	bool HasTranslucencyMaterial();
	bool HasTranslucencyOrAdditiveMaterial();
	void Initialize();
	void PlayCheckFlags();
	void PlayParticleImplements();
	void ResetParticleBP();
	void RestartParticle();
	void SetAllEmitterEnable(bool bNewEnableState);
	void SetAttachedOption(bool InAttachLocationX, bool InAttachLocationY, bool InAttachLocationZ, bool InAttachRotationX, bool InAttachRotationY, bool InAttachRotationZ, bool InAttachScaleX, bool InAttachScaleY, bool InAttachScaleZ, ERSParticleSystemAttachRotationOffMode InAttachRotationOffMode);
	void SetCulling(bool InCulling);
	void SetDilationOwner(ESequencerDilationOwner InDilationOwner);
	void SetEnableDistanceCulling(bool UseCulling);
	void SetForceLOD(int32 InLODLevel);
	void SetHideDebuggingInfoScreen(bool Hide);
	void SetLocalTimeDilation(float Dilation);
	void StopAndHideParticleImplements();
	void StopParticleImplements();
	bool UseStageSetting_Native();

	void GetAttachedOptionLocation(bool* OutAttachLocationX, bool* OutAttachLocationY, bool* OutAttachLocationZ) const;
	void GetAttachedOptionRotation(bool* OutAttachRotationX, bool* OutAttachRotationY, bool* OutAttachRotationZ) const;
	void GetAttachedOptionScale(bool* OutAttachScaleX, bool* OutAttachScaleY, bool* OutAttachScaleZ) const;
	int32 GetForceLOD() const;
	bool IsAutoDestroy() const;
	bool IsCulling() const;
	bool IsEnableDistanceCulling() const;
	bool IsHideDebuggingInfoScreen() const;
	bool UseForceLOD() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParticleSystemComponentBase">();
	}
	static class URSParticleSystemComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSParticleSystemComponentBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(URSParticleSystemComponentBase) == 0x000010, "Wrong alignment on URSParticleSystemComponentBase");
static_assert(sizeof(URSParticleSystemComponentBase) == 0x000700, "Wrong size on URSParticleSystemComponentBase");
static_assert(offsetof(URSParticleSystemComponentBase, CreatorActor) == 0x000678, "Member 'URSParticleSystemComponentBase::CreatorActor' has a wrong offset!");
static_assert(offsetof(URSParticleSystemComponentBase, TrailTime) == 0x000680, "Member 'URSParticleSystemComponentBase::TrailTime' has a wrong offset!");
static_assert(offsetof(URSParticleSystemComponentBase, IsApplyStageSetting) == 0x000684, "Member 'URSParticleSystemComponentBase::IsApplyStageSetting' has a wrong offset!");

// Class BattlePrototype.RSParticleSystemManager
// 0x27F8 (0x2A28 - 0x0230)
class ARSParticleSystemManager : public AActor
{
public:
	uint8                                         Pad_271E[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             FootStepDataTable;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCharacterPhysicalSurfaceActionEffectResource*> MapFootStep;                                       // 0x0248(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGeneralPhysicalSurfaceActionEffectResourceArray> MapGeneralPhysicalActions;                         // 0x0298(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class URSParticleSystemComponentBase*> Components;                                        // 0x02E8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitParticle>                   HitParticles;                                      // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDamageParticle>                DamageParticles;                                   // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpecialDamageParticle>         SpecialDamageParticles;                            // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleComponentListManager*>  ParticleComponentListManagers;                     // 0x0328(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UParticleComponentListManager*> M_AnimNotifyParticleCompListMngMap;                // 0x0338(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         SeeThroughRate;                                    // 0x0388(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271F[0x14];                                    // 0x038C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACullDistanceEffectBackgroundVolume*> CullDistanceBGVolumes;                             // 0x03A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistanceBG;                                    // 0x03B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2720[0x2650];                                  // 0x03B4(0x2650)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ManageHitEffectNum;                                // 0x2A04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManageEffectStopEndTrail;                         // 0x2A08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2721[0x7];                                     // 0x2A09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class URSParticleSystemComponentBase>> PlayHitEffectManageList;                           // 0x2A10(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2722[0x8];                                     // 0x2A20(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAllParticles(bool IsReset);
	void AddBackGroundParticle(class URSParticleSystemComponentBase* EffectBG);
	void ClearBackGroundParticle();
	void CullEffectAtStaticEvent(const struct FVector& CameraLocation);
	void DeactivateAllParticles();
	void DumpBackgroundCellList();
	void EventOnSystemFinishedSeeThroughParticle(class UParticleSystemComponent* PSystem);
	class UParticleSystem* GetGeneralPhysicalSurfaceActionResource(const EGamePhysicalSurfaceType PhysicsType, class FName ActionType);
	class UCharacterPhysicalSurfaceActionEffectResource* LoadFootStep(class FName NameId);
	void ParticleOnSystemFinished(class UParticleSystemComponent* PPSC);
	void PlayHitDamage(const struct FHitDamageInfo& Info);
	void RegisterComponent(class URSParticleSystemComponentBase* Component);
	void RegisterSeeThroughParticle(class URSParticleSystemComponentBase* Particle);
	void RemoveBackGroundParticle(class URSParticleSystemComponentBase* EffectBG);
	void ResetDebrisMaterial(class UParticleSystemComponent* PSystem);
	void SetBackgroundParameter(const struct FParticleSystemBackGroundParameter& Parameter);
	void SetDebugBackgroundInformation(bool bDebug);
	void SetSeeThroughRate(float Rate);
	void StartCheckBackgroundCull(const struct FVector& CheckLocation, bool OneFrameUpdate);
	bool UnloadFootStep(class FName NameId);
	void UnregisterComponent(class URSParticleSystemComponentBase* Component);
	void UnregisterComponentAll();
	void UnregisterSeeThroughParticle(class URSParticleSystemComponentBase* Particle);

	void DumpManagedParticles() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParticleSystemManager">();
	}
	static class ARSParticleSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSParticleSystemManager>();
	}
};
static_assert(alignof(ARSParticleSystemManager) == 0x000008, "Wrong alignment on ARSParticleSystemManager");
static_assert(sizeof(ARSParticleSystemManager) == 0x002A28, "Wrong size on ARSParticleSystemManager");
static_assert(offsetof(ARSParticleSystemManager, FootStepDataTable) == 0x000240, "Member 'ARSParticleSystemManager::FootStepDataTable' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, MapFootStep) == 0x000248, "Member 'ARSParticleSystemManager::MapFootStep' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, MapGeneralPhysicalActions) == 0x000298, "Member 'ARSParticleSystemManager::MapGeneralPhysicalActions' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, Components) == 0x0002E8, "Member 'ARSParticleSystemManager::Components' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, HitParticles) == 0x0002F8, "Member 'ARSParticleSystemManager::HitParticles' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, DamageParticles) == 0x000308, "Member 'ARSParticleSystemManager::DamageParticles' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, SpecialDamageParticles) == 0x000318, "Member 'ARSParticleSystemManager::SpecialDamageParticles' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, ParticleComponentListManagers) == 0x000328, "Member 'ARSParticleSystemManager::ParticleComponentListManagers' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, M_AnimNotifyParticleCompListMngMap) == 0x000338, "Member 'ARSParticleSystemManager::M_AnimNotifyParticleCompListMngMap' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, SeeThroughRate) == 0x000388, "Member 'ARSParticleSystemManager::SeeThroughRate' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, CullDistanceBGVolumes) == 0x0003A0, "Member 'ARSParticleSystemManager::CullDistanceBGVolumes' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, CullDistanceBG) == 0x0003B0, "Member 'ARSParticleSystemManager::CullDistanceBG' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, ManageHitEffectNum) == 0x002A04, "Member 'ARSParticleSystemManager::ManageHitEffectNum' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, bManageEffectStopEndTrail) == 0x002A08, "Member 'ARSParticleSystemManager::bManageEffectStopEndTrail' has a wrong offset!");
static_assert(offsetof(ARSParticleSystemManager, PlayHitEffectManageList) == 0x002A10, "Member 'ARSParticleSystemManager::PlayHitEffectManageList' has a wrong offset!");

// Class BattlePrototype.RSParticleTrailSystemComponent
// 0x0020 (0x0720 - 0x0700)
class URSParticleTrailSystemComponent final : public URSParticleSystemComponentBase
{
public:
	class FName                                   FirstSocketName;                                   // 0x06F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocketName;                                  // 0x0700(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               WidthScaleMode;                                    // 0x0708(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2727[0x3];                                     // 0x0709(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidthScale;                                        // 0x070C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeRate;                                          // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FadeOutMaterialScalarName;                         // 0x0714(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2728[0x4];                                     // 0x071C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSParticleTrailSystemComponent">();
	}
	static class URSParticleTrailSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSParticleTrailSystemComponent>();
	}
};
static_assert(alignof(URSParticleTrailSystemComponent) == 0x000010, "Wrong alignment on URSParticleTrailSystemComponent");
static_assert(sizeof(URSParticleTrailSystemComponent) == 0x000720, "Wrong size on URSParticleTrailSystemComponent");
static_assert(offsetof(URSParticleTrailSystemComponent, FirstSocketName) == 0x0006F8, "Member 'URSParticleTrailSystemComponent::FirstSocketName' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, SecondSocketName) == 0x000700, "Member 'URSParticleTrailSystemComponent::SecondSocketName' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, WidthScaleMode) == 0x000708, "Member 'URSParticleTrailSystemComponent::WidthScaleMode' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, WidthScale) == 0x00070C, "Member 'URSParticleTrailSystemComponent::WidthScale' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, FadeRate) == 0x000710, "Member 'URSParticleTrailSystemComponent::FadeRate' has a wrong offset!");
static_assert(offsetof(URSParticleTrailSystemComponent, FadeOutMaterialScalarName) == 0x000714, "Member 'URSParticleTrailSystemComponent::FadeOutMaterialScalarName' has a wrong offset!");

// Class BattlePrototype.RSPlayerAnimInstance
// 0x0200 (0x0820 - 0x0620)
class URSPlayerAnimInstance final : public URSCharacterAnimInstance
{
public:
	EPlayerAnimKind                               RequestAnimKind;                                   // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2729[0x3];                                     // 0x0621(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequestAnimParam;                                  // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipPhysics;                                      // 0x0628(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSkipPhysics;                                // 0x0629(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272A[0x2];                                     // 0x062A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftStickPower;                                    // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftStickPrevDiff;                                 // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerWalkRunStateKind                       WalkRunStateKind;                                  // 0x0634(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272B[0x3];                                     // 0x0635(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkSpeed;                                         // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkDir;                                           // 0x063C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWalkStopAble;                                     // 0x0640(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272C[0x3];                                     // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StepDirection;                                     // 0x0644(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAnimDir                                AnimParamDir;                                      // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272D[0x3];                                     // 0x0651(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SprintBank;                                        // 0x0654(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HeadRot;                                           // 0x0660(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SpineAimRot;                                       // 0x066C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUniquePsychicAimFlag;                             // 0x0678(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattling;                                         // 0x0679(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTalkMode;                                         // 0x067A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAjitoFlag;                                        // 0x067B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlyingAnimation;                                  // 0x067C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCaptureBlend;                                  // 0x067D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaptureBlendRateBack;                             // 0x067E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272E[0x1];                                     // 0x067F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CaptureBlendRate;                                  // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseKawaiiPhysics;                                  // 0x0684(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERSCharaRestrictionState                      RestrictionState;                                  // 0x0685(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272F[0x2];                                     // 0x0686(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchChangeNowAnimKind;                         // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchChangeWalkRunStateKind;                    // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageStarted;                            // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             DispatchMontageEnded;                              // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                HandIK_Offset;                                     // 0x06D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharacterIK_Offset;                                // 0x06E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandIK_Alpha;                                      // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RigidbodyAlpha;                                    // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RigidIdlingSec;                                    // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsIdlingSec;                             // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddDamageBlendRate;                                // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDispDebugLog;                                     // 0x0704(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAnimKind                               NowAnimKind;                                       // 0x0705(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerAnimKind                               OldAnimKind;                                       // 0x0706(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSubstateLastMotion;                               // 0x0707(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           DelayTimerHandle;                                  // 0x0708(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPlayerAnimTransitionKind                     DelayTransition;                                   // 0x0710(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2730[0x3];                                     // 0x0711(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FDelayActorDilation;                               // 0x0714(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeHorizontal;                                     // 0x0718(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeVertical;                                       // 0x071C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeBlendRate;                                      // 0x0720(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2731[0x4];                                     // 0x0724(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           _bEnableEyeControl;                                // 0x0728(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FloorCheckAngle;                                   // 0x0738(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKFootInterpSpeed;                             // 0x073C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKFootInterpSpeedUnderGround;                  // 0x0740(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKFootInterpSpeedFloaingFoot;                  // 0x0744(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKFootInterpSpeedCheckGroundOffset;            // 0x0748(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKMeshInterpSpeed;                             // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKMeshFloatingInterpSpeed;                     // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckHeightTop;                              // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckHeightBottom;                           // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUpperHeight;                                // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUpperHeightRun;                             // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUpperHeightSprint;                          // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUnderHeight;                                // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUnderHeightRun;                             // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUnderHeightSprint;                          // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootUnderHeightAjito;                           // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootHeightDiff;                                 // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootHeightDiffSlopeUp;                          // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFootHeightDiffSlopeDown;                        // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreInterpFootRange;                             // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootIKBlendRate;                                   // 0x0788(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKOffset_Left;                                 // 0x078C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKOffset_Right;                                // 0x0798(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKJointTargetLocation_Left;                    // 0x07A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootIKJointTargetLocation_Right;                   // 0x07B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _MeshOffset;                                       // 0x07BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2732[0x60];                                    // 0x07C0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetFootIKGroundLocation(struct FVector* OutFootLeft, struct FVector* OutFootRight);
	void OnChangeAnimKind();
	void ReceiveTransitionNotify(EPlayerAnimTransitionKind Transition);
	void ReceiveTransitionNotifyDelay(EPlayerAnimTransitionKind Transition, float DelayTime);
	void RecvOnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void RecvOnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void RecvOnMontageStarted(class UAnimMontage* Montage);
	void ReregistReceiveTransitionNotifyDelay();
	void SetAttackFootHeightDiff(bool bUse, float Diff, float SlopeDownDiff);
	void SetAttackMaxFootUnderHeight(bool bUse, float Height, float SlopeDownHeight);
	void SetAttackMaxFootUpperHeight(bool bUse, float Height, float SlopeDownHeight);
	void SetCaptureBlend(bool bUse, bool bBack, float BlendRate);
	void SetEnableFootIK(bool bEnable, float BlendTime);
	void SetEyeControlEnable(bool bEnable, class FName ClaimantName);
	void SetEyeControlParameter(float Horizontal, float Vertical);
	void SetWalkRunStateKind(EPlayerWalkRunStateKind Kind);

	EPlayerAnimKind GetNowAnimKind() const;
	bool IsCheckIdle() const;
	bool IsExistRequest() const;
	bool IsRequestKind(EPlayerAnimKind Kind) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerAnimInstance">();
	}
	static class URSPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSPlayerAnimInstance>();
	}
};
static_assert(alignof(URSPlayerAnimInstance) == 0x000010, "Wrong alignment on URSPlayerAnimInstance");
static_assert(sizeof(URSPlayerAnimInstance) == 0x000820, "Wrong size on URSPlayerAnimInstance");
static_assert(offsetof(URSPlayerAnimInstance, RequestAnimKind) == 0x000620, "Member 'URSPlayerAnimInstance::RequestAnimKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, RequestAnimParam) == 0x000624, "Member 'URSPlayerAnimInstance::RequestAnimParam' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bSkipPhysics) == 0x000628, "Member 'URSPlayerAnimInstance::bSkipPhysics' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bIgnoreSkipPhysics) == 0x000629, "Member 'URSPlayerAnimInstance::bIgnoreSkipPhysics' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, LeftStickPower) == 0x00062C, "Member 'URSPlayerAnimInstance::LeftStickPower' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, LeftStickPrevDiff) == 0x000630, "Member 'URSPlayerAnimInstance::LeftStickPrevDiff' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, WalkRunStateKind) == 0x000634, "Member 'URSPlayerAnimInstance::WalkRunStateKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, WalkSpeed) == 0x000638, "Member 'URSPlayerAnimInstance::WalkSpeed' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, WalkDir) == 0x00063C, "Member 'URSPlayerAnimInstance::WalkDir' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bWalkStopAble) == 0x000640, "Member 'URSPlayerAnimInstance::bWalkStopAble' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, StepDirection) == 0x000644, "Member 'URSPlayerAnimInstance::StepDirection' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, AnimParamDir) == 0x000650, "Member 'URSPlayerAnimInstance::AnimParamDir' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, SprintBank) == 0x000654, "Member 'URSPlayerAnimInstance::SprintBank' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, HeadRot) == 0x000660, "Member 'URSPlayerAnimInstance::HeadRot' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, SpineAimRot) == 0x00066C, "Member 'URSPlayerAnimInstance::SpineAimRot' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bUniquePsychicAimFlag) == 0x000678, "Member 'URSPlayerAnimInstance::bUniquePsychicAimFlag' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bBattling) == 0x000679, "Member 'URSPlayerAnimInstance::bBattling' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bTalkMode) == 0x00067A, "Member 'URSPlayerAnimInstance::bTalkMode' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bAjitoFlag) == 0x00067B, "Member 'URSPlayerAnimInstance::bAjitoFlag' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bFlyingAnimation) == 0x00067C, "Member 'URSPlayerAnimInstance::bFlyingAnimation' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bUseCaptureBlend) == 0x00067D, "Member 'URSPlayerAnimInstance::bUseCaptureBlend' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bCaptureBlendRateBack) == 0x00067E, "Member 'URSPlayerAnimInstance::bCaptureBlendRateBack' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, CaptureBlendRate) == 0x000680, "Member 'URSPlayerAnimInstance::CaptureBlendRate' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, UseKawaiiPhysics) == 0x000684, "Member 'URSPlayerAnimInstance::UseKawaiiPhysics' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, RestrictionState) == 0x000685, "Member 'URSPlayerAnimInstance::RestrictionState' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchChangeNowAnimKind) == 0x000688, "Member 'URSPlayerAnimInstance::DispatchChangeNowAnimKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchChangeWalkRunStateKind) == 0x000698, "Member 'URSPlayerAnimInstance::DispatchChangeWalkRunStateKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchMontageStarted) == 0x0006A8, "Member 'URSPlayerAnimInstance::DispatchMontageStarted' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchMontageBlendingOut) == 0x0006B8, "Member 'URSPlayerAnimInstance::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DispatchMontageEnded) == 0x0006C8, "Member 'URSPlayerAnimInstance::DispatchMontageEnded' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, HandIK_Offset) == 0x0006D8, "Member 'URSPlayerAnimInstance::HandIK_Offset' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, CharacterIK_Offset) == 0x0006E4, "Member 'URSPlayerAnimInstance::CharacterIK_Offset' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, HandIK_Alpha) == 0x0006F0, "Member 'URSPlayerAnimInstance::HandIK_Alpha' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, RigidbodyAlpha) == 0x0006F4, "Member 'URSPlayerAnimInstance::RigidbodyAlpha' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, RigidIdlingSec) == 0x0006F8, "Member 'URSPlayerAnimInstance::RigidIdlingSec' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, AnimDynamicsIdlingSec) == 0x0006FC, "Member 'URSPlayerAnimInstance::AnimDynamicsIdlingSec' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, AddDamageBlendRate) == 0x000700, "Member 'URSPlayerAnimInstance::AddDamageBlendRate' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bDispDebugLog) == 0x000704, "Member 'URSPlayerAnimInstance::bDispDebugLog' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, NowAnimKind) == 0x000705, "Member 'URSPlayerAnimInstance::NowAnimKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, OldAnimKind) == 0x000706, "Member 'URSPlayerAnimInstance::OldAnimKind' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, bSubstateLastMotion) == 0x000707, "Member 'URSPlayerAnimInstance::bSubstateLastMotion' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DelayTimerHandle) == 0x000708, "Member 'URSPlayerAnimInstance::DelayTimerHandle' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, DelayTransition) == 0x000710, "Member 'URSPlayerAnimInstance::DelayTransition' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FDelayActorDilation) == 0x000714, "Member 'URSPlayerAnimInstance::FDelayActorDilation' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, EyeHorizontal) == 0x000718, "Member 'URSPlayerAnimInstance::EyeHorizontal' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, EyeVertical) == 0x00071C, "Member 'URSPlayerAnimInstance::EyeVertical' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, EyeBlendRate) == 0x000720, "Member 'URSPlayerAnimInstance::EyeBlendRate' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, _bEnableEyeControl) == 0x000728, "Member 'URSPlayerAnimInstance::_bEnableEyeControl' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FloorCheckAngle) == 0x000738, "Member 'URSPlayerAnimInstance::FloorCheckAngle' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKFootInterpSpeed) == 0x00073C, "Member 'URSPlayerAnimInstance::FootIKFootInterpSpeed' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKFootInterpSpeedUnderGround) == 0x000740, "Member 'URSPlayerAnimInstance::FootIKFootInterpSpeedUnderGround' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKFootInterpSpeedFloaingFoot) == 0x000744, "Member 'URSPlayerAnimInstance::FootIKFootInterpSpeedFloaingFoot' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKFootInterpSpeedCheckGroundOffset) == 0x000748, "Member 'URSPlayerAnimInstance::FootIKFootInterpSpeedCheckGroundOffset' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKMeshInterpSpeed) == 0x00074C, "Member 'URSPlayerAnimInstance::FootIKMeshInterpSpeed' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKMeshFloatingInterpSpeed) == 0x000750, "Member 'URSPlayerAnimInstance::FootIKMeshFloatingInterpSpeed' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, GroundCheckHeightTop) == 0x000754, "Member 'URSPlayerAnimInstance::GroundCheckHeightTop' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, GroundCheckHeightBottom) == 0x000758, "Member 'URSPlayerAnimInstance::GroundCheckHeightBottom' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUpperHeight) == 0x00075C, "Member 'URSPlayerAnimInstance::MaxFootUpperHeight' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUpperHeightRun) == 0x000760, "Member 'URSPlayerAnimInstance::MaxFootUpperHeightRun' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUpperHeightSprint) == 0x000764, "Member 'URSPlayerAnimInstance::MaxFootUpperHeightSprint' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUnderHeight) == 0x000768, "Member 'URSPlayerAnimInstance::MaxFootUnderHeight' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUnderHeightRun) == 0x00076C, "Member 'URSPlayerAnimInstance::MaxFootUnderHeightRun' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUnderHeightSprint) == 0x000770, "Member 'URSPlayerAnimInstance::MaxFootUnderHeightSprint' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootUnderHeightAjito) == 0x000774, "Member 'URSPlayerAnimInstance::MaxFootUnderHeightAjito' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootHeightDiff) == 0x000778, "Member 'URSPlayerAnimInstance::MaxFootHeightDiff' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootHeightDiffSlopeUp) == 0x00077C, "Member 'URSPlayerAnimInstance::MaxFootHeightDiffSlopeUp' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, MaxFootHeightDiffSlopeDown) == 0x000780, "Member 'URSPlayerAnimInstance::MaxFootHeightDiffSlopeDown' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, IgnoreInterpFootRange) == 0x000784, "Member 'URSPlayerAnimInstance::IgnoreInterpFootRange' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKBlendRate) == 0x000788, "Member 'URSPlayerAnimInstance::FootIKBlendRate' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKOffset_Left) == 0x00078C, "Member 'URSPlayerAnimInstance::FootIKOffset_Left' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKOffset_Right) == 0x000798, "Member 'URSPlayerAnimInstance::FootIKOffset_Right' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKJointTargetLocation_Left) == 0x0007A4, "Member 'URSPlayerAnimInstance::FootIKJointTargetLocation_Left' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, FootIKJointTargetLocation_Right) == 0x0007B0, "Member 'URSPlayerAnimInstance::FootIKJointTargetLocation_Right' has a wrong offset!");
static_assert(offsetof(URSPlayerAnimInstance, _MeshOffset) == 0x0007BC, "Member 'URSPlayerAnimInstance::_MeshOffset' has a wrong offset!");

// Class BattlePrototype.RSPlayerCameraManager
// 0x0000 (0x34D0 - 0x34D0)
class ARSPlayerCameraManager : public APlayerCameraManager
{
public:
	void ClearCameraShakeCache();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerCameraManager">();
	}
	static class ARSPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSPlayerCameraManager>();
	}
};
static_assert(alignof(ARSPlayerCameraManager) == 0x000010, "Wrong alignment on ARSPlayerCameraManager");
static_assert(sizeof(ARSPlayerCameraManager) == 0x0034D0, "Wrong size on ARSPlayerCameraManager");

// Class BattlePrototype.RSPlayerController
// 0x0008 (0x05A0 - 0x0598)
class ARSPlayerController : public APlayerController
{
public:
	uint8                                         Pad_273C[0x8];                                     // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDisableForceFeedback(bool bDisable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerController">();
	}
	static class ARSPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSPlayerController>();
	}
};
static_assert(alignof(ARSPlayerController) == 0x000008, "Wrong alignment on ARSPlayerController");
static_assert(sizeof(ARSPlayerController) == 0x0005A0, "Wrong size on ARSPlayerController");

// Class BattlePrototype.RSPlayerHologramAnimInstance
// 0x0030 (0x02A0 - 0x0270)
class URSPlayerHologramAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_273D[0x8];                                     // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _bUseMontage;                                      // 0x0278(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273E[0x3];                                     // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SpineAimRot;                                       // 0x027C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseWeaponRoot;                                    // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273F[0x3];                                     // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WeaponRootLocation;                                // 0x028C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2740[0x8];                                     // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerHologramAnimInstance">();
	}
	static class URSPlayerHologramAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSPlayerHologramAnimInstance>();
	}
};
static_assert(alignof(URSPlayerHologramAnimInstance) == 0x000010, "Wrong alignment on URSPlayerHologramAnimInstance");
static_assert(sizeof(URSPlayerHologramAnimInstance) == 0x0002A0, "Wrong size on URSPlayerHologramAnimInstance");
static_assert(offsetof(URSPlayerHologramAnimInstance, _bUseMontage) == 0x000278, "Member 'URSPlayerHologramAnimInstance::_bUseMontage' has a wrong offset!");
static_assert(offsetof(URSPlayerHologramAnimInstance, SpineAimRot) == 0x00027C, "Member 'URSPlayerHologramAnimInstance::SpineAimRot' has a wrong offset!");
static_assert(offsetof(URSPlayerHologramAnimInstance, bUseWeaponRoot) == 0x000288, "Member 'URSPlayerHologramAnimInstance::bUseWeaponRoot' has a wrong offset!");
static_assert(offsetof(URSPlayerHologramAnimInstance, WeaponRootLocation) == 0x00028C, "Member 'URSPlayerHologramAnimInstance::WeaponRootLocation' has a wrong offset!");

// Class BattlePrototype.UIConfigSelectMulti
// 0x0068 (0x0468 - 0x0400)
class UUIConfigSelectMulti : public UUIConfigSelectBase
{
public:
	uint8                                         Pad_2741[0x68];                                    // 0x0400(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefaultGlay, class UWidgetAnimation* AnimSelectGlay, class UWidgetAnimation* AnimInGlay, class UWidgetAnimation* AnimOutGlay, class UTextBlock* TextTitle, class UTextBlock* TextParameter);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelectMulti">();
	}
	static class UUIConfigSelectMulti* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelectMulti>();
	}
};
static_assert(alignof(UUIConfigSelectMulti) == 0x000008, "Wrong alignment on UUIConfigSelectMulti");
static_assert(sizeof(UUIConfigSelectMulti) == 0x000468, "Wrong size on UUIConfigSelectMulti");

// Class BattlePrototype.RSPlayerHologramAnimInstanceInterface
// 0x0000 (0x0028 - 0x0028)
class IRSPlayerHologramAnimInstanceInterface final : public IInterface
{
public:
	void RequestAnim(EPlayerHologramAnimKind Kind);
	void SetAimRotator(const struct FRotator& Rotator);
	void SetUseMontage(bool bUse);
	void SetWeaponRootLocation(bool bUse, const struct FVector& Location);

	bool IsRequestAnimKind(EPlayerHologramAnimKind Kind) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerHologramAnimInstanceInterface">();
	}
	static class IRSPlayerHologramAnimInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSPlayerHologramAnimInstanceInterface>();
	}
};
static_assert(alignof(IRSPlayerHologramAnimInstanceInterface) == 0x000008, "Wrong alignment on IRSPlayerHologramAnimInstanceInterface");
static_assert(sizeof(IRSPlayerHologramAnimInstanceInterface) == 0x000028, "Wrong size on IRSPlayerHologramAnimInstanceInterface");

// Class BattlePrototype.RSPlayerSubAnimInstance
// 0x0010 (0x0280 - 0x0270)
class URSPlayerSubAnimInstance : public UAnimInstance
{
public:
	float                                         PhysicsAlpha;                                      // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsIdlingSec;                                  // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKawaiiPhysics;                                    // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2743[0x7];                                     // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSPlayerSubAnimInstance">();
	}
	static class URSPlayerSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSPlayerSubAnimInstance>();
	}
};
static_assert(alignof(URSPlayerSubAnimInstance) == 0x000010, "Wrong alignment on URSPlayerSubAnimInstance");
static_assert(sizeof(URSPlayerSubAnimInstance) == 0x000280, "Wrong size on URSPlayerSubAnimInstance");
static_assert(offsetof(URSPlayerSubAnimInstance, PhysicsAlpha) == 0x000270, "Member 'URSPlayerSubAnimInstance::PhysicsAlpha' has a wrong offset!");
static_assert(offsetof(URSPlayerSubAnimInstance, PhysicsIdlingSec) == 0x000274, "Member 'URSPlayerSubAnimInstance::PhysicsIdlingSec' has a wrong offset!");
static_assert(offsetof(URSPlayerSubAnimInstance, bKawaiiPhysics) == 0x000278, "Member 'URSPlayerSubAnimInstance::bKawaiiPhysics' has a wrong offset!");

// Class BattlePrototype.RSSaveGame
// 0x00A8 (0x00D0 - 0x0028)
class URSSaveGame final : public UObject
{
public:
	class URSGameInstance*                        M_gameInst;                                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERSSaveGameSaveType                           M_saveType;                                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2744[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, struct FSaveDataParameter>       M_saveParam;                                       // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	uint32                                        M_MasterVersion;                                   // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2745[0x4];                                     // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveDataSlotBuffer>            M_slotBufferList;                                  // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSaveDataSlotBuffer                    M_systemBuffer;                                    // 0x00A0(0x0010)(NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_SaveLoadScreenParamManager;                      // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERedSaveExistsResult                          M_SaveExistsResult;                                // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EConvertTrial2SaveDataAllResult               M_ConvertTrial2SaveDataAllResult;                  // 0x00B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2746[0x6];                                     // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGameInternal*                    M_pAsyncAutoSaveRSSaveGameInternal;                // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2747[0x8];                                     // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AsyncAutoSave();
	bool AutoDelete(int32 SlotNo, const bool IsFileDelete);
	bool AutoLoad();
	bool AutoPreLoad();
	bool AutoSave();
	bool CheckAriseCollaboration();
	void Clear();
	bool DebugLoad(int32 DataNo);
	bool DebugLoad_DirectName(const class FString& Filename);
	bool DebugSave(int32 DataNo);
	bool DebugTimeSave();
	bool Delete(int32 SlotNo, const bool IsFileDelete);
	bool DeleteData(ERSSaveGameSaveType Type, const class FString& Filename, const int32 UserIndex);
	EConvertTrial2SaveDataAllResult GetConvertTrial2SaveDataAllResult();
	ERedSaveExistsResult GetSaveExistsResult();
	bool GetSaveLoadScreenParam(struct FSaveLoadScreenParam* SlotParam, int32 SlotNo);
	void Initialize(class URSGameInstance* GameInst, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	bool IsExistSaveData(ERSSaveGameSaveType Type);
	bool Load(int32 SlotNo);
	bool LoadNormalOnly(int32 SlotNo);
	bool LoadRetryData();
	bool LoadTrial();
	bool LoadTrial2();
	bool PreLoad();
	bool PreLoadNormalOnly();
	bool Save(int32 DataNo);
	bool SaveNormalOnly(int32 DataNo);
	bool SaveRetryData();
	bool SystemDataDelete(int32 SlotNo, const bool IsFileDelete);
	bool SystemLoad();
	bool SystemSave();
	bool Trial2AchievementSaveDataCheck();
	bool TrialBonusRewardSaveDataCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSaveGame">();
	}
	static class URSSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSaveGame>();
	}
};
static_assert(alignof(URSSaveGame) == 0x000008, "Wrong alignment on URSSaveGame");
static_assert(sizeof(URSSaveGame) == 0x0000D0, "Wrong size on URSSaveGame");
static_assert(offsetof(URSSaveGame, M_gameInst) == 0x000028, "Member 'URSSaveGame::M_gameInst' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_saveType) == 0x000030, "Member 'URSSaveGame::M_saveType' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_saveParam) == 0x000038, "Member 'URSSaveGame::M_saveParam' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_MasterVersion) == 0x000088, "Member 'URSSaveGame::M_MasterVersion' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_slotBufferList) == 0x000090, "Member 'URSSaveGame::M_slotBufferList' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_systemBuffer) == 0x0000A0, "Member 'URSSaveGame::M_systemBuffer' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_SaveLoadScreenParamManager) == 0x0000B0, "Member 'URSSaveGame::M_SaveLoadScreenParamManager' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_SaveExistsResult) == 0x0000B8, "Member 'URSSaveGame::M_SaveExistsResult' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_ConvertTrial2SaveDataAllResult) == 0x0000B9, "Member 'URSSaveGame::M_ConvertTrial2SaveDataAllResult' has a wrong offset!");
static_assert(offsetof(URSSaveGame, M_pAsyncAutoSaveRSSaveGameInternal) == 0x0000C0, "Member 'URSSaveGame::M_pAsyncAutoSaveRSSaveGameInternal' has a wrong offset!");

// Class BattlePrototype.RSSaveGameUtility
// 0x0000 (0x0028 - 0x0028)
class URSSaveGameUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AutoLoadGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static void AutoPreLoadGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static void AutoSaveGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static bool CheckStorageSpace(class UObject* WorldContextObject);
	static bool IsExistSaveData(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager, ERSSaveGameSaveType Type);
	static void LoadGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static void SaveGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager, int32 No);
	static void SystemLoadGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);
	static void SystemSaveGame(class UObject* WorldContextObject, class USaveLoadScreenParamManager* PSaveLoadScreenParamManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSaveGameUtility">();
	}
	static class URSSaveGameUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSaveGameUtility>();
	}
};
static_assert(alignof(URSSaveGameUtility) == 0x000008, "Wrong alignment on URSSaveGameUtility");
static_assert(sizeof(URSSaveGameUtility) == 0x000028, "Wrong size on URSSaveGameUtility");

// Class BattlePrototype.UIDetailMap
// 0x0080 (0x0408 - 0x0388)
class UUIDetailMap : public UUIBase
{
public:
	class FName                                   M_SceneName;                                       // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABP_UI_SceneMap*                        M_ParentSceneMap;                                  // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2758[0x48];                                    // 0x0398(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pHudBase;                                        // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2759[0x20];                                    // 0x03E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ControlDetailMap(int32 SubState);
	bool CreateDetailMap();
	TSubclassOf<class ABP_UI_SceneMap> GetDetaileMapRefalence(const class FString& Path);
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_, class UWidgetAnimation* Iconinfoin, class UWidgetAnimation* Iconinfoout, class UWidgetAnimation* Default_iconinfo_none);
	bool InitializeDataDetailMap();
	void InitializeDetailMap();
	void InitializeMouseRectWidget(class UREDOverlay* Pc_pg1_1, class UREDOverlay* Pc_pg1_2, class UREDOverlay* Pc_pg2_2, class UREDOverlay* Pc_pg2_1);
	bool ReleaseDetailMap();
	bool TextFixDataDetailMap(int32 LocationNo);
	void UpdateStateDetailMap(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDetailMap">();
	}
	static class UUIDetailMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDetailMap>();
	}
};
static_assert(alignof(UUIDetailMap) == 0x000008, "Wrong alignment on UUIDetailMap");
static_assert(sizeof(UUIDetailMap) == 0x000408, "Wrong size on UUIDetailMap");
static_assert(offsetof(UUIDetailMap, M_SceneName) == 0x000388, "Member 'UUIDetailMap::M_SceneName' has a wrong offset!");
static_assert(offsetof(UUIDetailMap, M_ParentSceneMap) == 0x000390, "Member 'UUIDetailMap::M_ParentSceneMap' has a wrong offset!");
static_assert(offsetof(UUIDetailMap, M_pHudBase) == 0x0003E0, "Member 'UUIDetailMap::M_pHudBase' has a wrong offset!");

// Class BattlePrototype.RSSaveGameInterface
// 0x0000 (0x0028 - 0x0028)
class IRSSaveGameInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSaveGameInterface">();
	}
	static class IRSSaveGameInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSSaveGameInterface>();
	}
};
static_assert(alignof(IRSSaveGameInterface) == 0x000008, "Wrong alignment on IRSSaveGameInterface");
static_assert(sizeof(IRSSaveGameInterface) == 0x000028, "Wrong size on IRSSaveGameInterface");

// Class BattlePrototype.RSSaveGameInternal
// 0x0010 (0x0038 - 0x0028)
class URSSaveGameInternal final : public USaveGame
{
public:
	TArray<uint8>                                 buf;                                               // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSaveGameInternal">();
	}
	static class URSSaveGameInternal* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSaveGameInternal>();
	}
};
static_assert(alignof(URSSaveGameInternal) == 0x000008, "Wrong alignment on URSSaveGameInternal");
static_assert(sizeof(URSSaveGameInternal) == 0x000038, "Wrong size on URSSaveGameInternal");
static_assert(offsetof(URSSaveGameInternal, buf) == 0x000028, "Member 'URSSaveGameInternal::buf' has a wrong offset!");

// Class BattlePrototype.UIEnemyInfoWindow
// 0x00A0 (0x0428 - 0x0388)
class UUIEnemyInfoWindow : public UUIBase
{
public:
	TSubclassOf<class UUIEnemyDropItem>           M_pDropItemClass;                                  // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_275C[0x98];                                    // 0x0390(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault1, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault1_2, class UWidgetAnimation* AnimDefault2_1, class UVerticalBox* VerticalBoxDropItem, class UUIEnemyDropItem* ChildDropItem, class UVerticalBox* VerticalBoxHabitat, class UTextBlock* TextHabitat, class UOverlay* OverlayDetails, class UTextBlock* TextDetailsTitle, class UImage* EnemyImage, class UTextBlock* TextEnemyName, class UTextBlock* TextDropItemTitle, class UTextBlock* TextHabitatTitle, class UREDScrollBoxSimple* ScrollBox1, class UREDScrollBoxSimple* ScrollBox2, class UREDOverlay* Mousehitthubnail);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEnemyInfoWindow">();
	}
	static class UUIEnemyInfoWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEnemyInfoWindow>();
	}
};
static_assert(alignof(UUIEnemyInfoWindow) == 0x000008, "Wrong alignment on UUIEnemyInfoWindow");
static_assert(sizeof(UUIEnemyInfoWindow) == 0x000428, "Wrong size on UUIEnemyInfoWindow");
static_assert(offsetof(UUIEnemyInfoWindow, M_pDropItemClass) == 0x000388, "Member 'UUIEnemyInfoWindow::M_pDropItemClass' has a wrong offset!");

// Class BattlePrototype.RSSceneCaptureComponent2D
// 0x0010 (0x0B40 - 0x0B30)
class URSSceneCaptureComponent2D final : public USceneCaptureComponent2D
{
public:
	bool                                          bUseTextureStreaming;                              // 0x0B30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275D[0x3];                                     // 0x0B31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextureStreamingBoostFactor;                       // 0x0B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeparateTranslucency;                             // 0x0B38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275E[0x7];                                     // 0x0B39(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FMatrix CalcProjectionMatrix(float ScreenOffsetX, float ScreenOffsetY, float ScaleX, float ScaleY);
	void CaptureSceneSafe();
	void CaptureSceneSafe2Pass();
	void ClearTemporary();
	void DebugTest();
	void SetShowDynamicShadows(bool bShow);
	void SetShowSkeletalMeshes(bool bShow);
	void SetUseScreenPercentage(bool bShow);
	void SetUseTAA(bool UseTAA);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSceneCaptureComponent2D">();
	}
	static class URSSceneCaptureComponent2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSceneCaptureComponent2D>();
	}
};
static_assert(alignof(URSSceneCaptureComponent2D) == 0x000010, "Wrong alignment on URSSceneCaptureComponent2D");
static_assert(sizeof(URSSceneCaptureComponent2D) == 0x000B40, "Wrong size on URSSceneCaptureComponent2D");
static_assert(offsetof(URSSceneCaptureComponent2D, bUseTextureStreaming) == 0x000B30, "Member 'URSSceneCaptureComponent2D::bUseTextureStreaming' has a wrong offset!");
static_assert(offsetof(URSSceneCaptureComponent2D, TextureStreamingBoostFactor) == 0x000B34, "Member 'URSSceneCaptureComponent2D::TextureStreamingBoostFactor' has a wrong offset!");
static_assert(offsetof(URSSceneCaptureComponent2D, bSeparateTranslucency) == 0x000B38, "Member 'URSSceneCaptureComponent2D::bSeparateTranslucency' has a wrong offset!");

// Class BattlePrototype.RSSequencerComponent
// 0x0060 (0x0120 - 0x00C0)
class URSSequencerComponent final : public UActorComponent
{
public:
	TMap<int32, class URSSequencerValueBase*>     MapValue;                                          // 0x00C0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 DelList;                                           // 0x0110(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AllDestroySequenceValue();
	int32 ConvertNameToId(const class FString& Param_Name);
	bool DestroySequenceValue(int32 ID);
	class URSSequencerValueBase* GetSequenceValue(int32 ID);
	int32 RegisterSequenceValue(const class FString& HashName, class URSSequencerValueBase* Value, bool Override);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerComponent">();
	}
	static class URSSequencerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerComponent>();
	}
};
static_assert(alignof(URSSequencerComponent) == 0x000008, "Wrong alignment on URSSequencerComponent");
static_assert(sizeof(URSSequencerComponent) == 0x000120, "Wrong size on URSSequencerComponent");
static_assert(offsetof(URSSequencerComponent, MapValue) == 0x0000C0, "Member 'URSSequencerComponent::MapValue' has a wrong offset!");
static_assert(offsetof(URSSequencerComponent, DelList) == 0x000110, "Member 'URSSequencerComponent::DelList' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueBase
// 0x0028 (0x0050 - 0x0028)
class URSSequencerValueBase : public UObject
{
public:
	uint8                                         Pad_2763[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSSequencerComponent*                  SeqParent;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2764[0x10];                                    // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URSSequencerComponent* GetSeqParent();
	void SetSeqParent(class URSSequencerComponent* Parent);
	void SetupTimer(float Time, class UCurveFloat* CurveData, bool LoopFlag, bool AutoDestroyFlag);
	void StoreParameter(float Rate);

	bool IsFinished() const;
	bool IsLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueBase">();
	}
	static class URSSequencerValueBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueBase>();
	}
};
static_assert(alignof(URSSequencerValueBase) == 0x000008, "Wrong alignment on URSSequencerValueBase");
static_assert(sizeof(URSSequencerValueBase) == 0x000050, "Wrong size on URSSequencerValueBase");
static_assert(offsetof(URSSequencerValueBase, Curve) == 0x000030, "Member 'URSSequencerValueBase::Curve' has a wrong offset!");
static_assert(offsetof(URSSequencerValueBase, SeqParent) == 0x000038, "Member 'URSSequencerValueBase::SeqParent' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueAisac
// 0x0020 (0x0070 - 0x0050)
class URSSequencerValueAisac final : public URSSequencerValueBase
{
public:
	class UAtomComponent*                         Component;                                         // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ParameterName;                                     // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartValue;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndValue;                                          // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetParameter(class UAtomComponent* AtomComponent, const class FString& Param_Name, float Start, float End, float Timer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueAisac">();
	}
	static class URSSequencerValueAisac* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueAisac>();
	}
};
static_assert(alignof(URSSequencerValueAisac) == 0x000008, "Wrong alignment on URSSequencerValueAisac");
static_assert(sizeof(URSSequencerValueAisac) == 0x000070, "Wrong size on URSSequencerValueAisac");
static_assert(offsetof(URSSequencerValueAisac, Component) == 0x000050, "Member 'URSSequencerValueAisac::Component' has a wrong offset!");
static_assert(offsetof(URSSequencerValueAisac, ParameterName) == 0x000058, "Member 'URSSequencerValueAisac::ParameterName' has a wrong offset!");
static_assert(offsetof(URSSequencerValueAisac, StartValue) == 0x000068, "Member 'URSSequencerValueAisac::StartValue' has a wrong offset!");
static_assert(offsetof(URSSequencerValueAisac, EndValue) == 0x00006C, "Member 'URSSequencerValueAisac::EndValue' has a wrong offset!");

// Class BattlePrototype.UIFade
// 0x0030 (0x03B8 - 0x0388)
class UUIFade : public UUIBase
{
public:
	uint8                                         Pad_2768[0x30];                                    // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageBG);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFade">();
	}
	static class UUIFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFade>();
	}
};
static_assert(alignof(UUIFade) == 0x000008, "Wrong alignment on UUIFade");
static_assert(sizeof(UUIFade) == 0x0003B8, "Wrong size on UUIFade");

// Class BattlePrototype.RSSequencerValueMaterialScalarParameter
// 0x0018 (0x0068 - 0x0050)
class URSSequencerValueMaterialScalarParameter final : public URSSequencerValueBase
{
public:
	class UMeshComponent*                         Component;                                         // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParameterName;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartValue;                                        // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndValue;                                          // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetParameter(class UMeshComponent* MeshComponent, class FName Param_Name, float Start, float End, float Timer, class UCurveFloat* CurveData, bool bLoop, bool bAutoDestroy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueMaterialScalarParameter">();
	}
	static class URSSequencerValueMaterialScalarParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueMaterialScalarParameter>();
	}
};
static_assert(alignof(URSSequencerValueMaterialScalarParameter) == 0x000008, "Wrong alignment on URSSequencerValueMaterialScalarParameter");
static_assert(sizeof(URSSequencerValueMaterialScalarParameter) == 0x000068, "Wrong size on URSSequencerValueMaterialScalarParameter");
static_assert(offsetof(URSSequencerValueMaterialScalarParameter, Component) == 0x000050, "Member 'URSSequencerValueMaterialScalarParameter::Component' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialScalarParameter, ParameterName) == 0x000058, "Member 'URSSequencerValueMaterialScalarParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialScalarParameter, StartValue) == 0x000060, "Member 'URSSequencerValueMaterialScalarParameter::StartValue' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialScalarParameter, EndValue) == 0x000064, "Member 'URSSequencerValueMaterialScalarParameter::EndValue' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueMaterialVectorParameter
// 0x0030 (0x0080 - 0x0050)
class URSSequencerValueMaterialVectorParameter final : public URSSequencerValueBase
{
public:
	class UMeshComponent*                         Component;                                         // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ParameterName;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector4                               StartValue;                                        // 0x0060(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector4                               EndValue;                                          // 0x0070(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetParameter(class UMeshComponent* MeshComponent, class FName Param_Name, const struct FVector4& Start, const struct FVector4& End, float Timer, class UCurveFloat* CurveData, bool bLoop, bool bAutoDestroy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueMaterialVectorParameter">();
	}
	static class URSSequencerValueMaterialVectorParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueMaterialVectorParameter>();
	}
};
static_assert(alignof(URSSequencerValueMaterialVectorParameter) == 0x000010, "Wrong alignment on URSSequencerValueMaterialVectorParameter");
static_assert(sizeof(URSSequencerValueMaterialVectorParameter) == 0x000080, "Wrong size on URSSequencerValueMaterialVectorParameter");
static_assert(offsetof(URSSequencerValueMaterialVectorParameter, Component) == 0x000050, "Member 'URSSequencerValueMaterialVectorParameter::Component' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialVectorParameter, ParameterName) == 0x000058, "Member 'URSSequencerValueMaterialVectorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialVectorParameter, StartValue) == 0x000060, "Member 'URSSequencerValueMaterialVectorParameter::StartValue' has a wrong offset!");
static_assert(offsetof(URSSequencerValueMaterialVectorParameter, EndValue) == 0x000070, "Member 'URSSequencerValueMaterialVectorParameter::EndValue' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueDebugging
// 0x0010 (0x0060 - 0x0050)
class URSSequencerValueDebugging final : public URSSequencerValueBase
{
public:
	class FString                                 Name_RSSequencerValueDebugging;                    // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetParameter(const class FString& InName, float Timer, class UCurveFloat* CurveData, bool LoopFlag, bool AutoDestroyFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueDebugging">();
	}
	static class URSSequencerValueDebugging* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSequencerValueDebugging>();
	}
};
static_assert(alignof(URSSequencerValueDebugging) == 0x000008, "Wrong alignment on URSSequencerValueDebugging");
static_assert(sizeof(URSSequencerValueDebugging) == 0x000060, "Wrong size on URSSequencerValueDebugging");
static_assert(offsetof(URSSequencerValueDebugging, Name_RSSequencerValueDebugging) == 0x000050, "Member 'URSSequencerValueDebugging::Name_RSSequencerValueDebugging' has a wrong offset!");

// Class BattlePrototype.RSSequencerValueInterface
// 0x0000 (0x0028 - 0x0028)
class IRSSequencerValueInterface final : public IInterface
{
public:
	void OnDestroySequencer();
	void OnRegisterSequencer();
	bool UpdateSequencer(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSequencerValueInterface">();
	}
	static class IRSSequencerValueInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSSequencerValueInterface>();
	}
};
static_assert(alignof(IRSSequencerValueInterface) == 0x000008, "Wrong alignment on IRSSequencerValueInterface");
static_assert(sizeof(IRSSequencerValueInterface) == 0x000028, "Wrong size on IRSSequencerValueInterface");

// Class BattlePrototype.TipsCountParamManager
// 0x0138 (0x0160 - 0x0028)
class UTipsCountParamManager final : public UObject
{
public:
	uint8                                         Pad_2770[0x138];                                   // 0x0028(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitData(class URSGameInstance* GameInst);
	void ResetTips(EHelpTutorial HelpID);
	void SetDisplayedData(EHelpTutorial HelpID, bool NewValue);
	void SetHiddenTips(bool NewFlag);
	bool WhetherTheConditionsAreMet(EHelpTutorial HelpID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TipsCountParamManager">();
	}
	static class UTipsCountParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTipsCountParamManager>();
	}
};
static_assert(alignof(UTipsCountParamManager) == 0x000008, "Wrong alignment on UTipsCountParamManager");
static_assert(sizeof(UTipsCountParamManager) == 0x000160, "Wrong size on UTipsCountParamManager");

// Class BattlePrototype.RSShareUtilityManager
// 0x0018 (0x0040 - 0x0028)
class URSShareUtilityManager : public UObject
{
public:
	uint8                                         Pad_2771[0x18];                                    // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DoShareWorkPlatform();
	class FString GetLastSavedScreenShotFileName();
	void TwitterLaunchURL(const class FString& Str);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSShareUtilityManager">();
	}
	static class URSShareUtilityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSShareUtilityManager>();
	}
};
static_assert(alignof(URSShareUtilityManager) == 0x000008, "Wrong alignment on URSShareUtilityManager");
static_assert(sizeof(URSShareUtilityManager) == 0x000040, "Wrong size on URSShareUtilityManager");

// Class BattlePrototype.RSSkeletalMeshMerger
// 0x0000 (0x0028 - 0x0028)
class URSSkeletalMeshMerger final : public UBlueprintFunctionLibrary
{
public:
	static class USkeletalMesh* MergeSkeletalMeshes(const struct FRSSkeletalMeshMergeParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSkeletalMeshMerger">();
	}
	static class URSSkeletalMeshMerger* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSkeletalMeshMerger>();
	}
};
static_assert(alignof(URSSkeletalMeshMerger) == 0x000008, "Wrong alignment on URSSkeletalMeshMerger");
static_assert(sizeof(URSSkeletalMeshMerger) == 0x000028, "Wrong size on URSSkeletalMeshMerger");

// Class BattlePrototype.RSSoundManager
// 0x0300 (0x0530 - 0x0230)
class ARSSoundManager : public AActor
{
public:
	uint8                                         Pad_2772[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URSAtomComponentBase*>           Components;                                        // 0x0240(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URSAtomComponentBase*>           DestroyReserveList;                                // 0x0250(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             FootStepDataTable;                                 // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UCharacterPhysicalSurfaceActionSoundResource*> MapFootStep;                                       // 0x0268(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGeneralPhysicalSurfaceActionSoundResourceArray> MapGeneralPhysicalActions;                         // 0x02B8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class USoundAtomCue*>                  SoundEffectAttackPly;                              // 0x0308(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCue*>                  SoundEffectAttackEmnNormal;                        // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCue*>                  SoundEffectAttackEmnMetal;                         // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSoundEffectAttribute>          SoundEffectAttribute;                              // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSoundEffectDamage>             SoundEffectDamage;                                 // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitSoundIntervalWork;                              // 0x0358(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitSoundInterval;                                  // 0x035C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CurveBgmTransEffect;                               // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLoopSeParam>                   LoopSeList;                                        // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URSAtomComponentBase*>           BgmList;                                           // 0x0378(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCueSheetManager*                  CueSheetManager;                                   // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundPoolManager*                      PoolManager;                                       // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          SoundEmitterList;                                  // 0x0398(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCueSheet*>             LoadedVoiceSheet;                                  // 0x03A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 BeforeStageName;                                   // 0x03B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         ScenarioVoiceCueSheetNames;                        // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         BondsVoiceCueSheetNames;                           // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCueSheet*>             LoadedScenarioVoiceSheet;                          // 0x03E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCueSheet*>             LoadedBondsVoiceSheet;                             // 0x03F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FNotifyPlaySoundReplaceParam>   EnBrainField_DataTableList;                        // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNotifyPlaySoundReplaceProgressIdData> ProgressID_DataTableList;                          // 0x0418(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifySoundReplace_EnStr                     M_NotifySoundReplace_EnStr;                        // 0x0428(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2773[0x7];                                     // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNotifyPlaySoundReplaceProgressIdData> ReplaceEnStr_Mid_DataTableList;                    // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNotifyPlaySoundReplaceProgressIdData> ReplaceEnStr_High_DataTableList;                   // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2774[0x8];                                     // 0x0450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundVolumeController*                 SoundVolumeController;                             // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundState                                   SoundState;                                        // 0x0460(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2775[0x3];                                     // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MenuVolumeRate;                                    // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class USoundAtomCue*>     AdlibCue;                                          // 0x0468(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class URSAtomComponentBase*>           PlayingAdlibVoices_;                               // 0x04B8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundAtomCueSheet*>             SequencerSoundCueSheets;                           // 0x04C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDlc1Available;                                   // 0x04D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDlc2Available;                                   // 0x04D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDlc3Available;                                   // 0x04DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2776[0x5];                                     // 0x04DB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class USoundAtomCue*>       MapVisionSimulator_VoiceReplace;                   // 0x04E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class FString GetSoundSelectorLabelString(ESoundSelectorLabel Label);
	static class FString GetSoundSelectorString(ESoundSelector Selector);

	bool ChangeLanguageVoiceSheet(bool IsJapanese);
	bool ChangeSoundState(ESoundState SndState);
	class URSAtomComponentBase* DoIsVoiceToSpawnSoundAttachedLoadedSheetRS(const class UObject* WorldContextObject, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAtomCue* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, class USoundAttenuation* AttenuationSettings, class UObject* Creator);
	float GetBaseSoundVolume(ESoundCategory SoundCategory, const class FString& ParamName);
	class FString GetCueSheetName(class USoundAtomCue* Cue);
	class USoundAtomCue* GetGeneralPhysicalSurfaceActionResource(const EGamePhysicalSurfaceType PhysicsType, class FName ActionType);
	class FString GetLanguageSettingString();
	bool GetPlayerWeaponActorListFromNative(class AActor* OwnerPlayer, EGetPlayerWeaponType Type, TArray<class AActor*>* WeaponList);
	TArray<struct FNotifyPlaySoundReplaceProgressIdData> GetReplaceEnStrDataTableList();
	class USoundAtomCueSheet* GetSoundCueSheet(const class FString& SheetName);
	class AActor* GetSoundEmitter(const int32 Param_Index);
	int32 GetSoundEmitterListCount();
	void Init_ReplaceVoice_VisionSimulator();
	bool IsRegistLoopSe(class FName Param_Name);
	bool IsValidCurrentSimulatorLevelInfos();
	bool LoadBondsCueSheet(EPlayerID HeroID, EPlayerID PartnerId);
	class UCharacterPhysicalSurfaceActionSoundResource* LoadFootStep(class FName NameId);
	bool LoadScenarioCueSheet();
	void LoadSequencerSeCueSheet(class ARSLevelSequenceActor* SeqActor);
	void LoadUseAdlibVoicePath(class ULevelSequence* Seq, TArray<class FString>* AdlibVoiceNames, bool bCueReset);
	bool LoadVoiceCueSheetPlayStage(const class FString& SeName);
	int32 Macro_GetPartyTotalExp();
	bool Macro_GetPlayer(ERSPartyPlayerKind Kind, class USkeletalMeshComponent** Mesh, EPlayerID* PlayerId);
	bool Macro_IsAriseItemEquipped(ERSPartyPlayerKind Kind);
	bool Macro_IsSpCostume(ERSPartyPlayerKind Kind);
	void MakeBondsChueSheetName(EPlayerID HeroID, EPlayerID PartnerId, class FString* MakedName);
	class FString MakeCueSheetPath(const class FString& BaseName);
	void OnBrainCrashOn();
	void OnBrainFieldCloseFromNative();
	void OnEDBrainFieldBattleEndNativeEvent(EBrainFieldEndType EndType);
	void OnMessageSkipSePlay();
	void OnSkipEvent();
	bool PauseAllSound();
	bool PauseBgm(EBgmCategory Category, float FadeTime, float FadeVolume);
	bool PauseEnv(float FadeTime, float FadeVolume);
	bool PauseLoopSe(class FName Param_Name, float FadeTime, float FadeVolume);
	bool PauseME(float FadeTime, float FadeVolume);
	void PlayAdlibVoiceFromLoadedAsset(const class FString& VoiceName);
	bool PlayBgm(EBgmCategory Category, class USoundAtomCue* AtomCue, float FadeTime, float FadeVolume, bool ForceFirstStart);
	class URSAtomComponentBase* PlayCueWeaponLocation(class AActor* OwnerPlayer, class USoundAtomCue* Sound, EGetPlayerWeaponType WeaponType, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USoundAttenuation* AttenuationSettings);
	bool PlayEnv(class USoundAtomCue* AtomCue, float FadeTime, float FadeVolume);
	void PlayHitSoundEffect(const struct FHitDamageInfo& Info);
	bool PlayLoopSe(class FName Param_Name, class USoundAtomCue* AtomCue, const struct FVector& Location, const struct FRotator& Rotation, float FadeTime, float FadeVolume, bool ForceFirstStart);
	bool PlayME(class USoundAtomCue* AtomCue, float FadeTime, float FadeVolume);
	class URSAtomComponentBase* PlayVoice(class USoundAtomCue* Sound, bool IsAttache, bool IsAutoActivate, class USceneComponent* AttachToComponent, class FName AttachPointName, EFilterCallbackType FilterCallbackType);
	void PlayVoiceAtCue(const class UObject* WorldContextObject, class USoundAtomCue* SoundCue, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	void PlayVoiceAtCueName(const class UObject* WorldContextObject, const class FString& CueName, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
	void RegisterComponent(class URSAtomComponentBase* Component);
	bool RegisterCueSheet(class USoundAtomCueSheet* Sheet);
	void RegisterSoundEmitter(class AActor* SoundEmitter);
	void RegistLoopSe(class FName Param_Name, class URSAtomComponentBase* PSound);
	bool ReplacedVoiceSheet(bool IsJapanese);
	class USoundAtomCue* ReplaceNotifySound_Native(class USoundAtomCue* InputSound);
	class USoundAtomCue* ReplaceVoice_VisionSimulator(class USoundAtomCue* InputSound);
	void ResetAllBusBypass(bool Bypass);
	void ResetCharacterCueSheetVolume(const class FString& CharaID);
	void ResetNonPlayerCueSheetVolume();
	bool ResumeBgm(EBgmCategory Category, float FadeTime, float FadeVolume);
	bool ResumeEnv(float FadeTime, float FadeVolume);
	bool ResumeFromPauseAllSound();
	bool ResumeLoopSe(class FName Param_Name, float FadeTime, float FadeVolume);
	bool ResumeME(float FadeTime, float FadeVolume);
	class URSAtomComponentBase* RSAtomCuePlay_AnimNotify_Native(class AActor* OwnerPlayer, class USoundAtomCue* Sound, bool UseWeaponLocation, EGetPlayerWeaponType WeaponType, TSubclassOf<class URSAtomComponentBase> ComponentClass, class USceneComponent* AttachToComponent, class FName AttachPointName, class USoundAttenuation* AttenuationSettings, bool IsInvalidProgressIdCheck);
	void SetAisacValue(class UAtomComponent* AtomCom, ESoundCategory Category, ESoundAisacControlId Control, float ControlValue);
	bool SetBaseSoundVolume(ESoundCategory SoundCategory, const class FString& ParamName, float Volume);
	void SetBgmTransEffectValue(const float Rate, const bool IsDirect);
	bool SetBGMVolume(float Volume);
	void SetCharacterCueSheetVolume(const class FString& CharaID);
	bool SetConfigVolumeByCategoryName(ESoundCategory SoundCategory, float DestVolume);
	bool SetFadeAllCategory(float FadeTime, float DestVol);
	bool SetFadeByCategoryName(ESoundCategory Category, float FadeTime, float DestVol);
	bool SetInGameVolumeAll(float DestVol);
	bool SetInGameVolumeByCategoryName(ESoundCategory Category, float DestVol);
	bool SetLoopSEVolume(float Volume);
	bool SetMuteAll();
	void SetNonPlayerCueSheetVolume();
	void SetNotifySoundReplace_EnStr(ENotifySoundReplace_EnStr Param);
	bool SetResumeFromMuteAll();
	void SetSoundBusBypass(EDspBus DspBus, bool Bypass);
	void SetSoundLevelParam(const struct FSoundLevelParam& SoundLevelParam, class UAtomComponent* AtomCom);
	void SetSoundLevelSnapshot(const struct FSoundSnapshot& Snapshot);
	void StopAllAdlibVoice();
	void StopAllSound();
	bool StopBgm(EBgmCategory Category, float FadeTime, float FadeVolume);
	bool StopEnv(float FadeTime, float FadeVolume);
	bool StopLoopSe(class FName Param_Name, float FadeTime, float FadeVolume);
	bool StopME(float FadeTime, float FadeVolume);
	bool UnloadFootStep(class FName NameId);
	void UnLoadSequencerSeCueSheet();
	void UnregistAllLoopSe(const bool IsStopSound);
	void UnregisterComponent(class URSAtomComponentBase* Component);
	void UnregisterComponentAll();
	bool UnregisterCueSheet(class USoundAtomCueSheet* Sheet);
	void UnregisterSoundEmitter(class AActor* SoundEmitter);
	void UnregisterSoundEmitterAll();
	void UnregistLoopSe(class FName Param_Name);

	class USoundCueSheetManager* GetCueSheetManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSoundManager">();
	}
	static class ARSSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSSoundManager>();
	}
};
static_assert(alignof(ARSSoundManager) == 0x000008, "Wrong alignment on ARSSoundManager");
static_assert(sizeof(ARSSoundManager) == 0x000530, "Wrong size on ARSSoundManager");
static_assert(offsetof(ARSSoundManager, Components) == 0x000240, "Member 'ARSSoundManager::Components' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, DestroyReserveList) == 0x000250, "Member 'ARSSoundManager::DestroyReserveList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, FootStepDataTable) == 0x000260, "Member 'ARSSoundManager::FootStepDataTable' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, MapFootStep) == 0x000268, "Member 'ARSSoundManager::MapFootStep' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, MapGeneralPhysicalActions) == 0x0002B8, "Member 'ARSSoundManager::MapGeneralPhysicalActions' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectAttackPly) == 0x000308, "Member 'ARSSoundManager::SoundEffectAttackPly' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectAttackEmnNormal) == 0x000318, "Member 'ARSSoundManager::SoundEffectAttackEmnNormal' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectAttackEmnMetal) == 0x000328, "Member 'ARSSoundManager::SoundEffectAttackEmnMetal' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectAttribute) == 0x000338, "Member 'ARSSoundManager::SoundEffectAttribute' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEffectDamage) == 0x000348, "Member 'ARSSoundManager::SoundEffectDamage' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, HitSoundIntervalWork) == 0x000358, "Member 'ARSSoundManager::HitSoundIntervalWork' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, HitSoundInterval) == 0x00035C, "Member 'ARSSoundManager::HitSoundInterval' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, CurveBgmTransEffect) == 0x000360, "Member 'ARSSoundManager::CurveBgmTransEffect' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, LoopSeList) == 0x000368, "Member 'ARSSoundManager::LoopSeList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, BgmList) == 0x000378, "Member 'ARSSoundManager::BgmList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, CueSheetManager) == 0x000388, "Member 'ARSSoundManager::CueSheetManager' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, PoolManager) == 0x000390, "Member 'ARSSoundManager::PoolManager' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundEmitterList) == 0x000398, "Member 'ARSSoundManager::SoundEmitterList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, LoadedVoiceSheet) == 0x0003A8, "Member 'ARSSoundManager::LoadedVoiceSheet' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, BeforeStageName) == 0x0003B8, "Member 'ARSSoundManager::BeforeStageName' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, ScenarioVoiceCueSheetNames) == 0x0003C8, "Member 'ARSSoundManager::ScenarioVoiceCueSheetNames' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, BondsVoiceCueSheetNames) == 0x0003D8, "Member 'ARSSoundManager::BondsVoiceCueSheetNames' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, LoadedScenarioVoiceSheet) == 0x0003E8, "Member 'ARSSoundManager::LoadedScenarioVoiceSheet' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, LoadedBondsVoiceSheet) == 0x0003F8, "Member 'ARSSoundManager::LoadedBondsVoiceSheet' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, EnBrainField_DataTableList) == 0x000408, "Member 'ARSSoundManager::EnBrainField_DataTableList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, ProgressID_DataTableList) == 0x000418, "Member 'ARSSoundManager::ProgressID_DataTableList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, M_NotifySoundReplace_EnStr) == 0x000428, "Member 'ARSSoundManager::M_NotifySoundReplace_EnStr' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, ReplaceEnStr_Mid_DataTableList) == 0x000430, "Member 'ARSSoundManager::ReplaceEnStr_Mid_DataTableList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, ReplaceEnStr_High_DataTableList) == 0x000440, "Member 'ARSSoundManager::ReplaceEnStr_High_DataTableList' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundVolumeController) == 0x000458, "Member 'ARSSoundManager::SoundVolumeController' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SoundState) == 0x000460, "Member 'ARSSoundManager::SoundState' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, MenuVolumeRate) == 0x000464, "Member 'ARSSoundManager::MenuVolumeRate' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, AdlibCue) == 0x000468, "Member 'ARSSoundManager::AdlibCue' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, PlayingAdlibVoices_) == 0x0004B8, "Member 'ARSSoundManager::PlayingAdlibVoices_' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, SequencerSoundCueSheets) == 0x0004C8, "Member 'ARSSoundManager::SequencerSoundCueSheets' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, IsDlc1Available) == 0x0004D8, "Member 'ARSSoundManager::IsDlc1Available' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, IsDlc2Available) == 0x0004D9, "Member 'ARSSoundManager::IsDlc2Available' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, IsDlc3Available) == 0x0004DA, "Member 'ARSSoundManager::IsDlc3Available' has a wrong offset!");
static_assert(offsetof(ARSSoundManager, MapVisionSimulator_VoiceReplace) == 0x0004E0, "Member 'ARSSoundManager::MapVisionSimulator_VoiceReplace' has a wrong offset!");

// Class BattlePrototype.TrialParamDebugGroup
// 0x0028 (0x02F8 - 0x02D0)
class ATrialParamDebugGroup final : public ADebuggingItemGroup
{
public:
	TWeakObjectPtr<class ADebuggingItemBool>      IsPlayTrialYuito;                                  // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemBool>      IsPlayTrialKasane;                                 // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecParamChange;                                   // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ADebuggingItemEvent>     ExecLoadTrialParam;                                // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USaveLoadScreenParamManager*            DebugSaveLoadScreenParamManager;                   // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnExecuteLoadTrialSave(const class ADebuggingItemEvent* Item);
	void OnExecuteParameterChange(const class ADebuggingItemEvent* Item);
	void OnPageOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrialParamDebugGroup">();
	}
	static class ATrialParamDebugGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrialParamDebugGroup>();
	}
};
static_assert(alignof(ATrialParamDebugGroup) == 0x000008, "Wrong alignment on ATrialParamDebugGroup");
static_assert(sizeof(ATrialParamDebugGroup) == 0x0002F8, "Wrong size on ATrialParamDebugGroup");
static_assert(offsetof(ATrialParamDebugGroup, IsPlayTrialYuito) == 0x0002D0, "Member 'ATrialParamDebugGroup::IsPlayTrialYuito' has a wrong offset!");
static_assert(offsetof(ATrialParamDebugGroup, IsPlayTrialKasane) == 0x0002D8, "Member 'ATrialParamDebugGroup::IsPlayTrialKasane' has a wrong offset!");
static_assert(offsetof(ATrialParamDebugGroup, ExecParamChange) == 0x0002E0, "Member 'ATrialParamDebugGroup::ExecParamChange' has a wrong offset!");
static_assert(offsetof(ATrialParamDebugGroup, ExecLoadTrialParam) == 0x0002E8, "Member 'ATrialParamDebugGroup::ExecLoadTrialParam' has a wrong offset!");
static_assert(offsetof(ATrialParamDebugGroup, DebugSaveLoadScreenParamManager) == 0x0002F0, "Member 'ATrialParamDebugGroup::DebugSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.RSSplineMeshComponent
// 0x0020 (0x0550 - 0x0530)
class URSSplineMeshComponent final : public USplineMeshComponent
{
public:
	bool                                          bRsCastDynamicShadow;                              // 0x0530(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCastStaticShadow;                               // 0x0531(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCanEverAffectNavigation;                        // 0x0532(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsOverrideLightMapRes;                            // 0x0533(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsUseTwoSidedLighting;                            // 0x0534(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCastShadowAsTwoSided;                           // 0x0535(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B4[0x2];                                     // 0x0536(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RsOverriddenLightMapRes;                           // 0x0538(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsLightmapTypeForceVolumetric;                    // 0x053C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsVisibleInReflectionCaptures;                    // 0x053D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B5[0x2];                                     // 0x053E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RsMinDrawDistance;                                 // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RsLDMaxDrawDistance;                               // 0x0544(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsAllowCullDistanceVolume;                        // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B6[0x7];                                     // 0x0549(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSSplineMeshComponent">();
	}
	static class URSSplineMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSSplineMeshComponent>();
	}
};
static_assert(alignof(URSSplineMeshComponent) == 0x000010, "Wrong alignment on URSSplineMeshComponent");
static_assert(sizeof(URSSplineMeshComponent) == 0x000550, "Wrong size on URSSplineMeshComponent");
static_assert(offsetof(URSSplineMeshComponent, bRsCastDynamicShadow) == 0x000530, "Member 'URSSplineMeshComponent::bRsCastDynamicShadow' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsCastStaticShadow) == 0x000531, "Member 'URSSplineMeshComponent::bRsCastStaticShadow' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsCanEverAffectNavigation) == 0x000532, "Member 'URSSplineMeshComponent::bRsCanEverAffectNavigation' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsOverrideLightMapRes) == 0x000533, "Member 'URSSplineMeshComponent::bRsOverrideLightMapRes' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsUseTwoSidedLighting) == 0x000534, "Member 'URSSplineMeshComponent::bRsUseTwoSidedLighting' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsCastShadowAsTwoSided) == 0x000535, "Member 'URSSplineMeshComponent::bRsCastShadowAsTwoSided' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, RsOverriddenLightMapRes) == 0x000538, "Member 'URSSplineMeshComponent::RsOverriddenLightMapRes' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsLightmapTypeForceVolumetric) == 0x00053C, "Member 'URSSplineMeshComponent::bRsLightmapTypeForceVolumetric' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsVisibleInReflectionCaptures) == 0x00053D, "Member 'URSSplineMeshComponent::bRsVisibleInReflectionCaptures' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, RsMinDrawDistance) == 0x000540, "Member 'URSSplineMeshComponent::RsMinDrawDistance' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, RsLDMaxDrawDistance) == 0x000544, "Member 'URSSplineMeshComponent::RsLDMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(URSSplineMeshComponent, bRsAllowCullDistanceVolume) == 0x000548, "Member 'URSSplineMeshComponent::bRsAllowCullDistanceVolume' has a wrong offset!");

// Class BattlePrototype.RSStateComponent
// 0x0010 (0x00D0 - 0x00C0)
class URSStateComponent : public UActorComponent
{
public:
	uint8                                         Pad_27B7[0x10];                                    // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndProcess();
	int32 Enter(int32 Param);
	int32 Exit(int32 NextStateIndex);
	void NextProcess();
	void SetProcess(int32 NextProcess);
	void SetState(int32 StateIndex, int32 Param);
	bool Transition();
	int32 Update();

	int32 GetProcess() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSStateComponent">();
	}
	static class URSStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSStateComponent>();
	}
};
static_assert(alignof(URSStateComponent) == 0x000008, "Wrong alignment on URSStateComponent");
static_assert(sizeof(URSStateComponent) == 0x0000D0, "Wrong size on URSStateComponent");

// Class BattlePrototype.RSStateManageComponent
// 0x0028 (0x00E8 - 0x00C0)
class URSStateManageComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             DispatchEnterState;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B8[0x18];                                    // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(const TArray<class URSStateComponent*>& StateList);
	void SetState(int32 StateIndex, int32 Param);
	void Update();

	int32 GetCurrentStateIndex() const;
	int32 GetPrevStateIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSStateManageComponent">();
	}
	static class URSStateManageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSStateManageComponent>();
	}
};
static_assert(alignof(URSStateManageComponent) == 0x000008, "Wrong alignment on URSStateManageComponent");
static_assert(sizeof(URSStateManageComponent) == 0x0000E8, "Wrong size on URSStateManageComponent");
static_assert(offsetof(URSStateManageComponent, DispatchEnterState) == 0x0000C0, "Member 'URSStateManageComponent::DispatchEnterState' has a wrong offset!");

// Class BattlePrototype.RSStaticEventCharaAnimInstance
// 0x0010 (0x0280 - 0x0270)
class URSStaticEventCharaAnimInstance final : public UAnimInstance
{
public:
	float                                         EyeXAxisValue;                                     // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeYAxisValue;                                     // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeBlendWeight;                                    // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27B9[0x4];                                     // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSStaticEventCharaAnimInstance">();
	}
	static class URSStaticEventCharaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSStaticEventCharaAnimInstance>();
	}
};
static_assert(alignof(URSStaticEventCharaAnimInstance) == 0x000010, "Wrong alignment on URSStaticEventCharaAnimInstance");
static_assert(sizeof(URSStaticEventCharaAnimInstance) == 0x000280, "Wrong size on URSStaticEventCharaAnimInstance");
static_assert(offsetof(URSStaticEventCharaAnimInstance, EyeXAxisValue) == 0x000270, "Member 'URSStaticEventCharaAnimInstance::EyeXAxisValue' has a wrong offset!");
static_assert(offsetof(URSStaticEventCharaAnimInstance, EyeYAxisValue) == 0x000274, "Member 'URSStaticEventCharaAnimInstance::EyeYAxisValue' has a wrong offset!");
static_assert(offsetof(URSStaticEventCharaAnimInstance, EyeBlendWeight) == 0x000278, "Member 'URSStaticEventCharaAnimInstance::EyeBlendWeight' has a wrong offset!");

// Class BattlePrototype.TwoShotParamManager
// 0x0018 (0x0248 - 0x0230)
class ATwoShotParamManager final : public AActor
{
public:
	uint8                                         Pad_27BA[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClearReplaceList();
	void ReplacementChkFlag(bool IsMan);
	void ReturnCheckFlag(bool IsMan);
	void SaveCheckFlags();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwoShotParamManager">();
	}
	static class ATwoShotParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATwoShotParamManager>();
	}
};
static_assert(alignof(ATwoShotParamManager) == 0x000008, "Wrong alignment on ATwoShotParamManager");
static_assert(sizeof(ATwoShotParamManager) == 0x000248, "Wrong size on ATwoShotParamManager");
static_assert(offsetof(ATwoShotParamManager, _gameInstance) == 0x000240, "Member 'ATwoShotParamManager::_gameInstance' has a wrong offset!");

// Class BattlePrototype.RSStaticMeshComponent
// 0x0020 (0x04C0 - 0x04A0)
class URSStaticMeshComponent final : public UStaticMeshComponent
{
public:
	bool                                          bRsCastDynamicShadow;                              // 0x0498(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCastStaticShadow;                               // 0x0499(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCanEverAffectNavigation;                        // 0x049A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsOverrideLightMapRes;                            // 0x049B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsUseTwoSidedLighting;                            // 0x049C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsCastShadowAsTwoSided;                           // 0x049D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BB[0x2];                                     // 0x049E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RsOverriddenLightMapRes;                           // 0x04A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsLightmapTypeForceVolumetric;                    // 0x04A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRsVisibleInReflectionCaptures;                    // 0x04A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27BC[0x2];                                     // 0x04A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RsMinDrawDistance;                                 // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RsLDMaxDrawDistance;                               // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRsAllowCullDistanceVolume : 1;                    // 0x04B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_27BD[0xF];                                     // 0x04B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSStaticMeshComponent">();
	}
	static class URSStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSStaticMeshComponent>();
	}
};
static_assert(alignof(URSStaticMeshComponent) == 0x000010, "Wrong alignment on URSStaticMeshComponent");
static_assert(sizeof(URSStaticMeshComponent) == 0x0004C0, "Wrong size on URSStaticMeshComponent");
static_assert(offsetof(URSStaticMeshComponent, bRsCastDynamicShadow) == 0x000498, "Member 'URSStaticMeshComponent::bRsCastDynamicShadow' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsCastStaticShadow) == 0x000499, "Member 'URSStaticMeshComponent::bRsCastStaticShadow' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsCanEverAffectNavigation) == 0x00049A, "Member 'URSStaticMeshComponent::bRsCanEverAffectNavigation' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsOverrideLightMapRes) == 0x00049B, "Member 'URSStaticMeshComponent::bRsOverrideLightMapRes' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsUseTwoSidedLighting) == 0x00049C, "Member 'URSStaticMeshComponent::bRsUseTwoSidedLighting' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsCastShadowAsTwoSided) == 0x00049D, "Member 'URSStaticMeshComponent::bRsCastShadowAsTwoSided' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, RsOverriddenLightMapRes) == 0x0004A0, "Member 'URSStaticMeshComponent::RsOverriddenLightMapRes' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsLightmapTypeForceVolumetric) == 0x0004A4, "Member 'URSStaticMeshComponent::bRsLightmapTypeForceVolumetric' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, bRsVisibleInReflectionCaptures) == 0x0004A5, "Member 'URSStaticMeshComponent::bRsVisibleInReflectionCaptures' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, RsMinDrawDistance) == 0x0004A8, "Member 'URSStaticMeshComponent::RsMinDrawDistance' has a wrong offset!");
static_assert(offsetof(URSStaticMeshComponent, RsLDMaxDrawDistance) == 0x0004AC, "Member 'URSStaticMeshComponent::RsLDMaxDrawDistance' has a wrong offset!");

// Class BattlePrototype.RSTimeManager
// 0x0000 (0x0028 - 0x0028)
class URSTimeManager final : public UBlueprintFunctionLibrary
{
public:
	static float GetActorDeltaSeconds(const class AActor* Actor);
	static float GetActorIgnoreHitStop(float HitStopRate);
	static float GetSystemDeltaSeconds(const class UObject* Object);
	static float GetWorldNormalDeltaSeconds(const class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSTimeManager">();
	}
	static class URSTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSTimeManager>();
	}
};
static_assert(alignof(URSTimeManager) == 0x000008, "Wrong alignment on URSTimeManager");
static_assert(sizeof(URSTimeManager) == 0x000028, "Wrong size on URSTimeManager");

// Class BattlePrototype.RSTitleAnimInstance
// 0x0010 (0x0630 - 0x0620)
class URSTitleAnimInstance final : public URSCharacterAnimInstance
{
public:
	ETitleAnime                                   NowAnimKind;                                       // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETitleAnime                                   RequestAnimKind;                                   // 0x0621(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C1[0xE];                                     // 0x0622(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRequestAnimKind(ETitleAnime Type);

	ETitleAnime GetNowAnimKind() const;
	bool IsExistRequest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSTitleAnimInstance">();
	}
	static class URSTitleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSTitleAnimInstance>();
	}
};
static_assert(alignof(URSTitleAnimInstance) == 0x000010, "Wrong alignment on URSTitleAnimInstance");
static_assert(sizeof(URSTitleAnimInstance) == 0x000630, "Wrong size on URSTitleAnimInstance");
static_assert(offsetof(URSTitleAnimInstance, NowAnimKind) == 0x000620, "Member 'URSTitleAnimInstance::NowAnimKind' has a wrong offset!");
static_assert(offsetof(URSTitleAnimInstance, RequestAnimKind) == 0x000621, "Member 'URSTitleAnimInstance::RequestAnimKind' has a wrong offset!");

// Class BattlePrototype.RSTitleManager
// 0x00C8 (0x02F8 - 0x0230)
class ARSTitleManager final : public AActor
{
public:
	uint8                                         Pad_27C2[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             M_OnTitleEventSaveLoadError;                       // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             M_OnTitleEventSoundEnd;                            // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             M_OnTitleEventSoundStart;                          // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C3[0x8];                                     // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_paFirstFlowFonts[0x4];                           // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMultiLanguageTextData*                 M_pMultiLanguageTextData;                          // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserParamManager*                      UserParamManager;                                  // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSHUDBase*                             M_pRSHudBase;                                      // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDatabaseManager*                       DatabaseManager;                                   // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSGameInstance*                        M_pGameInstance;                                   // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pSaveSystem;                                     // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27C4[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGame*                            M_pSaveGame;                                       // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pAutoSave;                                       // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadParamManager;                           // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pAutoSaveLoadParamManager;                       // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadSystemParamManager;                     // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARSLevelSequenceActor*                  TitleSequencer;                                    // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class URSTitleAnimInstance* GetKasaneAnimInstance();
	class ASkeletalMeshActor* GetKasaneMesh();
	class URSTitleAnimInstance* GetYuitoAnimInstance();
	class ASkeletalMeshActor* GetYuitoMesh();
	void InitializeAutoSaveSlotSetting();
	void InitializeSaveSlotSetting();
	bool IsChapterZeroCrear();
	bool IsClearChara(int32 SlotNo, bool* Yuito, bool* Kasane);
	bool IsClearData();
	bool IsClearEXNewRelease();
	bool IsEndGeneralChoice();
	bool IsEnding();
	bool IsFirstFlow();
	bool IsGameClearData();
	bool IsPlayMovie();
	bool IsPlaySequencer();
	bool IsReadyMovie();
	bool IsSaveData();
	bool IsStopMovie();
	bool IsStreamingLevelLoaded();
	bool IsValidUser();
	bool Pause(bool Flag);
	bool PlayMovie();
	bool PlaySequencer(const class FText& bindPlayName);
	bool PlaySequencerType(EUITitleSequencer Type, const class FText& bindPlayName);
	bool SaveDataErrorCheck(ETitleSaveCheck CheckType);
	bool SetEffectKill(class FName ChName);
	bool SetKasaneEffect();
	bool SetMaterialEffectKill();
	void SetPlaySequencerType();
	void SetSaveLoadScreenParam(class USaveLoadScreenParamManager* SaveLoad, class USaveLoadScreenParamManager* AutoSave);
	bool SettingMovie();
	bool SetYuitoEffect();
	bool StopMovie();
	bool SystemSaveDataErrorCheck();
	void TitleLSResetBindings();
	void TitleToLogojump();

	bool IsTitleBackStatic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSTitleManager">();
	}
	static class ARSTitleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSTitleManager>();
	}
};
static_assert(alignof(ARSTitleManager) == 0x000008, "Wrong alignment on ARSTitleManager");
static_assert(sizeof(ARSTitleManager) == 0x0002F8, "Wrong size on ARSTitleManager");
static_assert(offsetof(ARSTitleManager, M_OnTitleEventSaveLoadError) == 0x000238, "Member 'ARSTitleManager::M_OnTitleEventSaveLoadError' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_OnTitleEventSoundEnd) == 0x000248, "Member 'ARSTitleManager::M_OnTitleEventSoundEnd' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_OnTitleEventSoundStart) == 0x000258, "Member 'ARSTitleManager::M_OnTitleEventSoundStart' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_paFirstFlowFonts) == 0x000270, "Member 'ARSTitleManager::M_paFirstFlowFonts' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pMultiLanguageTextData) == 0x000290, "Member 'ARSTitleManager::M_pMultiLanguageTextData' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, UserParamManager) == 0x000298, "Member 'ARSTitleManager::UserParamManager' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pRSHudBase) == 0x0002A0, "Member 'ARSTitleManager::M_pRSHudBase' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, DatabaseManager) == 0x0002A8, "Member 'ARSTitleManager::DatabaseManager' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pGameInstance) == 0x0002B0, "Member 'ARSTitleManager::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pSaveSystem) == 0x0002B8, "Member 'ARSTitleManager::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pSaveGame) == 0x0002C8, "Member 'ARSTitleManager::M_pSaveGame' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pAutoSave) == 0x0002D0, "Member 'ARSTitleManager::M_pAutoSave' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pSaveLoadParamManager) == 0x0002D8, "Member 'ARSTitleManager::M_pSaveLoadParamManager' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pAutoSaveLoadParamManager) == 0x0002E0, "Member 'ARSTitleManager::M_pAutoSaveLoadParamManager' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, M_pSaveLoadSystemParamManager) == 0x0002E8, "Member 'ARSTitleManager::M_pSaveLoadSystemParamManager' has a wrong offset!");
static_assert(offsetof(ARSTitleManager, TitleSequencer) == 0x0002F0, "Member 'ARSTitleManager::TitleSequencer' has a wrong offset!");

// Class BattlePrototype.UIAreaNext
// 0x0018 (0x03A0 - 0x0388)
class UUIAreaNext : public UUIBase
{
public:
	uint8                                         Pad_27CA[0x18];                                    // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool End();
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut);
	bool Start(int32 LocationId, int32 AreaId, int32 PortalID, bool IsWorldMap);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAreaNext">();
	}
	static class UUIAreaNext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAreaNext>();
	}
};
static_assert(alignof(UUIAreaNext) == 0x000008, "Wrong alignment on UUIAreaNext");
static_assert(sizeof(UUIAreaNext) == 0x0003A0, "Wrong size on UUIAreaNext");

// Class BattlePrototype.RSToolFuncLib
// 0x0000 (0x0028 - 0x0028)
class URSToolFuncLib final : public UBlueprintFunctionLibrary
{
public:
	static void CaptureProfileGPU(const class FString& OutputFileName);
	static void CheckCaptureMovie();
	static class UActorComponent* EditorAddActorComponent(class AActor* ActorInstance, class UClass* ComponentClass, bool IsMovable);
	static void EditorCallConstructionScript(class AActor* ActorInstance);
	static void EditorClipboardCopy(const class FString& Text);
	static void EditorDumpReferenceAsset(class UObject* Target);
	static void EditorDumpReferencerAsset(class UObject* Target);
	static void EditorFlushInstancedStaticMesh(class UInstancedStaticMeshComponent* Component, bool* HasError);
	static void EditorLogInstancedStaticMesh(class UInstancedStaticMeshComponent* Component);
	static void EditorRefreshMaterial(class UMaterialInterface* Material);
	static bool EditorRemoveActorComponent(class AActor* Actor, class UActorComponent* Component);
	static void EditorSearchReferenceAsset(class UObject* Target, const TArray<class UObject*>& SearchList);
	static void EditorSearchReferenceFromClassList(class UObject* Target, const TArray<class UClass*>& SearchList);
	static void EditorSearchReferencerAsset(class UObject* Target, const TArray<class UObject*>& SearchList);
	static void EditorSetCanEverAffectNavigation(class UActorComponent* Component, bool Enable);
	static void EditorSetComponentAttachParentBound(class USceneComponent* Component, bool Enable);
	static void EditorSetComponentDiffuseBoost(class UPrimitiveComponent* Component, float Value);
	static void EditorSetComponentDynamicShadow(class UPrimitiveComponent* Component, bool Enable);
	static void EditorSetComponentEmissiveBoost(class UPrimitiveComponent* Component, float Value);
	static void EditorSetComponentEmissiveForStaticLighting(class UPrimitiveComponent* Component, bool Enable);
	static void EditorSetComponentLightmapResolution(class UPrimitiveComponent* Component, bool Enable, int32 Resolution);
	static void EditorSetComponentMobility(class USceneComponent* Component, EEditorMobility Mobility);
	static void EditorSetComponentStartAwake(class UPrimitiveComponent* Component, bool Enable);
	static void EditorSetComponentStaticShadow(class UPrimitiveComponent* Component, bool Enable);
	static void EndCaptureMovie();
	static void GetDevelopUObjectCount(const TArray<class UClass*>& ClassList, TArray<int32>* CountList, bool ChildClass);
	static void SetupDrawEvents(class UObject* WorldContextObject, bool Enable);
	static void StartCaptureMovie(const class FString& OutputFileName, int32 RecordSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSToolFuncLib">();
	}
	static class URSToolFuncLib* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSToolFuncLib>();
	}
};
static_assert(alignof(URSToolFuncLib) == 0x000008, "Wrong alignment on URSToolFuncLib");
static_assert(sizeof(URSToolFuncLib) == 0x000028, "Wrong size on URSToolFuncLib");

// Class BattlePrototype.RSUniqueIdInterface
// 0x0000 (0x0028 - 0x0028)
class IRSUniqueIdInterface final : public IInterface
{
public:
	class FName GetEnemyDeadReplaceLogName() const;
	int32 GetUniqueId() const;
	class FName GetUniqueName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUniqueIdInterface">();
	}
	static class IRSUniqueIdInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRSUniqueIdInterface>();
	}
};
static_assert(alignof(IRSUniqueIdInterface) == 0x000008, "Wrong alignment on IRSUniqueIdInterface");
static_assert(sizeof(IRSUniqueIdInterface) == 0x000028, "Wrong size on IRSUniqueIdInterface");

// Class BattlePrototype.RSUniqueIdComponent
// 0x0010 (0x00D0 - 0x00C0)
class URSUniqueIdComponent final : public UActorComponent
{
public:
	int32                                         ID;                                                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   Name_RSUniqueIdComponent;                          // 0x00C4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_27DC[0x4];                                     // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetId(int32 InId);
	void SetName(class FName InName);

	int32 GetId() const;
	const class FName GetName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUniqueIdComponent">();
	}
	static class URSUniqueIdComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUniqueIdComponent>();
	}
};
static_assert(alignof(URSUniqueIdComponent) == 0x000008, "Wrong alignment on URSUniqueIdComponent");
static_assert(sizeof(URSUniqueIdComponent) == 0x0000D0, "Wrong size on URSUniqueIdComponent");
static_assert(offsetof(URSUniqueIdComponent, ID) == 0x0000C0, "Member 'URSUniqueIdComponent::ID' has a wrong offset!");
static_assert(offsetof(URSUniqueIdComponent, Name_RSUniqueIdComponent) == 0x0000C4, "Member 'URSUniqueIdComponent::Name_RSUniqueIdComponent' has a wrong offset!");

// Class BattlePrototype.RSUniqueIdFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSUniqueIdFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsCharacterFromUniqueId(int32 ID);
	static bool IsCharacterFromUniqueName(class FName Param_Name);
	static bool IsEnemyFromUniqueId(int32 ID);
	static bool IsEnemyFromUniqueName(class FName Param_Name);
	static bool IsENPCFromUniqueId(int32 ID);
	static bool IsENPCFromUniqueName(class FName Param_Name);
	static bool IsItemFromUniqueId(int32 ID);
	static bool IsItemFromUniqueName(class FName Param_Name);
	static bool IsPlayerFromUniqueId(int32 ID);
	static bool IsPlayerFromUniqueName(class FName Param_Name);
	static bool IsWeaponFromUniqueId(int32 ID);
	static bool IsWeaponFromUniqueName(class FName Param_Name);
	static int32 UniqueIdFromName(class FName Param_Name);
	static class FName UniqueNameFromId(int32 ID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUniqueIdFunctionLibrary">();
	}
	static class URSUniqueIdFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUniqueIdFunctionLibrary>();
	}
};
static_assert(alignof(URSUniqueIdFunctionLibrary) == 0x000008, "Wrong alignment on URSUniqueIdFunctionLibrary");
static_assert(sizeof(URSUniqueIdFunctionLibrary) == 0x000028, "Wrong size on URSUniqueIdFunctionLibrary");

// Class BattlePrototype.UILoadingChapter
// 0x0058 (0x03E0 - 0x0388)
class UUILoadingChapter : public UUIBase
{
public:
	uint8                                         Pad_27E9[0x58];                                    // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle, class UTextBlock* TextInfo, class UImage* ImageLocation, class UREDRetainerBox* RetainerBoxNoise1);
	void SetId(int32 ID);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	void IsClosable(bool* Closable) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoadingChapter">();
	}
	static class UUILoadingChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILoadingChapter>();
	}
};
static_assert(alignof(UUILoadingChapter) == 0x000008, "Wrong alignment on UUILoadingChapter");
static_assert(sizeof(UUILoadingChapter) == 0x0003E0, "Wrong size on UUILoadingChapter");

// Class BattlePrototype.RSUtilityEventFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSUtilityEventFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FName> GetMovieTextureNameListFromMakeEventActor(TSubclassOf<class AActor> MakeEventActorClass);
	static TArray<class FName> GetPresetNameListFromMakeEventActor(TSubclassOf<class AActor> MakeEventActorClass);
	static class FString GetStandbyPhaseFromProgressID(int32 ProgressId);
	static TArray<class FName> GetTextureNameListFromMakeEventActor(TSubclassOf<class AActor> MakeEventActorClass);
	static void ResetCheckPlMaterialTolerance();
	static void SetCheckPlMaterialTolerance(float Tolelance);
	static void SetupCutsceneHideDitherSaveShop(class UObject* WorldContextObject, float DitherRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUtilityEventFunctionLibrary">();
	}
	static class URSUtilityEventFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUtilityEventFunctionLibrary>();
	}
};
static_assert(alignof(URSUtilityEventFunctionLibrary) == 0x000008, "Wrong alignment on URSUtilityEventFunctionLibrary");
static_assert(sizeof(URSUtilityEventFunctionLibrary) == 0x000028, "Wrong size on URSUtilityEventFunctionLibrary");

// Class BattlePrototype.RSUtilityLibrary
// 0x0000 (0x0028 - 0x0028)
class URSUtilityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString AddAssetPathPrefix(const class FString& Path, const class FString& Prefix, int32 Param_Index);
	static class FString AddAssetPathSuffix(const class FString& Path, const class FString& Suffix, int32 LastIndex);
	static struct FWeightedBlendables AddPostProcessMaterials(const struct FWeightedBlendables& BaseMaterials, const struct FWeightedBlendables& OverrideMaterials, float Weight);
	static struct FPostProcessSettings AddPostProcessSettings(const struct FPostProcessSettings& BaseSettings, const struct FPostProcessSettings& OverrideSettings, float Weight);
	static struct FPostProcessSettings AddPostProcessSettingsCamera(const struct FPostProcessSettings& BaseSettings, class UCineCameraComponent* OverrideCamera);
	static void AddStageParameterSettings(const struct FStageParameterSettings& BaseSetting, const struct FStageParameterSettings& OverrideSetting, float Weight, struct FStageParameterSettings* OutSettings);
	static bool ApplyDLC(const class UObject* WorldContextObject, class FName ContentsName, bool IsForceApply);
	static void BackToTitle(const class UObject* WorldContextObject, const bool bAccountReset);
	static bool BitFlagCheck(int32 Flag, int32 bitIndex);
	static int32 BitFlagOff(int32 Flag, int32 bitIndex);
	static int32 BitFlagOn(int32 Flag, int32 bitIndex);
	static struct FPostProcessSettings CalcPostProcessVolume(const TArray<class APostProcessVolume*>& PostProcessLists, const struct FVector& Location, bool CheckEnable);
	static struct FTransform CalcRootMotionTransform(class USkeletalMeshComponent* Mesh, bool bWorld);
	static struct FPostProcessSettings CalcSceneCapturePostProcessSettings(class USceneCaptureComponent2D* SceneCapture, const TArray<class APostProcessVolume*>& PostProcessLists, const struct FVector& Location, bool CheckEnable);
	static struct FPostProcessSettings CalcScenePostProcessVolume(class UObject* WorldContextObject, const struct FVector& Location, bool CheckEnable);
	static struct FPostProcessSettings CalcStaticCapturePostProcessSettings(class USceneCaptureComponent2D* SceneCapture, const TArray<class APostProcessVolume*>& PostProcessLists, const TArray<struct FPostProcessSettings>& AddPPSs, const struct FVector& Location, float AddPPSPriority, bool CheckEnable);
	static void ClearMainViewTemporalBuffer();
	static void ClearPlayerOverlapEvent(const class UObject* WorldContextObject);
	static bool CompareSkeleton(class UAnimSequence* AnimSequence, class USkeletalMeshComponent* SkelMeshComp);
	static bool ConstructLocalEntitleData(const class UObject* WorldContextObject);
	static class FString ConvertAssetPathPlatformName(const class FString& Path);
	static E_SASKindNative ConvertPlayerIDtoSAS(EPlayerID PlayerId);
	static EPlayerID ConvertSAStoPlayerID(E_SASKindNative SasKind);
	static void CopyBaseCineCameraToCineCamera(class UCineCameraComponent* BaseCineCamera, class UCineCameraComponent* ToCineCamera);
	static void CopySequencerTemplateToCineCamera(class ARSLevelSequenceActor* Sequencer, const struct FMovieSceneObjectBindingID& BindingID, class UCineCameraComponent* CineCamera);
	static class UMaterialInstanceDynamic* CreateDynamicMaterialInstanceFromName_Mesh(class UMeshComponent* MeshComponent, const class FName MaterialName, class UMaterialInterface* SourceMaterial);
	static class UMaterialInstanceDynamic* CreateDynamicMaterialInstanceFromName_Particle(class URSParticleSystemComponentBase* RSParticleComponent, const class FName EmitterName, class UMaterialInterface* SourceMaterial);
	static class UTextureRenderTarget2D* CreateRenderTarget2DCustom(class UObject* WorldContextObject, int32 Width, int32 Height, ERenderTargetCustomFormat Format, ETextureAddress AddressX, ETextureAddress AddressY, bool LinearGamma);
	static void DebugDisplayURO(class USkinnedMeshComponent* Mesh, bool bDisplay);
	static void DebugLogWarning(const class FText& WarningText);
	static void DoFlushRenderingCommands();
	static void ExNewGameParamAdjust(const class UObject* WorldContextObject, const bool IsTakeOverPlayerLv, const bool IsTakeOverBrainMap);
	static void ForceGC(bool bFullPurge);
	static void ForceGC_NoEditor(bool bFullPurge);
	static void ForceUploadGPUScene();
	static void GameClearSaveParamAdjust(const class UObject* WorldContextObject);
	static void GameOverActorStopFunc(const class UObject* WorldContextObject);
	static class AActor* GetActorFromTag(class UObject* WorldObject, class FName Tag);
	static class AActor* GetActorFromTagConst(const class UObject* WorldObject, const class FName& Tag);
	static class AActor* GetActorFromTagForLevelName(const class UObject* WorldContextObject, class FName Tag, class FName LevelName);
	static TArray<class AActor*> GetActorsFromLevelStreaming(class ULevelStreaming* Level);
	static bool GetAppropriateSystemAvailableResolutions(struct FScreenResolutionSetting* Resolution, const int32 Width, const int32 Height, const bool bIgnoreRefreshRate);
	static TSubclassOf<class AActor> GetAssetUClass(class FName ClassName, class FName AssetName);
	static void GetCelLookAmbientReplaceParam(struct FLinearColor* OutColor, float* OutRate);
	static struct FVector GetCelLookLightDirection();
	static struct FTransform GetComposedRefPoseTransform(class USkeletalMesh* SkeletalMesh, class FName BoneName);
	static struct FRotator GetCurrentCameraRotation(const class UObject* WorldContextObject);
	static uint8 GetGameViewRenderLayer();
	static bool GetInitialScreenResolution(struct FVector2D* Resolution, bool* IsVertical);
	static float GetMaxDistanceFactor(class USkinnedMeshComponent* Mesh);
	static bool GetNativeScreenResolution(struct FVector2D* Resolution, bool* IsVertical);
	static bool GetPlayTrial2Flag(class UObject* WorldContextObject, const bool bYuito);
	static class FName GetPrimaryAssetTypeName(const struct FPrimaryAssetType& AssetType);
	static class URSGameInstance* GetRSGameInstance(const class UObject* WorldContextObject);
	static bool GetScreenResolution(struct FVector2D* Resolution, bool* IsVertical);
	static class USkeletalMeshComponent* GetSkeletalMeshFromActor(class AActor* Actor);
	static TArray<class UStaticMeshComponent*> GetStaticMeshArrayFromActor(class AActor* Actor);
	static class UStaticMeshComponent* GetStaticMeshFromActor(class AActor* Actor);
	static bool GetSystemAvailableFullscreenResolutions(const TArray<struct FScreenResolutionSetting>& InResolutions, TArray<struct FScreenResolutionSetting>* OutResolutions, bool bIgnoreRefreshRate);
	static bool GetSystemAvailableResolutions(TArray<struct FScreenResolutionSetting>* Resolutions, bool bIgnoreRefreshRate);
	static bool GetSystemAvailableWindowedResolutions(const TArray<struct FScreenResolutionSetting>& InResolutions, TArray<struct FScreenResolutionSetting>* OutResolutions, bool bIgnoreRefreshRate);
	static void GetToday(const class UObject* WorldContextObject, int32* Year, int32* Month, int32* Day);
	static float GetUROUpdateRate(class USkinnedMeshComponent* Mesh);
	static TArray<class APostProcessVolume*> GetWorldPostProcessVolume(class UObject* WorldContextObject);
	static void GeWorldPostProcesstEnabledMaterials(class UObject* WorldContextObject, const struct FVector& Location, TArray<class UMaterialInterface*>* OutMaterials, TArray<class FString>* OutMaterialNames);
	static bool HasSimpleCollision(class UPrimitiveComponent* Primitive);
	static bool HasWorldEndOfFrameUpdates(const class UObject* WorldContextObject);
	static void InvalidDLCInvalidation(const class UObject* WorldContextObject, const TArray<class FName>& InvalidContentsList);
	static bool IsAddContentsNewFlag(const class UObject* WorldContextObject, class FName ContentsName);
	static bool IsAllSlotNotAppliedAndNotNotifiedDLC(const class UObject* WorldContextObject, TArray<class FName>* ResultAddContentsNameList);
	static bool IsAnimMontageStoped(class UAnimInstance* AnimInstance, class UAnimSequenceBase* Anim);
	static bool IsApplicationActive();
	static bool IsAppliedDLC(const class UObject* WorldContextObject, class FName ContentsName);
	static bool IsDisplayVertical(bool* IsVertical);
	static bool IsDLCHaveNoRightsInApplied(const class UObject* WorldContextObject, const TArray<class FName>& AppliedAddContentsNameList);
	static bool IsDLCOverPossession(const class UObject* WorldContextObject, class FName ContentsName);
	static bool IsExistNotInformNewAddContents(const class UObject* WorldContextObject, TArray<class FName>* AddContentsNameList, const bool IsUpdateSystemSave);
	static bool IsExistNotInformPurchasedAddContents(const class UObject* WorldContextObject, TArray<class FName>* AddContentsNameList, const bool IsUpdateSystemSave);
	static bool IsGameClearThisPlay(const class UObject* WorldContextObject);
	static bool IsNewDLC(const class UObject* WorldContextObject, bool IsParamUpdate);
	static bool IsNotAppliedDLC(const class UObject* WorldContextObject, TArray<class FName>* NotAppliedAddContentsNameList, const bool IsPurchasedOnly);
	static bool IsNotAppliedDLCAndReceiveBrainMessage(class UObject* WorldContextObject);
	static bool IsRootMotionAnimMontage(class UAnimMontage* Anim);
	static void LevelChangeBeforeWorkFromIngame(const class UObject* WorldContextObject);
	static void LoadAssetFromStringAssetReference(class UObject* WorldContextObject, const struct FSoftObjectPath& StringAsset, TDelegate<void(class UObject* Loaded)> OnLoaded, const struct FLatentActionInfo& LatentInfo, bool NoFindCheck);
	static class UDataTable* LoadDataTable(const class FString& FilePath);
	static class UObject* LoadObjectGeneric(const class FString& FilePath);
	static class UClass* LoadSoftClass(TSoftClassPtr<class UClass> Target);
	static TSubclassOf<class AActor> LoadSoftClassActor(TSoftClassPtr<class UClass> Target);
	static class UObject* LoadSoftObject(TSoftObjectPtr<class UObject> Target);
	static class AActor* LoadSoftObjectActor(TSoftObjectPtr<class AActor> Target);
	static void OutputNowTime(const class FString& LogText);
	static void RedAssert(bool IsCheck, const class FString& Message);
	static void RedEnsure(bool IsCheck, const class FString& Message);
	static void RedUnImplement();
	static void RefreshSkinMesh(class USkinnedMeshComponent* SkinMesh);
	static void RefreshSkinMeshSkipAnimNotify(class USkeletalMeshComponent* SkeletalMesh);
	static void RemovePostProcessMaterialFromComponent(class UPostProcessComponent* PPComponent, class UMaterialInterface* RemoveMaterial);
	static struct FPostProcessSettings RemovePostProcessMaterialFromPPS(const struct FPostProcessSettings& BaseSettings, class UMaterialInterface* RemoveMaterial);
	static void ReplaceMaterialInstanceFromImagePlatformTexture(class UImage* Image);
	static void ReplaceMaterialInstancePlatformTexture(class UMaterialInstanceDynamic* MaterialInstance);
	static void ResetRenderTargets(const class UObject* WorldContextObject);
	static void RestorePPMaskParticlenative(class UObject* WorldContextObject, const TArray<class ASequencerParticle*>& SequencerParticles, const TArray<int32>& RestoreCustomStencil);
	static void SaveDataLoadAfterParamAdjust(const class UObject* WorldContextObject);
	static void SetAddContentsNewFlag(const class UObject* WorldContextObject, class FName ContentsName, const bool Flag);
	static void SetBgEdgeDriveColor(const struct FLinearColor& InnerColor, const struct FLinearColor& OuterColor);
	static void SetBgEdgeDriveLocation(const struct FVector& Location);
	static void SetBgEdgeDriveParameter(float Length, float Smooth, float ColorShift, float Parameter4, float EdgeThresholdNomrmal, float EdgeThresholdLuminance, float Parameter7, float Parameter8);
	static void SetCelLookLightDirection(const struct FVector& LightDirection);
	static void SetDisplayBrightnessNative(class UObject* WorldContextObject, int32 Brightness);
	static void SetEnableURO(class USkinnedMeshComponent* Mesh, bool bEnable);
	static void SetForcedLOD(class USceneComponent* Mesh, int32 LodIndex, bool bApplyChiledComponent);
	static void SetGamePausedRS(const class UObject* WorldContextObject, bool bPaused, class FName ClaimantName, bool bPauseInputManager);
	static void SetGameViewRenderLayer(uint8 RenderLayer);
	static void SetLightChannnel(class UPrimitiveComponent* Primitive, bool Channel0, bool Channel1, bool Channel2);
	static void SetMainViewOverrideAA(bool bOverride, int32 AAMethod);
	static void SetPicturizeQuality(int32 Quality);
	static void SetPlayTrial2Flag(class UObject* WorldContextObject, const bool bYuito, const bool Flag);
	static void SetRenderAfterDOF(class UMaterial* Material, bool IsEnable);
	static void SetShadowMapAtlasTargetsEnabled(bool Enabled);
	static void SetupPPMaskParticlenative(class UObject* WorldContextObject, TArray<class ASequencerParticle*>* SequencerParticles, TArray<int32>* RestoreCustomStencil, bool Enable);
	static void SetUROParameter(class USkinnedMeshComponent* Mesh, const TArray<float>& Thesholds, int32 MaxEvalRateForInterpolation, int32 BaseNonRenderedUpdateRate);
	static void ShippingDebugString(const class FString& OutString);
	static class AActor* SpawnActorFromBPFilePath(class UObject* WorldContextObject, const class FString& Path);
	static void StartDeadGameOverPreWork(const class UObject* WorldContextObject);
	static void UnloadLevelInstance(class UObject* WorldContextObject, class ULevelStreamingDynamic* LevelStreaming);
	static void UpdateBoundsComponent(class USceneComponent* Component);
	static void UpdateDLCInfo(const class UObject* WorldContextObject, const TArray<class FName>& EntitledContentsList, const TArray<class FName>& InvalidContentsList, bool IsInvalidDLCInvalidation);
	static void VisionSimulatorRetryActorStopFunc(const class UObject* WorldContextObject);
	static void VisionSimulatorReturnAjitoFunc(const class UObject* WorldContextObject);

	void OnAssetLoaded__DelegateSignature(class UObject* Loaded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUtilityLibrary">();
	}
	static class URSUtilityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUtilityLibrary>();
	}
};
static_assert(alignof(URSUtilityLibrary) == 0x000008, "Wrong alignment on URSUtilityLibrary");
static_assert(sizeof(URSUtilityLibrary) == 0x000028, "Wrong size on URSUtilityLibrary");

// Class BattlePrototype.RSUtilityMathFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URSUtilityMathFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CalcMeshSocketRotation(struct FVector* OutLocation, struct FRotator* OutRotator, class AActor* RotateActor, class UMeshComponent* Mesh, class FName SocketName, float Angle);
	static struct FVector ClampVectorLimitAngle(const struct FVector& baseDist, const struct FVector& CheckDist, float LimitDegree);
	static struct FVector GetBulletDirection(const struct FVector& FireLocation, const struct FVector& TargetLocation, const struct FVector& FireForwardVector, float MaxAngleXY, float MaxAngleZ);
	static struct FVector GetDamageReactionDir(class AActor* Owner, const struct FHCHitResult& HitResult);
	static void GetSearchBaseParam(const class UObject* WorldContextObject, struct FVector* OutPlayerLocation, struct FVector* OutCameraDirH);
	static float GetTargetAngle(const struct FVector& baseDist, const struct FVector& TargetDist);
	static float GetTargetRangeAngle(const struct FVector& baseDist, const struct FVector& TargetDist);
	static bool IsNearlyAngle(float A, float B, float Angle);
	static struct FVector TurnToTargetVector(const struct FVector& SrcVec, const struct FVector& DstVec, float Angle);
	static float UpdateTimer(float Timer, float DeltaSeconds);
	static struct FVector UpDownVector(const struct FVector& Src, float Angle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSUtilityMathFunctionLibrary">();
	}
	static class URSUtilityMathFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSUtilityMathFunctionLibrary>();
	}
};
static_assert(alignof(URSUtilityMathFunctionLibrary) == 0x000008, "Wrong alignment on URSUtilityMathFunctionLibrary");
static_assert(sizeof(URSUtilityMathFunctionLibrary) == 0x000028, "Wrong size on URSUtilityMathFunctionLibrary");

// Class BattlePrototype.UIMainContents
// 0x0048 (0x03D0 - 0x0388)
class UUIMainContents : public UUIBase
{
public:
	TArray<class UUIBase*>                        MenuList;                                          // 0x0388(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIConfigGame*                          UIConfig;                                          // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MenuIndex;                                         // 0x03A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MenuIndexNext;                                     // 0x03A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MenuIndexBackup;                                   // 0x03A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TabEnableFlag;                                     // 0x03AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsBrainMessageAutoMode;                           // 0x03B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_282D[0x3];                                     // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MBrainMessageDefaultThreadID;                      // 0x03B4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MIsMenuSingle;                                     // 0x03BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_282E[0x13];                                    // 0x03BD(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimPressButtonL();
	void AnimPressButtonR();
	void ControlFunc(int32 SubState);
	bool Create3DView();
	bool IsEndCurrentMenu();
	bool Release3DView();
	bool ResetReplyBondsEpisodeFlag();
	bool ResetWeaponMenuDefaultCursor();
	bool SetBrainMapCursorCorrectArea(float Area);
	bool SetBrainMapCursorCorrectSpeed(float Speed);
	bool SetBrainMapCursorSpeed(float Speed);
	void SetBrainMessageAutoMode(bool IsAuto);
	void SetBrainMessageDefaultThread(class FName ThreadID);
	bool SetChangeMainMenuTab(int32 Nextindex);
	bool SetChangeMainMenuTabL();
	bool SetChangeMainMenuTabR();
	bool SetMouseEnableMode(bool Flag);
	void SetOnlyBrainMessage(bool IsOnlyBrainMessage);
	void SetOnlyEnemyBooks(bool IsOnlyEnemyBooks);
	void SetOnlyWeaponMenu(bool IsOnlyWeaponMenu);
	void SetPopupMode(bool IsPopupMode);
	void SetStartBrainMessage(bool IsDefaultBrainMessage);
	void SetTabEnable(int32 Param_Index, bool IsEnable);
	void SetViewerMode(bool IsViewerMode);
	bool SetWeaponMenuDefaultCursor(EPlayerID CharaID, bool IsVisual);
	void UpdateBP();
	void UpdateMoney();

	float GetBrainMapCursorCorrectArea() const;
	float GetBrainMapCursorCorrectSpeed() const;
	float GetBrainMapCursorSpeed() const;
	bool IsLockTabChange() const;
	bool IsOnlyBrainMessage() const;
	bool IsOnlyEnemyBooks() const;
	bool IsOnlyWeaponMenu() const;
	bool IsPopupMode() const;
	bool IsReplyBondsEpisode() const;
	bool IsStartBrainMessage() const;
	bool IsTabEnable(int32 Param_Index) const;
	bool IsViewerMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMainContents">();
	}
	static class UUIMainContents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMainContents>();
	}
};
static_assert(alignof(UUIMainContents) == 0x000008, "Wrong alignment on UUIMainContents");
static_assert(sizeof(UUIMainContents) == 0x0003D0, "Wrong size on UUIMainContents");
static_assert(offsetof(UUIMainContents, MenuList) == 0x000388, "Member 'UUIMainContents::MenuList' has a wrong offset!");
static_assert(offsetof(UUIMainContents, UIConfig) == 0x000398, "Member 'UUIMainContents::UIConfig' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MenuIndex) == 0x0003A0, "Member 'UUIMainContents::MenuIndex' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MenuIndexNext) == 0x0003A4, "Member 'UUIMainContents::MenuIndexNext' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MenuIndexBackup) == 0x0003A8, "Member 'UUIMainContents::MenuIndexBackup' has a wrong offset!");
static_assert(offsetof(UUIMainContents, TabEnableFlag) == 0x0003AC, "Member 'UUIMainContents::TabEnableFlag' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MIsBrainMessageAutoMode) == 0x0003B0, "Member 'UUIMainContents::MIsBrainMessageAutoMode' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MBrainMessageDefaultThreadID) == 0x0003B4, "Member 'UUIMainContents::MBrainMessageDefaultThreadID' has a wrong offset!");
static_assert(offsetof(UUIMainContents, MIsMenuSingle) == 0x0003BC, "Member 'UUIMainContents::MIsMenuSingle' has a wrong offset!");

// Class BattlePrototype.RSWidgetComponent
// 0x0000 (0x0550 - 0x0550)
class URSWidgetComponent final : public UWidgetComponent
{
public:
	void CallUpdateWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RSWidgetComponent">();
	}
	static class URSWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URSWidgetComponent>();
	}
};
static_assert(alignof(URSWidgetComponent) == 0x000010, "Wrong alignment on URSWidgetComponent");
static_assert(sizeof(URSWidgetComponent) == 0x000550, "Wrong size on URSWidgetComponent");

// Class BattlePrototype.SASManager
// 0x0008 (0x0238 - 0x0230)
class ASASManager : public AActor
{
public:
	uint8                                         Pad_2835[0x8];                                     // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetSASEffectFixParam(E_SASKindNative InKind, TArray<struct F_SASParamNative>* OutFixParam);
	bool IsCutinPlayingNative();
	bool IsPlayingCutinExtra();
	void ResetHudCustomTimeDilationAccelerateSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SASManager">();
	}
	static class ASASManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASASManager>();
	}
};
static_assert(alignof(ASASManager) == 0x000008, "Wrong alignment on ASASManager");
static_assert(sizeof(ASASManager) == 0x000238, "Wrong size on ASASManager");

// Class BattlePrototype.SASVisionComponent
// 0x00B8 (0x0178 - 0x00C0)
class USASVisionComponent final : public UActorComponent
{
public:
	TSubclassOf<class AActor>                     _maskActorClass;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           _curveMaskAppearLocation;                          // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           _curveMaskDisappearLocation;                       // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           _curveMaskRotation;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           _curveMaskScale;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bDebugDispMask;                                   // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2838[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _meshShakeOffsetMax;                               // 0x00EC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _meshShakeSpanShort;                               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _meshShakeSpanLongMin;                             // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _meshShakeSpanLongMax;                             // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _meshShakeSmallContinueMin;                        // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _meshShakeSmallContinueMax;                        // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bShakeLinear;                                     // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2839[0x6B];                                    // 0x010D(0x006B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USASVisionComponent* GetSASVisionComponent(class AActor* Actor);

	bool OnStartDisappear();
	void StartDisappear();

	class AActor* GetMainActor() const;
	class USkeletalMeshComponent* GetMainMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SASVisionComponent">();
	}
	static class USASVisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USASVisionComponent>();
	}
};
static_assert(alignof(USASVisionComponent) == 0x000008, "Wrong alignment on USASVisionComponent");
static_assert(sizeof(USASVisionComponent) == 0x000178, "Wrong size on USASVisionComponent");
static_assert(offsetof(USASVisionComponent, _maskActorClass) == 0x0000C0, "Member 'USASVisionComponent::_maskActorClass' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _curveMaskAppearLocation) == 0x0000C8, "Member 'USASVisionComponent::_curveMaskAppearLocation' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _curveMaskDisappearLocation) == 0x0000D0, "Member 'USASVisionComponent::_curveMaskDisappearLocation' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _curveMaskRotation) == 0x0000D8, "Member 'USASVisionComponent::_curveMaskRotation' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _curveMaskScale) == 0x0000E0, "Member 'USASVisionComponent::_curveMaskScale' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _bDebugDispMask) == 0x0000E8, "Member 'USASVisionComponent::_bDebugDispMask' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeOffsetMax) == 0x0000EC, "Member 'USASVisionComponent::_meshShakeOffsetMax' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSpanShort) == 0x0000F8, "Member 'USASVisionComponent::_meshShakeSpanShort' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSpanLongMin) == 0x0000FC, "Member 'USASVisionComponent::_meshShakeSpanLongMin' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSpanLongMax) == 0x000100, "Member 'USASVisionComponent::_meshShakeSpanLongMax' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSmallContinueMin) == 0x000104, "Member 'USASVisionComponent::_meshShakeSmallContinueMin' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _meshShakeSmallContinueMax) == 0x000108, "Member 'USASVisionComponent::_meshShakeSmallContinueMax' has a wrong offset!");
static_assert(offsetof(USASVisionComponent, _bShakeLinear) == 0x00010C, "Member 'USASVisionComponent::_bShakeLinear' has a wrong offset!");

// Class BattlePrototype.SaveIntermediary
// 0x0000 (0x0230 - 0x0230)
class ASaveIntermediary final : public AActor
{
public:
	void Load(const class FString& SaveSlotName, int32* TestInt, float* TestFloat, class FName* TestName, TArray<int32>* TestArrayInt, struct FSaveTestStruct* TestStruct, TArray<struct FSaveTestStruct>* TestArrayStruct);
	void Save(const class FString& SlotName, int32 TestInt, float TestFloat, class FName TestName, const TArray<int32>& TestArrayInt, const struct FSaveTestStruct& TestStruct, const TArray<struct FSaveTestStruct>& TestArrayStruct);
	uint8 TestBuffer(int32 Num, int32 Param_Index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveIntermediary">();
	}
	static class ASaveIntermediary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASaveIntermediary>();
	}
};
static_assert(alignof(ASaveIntermediary) == 0x000008, "Wrong alignment on ASaveIntermediary");
static_assert(sizeof(ASaveIntermediary) == 0x000230, "Wrong size on ASaveIntermediary");

// Class BattlePrototype.UIMiniMainQuestGoal
// 0x0000 (0x0388 - 0x0388)
class UUIMiniMainQuestGoal : public UUIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniMainQuestGoal">();
	}
	static class UUIMiniMainQuestGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniMainQuestGoal>();
	}
};
static_assert(alignof(UUIMiniMainQuestGoal) == 0x000008, "Wrong alignment on UUIMiniMainQuestGoal");
static_assert(sizeof(UUIMiniMainQuestGoal) == 0x000388, "Wrong size on UUIMiniMainQuestGoal");

// Class BattlePrototype.SaveLoadArrangeItemManager
// 0x0038 (0x0060 - 0x0028)
class USaveLoadArrangeItemManager final : public UObject
{
public:
	uint8                                         Pad_283B[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArrangeItemListForSaveData>    M_allArrangeItemList;                              // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRandomArrangeItemIDInfo>       M_allRandomArrangeItemIDInfo;                      // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        M_timerCount;                                      // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadArrangeItemManager">();
	}
	static class USaveLoadArrangeItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadArrangeItemManager>();
	}
};
static_assert(alignof(USaveLoadArrangeItemManager) == 0x000008, "Wrong alignment on USaveLoadArrangeItemManager");
static_assert(sizeof(USaveLoadArrangeItemManager) == 0x000060, "Wrong size on USaveLoadArrangeItemManager");
static_assert(offsetof(USaveLoadArrangeItemManager, M_allArrangeItemList) == 0x000038, "Member 'USaveLoadArrangeItemManager::M_allArrangeItemList' has a wrong offset!");
static_assert(offsetof(USaveLoadArrangeItemManager, M_allRandomArrangeItemIDInfo) == 0x000048, "Member 'USaveLoadArrangeItemManager::M_allRandomArrangeItemIDInfo' has a wrong offset!");
static_assert(offsetof(USaveLoadArrangeItemManager, M_timerCount) == 0x000058, "Member 'USaveLoadArrangeItemManager::M_timerCount' has a wrong offset!");

// Class BattlePrototype.SaveLoadEnemyParamManager
// 0x00B0 (0x00D8 - 0x0028)
class USaveLoadEnemyParamManager final : public UObject
{
public:
	uint8                                         Pad_283C[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FEnemyRepopLevelInfo> M_EnemyRepopLevelInfoList;                         // 0x0038(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<class FName, bool>                       M_UniqueBrainCrashPlayedList;                      // 0x0088(0x0050)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadEnemyParamManager">();
	}
	static class USaveLoadEnemyParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadEnemyParamManager>();
	}
};
static_assert(alignof(USaveLoadEnemyParamManager) == 0x000008, "Wrong alignment on USaveLoadEnemyParamManager");
static_assert(sizeof(USaveLoadEnemyParamManager) == 0x0000D8, "Wrong size on USaveLoadEnemyParamManager");
static_assert(offsetof(USaveLoadEnemyParamManager, M_EnemyRepopLevelInfoList) == 0x000038, "Member 'USaveLoadEnemyParamManager::M_EnemyRepopLevelInfoList' has a wrong offset!");
static_assert(offsetof(USaveLoadEnemyParamManager, M_UniqueBrainCrashPlayedList) == 0x000088, "Member 'USaveLoadEnemyParamManager::M_UniqueBrainCrashPlayedList' has a wrong offset!");

// Class BattlePrototype.SaveLoadExSystemParamManager
// 0x0110 (0x0138 - 0x0028)
class USaveLoadExSystemParamManager final : public UObject
{
public:
	uint8                                         Pad_283D[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_AdditionalSystemSave;                            // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPatch01Param                          Patch01Param;                                      // 0x0048(0x0058)(NativeAccessSpecifierPrivate)
	struct FPatch03Param                          Patch03Param;                                      // 0x00A0(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPatchParam_DLC01                      PatchDLC01Param;                                   // 0x00B0(0x0028)(NativeAccessSpecifierPrivate)
	struct FPatchParam_DLC02                      PatchDLC02Param;                                   // 0x00D8(0x0010)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPatchParam_DLC03                      PatchDLC03Param;                                   // 0x00E8(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPatchParam_DLC04                      PatchDLC04Param;                                   // 0x0100(0x0030)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_283E[0x8];                                     // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EAttackDirOrtho GetAttackDirOrtho();
	EAttackDirOrthoLockon GetAttackDirOrthoLockon();
	uint8 GetBehindCameraSpeed();
	ECameraDistance GetCameraDistance();
	uint8 GetCameraSpeedLockon();
	ELetterSize GetLetterSize();
	ESASCutin GetSASCutin();
	void SetAttackDirOrtho(EAttackDirOrtho Value);
	void SetAttackDirOrthoLockon(EAttackDirOrthoLockon Value);
	void SetBehindCameraSpeed(uint8 Value);
	void SetCameraDistance(ECameraDistance Value);
	void SetCameraSpeedLockon(uint8 Value);
	void SetLetterSize(ELetterSize Value);
	void SetSASCutin(ESASCutin Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadExSystemParamManager">();
	}
	static class USaveLoadExSystemParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadExSystemParamManager>();
	}
};
static_assert(alignof(USaveLoadExSystemParamManager) == 0x000008, "Wrong alignment on USaveLoadExSystemParamManager");
static_assert(sizeof(USaveLoadExSystemParamManager) == 0x000138, "Wrong size on USaveLoadExSystemParamManager");
static_assert(offsetof(USaveLoadExSystemParamManager, M_AdditionalSystemSave) == 0x000038, "Member 'USaveLoadExSystemParamManager::M_AdditionalSystemSave' has a wrong offset!");
static_assert(offsetof(USaveLoadExSystemParamManager, Patch01Param) == 0x000048, "Member 'USaveLoadExSystemParamManager::Patch01Param' has a wrong offset!");
static_assert(offsetof(USaveLoadExSystemParamManager, Patch03Param) == 0x0000A0, "Member 'USaveLoadExSystemParamManager::Patch03Param' has a wrong offset!");
static_assert(offsetof(USaveLoadExSystemParamManager, PatchDLC01Param) == 0x0000B0, "Member 'USaveLoadExSystemParamManager::PatchDLC01Param' has a wrong offset!");
static_assert(offsetof(USaveLoadExSystemParamManager, PatchDLC02Param) == 0x0000D8, "Member 'USaveLoadExSystemParamManager::PatchDLC02Param' has a wrong offset!");
static_assert(offsetof(USaveLoadExSystemParamManager, PatchDLC03Param) == 0x0000E8, "Member 'USaveLoadExSystemParamManager::PatchDLC03Param' has a wrong offset!");
static_assert(offsetof(USaveLoadExSystemParamManager, PatchDLC04Param) == 0x000100, "Member 'USaveLoadExSystemParamManager::PatchDLC04Param' has a wrong offset!");

// Class BattlePrototype.SaveLoadParamClassManager
// 0x0068 (0x0090 - 0x0028)
class USaveLoadParamClassManager final : public UObject
{
public:
	uint8                                         Pad_283F[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_isLoadExecution;                                 // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2840[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_RetryData;                                       // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 M_AsyncAutoSaveData;                               // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadSystemParamManager*            M_pSaveLoadSystemParamManager;                     // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadPlayerParamManager*            M_pSaveLoadPlayerParamManager;                     // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadEnemyParamManager*             M_pSaveLoadEnemyParamManager;                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadArrangeItemManager*            M_pSaveLoadArrangeItemManager;                     // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadExSystemParamManager*          M_pSaveLoadExSystemParamManager;                   // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveLoadExSystemParamManager*          M_pSaveLoadExSystemParamManager_Trial2LoadOnly;    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2841[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USaveLoadArrangeItemManager* GetSaveLoadArrangeItemManager();
	class USaveLoadEnemyParamManager* GetSaveLoadEnemyParamManager();
	class USaveLoadExSystemParamManager* GetSaveLoadExSystemParamManager();
	class USaveLoadExSystemParamManager* GetSaveLoadExSystemParamManager_Trial2LoadOnly();
	class USaveLoadPlayerParamManager* GetSaveLoadPlayerParamManager();
	class USaveLoadSystemParamManager* GetSaveLoadSystemParamManager();
	bool IsLoadExecution();
	void SetGameInstance(class URSGameInstance* GameInst);
	void SetIsLoadExecution(const bool Flag);
	void SetSaveParamToGameParam(const class URSGameInstance* GameInst);
	void SetSaveParamToGameParam_ScenarioFlag(const class URSGameInstance* GameInst);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadParamClassManager">();
	}
	static class USaveLoadParamClassManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadParamClassManager>();
	}
};
static_assert(alignof(USaveLoadParamClassManager) == 0x000008, "Wrong alignment on USaveLoadParamClassManager");
static_assert(sizeof(USaveLoadParamClassManager) == 0x000090, "Wrong size on USaveLoadParamClassManager");
static_assert(offsetof(USaveLoadParamClassManager, M_isLoadExecution) == 0x000030, "Member 'USaveLoadParamClassManager::M_isLoadExecution' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_RetryData) == 0x000038, "Member 'USaveLoadParamClassManager::M_RetryData' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_AsyncAutoSaveData) == 0x000048, "Member 'USaveLoadParamClassManager::M_AsyncAutoSaveData' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadSystemParamManager) == 0x000058, "Member 'USaveLoadParamClassManager::M_pSaveLoadSystemParamManager' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadPlayerParamManager) == 0x000060, "Member 'USaveLoadParamClassManager::M_pSaveLoadPlayerParamManager' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadEnemyParamManager) == 0x000068, "Member 'USaveLoadParamClassManager::M_pSaveLoadEnemyParamManager' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadArrangeItemManager) == 0x000070, "Member 'USaveLoadParamClassManager::M_pSaveLoadArrangeItemManager' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadExSystemParamManager) == 0x000078, "Member 'USaveLoadParamClassManager::M_pSaveLoadExSystemParamManager' has a wrong offset!");
static_assert(offsetof(USaveLoadParamClassManager, M_pSaveLoadExSystemParamManager_Trial2LoadOnly) == 0x000080, "Member 'USaveLoadParamClassManager::M_pSaveLoadExSystemParamManager_Trial2LoadOnly' has a wrong offset!");

// Class BattlePrototype.UIMinimapDistance
// 0x0028 (0x03B0 - 0x0388)
class UUIMinimapDistance : public UUIBase
{
public:
	uint8                                         Pad_2842[0x28];                                    // 0x0388(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Default_normal, class UWidgetAnimation* Default_red);
	void InitializeText(class UTextBlock* Distancenum, class UTextBlock* Distancetext);
	void SetDistance(const class FString& Num);
	void SetTextColor(EUIMinmapDistanceIconColor Color);
	void SetThumbnail(EUIMinmapDistanceIcon Icon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMinimapDistance">();
	}
	static class UUIMinimapDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMinimapDistance>();
	}
};
static_assert(alignof(UUIMinimapDistance) == 0x000008, "Wrong alignment on UUIMinimapDistance");
static_assert(sizeof(UUIMinimapDistance) == 0x0003B0, "Wrong size on UUIMinimapDistance");

// Class BattlePrototype.SaveLoadPlayerParamManager
// 0x0038 (0x0060 - 0x0028)
class USaveLoadPlayerParamManager final : public UObject
{
public:
	uint8                                         Pad_2843[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerID                                     M_BattleMemberMain;                                // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     M_BattleMemberLeft;                                // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerID                                     M_BattleMemberRight;                               // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2844[0x5];                                     // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveLoadPlayerParam>           M_saveLoadPlayerParamList;                         // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NpcAssistCountHP;                                // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NpcAssistCountBadStatus;                         // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_NpcAssistCountRevive;                            // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDriveUsedFlag;                                  // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2845[0x3];                                     // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadPlayerParamManager">();
	}
	static class USaveLoadPlayerParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadPlayerParamManager>();
	}
};
static_assert(alignof(USaveLoadPlayerParamManager) == 0x000008, "Wrong alignment on USaveLoadPlayerParamManager");
static_assert(sizeof(USaveLoadPlayerParamManager) == 0x000060, "Wrong size on USaveLoadPlayerParamManager");
static_assert(offsetof(USaveLoadPlayerParamManager, M_BattleMemberMain) == 0x000038, "Member 'USaveLoadPlayerParamManager::M_BattleMemberMain' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_BattleMemberLeft) == 0x000039, "Member 'USaveLoadPlayerParamManager::M_BattleMemberLeft' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_BattleMemberRight) == 0x00003A, "Member 'USaveLoadPlayerParamManager::M_BattleMemberRight' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_saveLoadPlayerParamList) == 0x000040, "Member 'USaveLoadPlayerParamManager::M_saveLoadPlayerParamList' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_NpcAssistCountHP) == 0x000050, "Member 'USaveLoadPlayerParamManager::M_NpcAssistCountHP' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_NpcAssistCountBadStatus) == 0x000054, "Member 'USaveLoadPlayerParamManager::M_NpcAssistCountBadStatus' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_NpcAssistCountRevive) == 0x000058, "Member 'USaveLoadPlayerParamManager::M_NpcAssistCountRevive' has a wrong offset!");
static_assert(offsetof(USaveLoadPlayerParamManager, M_bDriveUsedFlag) == 0x00005C, "Member 'USaveLoadPlayerParamManager::M_bDriveUsedFlag' has a wrong offset!");

// Class BattlePrototype.SaveLoadPsychicObjectManager
// 0x0020 (0x0048 - 0x0028)
class USaveLoadPsychicObjectManager final : public UObject
{
public:
	uint8                                         Pad_2846[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveLoadPsychicObjectParam>    M_saveLoadPsychicObjectParamList;                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadPsychicObjectManager">();
	}
	static class USaveLoadPsychicObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadPsychicObjectManager>();
	}
};
static_assert(alignof(USaveLoadPsychicObjectManager) == 0x000008, "Wrong alignment on USaveLoadPsychicObjectManager");
static_assert(sizeof(USaveLoadPsychicObjectManager) == 0x000048, "Wrong size on USaveLoadPsychicObjectManager");
static_assert(offsetof(USaveLoadPsychicObjectManager, M_saveLoadPsychicObjectParamList) == 0x000038, "Member 'USaveLoadPsychicObjectManager::M_saveLoadPsychicObjectParamList' has a wrong offset!");

// Class BattlePrototype.SaveLoadScreenParamManager
// 0x0090 (0x00B8 - 0x0028)
class USaveLoadScreenParamManager final : public UObject
{
public:
	uint8                                         Pad_2847[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveLoadScreenParam>           M_saveLoadScreenParamList;                         // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2848[0x70];                                    // 0x0048(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadScreenParamManager">();
	}
	static class USaveLoadScreenParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadScreenParamManager>();
	}
};
static_assert(alignof(USaveLoadScreenParamManager) == 0x000008, "Wrong alignment on USaveLoadScreenParamManager");
static_assert(sizeof(USaveLoadScreenParamManager) == 0x0000B8, "Wrong size on USaveLoadScreenParamManager");
static_assert(offsetof(USaveLoadScreenParamManager, M_saveLoadScreenParamList) == 0x000038, "Member 'USaveLoadScreenParamManager::M_saveLoadScreenParamList' has a wrong offset!");

// Class BattlePrototype.SaveLoadSystemParamManager
// 0x00A0 (0x00C8 - 0x0028)
class USaveLoadSystemParamManager final : public UObject
{
public:
	uint8                                         Pad_2849[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_LastSaveSlotNo;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_284A[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                M_ScenarioFlags;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_ProgressID;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_LocationID;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_AreaID;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_VariationID;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_PortalID;                                        // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284B[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 M_LiftFloorList;                                   // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         M_LoadMakeEventPathList;                           // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284C[0x40];                                    // 0x0088(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetLastSaveSlotNo();
	void SetLastSaveSlotNo(const int32 SlotNo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveLoadSystemParamManager">();
	}
	static class USaveLoadSystemParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveLoadSystemParamManager>();
	}
};
static_assert(alignof(USaveLoadSystemParamManager) == 0x000008, "Wrong alignment on USaveLoadSystemParamManager");
static_assert(sizeof(USaveLoadSystemParamManager) == 0x0000C8, "Wrong size on USaveLoadSystemParamManager");
static_assert(offsetof(USaveLoadSystemParamManager, M_LastSaveSlotNo) == 0x000038, "Member 'USaveLoadSystemParamManager::M_LastSaveSlotNo' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_ScenarioFlags) == 0x000040, "Member 'USaveLoadSystemParamManager::M_ScenarioFlags' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_ProgressID) == 0x000050, "Member 'USaveLoadSystemParamManager::M_ProgressID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_LocationID) == 0x000054, "Member 'USaveLoadSystemParamManager::M_LocationID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_AreaID) == 0x000058, "Member 'USaveLoadSystemParamManager::M_AreaID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_VariationID) == 0x00005C, "Member 'USaveLoadSystemParamManager::M_VariationID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_PortalID) == 0x000060, "Member 'USaveLoadSystemParamManager::M_PortalID' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_LiftFloorList) == 0x000068, "Member 'USaveLoadSystemParamManager::M_LiftFloorList' has a wrong offset!");
static_assert(offsetof(USaveLoadSystemParamManager, M_LoadMakeEventPathList) == 0x000078, "Member 'USaveLoadSystemParamManager::M_LoadMakeEventPathList' has a wrong offset!");

// Class BattlePrototype.ScarParam
// 0x00D0 (0x0100 - 0x0030)
class UScarParam final : public UDataAsset
{
public:
	float                                         LengthStroke;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthThick;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthFront;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScarColorParam                        ColorNormal;                                       // 0x003C(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FScarColorParam                        ColorFlame;                                        // 0x007C(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FScarColorParam                        ColorElectric;                                     // 0x00BC(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_284D[0x4];                                     // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScarParam">();
	}
	static class UScarParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScarParam>();
	}
};
static_assert(alignof(UScarParam) == 0x000008, "Wrong alignment on UScarParam");
static_assert(sizeof(UScarParam) == 0x000100, "Wrong size on UScarParam");
static_assert(offsetof(UScarParam, LengthStroke) == 0x000030, "Member 'UScarParam::LengthStroke' has a wrong offset!");
static_assert(offsetof(UScarParam, LengthThick) == 0x000034, "Member 'UScarParam::LengthThick' has a wrong offset!");
static_assert(offsetof(UScarParam, LengthFront) == 0x000038, "Member 'UScarParam::LengthFront' has a wrong offset!");
static_assert(offsetof(UScarParam, ColorNormal) == 0x00003C, "Member 'UScarParam::ColorNormal' has a wrong offset!");
static_assert(offsetof(UScarParam, ColorFlame) == 0x00007C, "Member 'UScarParam::ColorFlame' has a wrong offset!");
static_assert(offsetof(UScarParam, ColorElectric) == 0x0000BC, "Member 'UScarParam::ColorElectric' has a wrong offset!");

// Class BattlePrototype.SceneManager
// 0x0098 (0x02C8 - 0x0230)
class ASceneManager : public ARSActorSystemBase
{
public:
	uint8                                         Pad_284E[0x10];                                    // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsAreaChanging;                                    // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284F[0x7];                                     // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnBeforeChangeScenarioFlag;                        // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAfterChangeScenarioFlag;                         // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeAreaLoadStatus;                            // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsCheckTextureLoadAtStartScene;                    // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2850[0x3];                                     // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TextureLoadPercentAtStartScene;                    // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AJumpAreaBase*>                  CurrentEnabledJumpAreas;                           // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint32>                                M_flags;                                           // 0x0290(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             M_FlagTable;                                       // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlueprintFunctionLibrary*              FunctionLibrary;                                   // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 M_FunctionLibraryActor;                            // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isSaveDataLoadFlow_ArrangeItemManager;           // 0x02B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_isAreaChangeRetrySaveFlag;                       // 0x02B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2851[0x2];                                     // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_WaitUnloadDynamicLevels_WaitCaount;              // 0x02BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_WaitUnloadDynamicLevels_IsDoFlushRenderingCommands; // 0x02C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2852[0x7];                                     // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCurrentJumpArea(class AJumpAreaBase* Actor);
	void CallFuncFromCode_UpdateAllTownPeopleState();
	void CallOnChangeAreaLoadStatus(EChangeAreaStatus Status, bool IsChangeLocation);
	void CallPortalFunction(int32 LocationId, int32 AreaId, int32 PortalID, int32* NextLocationID, int32* NextAreaID, class FName* PortalName);
	bool CheckScenarioFlag(class FName RowName);
	void ClearCurrentJumpArea();
	void FlushPhysicsSimulation();
	void GetBeforeLocationAndArea(int32* LocationId, int32* AreaId);
	class FName GetBeforeLocationName();
	void GetCurrentLocationAndArea(int32* LocationId, int32* AreaId);
	void GetCurrentLocationInfo(int32* LocationId, int32* AreaId, int32* VariationID, int32* PortalID);
	class FName GetCurrentLocationName();
	EMainScenarioType GetMainScenarioType();
	bool IsAreaChangeRetrySaveFlag();
	bool IsSaveDataLoadFlow_ArrangeItemManager();
	bool IsWaitedForWaitUnloadDynamicLevels();
	void OffScenarioFlag(class FName RowName);
	bool OnEndGameMenu();
	void OnScenarioFlag(class FName RowName);
	void RemoveCurrentJumpArea(class AJumpAreaBase* Actor);
	void RequestChangeScene(int32 LocationId, int32 AreaId, int32 PortalID, const TArray<class FName>& SceneArgs, bool NoFade, bool* Error, ELoadingScreenType LoadingScreenType, int32 LoadingScreenParam, bool IsAutoSaveEnable, class FName BattleSimulatorLevelInfosName);
	void RequestChangeSceneBattleSimulator(class FName BattleSimulatorRowName);
	void SetIsAreaChangeRetrySaveFlag(const bool Flag);
	void SetIsSaveDataLoadFlow_ArrangeItemManager(const bool Flag);
	void ToggleScenarioFlag(class FName RowName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneManager">();
	}
	static class ASceneManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASceneManager>();
	}
};
static_assert(alignof(ASceneManager) == 0x000008, "Wrong alignment on ASceneManager");
static_assert(sizeof(ASceneManager) == 0x0002C8, "Wrong size on ASceneManager");
static_assert(offsetof(ASceneManager, IsAreaChanging) == 0x000240, "Member 'ASceneManager::IsAreaChanging' has a wrong offset!");
static_assert(offsetof(ASceneManager, OnBeforeChangeScenarioFlag) == 0x000248, "Member 'ASceneManager::OnBeforeChangeScenarioFlag' has a wrong offset!");
static_assert(offsetof(ASceneManager, OnAfterChangeScenarioFlag) == 0x000258, "Member 'ASceneManager::OnAfterChangeScenarioFlag' has a wrong offset!");
static_assert(offsetof(ASceneManager, OnChangeAreaLoadStatus) == 0x000268, "Member 'ASceneManager::OnChangeAreaLoadStatus' has a wrong offset!");
static_assert(offsetof(ASceneManager, IsCheckTextureLoadAtStartScene) == 0x000278, "Member 'ASceneManager::IsCheckTextureLoadAtStartScene' has a wrong offset!");
static_assert(offsetof(ASceneManager, TextureLoadPercentAtStartScene) == 0x00027C, "Member 'ASceneManager::TextureLoadPercentAtStartScene' has a wrong offset!");
static_assert(offsetof(ASceneManager, CurrentEnabledJumpAreas) == 0x000280, "Member 'ASceneManager::CurrentEnabledJumpAreas' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_flags) == 0x000290, "Member 'ASceneManager::M_flags' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_FlagTable) == 0x0002A0, "Member 'ASceneManager::M_FlagTable' has a wrong offset!");
static_assert(offsetof(ASceneManager, FunctionLibrary) == 0x0002A8, "Member 'ASceneManager::FunctionLibrary' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_FunctionLibraryActor) == 0x0002B0, "Member 'ASceneManager::M_FunctionLibraryActor' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_isSaveDataLoadFlow_ArrangeItemManager) == 0x0002B8, "Member 'ASceneManager::M_isSaveDataLoadFlow_ArrangeItemManager' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_isAreaChangeRetrySaveFlag) == 0x0002B9, "Member 'ASceneManager::M_isAreaChangeRetrySaveFlag' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_WaitUnloadDynamicLevels_WaitCaount) == 0x0002BC, "Member 'ASceneManager::M_WaitUnloadDynamicLevels_WaitCaount' has a wrong offset!");
static_assert(offsetof(ASceneManager, M_WaitUnloadDynamicLevels_IsDoFlushRenderingCommands) == 0x0002C0, "Member 'ASceneManager::M_WaitUnloadDynamicLevels_IsDoFlushRenderingCommands' has a wrong offset!");

// Class BattlePrototype.SearchingComponent
// 0x0000 (0x00C0 - 0x00C0)
class USearchingComponent final : public UActorComponent
{
public:
	bool IsDistanceAngleCheck(class AActor* Target, const struct FVector& TargetLocation, float Range, float Angle, const struct FRotator& Rot, bool NoHeight, const struct FVector& SelfLocation, bool SelfLocationOn);

	bool IsSearch(const struct FVector& VecStart, const struct FVector& VecEnd, const struct FVector& VecForward, float Distance, float Range) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchingComponent">();
	}
	static class USearchingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchingComponent>();
	}
};
static_assert(alignof(USearchingComponent) == 0x000008, "Wrong alignment on USearchingComponent");
static_assert(sizeof(USearchingComponent) == 0x0000C0, "Wrong size on USearchingComponent");

// Class BattlePrototype.UITitleLogo
// 0x00D0 (0x0458 - 0x0388)
class UUITitleLogo : public UUIBase
{
public:
	uint8                                         Pad_285B[0x28];                                    // 0x0388(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               TextureLogo[0x6];                                  // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIGamerTag*                            M_UserTag;                                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285C[0x28];                                    // 0x03E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSHUDBase*                             M_pRSHudBase;                                      // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URSSaveGame*                            M_pSaveGameSystem;                                 // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadSystemParamManager;                     // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285D[0x30];                                    // 0x0428(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UImage* ImageLogo);
	void SetUserTagWidget(class UUIGamerTag* UserTag);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleLogo">();
	}
	static class UUITitleLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleLogo>();
	}
};
static_assert(alignof(UUITitleLogo) == 0x000008, "Wrong alignment on UUITitleLogo");
static_assert(sizeof(UUITitleLogo) == 0x000458, "Wrong size on UUITitleLogo");
static_assert(offsetof(UUITitleLogo, TextureLogo) == 0x0003B0, "Member 'UUITitleLogo::TextureLogo' has a wrong offset!");
static_assert(offsetof(UUITitleLogo, M_UserTag) == 0x0003E0, "Member 'UUITitleLogo::M_UserTag' has a wrong offset!");
static_assert(offsetof(UUITitleLogo, M_pRSHudBase) == 0x000410, "Member 'UUITitleLogo::M_pRSHudBase' has a wrong offset!");
static_assert(offsetof(UUITitleLogo, M_pSaveGameSystem) == 0x000418, "Member 'UUITitleLogo::M_pSaveGameSystem' has a wrong offset!");
static_assert(offsetof(UUITitleLogo, M_pSaveLoadSystemParamManager) == 0x000420, "Member 'UUITitleLogo::M_pSaveLoadSystemParamManager' has a wrong offset!");

// Class BattlePrototype.SeqAnimInstance
// 0x0000 (0x0270 - 0x0270)
class USeqAnimInstance final : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeqAnimInstance">();
	}
	static class USeqAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeqAnimInstance>();
	}
};
static_assert(alignof(USeqAnimInstance) == 0x000010, "Wrong alignment on USeqAnimInstance");
static_assert(sizeof(USeqAnimInstance) == 0x000270, "Wrong size on USeqAnimInstance");

// Class BattlePrototype.SequencerCharacterDummy
// 0x0008 (0x0238 - 0x0230)
class ASequencerCharacterDummy final : public ARSActorSystemBase
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerCharacterDummy">();
	}
	static class ASequencerCharacterDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerCharacterDummy>();
	}
};
static_assert(alignof(ASequencerCharacterDummy) == 0x000008, "Wrong alignment on ASequencerCharacterDummy");
static_assert(sizeof(ASequencerCharacterDummy) == 0x000238, "Wrong size on ASequencerCharacterDummy");
static_assert(offsetof(ASequencerCharacterDummy, Mesh) == 0x000230, "Member 'ASequencerCharacterDummy::Mesh' has a wrong offset!");

// Class BattlePrototype.SequencerEventUtility
// 0x0000 (0x0230 - 0x0230)
class ASequencerEventUtility final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerEventUtility">();
	}
	static class ASequencerEventUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerEventUtility>();
	}
};
static_assert(alignof(ASequencerEventUtility) == 0x000008, "Wrong alignment on ASequencerEventUtility");
static_assert(sizeof(ASequencerEventUtility) == 0x000230, "Wrong size on ASequencerEventUtility");

// Class BattlePrototype.SequencerParticle
// 0x0038 (0x0268 - 0x0230)
class ASequencerParticle : public AActor
{
public:
	float                                         WarmupTime;                                        // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            AttachSocketLocation;                              // 0x0234(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoolVector                            AttachSocketRotation;                              // 0x0237(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ERSParticleSystemAttachRotationOffMode        AttachSocketRotationOffMode;                       // 0x023A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoolVector                            AttachSocketScale;                                 // 0x023B(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	ESequencerDilationOwner                       DilationOwner;                                     // 0x023E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_285E[0x1];                                     // 0x023F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         ParticleSystemComponent;                           // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_285F[0x20];                                    // 0x0248(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivated(class UActorComponent* Component, bool bReset);
	void SetupAttachInstanceParameter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerParticle">();
	}
	static class ASequencerParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerParticle>();
	}
};
static_assert(alignof(ASequencerParticle) == 0x000008, "Wrong alignment on ASequencerParticle");
static_assert(sizeof(ASequencerParticle) == 0x000268, "Wrong size on ASequencerParticle");
static_assert(offsetof(ASequencerParticle, WarmupTime) == 0x000230, "Member 'ASequencerParticle::WarmupTime' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, AttachSocketLocation) == 0x000234, "Member 'ASequencerParticle::AttachSocketLocation' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, AttachSocketRotation) == 0x000237, "Member 'ASequencerParticle::AttachSocketRotation' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, AttachSocketRotationOffMode) == 0x00023A, "Member 'ASequencerParticle::AttachSocketRotationOffMode' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, AttachSocketScale) == 0x00023B, "Member 'ASequencerParticle::AttachSocketScale' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, DilationOwner) == 0x00023E, "Member 'ASequencerParticle::DilationOwner' has a wrong offset!");
static_assert(offsetof(ASequencerParticle, ParticleSystemComponent) == 0x000240, "Member 'ASequencerParticle::ParticleSystemComponent' has a wrong offset!");

// Class BattlePrototype.SequencerParticleTrail
// 0x0028 (0x0290 - 0x0268)
class ASequencerParticleTrail final : public ASequencerParticle
{
public:
	class FName                                   FirstSocketName;                                   // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocketName;                                  // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               WidthScaleMode;                                    // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2861[0x3];                                     // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidthScale;                                        // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeRate;                                          // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FadeOutMaterialScalarName;                         // 0x0284(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2862[0x4];                                     // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerParticleTrail">();
	}
	static class ASequencerParticleTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerParticleTrail>();
	}
};
static_assert(alignof(ASequencerParticleTrail) == 0x000008, "Wrong alignment on ASequencerParticleTrail");
static_assert(sizeof(ASequencerParticleTrail) == 0x000290, "Wrong size on ASequencerParticleTrail");
static_assert(offsetof(ASequencerParticleTrail, FirstSocketName) == 0x000268, "Member 'ASequencerParticleTrail::FirstSocketName' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, SecondSocketName) == 0x000270, "Member 'ASequencerParticleTrail::SecondSocketName' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, WidthScaleMode) == 0x000278, "Member 'ASequencerParticleTrail::WidthScaleMode' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, WidthScale) == 0x00027C, "Member 'ASequencerParticleTrail::WidthScale' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, FadeRate) == 0x000280, "Member 'ASequencerParticleTrail::FadeRate' has a wrong offset!");
static_assert(offsetof(ASequencerParticleTrail, FadeOutMaterialScalarName) == 0x000284, "Member 'ASequencerParticleTrail::FadeOutMaterialScalarName' has a wrong offset!");

// Class BattlePrototype.SequencerSound
// 0x0010 (0x0240 - 0x0230)
class ASequencerSound final : public AActor
{
public:
	class URSAtomComponentBase*                   AtomComponent;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2863[0x8];                                     // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URSAtomComponentBase* GetAtomComponent();
	void StopSequenceSound(float FadeTime, float FadeVolume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerSound">();
	}
	static class ASequencerSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerSound>();
	}
};
static_assert(alignof(ASequencerSound) == 0x000008, "Wrong alignment on ASequencerSound");
static_assert(sizeof(ASequencerSound) == 0x000240, "Wrong size on ASequencerSound");
static_assert(offsetof(ASequencerSound, AtomComponent) == 0x000230, "Member 'ASequencerSound::AtomComponent' has a wrong offset!");

// Class BattlePrototype.UIVisionSimulatorListIndex
// 0x0070 (0x03F8 - 0x0388)
class UUIVisionSimulatorListIndex : public UUIBase
{
public:
	uint8                                         Pad_2864[0x70];                                    // 0x0388(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimDefaultLock, class UWidgetAnimation* AnimSelectLock, class UWidgetAnimation* AnimSelectInLock, class UImage* ImageNewIcon, class UOverlay* OverlayRankIcon, class UImage* ImageRankIcon, class UImage* ImageRankIconAdd, class UTextBlock* TextName, class UTextBlock* TextMissionNumber);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVisionSimulatorListIndex">();
	}
	static class UUIVisionSimulatorListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVisionSimulatorListIndex>();
	}
};
static_assert(alignof(UUIVisionSimulatorListIndex) == 0x000008, "Wrong alignment on UUIVisionSimulatorListIndex");
static_assert(sizeof(UUIVisionSimulatorListIndex) == 0x0003F8, "Wrong size on UUIVisionSimulatorListIndex");

// Class BattlePrototype.SequencerSoundManagerController
// 0x0010 (0x0240 - 0x0230)
class ASequencerSoundManagerController final : public AActor
{
public:
	TArray<class USoundAtomCue*>                  BgmCueArray;                                       // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerSoundManagerController">();
	}
	static class ASequencerSoundManagerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequencerSoundManagerController>();
	}
};
static_assert(alignof(ASequencerSoundManagerController) == 0x000008, "Wrong alignment on ASequencerSoundManagerController");
static_assert(sizeof(ASequencerSoundManagerController) == 0x000240, "Wrong size on ASequencerSoundManagerController");
static_assert(offsetof(ASequencerSoundManagerController, BgmCueArray) == 0x000230, "Member 'ASequencerSoundManagerController::BgmCueArray' has a wrong offset!");

// Class BattlePrototype.ShowDestinationActor
// 0x0000 (0x0230 - 0x0230)
class AShowDestinationActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationActor">();
	}
	static class AShowDestinationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShowDestinationActor>();
	}
};
static_assert(alignof(AShowDestinationActor) == 0x000008, "Wrong alignment on AShowDestinationActor");
static_assert(sizeof(AShowDestinationActor) == 0x000230, "Wrong size on AShowDestinationActor");

// Class BattlePrototype.ShowDestinationData
// 0x0008 (0x0030 - 0x0028)
class UShowDestinationData final : public UObject
{
public:
	class UShowDestinationDBAsset*                ShowDestinationAsset_;                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetDataCellFromActorName(class FName ActorName, struct FShowDestinationDBDataCell* Cell);
	bool LoadDataAsset(const class FString& DtPath);

	const TMap<class FName, struct FShowDestinationDBDataCell> GetDB() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationData">();
	}
	static class UShowDestinationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShowDestinationData>();
	}
};
static_assert(alignof(UShowDestinationData) == 0x000008, "Wrong alignment on UShowDestinationData");
static_assert(sizeof(UShowDestinationData) == 0x000030, "Wrong size on UShowDestinationData");
static_assert(offsetof(UShowDestinationData, ShowDestinationAsset_) == 0x000028, "Member 'UShowDestinationData::ShowDestinationAsset_' has a wrong offset!");

// Class BattlePrototype.UIPsychicWeightGauge
// 0x00B8 (0x0440 - 0x0388)
class UUIPsychicWeightGauge : public UUIBase
{
public:
	uint8                                         Pad_2866[0x38];                                    // 0x0388(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2867[0x78];                                    // 0x03C8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseDirectEx();
	struct FVector GetPsychicObjectWeightGaugePos(class AActor* Param_Target);
	void InitializeThis(class UImage* ImageBar1, class UImage* ImageBar2, class UImage* ImageBar1Add, class UImage* ImageWeightButton, class UImage* ImageWeightIconFont, class UImage* ImageFrame1, class UImage* ImageFrame2, class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault1, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault3, class UWidgetAnimation* AnimDefault4, class UWidgetAnimation* AnimIn1, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimIn4, class UWidgetAnimation* AnimOut1, class UWidgetAnimation* AnimOut2, class UWidgetAnimation* AnimChange1, class UWidgetAnimation* AnimChange2, class UWidgetAnimation* AnimDecision1, class UWidgetAnimation* AnimDecision2);
	void OpenEx();
	void SetEnableCombo(bool IsEnable);
	void SetEnabnle(bool IsEnable);
	void SetExObjectFlag(bool IsExObject);
	void SetGauge(int32 Level, float FPercent);
	void SetGaugeReverse(bool FlagReverse);
	void SetGaugeVisible(bool Param_IsVisible);
	void SetStyle(EPsychicWeightGaugeButton Button, EPsychicWeightGaugeSize Size, int32 MaxLevel);
	void SetSuccessFlag(bool IsSuccess);
	void SetTarget(class AActor* Param_Target);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	struct FLinearColor GetFontColorButton1() const;
	struct FLinearColor GetFontColorButton2() const;
	bool GetGaugeReverseFlag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPsychicWeightGauge">();
	}
	static class UUIPsychicWeightGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPsychicWeightGauge>();
	}
};
static_assert(alignof(UUIPsychicWeightGauge) == 0x000008, "Wrong alignment on UUIPsychicWeightGauge");
static_assert(sizeof(UUIPsychicWeightGauge) == 0x000440, "Wrong size on UUIPsychicWeightGauge");
static_assert(offsetof(UUIPsychicWeightGauge, Target) == 0x0003C0, "Member 'UUIPsychicWeightGauge::Target' has a wrong offset!");

// Class BattlePrototype.ShowDestinationExporter
// 0x0098 (0x02C8 - 0x0230)
class AShowDestinationExporter final : public AActor
{
public:
	uint8                                         Pad_286A[0x98];                                    // 0x0230(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConvertString();
	void ExportData();
	void GetAllActorsOfAllLevels(const class UObject* WorldContextObject, TArray<class AActor*>* Actors);
	void RegistData(const class FString& ActorName, const struct FVector& ActorPosition, int32 CheckType, int32 ProgressId, int32 Nanka, const TArray<int32>& CType, const TArray<class FString>& CName, const TArray<bool>& CIsCheck, class FString* LocationName, class FString* AreaName);
	void RegistSortData(const class FString& ActorName, const class FString& LocationName, const class FString& AreaName, const struct FVector& ActorPosition, int32 CheckType, int32 ProgressId, int32 Nanka, const TArray<int32>& CType, const TArray<class FString>& CName, const TArray<bool>& CIsCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationExporter">();
	}
	static class AShowDestinationExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShowDestinationExporter>();
	}
};
static_assert(alignof(AShowDestinationExporter) == 0x000008, "Wrong alignment on AShowDestinationExporter");
static_assert(sizeof(AShowDestinationExporter) == 0x0002C8, "Wrong size on AShowDestinationExporter");

// Class BattlePrototype.ShowDestinationTableExporter
// 0x0040 (0x0270 - 0x0230)
class AShowDestinationTableExporter final : public AActor
{
public:
	uint8                                         Pad_286B[0x20];                                    // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULevel*>                         LoadedLevels_;                                     // 0x0250(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FShowDestinationActorData>      PickedUpActor_;                                    // 0x0260(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ExportCSVData();
	void GetAllActorsOfAllLevels(const class UObject* WorldContextObject, TArray<class AActor*>* PickedUpActor, int32 LocationId, int32 AreaId);
	bool RegistDataAtLoadedLevel(int32 LocationId, int32 AreaId);
	void RegistExportDatas(const TArray<struct FShowDestinationActorData>& ExportDatas);
	void SearchLoadedLevels();
	void StartupAtLoadBeginDoOnce();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShowDestinationTableExporter">();
	}
	static class AShowDestinationTableExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShowDestinationTableExporter>();
	}
};
static_assert(alignof(AShowDestinationTableExporter) == 0x000008, "Wrong alignment on AShowDestinationTableExporter");
static_assert(sizeof(AShowDestinationTableExporter) == 0x000270, "Wrong size on AShowDestinationTableExporter");
static_assert(offsetof(AShowDestinationTableExporter, LoadedLevels_) == 0x000250, "Member 'AShowDestinationTableExporter::LoadedLevels_' has a wrong offset!");
static_assert(offsetof(AShowDestinationTableExporter, PickedUpActor_) == 0x000260, "Member 'AShowDestinationTableExporter::PickedUpActor_' has a wrong offset!");

// Class BattlePrototype.SIWBlock
// 0x0008 (0x0238 - 0x0230)
class ASIWBlock final : public AActor
{
public:
	float                                         AttenuationRate;                                   // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286D[0x4];                                     // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SIWBlock">();
	}
	static class ASIWBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASIWBlock>();
	}
};
static_assert(alignof(ASIWBlock) == 0x000008, "Wrong alignment on ASIWBlock");
static_assert(sizeof(ASIWBlock) == 0x000238, "Wrong size on ASIWBlock");
static_assert(offsetof(ASIWBlock, AttenuationRate) == 0x000230, "Member 'ASIWBlock::AttenuationRate' has a wrong offset!");

// Class BattlePrototype.SIWManager
// 0x0080 (0x0140 - 0x00C0)
class USIWManager : public UActorComponent
{
public:
	float                                         WithoutCalcAttenuationNearDistance;                // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WithoutCalcAttenuationFarDistance;                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_286E[0x78];                                    // 0x00C8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SIWManager">();
	}
	static class USIWManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USIWManager>();
	}
};
static_assert(alignof(USIWManager) == 0x000008, "Wrong alignment on USIWManager");
static_assert(sizeof(USIWManager) == 0x000140, "Wrong size on USIWManager");
static_assert(offsetof(USIWManager, WithoutCalcAttenuationNearDistance) == 0x0000C0, "Member 'USIWManager::WithoutCalcAttenuationNearDistance' has a wrong offset!");
static_assert(offsetof(USIWManager, WithoutCalcAttenuationFarDistance) == 0x0000C4, "Member 'USIWManager::WithoutCalcAttenuationFarDistance' has a wrong offset!");

// Class BattlePrototype.UIQuestDetailsSub
// 0x0188 (0x0510 - 0x0388)
class UUIQuestDetailsSub : public UUIBase
{
public:
	uint8                                         Pad_286F[0x188];                                   // 0x0388(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeProgress(int32 Param_Index, class UHorizontalBox* HorizontalBox, class UOverlay* IconSet, class UImage* ImageItemRarity, class UImage* ImageItemCategory, class UTextBlock* TextBlock, class UOverlay* NumSet, class UTextBlock* TextProgressCurrent, class UTextBlock* TextProgressSlash, class UTextBlock* TextProgressTarget);
	void InitializeReward(int32 Param_Index, class UOverlay* TextSet, class UImage* ImageItemRarity, class UImage* ImageItemCategory);
	void InitializeThis(class UREDScrollBoxSimple* ScrollBox, class UTextBlock* TextTitle, class UTextBlock* TextIndexClient, class UTextBlock* TextIndexLocation, class UTextBlock* TextIndexProgress, class UTextBlock* TextIndexReward, class UTextBlock* TextClient, class UTextBlock* TextLocation, class USpacer* SpacerDescription1, class USpacer* SpacerDescription2, class UUIQuestIcon* UIQuestIcon, class UUIQuestNamePlate* UIQuestNamePlate, class UCanvasPanel* QuestPanel);
	void SetItemIcon(class UImage* ImageCategory, EItemIcon Category);
	void SetItemRarity(class UImage* ImageRarity, EItemRarity Rarity);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestDetailsSub">();
	}
	static class UUIQuestDetailsSub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestDetailsSub>();
	}
};
static_assert(alignof(UUIQuestDetailsSub) == 0x000008, "Wrong alignment on UUIQuestDetailsSub");
static_assert(sizeof(UUIQuestDetailsSub) == 0x000510, "Wrong size on UUIQuestDetailsSub");

// Class BattlePrototype.SnowCaptureBase
// 0x0108 (0x0338 - 0x0230)
class ASnowCaptureBase final : public AActor
{
public:
	class USceneComponent*                        RootComponent_;                                    // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URSSceneCaptureComponent2D*             SceneCaptureComponent_;                            // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshComponentCenter_;                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshComponentLeft_;                          // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshComponentRight_;                         // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshFootComponentCenter_;                    // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshFootComponentLeft_;                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleMeshFootComponentRight_;                     // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleBodyMeshComponentCenter_;                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleBodyMeshComponentLeft_;                      // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SimpleBodyMeshComponentRight_;                     // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ALandscapeProxy*>                Landscapes_;                                       // 0x0288(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSnowDepthData>                 DepthDatas_;                                       // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DepthMaterialBase_;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AddDepthValue_;                                    // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TextureSize_;                                      // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         blurLevel_;                                        // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseBlurBeforeFrameTex_;                            // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2874[0x3];                                     // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         blurSpeedMulti_;                                   // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         beforeCaptureDecayValue_;                          // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseSimpleMesh_;                                    // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseBothFeetSimpleMesh_;                            // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2875[0x6];                                     // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SimpleMesh_;                                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SimpleMeshScale_;                                  // 0x02D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2876[0x4];                                     // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SimpleBodyMesh_;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SimpleBodyMeshScale_;                              // 0x02F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2877[0x4];                                     // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSCharacterBase*                       PlayerData_;                                       // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOddFrame_;                                       // 0x0308(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2878[0x3];                                     // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                beforeActorEven_;                                  // 0x030C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                beforeActorOdd_;                                   // 0x0318(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2879[0x4];                                     // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MpcSnowCapture_;                                   // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_287A[0x8];                                     // 0x0330(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateRenderTargets();
	void CreateSnowMaterialInstance();
	void RegistShowOnlyActorComponent();
	void SetLandscapematerialParam(const struct FSnowDepthData& DepthData, const struct FVector& beforeLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnowCaptureBase">();
	}
	static class ASnowCaptureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASnowCaptureBase>();
	}
};
static_assert(alignof(ASnowCaptureBase) == 0x000008, "Wrong alignment on ASnowCaptureBase");
static_assert(sizeof(ASnowCaptureBase) == 0x000338, "Wrong size on ASnowCaptureBase");
static_assert(offsetof(ASnowCaptureBase, RootComponent_) == 0x000230, "Member 'ASnowCaptureBase::RootComponent_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SceneCaptureComponent_) == 0x000238, "Member 'ASnowCaptureBase::SceneCaptureComponent_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshComponentCenter_) == 0x000240, "Member 'ASnowCaptureBase::SimpleMeshComponentCenter_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshComponentLeft_) == 0x000248, "Member 'ASnowCaptureBase::SimpleMeshComponentLeft_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshComponentRight_) == 0x000250, "Member 'ASnowCaptureBase::SimpleMeshComponentRight_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshFootComponentCenter_) == 0x000258, "Member 'ASnowCaptureBase::SimpleMeshFootComponentCenter_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshFootComponentLeft_) == 0x000260, "Member 'ASnowCaptureBase::SimpleMeshFootComponentLeft_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshFootComponentRight_) == 0x000268, "Member 'ASnowCaptureBase::SimpleMeshFootComponentRight_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMeshComponentCenter_) == 0x000270, "Member 'ASnowCaptureBase::SimpleBodyMeshComponentCenter_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMeshComponentLeft_) == 0x000278, "Member 'ASnowCaptureBase::SimpleBodyMeshComponentLeft_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMeshComponentRight_) == 0x000280, "Member 'ASnowCaptureBase::SimpleBodyMeshComponentRight_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, Landscapes_) == 0x000288, "Member 'ASnowCaptureBase::Landscapes_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, DepthDatas_) == 0x000298, "Member 'ASnowCaptureBase::DepthDatas_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, DepthMaterialBase_) == 0x0002A8, "Member 'ASnowCaptureBase::DepthMaterialBase_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, AddDepthValue_) == 0x0002B0, "Member 'ASnowCaptureBase::AddDepthValue_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, TextureSize_) == 0x0002B4, "Member 'ASnowCaptureBase::TextureSize_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, blurLevel_) == 0x0002B8, "Member 'ASnowCaptureBase::blurLevel_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, UseBlurBeforeFrameTex_) == 0x0002BC, "Member 'ASnowCaptureBase::UseBlurBeforeFrameTex_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, blurSpeedMulti_) == 0x0002C0, "Member 'ASnowCaptureBase::blurSpeedMulti_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, beforeCaptureDecayValue_) == 0x0002C4, "Member 'ASnowCaptureBase::beforeCaptureDecayValue_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, UseSimpleMesh_) == 0x0002C8, "Member 'ASnowCaptureBase::UseSimpleMesh_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, UseBothFeetSimpleMesh_) == 0x0002C9, "Member 'ASnowCaptureBase::UseBothFeetSimpleMesh_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMesh_) == 0x0002D0, "Member 'ASnowCaptureBase::SimpleMesh_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleMeshScale_) == 0x0002D8, "Member 'ASnowCaptureBase::SimpleMeshScale_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMesh_) == 0x0002E8, "Member 'ASnowCaptureBase::SimpleBodyMesh_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, SimpleBodyMeshScale_) == 0x0002F0, "Member 'ASnowCaptureBase::SimpleBodyMeshScale_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, PlayerData_) == 0x000300, "Member 'ASnowCaptureBase::PlayerData_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, IsOddFrame_) == 0x000308, "Member 'ASnowCaptureBase::IsOddFrame_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, beforeActorEven_) == 0x00030C, "Member 'ASnowCaptureBase::beforeActorEven_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, beforeActorOdd_) == 0x000318, "Member 'ASnowCaptureBase::beforeActorOdd_' has a wrong offset!");
static_assert(offsetof(ASnowCaptureBase, MpcSnowCapture_) == 0x000328, "Member 'ASnowCaptureBase::MpcSnowCapture_' has a wrong offset!");

// Class BattlePrototype.SoundBackground
// 0x0008 (0x0238 - 0x0230)
class ASoundBackground final : public ARSActorBackgroundBase
{
public:
	class URSAtomComponentBase*                   AtomComponent;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundBackground">();
	}
	static class ASoundBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASoundBackground>();
	}
};
static_assert(alignof(ASoundBackground) == 0x000008, "Wrong alignment on ASoundBackground");
static_assert(sizeof(ASoundBackground) == 0x000238, "Wrong size on ASoundBackground");
static_assert(offsetof(ASoundBackground, AtomComponent) == 0x000230, "Member 'ASoundBackground::AtomComponent' has a wrong offset!");

// Class BattlePrototype.SoundCategoryComponent
// 0x00D0 (0x0190 - 0x00C0)
class USoundCategoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_287C[0xD0];                                    // 0x00C0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Fade(float DeltaTime);
	void FadeIn(ESoundCategory Category, float FadeTime, float FadeScale);
	void FadeOut(ESoundCategory Category, float FadeTime, float FadeScale);
	float GetSoundBaseVolumeCategoryScale(ESoundCategory Category);
	float GetSoundVolumeCategoryScaleCalc(ESoundCategory Category);
	void ResetSoundVolumeCategoryScale();
	void SetFadeParam(ESoundCategory Category, float FadeTime, float FadeFinishScale);
	void SetSoundVolumeCategoryScale(ESoundCategory Category, float Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundCategoryComponent">();
	}
	static class USoundCategoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundCategoryComponent>();
	}
};
static_assert(alignof(USoundCategoryComponent) == 0x000008, "Wrong alignment on USoundCategoryComponent");
static_assert(sizeof(USoundCategoryComponent) == 0x000190, "Wrong size on USoundCategoryComponent");

// Class BattlePrototype.SoundCueSheetManager
// 0x0010 (0x00D0 - 0x00C0)
class USoundCueSheetManager final : public UActorComponent
{
public:
	TArray<struct FSoundCueSheet>                 DynamicCueSheet;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class USoundAtomCue* GetAtomCueByLoadedCueSheet(TSoftObjectPtr<class USoundAtomCue> AtomCueSoftRef, TSoftObjectPtr<class USoundAtomCueSheet> PreferenceCueSheetSoftRef);
	class USoundAtomCue* GetAtomCueByLoadedCueSheetFromString(const class FString& CueName);
	class USoundAtomCueSheet* GetCueSheetByName(const class FString& CueSheetName);
	bool Register(class USoundAtomCueSheet* Sheet);
	bool RegisterFromPath(const class FString& Path);
	bool RegisterFromSoftRef(TSoftObjectPtr<class USoundAtomCueSheet> SheetSoftRef);
	bool Unregister(class USoundAtomCueSheet* Sheet);
	bool UnregisterFromPath(const class FString& Path);
	bool UnregisterFromSoftRef(TSoftObjectPtr<class USoundAtomCueSheet> SheetSoftRef);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundCueSheetManager">();
	}
	static class USoundCueSheetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundCueSheetManager>();
	}
};
static_assert(alignof(USoundCueSheetManager) == 0x000008, "Wrong alignment on USoundCueSheetManager");
static_assert(sizeof(USoundCueSheetManager) == 0x0000D0, "Wrong size on USoundCueSheetManager");
static_assert(offsetof(USoundCueSheetManager, DynamicCueSheet) == 0x0000C0, "Member 'USoundCueSheetManager::DynamicCueSheet' has a wrong offset!");

// Class BattlePrototype.UIQuestNamePlate
// 0x0018 (0x03A0 - 0x0388)
class UUIQuestNamePlate : public UUIBase
{
public:
	uint8                                         Pad_2889[0x18];                                    // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UOverlay* FaceYuito, class UOverlay* FaceKasane, class UTextBlock* TextName);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestNamePlate">();
	}
	static class UUIQuestNamePlate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestNamePlate>();
	}
};
static_assert(alignof(UUIQuestNamePlate) == 0x000008, "Wrong alignment on UUIQuestNamePlate");
static_assert(sizeof(UUIQuestNamePlate) == 0x0003A0, "Wrong size on UUIQuestNamePlate");

// Class BattlePrototype.SoundPoolObject
// 0x0010 (0x0038 - 0x0028)
class USoundPoolObject final : public UObject
{
public:
	class URSAtomComponentBase*                   Component;                                         // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Used;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288A[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class URSAtomComponentBase* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPoolObject">();
	}
	static class USoundPoolObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundPoolObject>();
	}
};
static_assert(alignof(USoundPoolObject) == 0x000008, "Wrong alignment on USoundPoolObject");
static_assert(sizeof(USoundPoolObject) == 0x000038, "Wrong size on USoundPoolObject");
static_assert(offsetof(USoundPoolObject, Component) == 0x000028, "Member 'USoundPoolObject::Component' has a wrong offset!");
static_assert(offsetof(USoundPoolObject, Used) == 0x000030, "Member 'USoundPoolObject::Used' has a wrong offset!");

// Class BattlePrototype.SoundPoolManager
// 0x0020 (0x0048 - 0x0028)
class USoundPoolManager final : public UObject
{
public:
	class UClass*                                 Class_SoundPoolManager;                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USoundPoolObject*>               Heap;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Num;                                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288B[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundPoolManager">();
	}
	static class USoundPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundPoolManager>();
	}
};
static_assert(alignof(USoundPoolManager) == 0x000008, "Wrong alignment on USoundPoolManager");
static_assert(sizeof(USoundPoolManager) == 0x000048, "Wrong size on USoundPoolManager");
static_assert(offsetof(USoundPoolManager, Class_SoundPoolManager) == 0x000028, "Member 'USoundPoolManager::Class_SoundPoolManager' has a wrong offset!");
static_assert(offsetof(USoundPoolManager, Heap) == 0x000030, "Member 'USoundPoolManager::Heap' has a wrong offset!");
static_assert(offsetof(USoundPoolManager, Num) == 0x000040, "Member 'USoundPoolManager::Num' has a wrong offset!");

// Class BattlePrototype.SoundVolumeController
// 0x0178 (0x0238 - 0x00C0)
class USoundVolumeController final : public UActorComponent
{
public:
	float                                         M_MasterVolume;                                    // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoundVolumeSetting                    M_SoundVolumeSetting[0x7];                         // 0x00C4(0x0034)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          M_IsFadeExitting;                                  // 0x0230(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288C[0x7];                                     // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float _GetAcfVolumeByCategoryName(ESoundCategory Category);
	float _GetConfigVolumeByCategoryName(ESoundCategory Category);
	float _GetDestVolumeByCategoryName(ESoundCategory Category);
	float _GetFadeTimeByCategoryName(ESoundCategory Category);
	float _GetInGameVolumeByCategoryName(ESoundCategory Category);
	bool _GetIsFadeByCategoryName(ESoundCategory Category);
	bool _GetIsTick();
	float _GetNowVolumeByCategoryName(ESoundCategory Category);
	float _GetPassedTimeByCategoryName(ESoundCategory Category);
	void Finalize();
	void Initialize();
	void SetConfigVolumeByCategoryName(ESoundCategory Category, float DestVol);
	void SetExitFadeAll();
	void SetFadeAllCategory(float FadeTime, float DestVol);
	void SetFadeByCategoryName(ESoundCategory Category, float FadeTime, float DestVol);
	void SetInGameVolumeAll(float DestVol);
	void SetInGameVolumeByCategoryName(ESoundCategory Category, float DestVol);
	void SetMuteAll();
	void SetRestertFadeAll();
	void SetResumeFromMuteAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundVolumeController">();
	}
	static class USoundVolumeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundVolumeController>();
	}
};
static_assert(alignof(USoundVolumeController) == 0x000008, "Wrong alignment on USoundVolumeController");
static_assert(sizeof(USoundVolumeController) == 0x000238, "Wrong size on USoundVolumeController");
static_assert(offsetof(USoundVolumeController, M_MasterVolume) == 0x0000C0, "Member 'USoundVolumeController::M_MasterVolume' has a wrong offset!");
static_assert(offsetof(USoundVolumeController, M_SoundVolumeSetting) == 0x0000C4, "Member 'USoundVolumeController::M_SoundVolumeSetting' has a wrong offset!");
static_assert(offsetof(USoundVolumeController, M_IsFadeExitting) == 0x000230, "Member 'USoundVolumeController::M_IsFadeExitting' has a wrong offset!");

// Class BattlePrototype.SplineLooperBase
// 0x0070 (0x02A0 - 0x0230)
class alignas(0x10) ASplineLooperBase : public AActor
{
public:
	class USplineComponent*                       SpawnSplineNv;                                     // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         SplineActorsNv;                                    // 0x0238(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2897[0x58];                                    // 0x0248(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupParameters(class USplineComponent* InSpawnSpline, const TArray<class AActor*>& InSplineActors, const TArray<float>& InInitialSplineLocations, const struct FTransform& InAdditonalTransform, float InSpeed, float InDirectionRotationSpeed, bool bInRotateAlongSpline, bool bInFlipToSpeedDirection, bool bInUpdateScale, bool bInUseScaleToSpeedRotation);
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineLooperBase">();
	}
	static class ASplineLooperBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineLooperBase>();
	}
};
static_assert(alignof(ASplineLooperBase) == 0x000010, "Wrong alignment on ASplineLooperBase");
static_assert(sizeof(ASplineLooperBase) == 0x0002A0, "Wrong size on ASplineLooperBase");
static_assert(offsetof(ASplineLooperBase, SpawnSplineNv) == 0x000230, "Member 'ASplineLooperBase::SpawnSplineNv' has a wrong offset!");
static_assert(offsetof(ASplineLooperBase, SplineActorsNv) == 0x000238, "Member 'ASplineLooperBase::SplineActorsNv' has a wrong offset!");

// Class BattlePrototype.UISASButton3
// 0x0018 (0x03A0 - 0x0388)
class UUISASButton3 : public UUIBase
{
public:
	uint8                                         Pad_289A[0x18];                                    // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Decide();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimChangeCv1, class UWidgetAnimation* AnimDefaultCv, class UWidgetAnimation* AnimChangeCv2, class UWidgetAnimation* AnimDecisionCv, class UWidgetAnimation* AnimChangePage1, class UWidgetAnimation* AnimDefaultPage, class UWidgetAnimation* AnimChangePage2, class UWidgetAnimation* AnimDecisionPage, class UImage* ImageSasIconFont, class UImage* ImageSasButton);
	void SetPageFlag(bool IsPage);
	void SetReadyFlag(bool IsReady);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASButton3">();
	}
	static class UUISASButton3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASButton3>();
	}
};
static_assert(alignof(UUISASButton3) == 0x000008, "Wrong alignment on UUISASButton3");
static_assert(sizeof(UUISASButton3) == 0x0003A0, "Wrong size on UUISASButton3");

// Class BattlePrototype.SprintComponent
// 0x0070 (0x0130 - 0x00C0)
class USprintComponent : public UActorComponent
{
public:
	float                                         _fWalkableFloorAngle;                              // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isSprinting;                                      // 0x00C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isEndSprinting;                                   // 0x00C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289B[0x2];                                     // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartSprint;                                     // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEndSprint;                                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	float                                         _sprintStartSec;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _walkStartTime;                                    // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _sprintClaimantName;                               // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxWalkSpeedRateBySprint;                         // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxWalkSpeedRateByBattleSprint;                   // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintCurveAngle;                                 // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintBankPow;                                    // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintBankBackPow;                                // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_289C[0x24];                                    // 0x010C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeBattleSprint(bool bBattle);
	void EndSprint();
	void ProcessSprint(float DeltaTime);
	void SetEventSprint(bool bEnable);
	void SetMaxWalkSpeedRate();
	void SetSprintSpeedRate(float Rate, float BattleRate);
	void StartSprint(bool bBattle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprintComponent">();
	}
	static class USprintComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprintComponent>();
	}
};
static_assert(alignof(USprintComponent) == 0x000008, "Wrong alignment on USprintComponent");
static_assert(sizeof(USprintComponent) == 0x000130, "Wrong size on USprintComponent");
static_assert(offsetof(USprintComponent, _fWalkableFloorAngle) == 0x0000C0, "Member 'USprintComponent::_fWalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(USprintComponent, _isSprinting) == 0x0000C4, "Member 'USprintComponent::_isSprinting' has a wrong offset!");
static_assert(offsetof(USprintComponent, _isEndSprinting) == 0x0000C5, "Member 'USprintComponent::_isEndSprinting' has a wrong offset!");
static_assert(offsetof(USprintComponent, OnStartSprint) == 0x0000C8, "Member 'USprintComponent::OnStartSprint' has a wrong offset!");
static_assert(offsetof(USprintComponent, OnEndSprint) == 0x0000D8, "Member 'USprintComponent::OnEndSprint' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintStartSec) == 0x0000E8, "Member 'USprintComponent::_sprintStartSec' has a wrong offset!");
static_assert(offsetof(USprintComponent, _walkStartTime) == 0x0000EC, "Member 'USprintComponent::_walkStartTime' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintClaimantName) == 0x0000F0, "Member 'USprintComponent::_sprintClaimantName' has a wrong offset!");
static_assert(offsetof(USprintComponent, _maxWalkSpeedRateBySprint) == 0x0000F8, "Member 'USprintComponent::_maxWalkSpeedRateBySprint' has a wrong offset!");
static_assert(offsetof(USprintComponent, _maxWalkSpeedRateByBattleSprint) == 0x0000FC, "Member 'USprintComponent::_maxWalkSpeedRateByBattleSprint' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintCurveAngle) == 0x000100, "Member 'USprintComponent::_sprintCurveAngle' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintBankPow) == 0x000104, "Member 'USprintComponent::_sprintBankPow' has a wrong offset!");
static_assert(offsetof(USprintComponent, _sprintBankBackPow) == 0x000108, "Member 'USprintComponent::_sprintBankBackPow' has a wrong offset!");

// Class BattlePrototype.StageEffectParameterSettingVolume
// 0x0018 (0x02A0 - 0x0288)
class AStageEffectParameterSettingVolume final : public ABlendableVolume
{
public:
	struct FStageEffectParameterSettings          Settings;                                          // 0x0288(0x0014)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_289D[0x4];                                     // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageEffectParameterSettingVolume">();
	}
	static class AStageEffectParameterSettingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageEffectParameterSettingVolume>();
	}
};
static_assert(alignof(AStageEffectParameterSettingVolume) == 0x000008, "Wrong alignment on AStageEffectParameterSettingVolume");
static_assert(sizeof(AStageEffectParameterSettingVolume) == 0x0002A0, "Wrong size on AStageEffectParameterSettingVolume");
static_assert(offsetof(AStageEffectParameterSettingVolume, Settings) == 0x000288, "Member 'AStageEffectParameterSettingVolume::Settings' has a wrong offset!");

// Class BattlePrototype.StageEffectParameterSettingVolumeManager
// 0x0018 (0x0260 - 0x0248)
class AStageEffectParameterSettingVolumeManager final : public ABlendableVolumeManager
{
public:
	struct FStageEffectParameterSettings          Parameter;                                         // 0x0248(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_289E[0x4];                                     // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FStageEffectParameterSettings CalcParameter(const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageEffectParameterSettingVolumeManager">();
	}
	static class AStageEffectParameterSettingVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageEffectParameterSettingVolumeManager>();
	}
};
static_assert(alignof(AStageEffectParameterSettingVolumeManager) == 0x000008, "Wrong alignment on AStageEffectParameterSettingVolumeManager");
static_assert(sizeof(AStageEffectParameterSettingVolumeManager) == 0x000260, "Wrong size on AStageEffectParameterSettingVolumeManager");
static_assert(offsetof(AStageEffectParameterSettingVolumeManager, Parameter) == 0x000248, "Member 'AStageEffectParameterSettingVolumeManager::Parameter' has a wrong offset!");

// Class BattlePrototype.StageManager
// 0x0028 (0x0258 - 0x0230)
class AStageManager : public AActor
{
public:
	uint8                                         Pad_289F[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UArrangeObjectManager*                  ArrangeObjectManager;                              // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrangeItemStageManager*               ArrangeItemStageManager;                           // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNpcManager*                            NpcManager;                                        // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickManager*                        GimmickManager;                                    // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UArrangeItemStageManager* GetArrangeItemStageManager();
	class UArrangeObjectManager* GetArrangeObjectManager();
	class UGimmickManager* GetGimmickManager();
	class UNpcManager* GetNpcManager();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageManager">();
	}
	static class AStageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageManager>();
	}
};
static_assert(alignof(AStageManager) == 0x000008, "Wrong alignment on AStageManager");
static_assert(sizeof(AStageManager) == 0x000258, "Wrong size on AStageManager");
static_assert(offsetof(AStageManager, ArrangeObjectManager) == 0x000238, "Member 'AStageManager::ArrangeObjectManager' has a wrong offset!");
static_assert(offsetof(AStageManager, ArrangeItemStageManager) == 0x000240, "Member 'AStageManager::ArrangeItemStageManager' has a wrong offset!");
static_assert(offsetof(AStageManager, NpcManager) == 0x000248, "Member 'AStageManager::NpcManager' has a wrong offset!");
static_assert(offsetof(AStageManager, GimmickManager) == 0x000250, "Member 'AStageManager::GimmickManager' has a wrong offset!");

// Class BattlePrototype.UIGuide
// 0x0018 (0x03A0 - 0x0388)
class UUIGuide : public UUIBase
{
public:
	uint8                                         Pad_28A0[0x18];                                    // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void buildGuide();
	void ClearGuide();
	void InitializeThis(class USpacer* GuideSpacer);
	void SetGuide(int32 Param_Index, EGuideKey Key, class FName String);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide">();
	}
	static class UUIGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide>();
	}
};
static_assert(alignof(UUIGuide) == 0x000008, "Wrong alignment on UUIGuide");
static_assert(sizeof(UUIGuide) == 0x0003A0, "Wrong size on UUIGuide");

// Class BattlePrototype.StageParameterSettingLightVector
// 0x0028 (0x0258 - 0x0230)
class AStageParameterSettingLightVector final : public AActor
{
public:
	uint8                                         Pad_28A2[0x8];                                     // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UArrowComponent*                        AmbientLightVector;                                // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A3[0x13];                                    // 0x0245(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageParameterSettingLightVector">();
	}
	static class AStageParameterSettingLightVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageParameterSettingLightVector>();
	}
};
static_assert(alignof(AStageParameterSettingLightVector) == 0x000008, "Wrong alignment on AStageParameterSettingLightVector");
static_assert(sizeof(AStageParameterSettingLightVector) == 0x000258, "Wrong size on AStageParameterSettingLightVector");
static_assert(offsetof(AStageParameterSettingLightVector, AmbientLightVector) == 0x000238, "Member 'AStageParameterSettingLightVector::AmbientLightVector' has a wrong offset!");
static_assert(offsetof(AStageParameterSettingLightVector, Priority) == 0x000240, "Member 'AStageParameterSettingLightVector::Priority' has a wrong offset!");
static_assert(offsetof(AStageParameterSettingLightVector, bEnabled) == 0x000244, "Member 'AStageParameterSettingLightVector::bEnabled' has a wrong offset!");

// Class BattlePrototype.StageParameterSettingVolume
// 0x00E0 (0x0368 - 0x0288)
class AStageParameterSettingVolume final : public ABlendableVolume
{
public:
	struct FStageParameterSettings                Settings;                                          // 0x0288(0x00E0)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageParameterSettingVolume">();
	}
	static class AStageParameterSettingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageParameterSettingVolume>();
	}
};
static_assert(alignof(AStageParameterSettingVolume) == 0x000008, "Wrong alignment on AStageParameterSettingVolume");
static_assert(sizeof(AStageParameterSettingVolume) == 0x000368, "Wrong size on AStageParameterSettingVolume");
static_assert(offsetof(AStageParameterSettingVolume, Settings) == 0x000288, "Member 'AStageParameterSettingVolume::Settings' has a wrong offset!");

// Class BattlePrototype.StageParameterSettingVolumeManager
// 0x0838 (0x0A80 - 0x0248)
class AStageParameterSettingVolumeManager : public ABlendableVolumeManager
{
public:
	struct FStageParameterSettings                Parameter;                                         // 0x0248(0x00E0)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A4[0x50];                                    // 0x0328(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class AStageEffectParameterSettingVolumeManager* EffectManager;                                     // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28A5[0x700];                                   // 0x0380(0x0700)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAppendActor(class AActor* Actor);
	const struct FStageParameterSettings CalcParameter(const struct FVector& Location);
	struct FStageParameterSettings CalcParameterEffect(const struct FVector& Location);
	void ClearParameter(class AActor* Actor);
	void ConvertSettingToParameters(const struct FStageParameterSettings& Settings, TArray<class FName>* ParamScalarNames, TArray<float>* ParamScalars, TArray<class FName>* ParamVectorNames, TArray<struct FLinearColor>* ParamVectors);
	void ForceAllUpdate();
	void ForceAllUpdateOption(bool bUpdatePlayer, bool bUpdateAppendActor);
	void ForceUpdateActor(class AActor* Actor, const struct FVector& Location);
	class AStageEffectParameterSettingVolumeManager* GetEffectManager();
	void RecalcSceneLightVector();
	void RemoveAppendActor(class AActor* Actor);
	void SetDebugDisableCache(bool DisableCache);
	void SetupActorInternal(const class AActor* Actor, const struct FVector& Location, const TArray<class FName>& ParamScalarNames, const TArray<float>& ParamScalars, const TArray<class FName>& ParamVectorNames, const TArray<struct FLinearColor>& ParamVectors);
	void SetupMPC(class UMaterialParameterCollection* Collection, const struct FStageParameterSettings& Settings);
	void SetUseReferenceLocationMode(bool Use);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageParameterSettingVolumeManager">();
	}
	static class AStageParameterSettingVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStageParameterSettingVolumeManager>();
	}
};
static_assert(alignof(AStageParameterSettingVolumeManager) == 0x000008, "Wrong alignment on AStageParameterSettingVolumeManager");
static_assert(sizeof(AStageParameterSettingVolumeManager) == 0x000A80, "Wrong size on AStageParameterSettingVolumeManager");
static_assert(offsetof(AStageParameterSettingVolumeManager, Parameter) == 0x000248, "Member 'AStageParameterSettingVolumeManager::Parameter' has a wrong offset!");
static_assert(offsetof(AStageParameterSettingVolumeManager, EffectManager) == 0x000378, "Member 'AStageParameterSettingVolumeManager::EffectManager' has a wrong offset!");

// Class BattlePrototype.StageParameterSettingFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UStageParameterSettingFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertStageSettingToMaterialParameters(const struct FStageParameterSettings& Settings, TArray<class FName>* ParamScalarNames, TArray<float>* ParamScalars, TArray<class FName>* ParamVectorNames, TArray<struct FLinearColor>* ParamVectors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageParameterSettingFunctionLibrary">();
	}
	static class UStageParameterSettingFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStageParameterSettingFunctionLibrary>();
	}
};
static_assert(alignof(UStageParameterSettingFunctionLibrary) == 0x000008, "Wrong alignment on UStageParameterSettingFunctionLibrary");
static_assert(sizeof(UStageParameterSettingFunctionLibrary) == 0x000028, "Wrong size on UStageParameterSettingFunctionLibrary");

// Class BattlePrototype.UIHelpPartsList
// 0x0058 (0x03E0 - 0x0388)
class UUIHelpPartsList : public UUIBase
{
public:
	uint8                                         Pad_28A8[0x58];                                    // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeListAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_);
	void InitializeListPartsList(class UTextBlock* TextList, class UImage* ImageNew);
	void UpdateStateHelpPartsList(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHelpPartsList">();
	}
	static class UUIHelpPartsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHelpPartsList>();
	}
};
static_assert(alignof(UUIHelpPartsList) == 0x000008, "Wrong alignment on UUIHelpPartsList");
static_assert(sizeof(UUIHelpPartsList) == 0x0003E0, "Wrong size on UUIHelpPartsList");

// Class BattlePrototype.StepComponent
// 0x0038 (0x00F8 - 0x00C0)
class UStepComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStartStep;                                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FVector                                _stepInputDirection;                               // 0x00D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _stepDistanceScale;                                // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintMoveDuration;                               // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintMoveDistance;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28A9[0x10];                                    // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndStep();
	void InputStep(const struct FVector& StepDirection, float StepDistanceRate, bool bEnableSprintMomentum);
	void StartStep(const struct FVector& StepDirection, float StepDistanceRate, bool bEnableSprintMomentum);

	struct FVector CalcDirectionWorldToActor(const struct FVector& WorldDir) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StepComponent">();
	}
	static class UStepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStepComponent>();
	}
};
static_assert(alignof(UStepComponent) == 0x000008, "Wrong alignment on UStepComponent");
static_assert(sizeof(UStepComponent) == 0x0000F8, "Wrong size on UStepComponent");
static_assert(offsetof(UStepComponent, OnStartStep) == 0x0000C0, "Member 'UStepComponent::OnStartStep' has a wrong offset!");
static_assert(offsetof(UStepComponent, _stepInputDirection) == 0x0000D0, "Member 'UStepComponent::_stepInputDirection' has a wrong offset!");
static_assert(offsetof(UStepComponent, _stepDistanceScale) == 0x0000DC, "Member 'UStepComponent::_stepDistanceScale' has a wrong offset!");
static_assert(offsetof(UStepComponent, _sprintMoveDuration) == 0x0000E0, "Member 'UStepComponent::_sprintMoveDuration' has a wrong offset!");
static_assert(offsetof(UStepComponent, _sprintMoveDistance) == 0x0000E4, "Member 'UStepComponent::_sprintMoveDistance' has a wrong offset!");

// Class BattlePrototype.TargetableObjectInterface
// 0x0000 (0x0028 - 0x0028)
class ITargetableObjectInterface final : public IInterface
{
public:
	class AActor* GetPsychicObjectShield();
	struct FVector GetTargetCursorLocation();
	bool IsPsychicObjectShieldActive();

	bool IsBerserkCharacter() const;
	bool IsControlPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetableObjectInterface">();
	}
	static class ITargetableObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITargetableObjectInterface>();
	}
};
static_assert(alignof(ITargetableObjectInterface) == 0x000008, "Wrong alignment on ITargetableObjectInterface");
static_assert(sizeof(ITargetableObjectInterface) == 0x000028, "Wrong size on ITargetableObjectInterface");

// Class BattlePrototype.TargetSearchComponent
// 0x0090 (0x0150 - 0x00C0)
class UTargetSearchComponent : public UActorComponent
{
public:
	float                                         SearchDistance;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchYaw;                                         // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchPitch;                                       // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AC[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTargetSearchArea>              SearchArea;                                        // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchMobDistance;                                 // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockDistance;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Trace2ndZOffset;                                   // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockonPlayerPos;                                   // 0x00EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InternalLockUpdateTime;                            // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28AD[0x4];                                     // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchChangeTarget;                              // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AEnemyManager*                          PEnemyManager_;                                    // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABattleManager*                         PBattleManager_;                                   // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickInterval_;                                     // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28AE[0x2C];                                    // 0x0124(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTargetSearchComponent* GetTargetSearchComponentFromActor(class AActor* Actor);

	bool ChangeLockTarget(float AxisValue, const TArray<class ARSCharacterBase*>& EnemyList);
	void ClearLostTargetActor();
	class ARSCharacterBase* GetCurrentTargetActor();
	class ARSCharacterBase* GetLostTargetActor();
	void LockonTargetCalcPos(float LockonHeight);
	void OnSetBattling(bool bBattle);
	void RestoreLockTarget(bool bRetargetRestoreFailed);
	void SetLockTarget(bool bLock);
	void SetLockTargetDirect(class ARSCharacterBase* Actor);
	void SetLostFlag();
	void SetTargetFix(bool bFix);
	void StoreLockTarget();
	void UpdateCurrentTarget();

	bool IsAbleTarget(class ARSCharacterBase* Target, bool IsLock, ETargetListType ListType, ETargetFailedReason* OutReason) const;
	bool IsBossBattle() const;
	bool IsLockTarget() const;
	bool IsLostLockTarget() const;
	bool IsTargetFix() const;
	class ARSCharacterBase* SearchTargetActor(const TArray<class ARSCharacterBase*>& EnemyList, ETargetListType ListType, bool bIgnoreRendered, bool bNotLockTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetSearchComponent">();
	}
	static class UTargetSearchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetSearchComponent>();
	}
};
static_assert(alignof(UTargetSearchComponent) == 0x000008, "Wrong alignment on UTargetSearchComponent");
static_assert(sizeof(UTargetSearchComponent) == 0x000150, "Wrong size on UTargetSearchComponent");
static_assert(offsetof(UTargetSearchComponent, SearchDistance) == 0x0000C0, "Member 'UTargetSearchComponent::SearchDistance' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, SearchYaw) == 0x0000C4, "Member 'UTargetSearchComponent::SearchYaw' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, SearchPitch) == 0x0000C8, "Member 'UTargetSearchComponent::SearchPitch' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, SearchArea) == 0x0000D0, "Member 'UTargetSearchComponent::SearchArea' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, SearchMobDistance) == 0x0000E0, "Member 'UTargetSearchComponent::SearchMobDistance' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, LockDistance) == 0x0000E4, "Member 'UTargetSearchComponent::LockDistance' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, Trace2ndZOffset) == 0x0000E8, "Member 'UTargetSearchComponent::Trace2ndZOffset' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, LockonPlayerPos) == 0x0000EC, "Member 'UTargetSearchComponent::LockonPlayerPos' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, InternalLockUpdateTime) == 0x0000F8, "Member 'UTargetSearchComponent::InternalLockUpdateTime' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, DispatchChangeTarget) == 0x000100, "Member 'UTargetSearchComponent::DispatchChangeTarget' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, PEnemyManager_) == 0x000110, "Member 'UTargetSearchComponent::PEnemyManager_' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, PBattleManager_) == 0x000118, "Member 'UTargetSearchComponent::PBattleManager_' has a wrong offset!");
static_assert(offsetof(UTargetSearchComponent, TickInterval_) == 0x000120, "Member 'UTargetSearchComponent::TickInterval_' has a wrong offset!");

// Class BattlePrototype.TaskBaseNative
// 0x0038 (0x00A8 - 0x0070)
class UTaskBaseNative final : public UBTTaskNode
{
public:
	uint8                                         Pad_28B3[0x38];                                    // 0x0070(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskBaseNative">();
	}
	static class UTaskBaseNative* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaskBaseNative>();
	}
};
static_assert(alignof(UTaskBaseNative) == 0x000008, "Wrong alignment on UTaskBaseNative");
static_assert(sizeof(UTaskBaseNative) == 0x0000A8, "Wrong size on UTaskBaseNative");

// Class BattlePrototype.UIItemMenu
// 0xFE00 (0x10188 - 0x0388)
class UUIItemMenu : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28B4[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28B5[0xFDE8];                                  // 0x03A0(0xFDE8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeCommonParts(class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeItemCategory(int32 Category, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimUnselect, class UTextBlock* TextCategory);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UBorder* borderAllColor, class UREDScrollBox* ScrollBox, class UUIItemDetails* UIItemDetails, class UUIItemPartyStatus* UiPartyStatus);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void SetContentsChange(bool IsChange);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsEndMenu() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemMenu">();
	}
	static class UUIItemMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemMenu>();
	}
};
static_assert(alignof(UUIItemMenu) == 0x000008, "Wrong alignment on UUIItemMenu");
static_assert(sizeof(UUIItemMenu) == 0x010188, "Wrong size on UUIItemMenu");
static_assert(offsetof(UUIItemMenu, ListElementSize) == 0x000388, "Member 'UUIItemMenu::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIItemMenu, ListOffsetSize) == 0x000390, "Member 'UUIItemMenu::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIItemMenu, ListIndexClass) == 0x000398, "Member 'UUIItemMenu::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.DebuggingItemTeamBondsLevel
// 0x0008 (0x0308 - 0x0300)
class ADebuggingItemTeamBondsLevel final : public ADebuggingItemInt
{
public:
	EPlayerID                                     PlayerType;                                        // 0x0300(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B9[0x7];                                     // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemTeamBondsLevel">();
	}
	static class ADebuggingItemTeamBondsLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemTeamBondsLevel>();
	}
};
static_assert(alignof(ADebuggingItemTeamBondsLevel) == 0x000008, "Wrong alignment on ADebuggingItemTeamBondsLevel");
static_assert(sizeof(ADebuggingItemTeamBondsLevel) == 0x000308, "Wrong size on ADebuggingItemTeamBondsLevel");
static_assert(offsetof(ADebuggingItemTeamBondsLevel, PlayerType) == 0x000300, "Member 'ADebuggingItemTeamBondsLevel::PlayerType' has a wrong offset!");

// Class BattlePrototype.DebuggingItemPresentEvent
// 0x0008 (0x02E8 - 0x02E0)
class ADebuggingItemPresentEvent final : public ADebuggingItemEvent
{
public:
	EPlayerID                                     PlayerType;                                        // 0x02E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28BA[0x3];                                     // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ToLevel;                                           // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemPresentEvent">();
	}
	static class ADebuggingItemPresentEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemPresentEvent>();
	}
};
static_assert(alignof(ADebuggingItemPresentEvent) == 0x000008, "Wrong alignment on ADebuggingItemPresentEvent");
static_assert(sizeof(ADebuggingItemPresentEvent) == 0x0002E8, "Wrong size on ADebuggingItemPresentEvent");
static_assert(offsetof(ADebuggingItemPresentEvent, PlayerType) == 0x0002E0, "Member 'ADebuggingItemPresentEvent::PlayerType' has a wrong offset!");
static_assert(offsetof(ADebuggingItemPresentEvent, ToLevel) == 0x0002E4, "Member 'ADebuggingItemPresentEvent::ToLevel' has a wrong offset!");

// Class BattlePrototype.DebuggingItemTeamBondsLevelGroup
// 0x0030 (0x0300 - 0x02D0)
class ADebuggingItemTeamBondsLevelGroup final : public ADebuggingItemGroup
{
public:
	TArray<TWeakObjectPtr<class ADebuggingItemTeamBondsLevel>> LevelIntList;                                      // 0x02D0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ADebuggingItemPresentEvent>> PresentEventList;                                  // 0x02E0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserParamManager*                      ParamMan;                                          // 0x02F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDatabaseManager*                       DbMan;                                             // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangeLevel(const class ADebuggingItemInt* Item);
	void OnExecutePresent(const class ADebuggingItemEvent* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebuggingItemTeamBondsLevelGroup">();
	}
	static class ADebuggingItemTeamBondsLevelGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebuggingItemTeamBondsLevelGroup>();
	}
};
static_assert(alignof(ADebuggingItemTeamBondsLevelGroup) == 0x000008, "Wrong alignment on ADebuggingItemTeamBondsLevelGroup");
static_assert(sizeof(ADebuggingItemTeamBondsLevelGroup) == 0x000300, "Wrong size on ADebuggingItemTeamBondsLevelGroup");
static_assert(offsetof(ADebuggingItemTeamBondsLevelGroup, LevelIntList) == 0x0002D0, "Member 'ADebuggingItemTeamBondsLevelGroup::LevelIntList' has a wrong offset!");
static_assert(offsetof(ADebuggingItemTeamBondsLevelGroup, PresentEventList) == 0x0002E0, "Member 'ADebuggingItemTeamBondsLevelGroup::PresentEventList' has a wrong offset!");
static_assert(offsetof(ADebuggingItemTeamBondsLevelGroup, ParamMan) == 0x0002F0, "Member 'ADebuggingItemTeamBondsLevelGroup::ParamMan' has a wrong offset!");
static_assert(offsetof(ADebuggingItemTeamBondsLevelGroup, DbMan) == 0x0002F8, "Member 'ADebuggingItemTeamBondsLevelGroup::DbMan' has a wrong offset!");

// Class BattlePrototype.TeamComponent
// 0x0008 (0x00C8 - 0x00C0)
class UTeamComponent final : public UActorComponent
{
public:
	ETeamKind                                     OwnKind;                                           // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28BB[0x7];                                     // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CopyTeamParameterBetweenActor(class AActor* From, class AActor* To);
	static class UTeamComponent* GetTeamComponentFromActor(class AActor* Actor);

	void CopyTeamParameterFrom(class UTeamComponent* Other);

	bool IsEnemy() const;
	bool IsFriend(const class UTeamComponent* Opponent) const;
	bool IsMob() const;
	bool IsPlayer() const;
	bool IsRival(const class UTeamComponent* Opponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamComponent">();
	}
	static class UTeamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamComponent>();
	}
};
static_assert(alignof(UTeamComponent) == 0x000008, "Wrong alignment on UTeamComponent");
static_assert(sizeof(UTeamComponent) == 0x0000C8, "Wrong size on UTeamComponent");
static_assert(offsetof(UTeamComponent, OwnKind) == 0x0000C0, "Member 'UTeamComponent::OwnKind' has a wrong offset!");

// Class BattlePrototype.UIItemTradeListIndex
// 0x00D0 (0x0458 - 0x0388)
class UUIItemTradeListIndex : public UUIBase
{
public:
	uint8                                         Pad_28BE[0xD0];                                    // 0x0388(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultEnough, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectEnough, class UWidgetAnimation* AnimSelectMax, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectInEnough, class UWidgetAnimation* AnimSelectInMax, class UWidgetAnimation* AnimSelect2, class UWidgetAnimation* AnimSelect2Enough, class UWidgetAnimation* AnimSelect2Max, class UWidgetAnimation* AnimChangeTradeItemIn, class UWidgetAnimation* AnimChangeTradeItemInEnough, class UWidgetAnimation* AnimChangeTradeItemInMax, class UWidgetAnimation* AnimChangeTradeItemOut, class UWidgetAnimation* AnimChangeTradeItemOutEnough, class UWidgetAnimation* AnimChangeTradeItemOutMax, class UImage* ImageNewIcon, class UImage* ImageWish, class UTextBlock* TextItemName, class UTextBlock* TextNumHave);
	bool SetItemInfo(const class FName& ItemId, int32 TradeItemIndex, bool CanTrade, int32 TakeNum);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemTradeListIndex">();
	}
	static class UUIItemTradeListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemTradeListIndex>();
	}
};
static_assert(alignof(UUIItemTradeListIndex) == 0x000008, "Wrong alignment on UUIItemTradeListIndex");
static_assert(sizeof(UUIItemTradeListIndex) == 0x000458, "Wrong size on UUIItemTradeListIndex");

// Class BattlePrototype.TeamUtility
// 0x0000 (0x0028 - 0x0028)
class UTeamUtility final : public UObject
{
public:
	static void SearchRivalCharacters(TArray<class ARSCharacterBase*>* FindCharas, class ARSCharacterBase* StarndardChara, float SeachDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamUtility">();
	}
	static class UTeamUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamUtility>();
	}
};
static_assert(alignof(UTeamUtility) == 0x000008, "Wrong alignment on UTeamUtility");
static_assert(sizeof(UTeamUtility) == 0x000028, "Wrong size on UTeamUtility");

// Class BattlePrototype.TeleportableWallBase
// 0x0028 (0x0258 - 0x0230)
class ATeleportableWallBase final : public AActor
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        IconPosition;                                      // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          ShowComponent;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WorldPositionOffset;                               // 0x0248(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C2[0x4];                                     // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportableWallBase">();
	}
	static class ATeleportableWallBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeleportableWallBase>();
	}
};
static_assert(alignof(ATeleportableWallBase) == 0x000008, "Wrong alignment on ATeleportableWallBase");
static_assert(sizeof(ATeleportableWallBase) == 0x000258, "Wrong size on ATeleportableWallBase");
static_assert(offsetof(ATeleportableWallBase, MeshComponent) == 0x000230, "Member 'ATeleportableWallBase::MeshComponent' has a wrong offset!");
static_assert(offsetof(ATeleportableWallBase, IconPosition) == 0x000238, "Member 'ATeleportableWallBase::IconPosition' has a wrong offset!");
static_assert(offsetof(ATeleportableWallBase, ShowComponent) == 0x000240, "Member 'ATeleportableWallBase::ShowComponent' has a wrong offset!");
static_assert(offsetof(ATeleportableWallBase, WorldPositionOffset) == 0x000248, "Member 'ATeleportableWallBase::WorldPositionOffset' has a wrong offset!");

// Class BattlePrototype.TestSave
// 0x0100 (0x0128 - 0x0028)
class UTestSave final : public USaveGame
{
public:
	int32                                         TestInt_;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestFloat_;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TestFName_;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 TestArrayInt_;                                     // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSaveTestStruct                        TestStruct_;                                       // 0x0048(0x0018)(NativeAccessSpecifierPublic)
	TArray<struct FSaveTestStruct>                TestArrayStruct_;                                  // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C3[0xB8];                                    // 0x0070(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestSave">();
	}
	static class UTestSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestSave>();
	}
};
static_assert(alignof(UTestSave) == 0x000008, "Wrong alignment on UTestSave");
static_assert(sizeof(UTestSave) == 0x000128, "Wrong size on UTestSave");
static_assert(offsetof(UTestSave, TestInt_) == 0x000028, "Member 'UTestSave::TestInt_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestFloat_) == 0x00002C, "Member 'UTestSave::TestFloat_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestFName_) == 0x000030, "Member 'UTestSave::TestFName_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestArrayInt_) == 0x000038, "Member 'UTestSave::TestArrayInt_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestStruct_) == 0x000048, "Member 'UTestSave::TestStruct_' has a wrong offset!");
static_assert(offsetof(UTestSave, TestArrayStruct_) == 0x000060, "Member 'UTestSave::TestArrayStruct_' has a wrong offset!");

// Class BattlePrototype.TextData
// 0x0008 (0x0030 - 0x0028)
class UTextData final : public UObject
{
public:
	class UDataTable*                             RefTextTable;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FString GetText(class FName ID, bool* Founded);
	bool LoadResource(const class FString& FilePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextData">();
	}
	static class UTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextData>();
	}
};
static_assert(alignof(UTextData) == 0x000008, "Wrong alignment on UTextData");
static_assert(sizeof(UTextData) == 0x000030, "Wrong size on UTextData");
static_assert(offsetof(UTextData, RefTextTable) == 0x000028, "Member 'UTextData::RefTextTable' has a wrong offset!");

// Class BattlePrototype.TradeItemData
// 0x0008 (0x0030 - 0x0028)
class UTradeItemData final : public UObject
{
public:
	class UDataTable*                             TradeItemDataTable_;                               // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetDataLineByIndex(const class FName Param_Index, struct FTradeItem* TradeItem);
	bool GetTItemDataFromDataTable(const class FString& TradeTablePath);

	class UDataTable* GetTradeItemDataTable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TradeItemData">();
	}
	static class UTradeItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTradeItemData>();
	}
};
static_assert(alignof(UTradeItemData) == 0x000008, "Wrong alignment on UTradeItemData");
static_assert(sizeof(UTradeItemData) == 0x000030, "Wrong size on UTradeItemData");
static_assert(offsetof(UTradeItemData, TradeItemDataTable_) == 0x000028, "Member 'UTradeItemData::TradeItemDataTable_' has a wrong offset!");

// Class BattlePrototype.TumbleConditionComponent
// 0x0020 (0x0180 - 0x0160)
class UTumbleConditionComponent final : public UConditionComponent
{
public:
	float                                         _tumbleSec;                                        // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C8[0x1C];                                    // 0x0164(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TumbleConditionComponent">();
	}
	static class UTumbleConditionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTumbleConditionComponent>();
	}
};
static_assert(alignof(UTumbleConditionComponent) == 0x000010, "Wrong alignment on UTumbleConditionComponent");
static_assert(sizeof(UTumbleConditionComponent) == 0x000180, "Wrong size on UTumbleConditionComponent");
static_assert(offsetof(UTumbleConditionComponent, _tumbleSec) == 0x000160, "Member 'UTumbleConditionComponent::_tumbleSec' has a wrong offset!");

// Class BattlePrototype.UIActionIcon
// 0x0100 (0x0488 - 0x0388)
class UUIActionIcon : public UUIBase
{
public:
	struct FVector2D                              baseOffset;                                        // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C9[0x8];                                     // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28CA[0xE8];                                    // 0x03A0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimOut2, class UWidgetAnimation* AnimSelect_Progress, class UWidgetAnimation* AnimSelectIn_Progress, class UWidgetAnimation* AnimSelectOut_Progress, class UWidgetAnimation* AnimIn2_Progress, class UWidgetAnimation* AnimOut2_Progress, class UWidgetAnimation* AnimSelect_Bonds, class UWidgetAnimation* AnimSelectIn_Bonds, class UWidgetAnimation* AnimSelectOut_Bonds, class UWidgetAnimation* AnimIn2_Bonds, class UWidgetAnimation* AnimOut2_Bonds, class UImage* ImageIcon, class UImage* ImageFrame1, class UImage* ImageFrame6Add, class UImage* ImageNo, class UImage* ImageNoAdd);
	void SetSubQuestStateDetail(EActionIconSubQuestState State, bool IsQuestActive, bool IsActive);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIActionIcon">();
	}
	static class UUIActionIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIActionIcon>();
	}
};
static_assert(alignof(UUIActionIcon) == 0x000008, "Wrong alignment on UUIActionIcon");
static_assert(sizeof(UUIActionIcon) == 0x000488, "Wrong size on UUIActionIcon");
static_assert(offsetof(UUIActionIcon, baseOffset) == 0x000388, "Member 'UUIActionIcon::baseOffset' has a wrong offset!");
static_assert(offsetof(UUIActionIcon, OwnerActor) == 0x000398, "Member 'UUIActionIcon::OwnerActor' has a wrong offset!");

// Class BattlePrototype.UIBooksTop
// 0x0338 (0x06C0 - 0x0388)
class UUIBooksTop : public UUIBase
{
public:
	uint8                                         Pad_28CB[0x338];                                   // 0x0388(0x0338)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeCategory(int32 Category, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimUnselect, class UWidgetAnimation* AnimDecision, class UTextBlock* TextCategory);
	void InitializeCommonParts(class UUIMainContents* Parent, class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimInfoWindow, class UWidgetAnimation* AnimInfoWindowIn, class UWidgetAnimation* AnimInfoWindowOut, class UBorder* borderAllColor, class UBorder* borderPicture, class UREDRetainerBox* RetainerBoxMenu, class UImage* ImageGhostViewer, class UImage* ImageViewerNoise, class UWidgetAnimation* AnimDefaultView, class UWidgetAnimation* AnimChangeView, class UWidgetAnimation* AnimChangeDefault, class UUIBrainMessage* UIBrainMessage, class UUICharaBooks* UICharaBooks, class UUIEnemyBooks* UIEnemyBooks, class UUIWishList* UiWish, class UUIClearGetter* UIClearGetter, class UUIHelpMenu* UIHelpMenu);
	void SetContentsChange(bool IsChange);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsEndMenu() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBooksTop">();
	}
	static class UUIBooksTop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBooksTop>();
	}
};
static_assert(alignof(UUIBooksTop) == 0x000008, "Wrong alignment on UUIBooksTop");
static_assert(sizeof(UUIBooksTop) == 0x0006C0, "Wrong size on UUIBooksTop");

// Class BattlePrototype.UIBrainMap
// 0x0060 (0x03E8 - 0x0388)
class UUIBrainMap : public UUIBase
{
public:
	struct FLinearColor                           ColorBrainIcon;                                    // 0x0388(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28CE[0x50];                                    // 0x0398(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UBorder* borderAllColor, class UImage* ImageCoverBlack, class UImage* ImageCA_Red, class UImage* ImageCA_Green, class UImage* ImageCA_Blue, class UImage* ImageBrainIcon2, class UImage* ImageBrainIcon3, class UImage* ImageBrainIcon4, class UUIBase* UiMainChliceParts);
	void PlayContentsIn();
	void PlayContentsOut();
	void UpdateProgramAnimation(float DeltaSeconds);

	bool IsPlayingContentsIn() const;
	bool IsPlayingContentsOut() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBrainMap">();
	}
	static class UUIBrainMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBrainMap>();
	}
};
static_assert(alignof(UUIBrainMap) == 0x000008, "Wrong alignment on UUIBrainMap");
static_assert(sizeof(UUIBrainMap) == 0x0003E8, "Wrong size on UUIBrainMap");
static_assert(offsetof(UUIBrainMap, ColorBrainIcon) == 0x000388, "Member 'UUIBrainMap::ColorBrainIcon' has a wrong offset!");

// Class BattlePrototype.UICharaBooks
// 0x00F0 (0x0478 - 0x0388)
class UUICharaBooks : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28CF[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D0[0x70];                                    // 0x03A0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               TextureCharacter[0x5];                             // 0x0410(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28D1[0x40];                                    // 0x0438(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeFromBooks(class UUIBooksTop* Parent, class UImage* ImageChara);
	void InitializeFromMain(class UUIMainContents* UIMainContents, class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimPresent, class UWidgetAnimation* AnimPresentIn, class UWidgetAnimation* AnimPresentOut, class UREDScrollBox* ScrollBox, class UUICharaInfoWindow* ChildInfoWin, class UUIEnemyListIndex* ChildListIndex, class UUICharaPresentWindow* PresentWindow);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaBooks">();
	}
	static class UUICharaBooks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaBooks>();
	}
};
static_assert(alignof(UUICharaBooks) == 0x000008, "Wrong alignment on UUICharaBooks");
static_assert(sizeof(UUICharaBooks) == 0x000478, "Wrong size on UUICharaBooks");
static_assert(offsetof(UUICharaBooks, ListElementSize) == 0x000388, "Member 'UUICharaBooks::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUICharaBooks, ListOffsetSize) == 0x000390, "Member 'UUICharaBooks::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUICharaBooks, ListIndexClass) == 0x000398, "Member 'UUICharaBooks::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUICharaBooks, TextureCharacter) == 0x000410, "Member 'UUICharaBooks::TextureCharacter' has a wrong offset!");

// Class BattlePrototype.UICharaPresentWindow
// 0x00E0 (0x0468 - 0x0388)
class UUICharaPresentWindow : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D3[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorNumNormal;                                    // 0x03A0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorNumMax;                                       // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D4[0xA8];                                    // 0x03C0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UREDScrollBox* ScrollBox, class UUICharaPresentListIndex* ChildListIndex, class UImage* ImagePresent, class UTextBlock* TextTitleBar, class UTextBlock* TextCharaName, class UBorder* borderBondLevelNum, class UTextBlock* TextBondLevelNum, class UTextBlock* TextItemName, class UBorder* borderCurrentNum, class UTextBlock* TextCurrentNum, class UTextBlock* TextSlash, class UTextBlock* TextMaxNum, class UUIGuide* ChildGuide, class UTextBlock* TextKeyBondsQuest);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	bool SetFaceIcon(EPlayerID CharacterId);
	bool SetFavorabilityIcon(EItemFavorability Favorability);
	bool SetItemInfo(const class FName& ItemId);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICharaPresentWindow">();
	}
	static class UUICharaPresentWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICharaPresentWindow>();
	}
};
static_assert(alignof(UUICharaPresentWindow) == 0x000008, "Wrong alignment on UUICharaPresentWindow");
static_assert(sizeof(UUICharaPresentWindow) == 0x000468, "Wrong size on UUICharaPresentWindow");
static_assert(offsetof(UUICharaPresentWindow, ListElementSize) == 0x000388, "Member 'UUICharaPresentWindow::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUICharaPresentWindow, ListOffsetSize) == 0x000390, "Member 'UUICharaPresentWindow::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUICharaPresentWindow, ListIndexClass) == 0x000398, "Member 'UUICharaPresentWindow::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUICharaPresentWindow, ColorNumNormal) == 0x0003A0, "Member 'UUICharaPresentWindow::ColorNumNormal' has a wrong offset!");
static_assert(offsetof(UUICharaPresentWindow, ColorNumMax) == 0x0003B0, "Member 'UUICharaPresentWindow::ColorNumMax' has a wrong offset!");

// Class BattlePrototype.UIClearGetter
// 0x0318 (0x06A0 - 0x0388)
class UUIClearGetter : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D7[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FontColorDefault;                                  // 0x03A0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FontColorRED;                                      // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28D8[0x2E0];                                   // 0x03C0(0x02E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddExp(int32 Exp);
	void CallEvent(const class FString& EventBPFilePath);
	void InitializeFromBooks(class UUIBooksTop* Parent, class UUIQuestChoice* UiQuestPopup);
	void InitializeFromMain(class UUIMainContents* UIMainContents, class UUIGuide* UiKeyGuide, class UTextBlock* TextHelp);
	void InitializeProgressItem(class UOverlay* IconSet, class UImage* ImageItemRarity, class UImage* ImageItemCategory, class UOverlay* NumSet, class UBorder* borderCurrent, class UTextBlock* TextProgressCurrent, class UTextBlock* TextProgressSlash, class UTextBlock* TextProgressTarget);
	void InitializeProgressTime(class UBorder* borderCurrentTime, class UTextBlock* TextCurrentTimeHH, class UTextBlock* TextCurrentTimeSeparate1, class UTextBlock* TextCurrentTimeMM, class UTextBlock* TextCurrentTimeSeparate2, class UTextBlock* TextCurrentTimeSS, class UTextBlock* TextSlash, class UOverlay* OverlayTargetTime, class UTextBlock* TextTargetTimeHH, class UTextBlock* TextTargetTimeSeparate1, class UTextBlock* TextTargetTimeMM, class UTextBlock* TextTargetTimeSeparate2, class UTextBlock* TextTargetTimeSS, class UTextBlock* TextBest, class UOverlay* OverlayBestTime, class UTextBlock* TextBestTimeHH, class UTextBlock* TextBestTimeSeparate1, class UTextBlock* TextBestTimeMM, class UTextBlock* TextBestTimeSeparate2, class UTextBlock* TextBestTimeSS);
	void InitializeReward(int32 Param_Index, class UOverlay* TextSet, class UImage* ImageItemRarity, class UImage* ImageItemCategory);
	void InitializeThis(class UBorder* borderAllColor, class UREDScrollBox* ScrollBoxMain, class UREDScrollBoxSimple* ScrollBoxSub, class UTextBlock* TextTitle, class UTextBlock* TextIndexProgress, class UTextBlock* TextIndexReward, class USpacer* SpacerDescription1, class USpacer* SpacerDescription2, class UUIQuestIcon* UIQuestIcon, class UCanvasPanel* QuestPanel, class UOverlay* OverlayProgressAll, class UImage* ImageLineQuest, class UTextBlock* TextProgressName);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void OnClearMission(EClearGetterType Type);
	void SetItemIcon(class UImage* ImageCategory, EItemIcon Category);
	void SetItemRarity(class UImage* ImageRarity, EItemRarity Rarity);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIClearGetter">();
	}
	static class UUIClearGetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIClearGetter>();
	}
};
static_assert(alignof(UUIClearGetter) == 0x000008, "Wrong alignment on UUIClearGetter");
static_assert(sizeof(UUIClearGetter) == 0x0006A0, "Wrong size on UUIClearGetter");
static_assert(offsetof(UUIClearGetter, ListElementSize) == 0x000388, "Member 'UUIClearGetter::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIClearGetter, ListOffsetSize) == 0x000390, "Member 'UUIClearGetter::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIClearGetter, ListIndexClass) == 0x000398, "Member 'UUIClearGetter::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUIClearGetter, FontColorDefault) == 0x0003A0, "Member 'UUIClearGetter::FontColorDefault' has a wrong offset!");
static_assert(offsetof(UUIClearGetter, FontColorRED) == 0x0003B0, "Member 'UUIClearGetter::FontColorRED' has a wrong offset!");

// Class BattlePrototype.UIConfigChoice
// 0x00C0 (0x0448 - 0x0388)
class UUIConfigChoice : public UUIBase
{
public:
	uint8                                         Pad_28DD[0xC0];                                    // 0x0388(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Param_Index, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UTextBlock* TextWindowTitle, class UTextBlock* TextMain, class UOverlay* OverlayGuideSet);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigChoice">();
	}
	static class UUIConfigChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigChoice>();
	}
};
static_assert(alignof(UUIConfigChoice) == 0x000008, "Wrong alignment on UUIConfigChoice");
static_assert(sizeof(UUIConfigChoice) == 0x000448, "Wrong size on UUIConfigChoice");

// Class BattlePrototype.UIConfigControllerSelect
// 0x0040 (0x03C8 - 0x0388)
class UUIConfigControllerSelect : public UUIBase
{
public:
	uint8                                         Pad_28DF[0x40];                                    // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class USpacer* Spacer, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigControllerSelect">();
	}
	static class UUIConfigControllerSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigControllerSelect>();
	}
};
static_assert(alignof(UUIConfigControllerSelect) == 0x000008, "Wrong alignment on UUIConfigControllerSelect");
static_assert(sizeof(UUIConfigControllerSelect) == 0x0003C8, "Wrong size on UUIConfigControllerSelect");

// Class BattlePrototype.UIConfigGame
// 0x0628 (0x09B0 - 0x0388)
class UUIConfigGame : public UUIBase
{
public:
	float                                         LineHeight;                                        // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IndexPerPage;                                      // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ControllerIndexPerPage;                            // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KeyboardIndexPerPage;                              // 0x0394(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          M_pSoundSampleVoiceJP;                             // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundAtomCue*                          M_pSoundSampleVoiceEN;                             // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E0[0x5A0];                                   // 0x03A8(0x05A0)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveLoadScreenParamManager*            M_pSystemSaveLoadScreenParamManager;               // 0x0948(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28E1[0x60];                                    // 0x0950(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void bindAnyKey();
	void InitializeArrowLR(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision);
	void InitializeCategory(int32 Category, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UTextBlock* TextCategory);
	void InitializeCommonParts(class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide, class UUIMainContents* Parent, class UWidgetAnimation* AnimMainMenuInfoWin, class UWidgetAnimation* AnimMainMenuInfoWinIn, class UWidgetAnimation* AnimMainMenuInfoWinOut);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimInfoWin, class UWidgetAnimation* AnimInfoWinIn, class UWidgetAnimation* AnimInfoWinOut, class UBackgroundBlur* BackgroundBlur, class UBorder* borderAllColor, class UImage* ImageCoverBlack, class UREDScrollBoxSimple* ScrollBox, class UTextBlock* TextTitle, class UTextBlock* TextHelp, class UOverlay* MenuSet, class UUIGuide* UIGuide, class UUIConfigBrightness* UiBrightness, class UUIConfigKeyboardMouse* UiKeyboardMouse, class UUIConfigController* UiController, class UUIConfigGraphics* UiGraphics, class UUIConfigOther* UiOther, class UImage* ImageOtherCategoryLine, class UUIConfigChoice* UIConfigChoice, class UUIConfigSelect4* UiIndexDifficulty, class UUIConfigSelect2* UiIndexAutoLockOn, class UUIConfigSelect2* UiIndexAttackDirOrtho, class UUIConfigSelect2* UiIndexAttackDirOrthoLockon, class UUIConfigSelect3* UiIndexCameraDistance, class UUIConfigSelect2* UiIndexAutoCamera, class UUIConfigSelect5* UiIndexBehindCameraSpeed, class UUIConfigSelect2* UiIndexCameraAfterMoveType, class UUIConfigSelect2* UiIndexDisplayEnemyDamage, class UUIConfigSelect2* UiIndexMiniMapDisplay, class UUIConfigSelect2* UiIndexMiniMapRotation, class UUIConfigSelect2* UiIndexMiniMapScaling, class UUIConfigSelect2* UiIndexSASCutin, class UUIConfigSelect2* UiIndexBrainCrashCutin, class UUIConfigSelect2* UiIndexLetterSize, class UUIConfigSelect2* UiIndexAutoSkip, class UUIConfigSelectMulti* UiIndexVoiceLanguage, class UUIConfigSelectSlider* UiIndexVoiceVolume, class UUIConfigSelectSlider* UiIndexBGMVolume, class UUIConfigSelectSlider* UiIndexSEVolume, class UUIConfigSelect5* UiIndexCameraRotationSpeed, class UUIConfigSelect5* UiIndexCameraSpeedLockon, class UUIConfigSelect2* UiIndexCameraRotationPitch, class UUIConfigSelect2* UiIndexCameraRotatinoYaw, class UUIConfigSelect2* UiIndexControllerVibration, class UTextBlock* TextCustomerID);
	bool IsAllowChangeMainMenuTab();
	void OnReceivedCustomerID(const class FString& ID);
	void PlayVibrationS();
	void SetAnyKey(const struct FKey& Key);
	void SetChangeMainMenuTabL();
	void SetChangeMainMenuTabR();
	void SetContentsChange(bool IsChange);
	void StartFromTitle();
	void UnbindAnyKey();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsChangeMainMenuTabL() const;
	bool IsChangeMainMenuTabR() const;
	bool IsEndMenu() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigGame">();
	}
	static class UUIConfigGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigGame>();
	}
};
static_assert(alignof(UUIConfigGame) == 0x000008, "Wrong alignment on UUIConfigGame");
static_assert(sizeof(UUIConfigGame) == 0x0009B0, "Wrong size on UUIConfigGame");
static_assert(offsetof(UUIConfigGame, LineHeight) == 0x000388, "Member 'UUIConfigGame::LineHeight' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, IndexPerPage) == 0x00038C, "Member 'UUIConfigGame::IndexPerPage' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, ControllerIndexPerPage) == 0x000390, "Member 'UUIConfigGame::ControllerIndexPerPage' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, KeyboardIndexPerPage) == 0x000394, "Member 'UUIConfigGame::KeyboardIndexPerPage' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, M_pSoundSampleVoiceJP) == 0x000398, "Member 'UUIConfigGame::M_pSoundSampleVoiceJP' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, M_pSoundSampleVoiceEN) == 0x0003A0, "Member 'UUIConfigGame::M_pSoundSampleVoiceEN' has a wrong offset!");
static_assert(offsetof(UUIConfigGame, M_pSystemSaveLoadScreenParamManager) == 0x000948, "Member 'UUIConfigGame::M_pSystemSaveLoadScreenParamManager' has a wrong offset!");

// Class BattlePrototype.UIConfigOther
// 0x0008 (0x0390 - 0x0388)
class UUIConfigOther : public UUIBase
{
public:
	class UUIBase*                                ChildIndex;                                        // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeThis(class UUIBase* UiIndex, class UREDTextBlock* TextIndex);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigOther">();
	}
	static class UUIConfigOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigOther>();
	}
};
static_assert(alignof(UUIConfigOther) == 0x000008, "Wrong alignment on UUIConfigOther");
static_assert(sizeof(UUIConfigOther) == 0x000390, "Wrong size on UUIConfigOther");
static_assert(offsetof(UUIConfigOther, ChildIndex) == 0x000388, "Member 'UUIConfigOther::ChildIndex' has a wrong offset!");

// Class BattlePrototype.UIConfigSelect3
// 0x0150 (0x0550 - 0x0400)
class UUIConfigSelect3 : public UUIConfigSelectBase
{
public:
	uint8                                         Pad_28E4[0x150];                                   // 0x0400(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut, class UTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelect3">();
	}
	static class UUIConfigSelect3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelect3>();
	}
};
static_assert(alignof(UUIConfigSelect3) == 0x000008, "Wrong alignment on UUIConfigSelect3");
static_assert(sizeof(UUIConfigSelect3) == 0x000550, "Wrong size on UUIConfigSelect3");

// Class BattlePrototype.UIConfigSelect4
// 0x0210 (0x0610 - 0x0400)
class UUIConfigSelect4 : public UUIConfigSelectBase
{
public:
	uint8                                         Pad_28E6[0x210];                                   // 0x0400(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut, class UTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelect4">();
	}
	static class UUIConfigSelect4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelect4>();
	}
};
static_assert(alignof(UUIConfigSelect4) == 0x000008, "Wrong alignment on UUIConfigSelect4");
static_assert(sizeof(UUIConfigSelect4) == 0x000610, "Wrong size on UUIConfigSelect4");

// Class BattlePrototype.UIConfigSelectSlider
// 0x0048 (0x0448 - 0x0400)
class UUIConfigSelectSlider : public UUIConfigSelectBase
{
public:
	int32                                         MinX;                                              // 0x0400(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxX;                                              // 0x0404(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28E8[0x40];                                    // 0x0408(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextTitle, class UREDImage* ImageSlider, class UREDOverlay* Gauge_set);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIConfigSelectSlider">();
	}
	static class UUIConfigSelectSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIConfigSelectSlider>();
	}
};
static_assert(alignof(UUIConfigSelectSlider) == 0x000008, "Wrong alignment on UUIConfigSelectSlider");
static_assert(sizeof(UUIConfigSelectSlider) == 0x000448, "Wrong size on UUIConfigSelectSlider");
static_assert(offsetof(UUIConfigSelectSlider, MinX) == 0x000400, "Member 'UUIConfigSelectSlider::MinX' has a wrong offset!");
static_assert(offsetof(UUIConfigSelectSlider, MaxX) == 0x000404, "Member 'UUIConfigSelectSlider::MaxX' has a wrong offset!");

// Class BattlePrototype.UICredit
// 0x3A08 (0x3D90 - 0x0388)
class UUICredit : public UUIBase
{
public:
	struct FSlateColor                            FontColor;                                         // 0x0388(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28E9[0x2E0];                                   // 0x03B0(0x02E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextData*                              TextData;                                          // 0x0690(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28EA[0x20];                                    // 0x0698(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TextureLogos[0x2];                                 // 0x06B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28EB[0x36C8];                                  // 0x06C8(0x36C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeCorporateName_Official(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextBlock);
	void InitializeLogo(class UOverlay* Overlay, class USpacer* Spacer, class UImage* ImageLogo);
	void InitializeOfficial_StaffName(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextPosition, class UREDTextBlock* TextStaff);
	void InitializeOfficial_StaffNameCombo(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextPosition1, class UREDTextBlock* TextStaff1, class UREDTextBlock* TextPosition2, class UREDTextBlock* TextStaff2);
	void InitializeOfficial_StaffNameDouble(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextPosition, class UREDTextBlock* TextStaff1, class UREDTextBlock* TextStaff2);
	void InitializeSpace_StaffName(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextStaff);
	void InitializeSpace_StaffNameDouble(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextStaff1, class UREDTextBlock* TextStaff2);
	void InitializeStaffName(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextBlock);
	void InitializeStaffNameDouble(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextStaff1, class UREDTextBlock* TextStaff2);
	void InitializeStaffNameQuad(class UOverlay* Overlay, class USpacer* Spacer, class UREDTextBlock* TextStaffLeft1, class UREDTextBlock* TextStaffLeft2, class UREDTextBlock* TextStaffRight1, class UREDTextBlock* TextStaffRight2);
	void InitializeThis(class UOverlay* OverlayParent);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICredit">();
	}
	static class UUICredit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICredit>();
	}
};
static_assert(alignof(UUICredit) == 0x000008, "Wrong alignment on UUICredit");
static_assert(sizeof(UUICredit) == 0x003D90, "Wrong size on UUICredit");
static_assert(offsetof(UUICredit, FontColor) == 0x000388, "Member 'UUICredit::FontColor' has a wrong offset!");
static_assert(offsetof(UUICredit, TextData) == 0x000690, "Member 'UUICredit::TextData' has a wrong offset!");
static_assert(offsetof(UUICredit, TextureLogos) == 0x0006B8, "Member 'UUICredit::TextureLogos' has a wrong offset!");

// Class BattlePrototype.UIEnemyBooks
// 0x00C8 (0x0450 - 0x0388)
class UUIEnemyBooks : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28EC[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28ED[0x50];                                    // 0x03A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               TextureEnemy[0x4];                                 // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28EE[0x40];                                    // 0x0410(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeFromBooks(class UUIBooksTop* Parent, class UImage* ImageEnemy);
	void InitializeFromMain(class UUIMainContents* UIMainContents, class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault, class UREDScrollBox* ScrollBox, class UUIEnemyInfoWindow* ChildInfoWin, class UUIEnemyListIndex* ChildListIndex);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEnemyBooks">();
	}
	static class UUIEnemyBooks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEnemyBooks>();
	}
};
static_assert(alignof(UUIEnemyBooks) == 0x000008, "Wrong alignment on UUIEnemyBooks");
static_assert(sizeof(UUIEnemyBooks) == 0x000450, "Wrong size on UUIEnemyBooks");
static_assert(offsetof(UUIEnemyBooks, ListElementSize) == 0x000388, "Member 'UUIEnemyBooks::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIEnemyBooks, ListOffsetSize) == 0x000390, "Member 'UUIEnemyBooks::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIEnemyBooks, ListIndexClass) == 0x000398, "Member 'UUIEnemyBooks::ListIndexClass' has a wrong offset!");
static_assert(offsetof(UUIEnemyBooks, TextureEnemy) == 0x0003F0, "Member 'UUIEnemyBooks::TextureEnemy' has a wrong offset!");

// Class BattlePrototype.UIEquip
// 0x0028 (0x03B0 - 0x0388)
class UUIEquip : public UUIBase
{
public:
	uint8                                         Pad_28F0[0x20];                                    // 0x0388(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_IsSetDefaultCursorParam;                         // 0x03A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_IsDefaultCursorVisual;                           // 0x03A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerID                                     M_DefaultCharaID;                                  // 0x03AA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28F1[0x5];                                     // 0x03AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	void InitializeThis(class UOverlay* OverlayAllSet, class UOverlay* Overlay2);
	bool IsEquip_ac3065(int32 CursorCategory, EPlayerID CharacterId);
	bool IsEquip_ac4043(int32 CursorCategory, EPlayerID CharacterId);
	void PlayContentsIn();
	void PlayContentsOut();
	void RemoveDuplicateAccessories(class FName CheckItemID, TArray<struct FPlayerInfo>& PlayerList, int32 CursorChara);
	void ResetDefaultCursor();
	void SetDefaultCursor(EPlayerID CharaID, bool IsVisual);
	void UpdateProgramAnimation(float DeltaSeconds);
	void UpdatEquipListMouseFocus();

	bool IsEnableWeaponSkin() const;
	bool IsPlayingContentsIn() const;
	bool IsPlayingContentsOut() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEquip">();
	}
	static class UUIEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEquip>();
	}
};
static_assert(alignof(UUIEquip) == 0x000008, "Wrong alignment on UUIEquip");
static_assert(sizeof(UUIEquip) == 0x0003B0, "Wrong size on UUIEquip");
static_assert(offsetof(UUIEquip, M_IsSetDefaultCursorParam) == 0x0003A8, "Member 'UUIEquip::M_IsSetDefaultCursorParam' has a wrong offset!");
static_assert(offsetof(UUIEquip, M_IsDefaultCursorVisual) == 0x0003A9, "Member 'UUIEquip::M_IsDefaultCursorVisual' has a wrong offset!");
static_assert(offsetof(UUIEquip, M_DefaultCharaID) == 0x0003AA, "Member 'UUIEquip::M_DefaultCharaID' has a wrong offset!");

// Class BattlePrototype.UIGamerTag
// 0x0018 (0x03A0 - 0x0388)
class UUIGamerTag : public UUIBase
{
public:
	class UOverlay*                               Guide;                                             // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             XBoxUserName;                                      // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       Anime_default;                                     // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeThis(class UTextBlock* Usernametext, class UWidgetAnimation* _default);
	void InitializeThisGuide(class UOverlay* Param_Guide);
	void SetGuideVisible(bool Param_IsVisible);
	void SetUserName();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGamerTag">();
	}
	static class UUIGamerTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGamerTag>();
	}
};
static_assert(alignof(UUIGamerTag) == 0x000008, "Wrong alignment on UUIGamerTag");
static_assert(sizeof(UUIGamerTag) == 0x0003A0, "Wrong size on UUIGamerTag");
static_assert(offsetof(UUIGamerTag, Guide) == 0x000388, "Member 'UUIGamerTag::Guide' has a wrong offset!");
static_assert(offsetof(UUIGamerTag, XBoxUserName) == 0x000390, "Member 'UUIGamerTag::XBoxUserName' has a wrong offset!");
static_assert(offsetof(UUIGamerTag, Anime_default) == 0x000398, "Member 'UUIGamerTag::Anime_default' has a wrong offset!");

// Class BattlePrototype.UIHelpMenu
// 0x0110 (0x0498 - 0x0388)
class UUIHelpMenu : public UUIBase
{
public:
	struct FVector2D                              ListElementSize;                                   // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSize;                                    // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28F5[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClass;                                    // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28F6[0xF8];                                    // 0x03A0(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeArrow(int32 Param_Index, class UUIHelpParts* Arrow);
	void InitializeCommonHelp(class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeHelp(class UUITutoTipsParts* UTutoTipsParts);
	void InitializeList(class UCanvasPanel* ScrollBoxParent, class UREDScrollBox* ScrollBox);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void UpdateStateHelpList(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHelpMenu">();
	}
	static class UUIHelpMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHelpMenu>();
	}
};
static_assert(alignof(UUIHelpMenu) == 0x000008, "Wrong alignment on UUIHelpMenu");
static_assert(sizeof(UUIHelpMenu) == 0x000498, "Wrong size on UUIHelpMenu");
static_assert(offsetof(UUIHelpMenu, ListElementSize) == 0x000388, "Member 'UUIHelpMenu::ListElementSize' has a wrong offset!");
static_assert(offsetof(UUIHelpMenu, ListOffsetSize) == 0x000390, "Member 'UUIHelpMenu::ListOffsetSize' has a wrong offset!");
static_assert(offsetof(UUIHelpMenu, ListIndexClass) == 0x000398, "Member 'UUIHelpMenu::ListIndexClass' has a wrong offset!");

// Class BattlePrototype.UIItemDetails
// 0x0060 (0x03E8 - 0x0388)
class UUIItemDetails : public UUIBase
{
public:
	uint8                                         Pad_28F9[0x60];                                    // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearItemInfo();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimDefaultNoSet, class UImage* ImageNewIcon, class UTextBlock* TextItemName, class UTextBlock* TextParameter, class UTextBlock* TextItemDescription, class UTextBlock* TextHave, class UTextBlock* TextItemHaveNum, class UTextBlock* TextItemMaxNum, class UTextBlock* TextItemNumSlash);
	bool SetItemInfo(const class FName& ItemId, int32 ItemIndex);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemDetails">();
	}
	static class UUIItemDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemDetails>();
	}
};
static_assert(alignof(UUIItemDetails) == 0x000008, "Wrong alignment on UUIItemDetails");
static_assert(sizeof(UUIItemDetails) == 0x0003E8, "Wrong size on UUIItemDetails");

// Class BattlePrototype.UIItemListIndex
// 0x00C8 (0x0450 - 0x0388)
class UUIItemListIndex : public UUIBase
{
public:
	struct FLinearColor                           ColorNumHave;                                      // 0x0388(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorMaxNumHave;                                   // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28FB[0xA8];                                    // 0x03A8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeOverlay(class UREDOverlay* ListLset, class UREDOverlay* ListRset);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelectL, class UWidgetAnimation* AnimSelectInL, class UBorder* borderHaveL, class UWidgetAnimation* AnimSelectR, class UWidgetAnimation* AnimSelectInR, class UBorder* borderHaveR, class UWidgetAnimation* AnimChangeR, class UWidgetAnimation* AnimChangeL, class UImage* ImageNewIconL, class UTextBlock* TextItemNameL, class UTextBlock* TextNumHaveL, class UOverlay* OverlayR, class UImage* ImageNewIconR, class UTextBlock* TextItemNameR, class UTextBlock* TextNumHaveR);
	bool SetItemInfoL(const class FName& ItemId, int32 ItemIndex);
	bool SetItemInfoR(const class FName& ItemId, int32 ItemIndex);
	void UpdateStateThis();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemListIndex">();
	}
	static class UUIItemListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemListIndex>();
	}
};
static_assert(alignof(UUIItemListIndex) == 0x000008, "Wrong alignment on UUIItemListIndex");
static_assert(sizeof(UUIItemListIndex) == 0x000450, "Wrong size on UUIItemListIndex");
static_assert(offsetof(UUIItemListIndex, ColorNumHave) == 0x000388, "Member 'UUIItemListIndex::ColorNumHave' has a wrong offset!");
static_assert(offsetof(UUIItemListIndex, ColorMaxNumHave) == 0x000398, "Member 'UUIItemListIndex::ColorMaxNumHave' has a wrong offset!");

// Class BattlePrototype.UIItemPartyStatus
// 0x0058 (0x03E0 - 0x0388)
class UUIItemPartyStatus : public UUIBase
{
public:
	uint8                                         Pad_28FE[0x58];                                    // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIcons(class UUIItemPartyStatusIcon* UiIcon1, class UUIItemPartyStatusIcon* UiIcon2, class UUIItemPartyStatusIcon* UiIcon3, class UUIItemPartyStatusIcon* UiIcon4, class UUIItemPartyStatusIcon* UiIcon5, class UUIItemPartyStatusIcon* UiIcon6, class UUIItemPartyStatusIcon* UiIcon7, class UUIItemPartyStatusIcon* UiIcon8, class UUIItemPartyStatusIcon* UiIcon9, class UUIItemPartyStatusIcon* UiIcon10);
	void InitializeThis(class UWidgetAnimation* AnimDefault);
	void UpdatePartyStatus(const class FName& ItemId);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemPartyStatus">();
	}
	static class UUIItemPartyStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemPartyStatus>();
	}
};
static_assert(alignof(UUIItemPartyStatus) == 0x000008, "Wrong alignment on UUIItemPartyStatus");
static_assert(sizeof(UUIItemPartyStatus) == 0x0003E0, "Wrong size on UUIItemPartyStatus");

// Class BattlePrototype.UIItemPartyStatusIcon
// 0x0060 (0x03E8 - 0x0388)
class UUIItemPartyStatusIcon : public UUIBase
{
public:
	uint8                                         Pad_28FF[0x60];                                    // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimUnselect, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimDarkMax, class UImage* ImageEquip, class UImage* ImageDone, class UHorizonFlipbookWidget* FlipArrowUP, class UHorizonFlipbookWidget* FlipArrowDOWN, class UPaperFlipbook* UpDefaultPF, class UPaperFlipbook* DownDefaultPF, class UOverlay* OverlayBondSet, class UTextBlock* TextBondNum, class UImage* ImageEWeaponSkin);
	void SetEquipOrLoveIcon(EEquipOrLoveIcon Type);
	void SetFaceIcon(EPlayerID CharacterId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemPartyStatusIcon">();
	}
	static class UUIItemPartyStatusIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemPartyStatusIcon>();
	}
};
static_assert(alignof(UUIItemPartyStatusIcon) == 0x000008, "Wrong alignment on UUIItemPartyStatusIcon");
static_assert(sizeof(UUIItemPartyStatusIcon) == 0x0003E8, "Wrong size on UUIItemPartyStatusIcon");

// Class BattlePrototype.UIKeyword
// 0x0090 (0x0418 - 0x0388)
class UUIKeyword : public UUIBase
{
public:
	uint8                                         Pad_2900[0x90];                                    // 0x0388(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextDescription, class UTextBlock* TextKeyword, class UTextBlock* TextInformation, class UEditableText* TextEdit);
	void TextCancel();
	void TextChange(const class FText& Text);
	void TextEnter(const class FText& Text);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	class FString GetResult() const;
	bool IsCancel() const;
	bool IsWindows() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyword">();
	}
	static class UUIKeyword* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyword>();
	}
};
static_assert(alignof(UUIKeyword) == 0x000008, "Wrong alignment on UUIKeyword");
static_assert(sizeof(UUIKeyword) == 0x000418, "Wrong size on UUIKeyword");

// Class BattlePrototype.UILog
// 0x03F0 (0x0778 - 0x0388)
class UUILog : public UUIBase
{
public:
	uint8                                         Pad_2901[0x3F0];                                   // 0x0388(0x03F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLogMessage(const class FString& LogMessage, const float _drawTime);
	void AddLogMessageSE(const class FString& LogMessage, EUI_SE Se, const float _drawTime);
	void InitializeThis(class UWidgetAnimation* AnimIn1, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimIn3, class UWidgetAnimation* AnimIn4, class UWidgetAnimation* AnimIn5, class UWidgetAnimation* AnimIn6, class UWidgetAnimation* AnimIn7, class UWidgetAnimation* AnimDefault1, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault3, class UWidgetAnimation* AnimDefault4, class UWidgetAnimation* AnimDefault5, class UWidgetAnimation* AnimDefault6, class UUILogParts* Log1, class UUILogParts* Log2, class UUILogParts* Log3, class UUILogParts* Log4, class UUILogParts* Log5, class UUILogParts* Log6, class UUILogParts* Log7);
	void SetDrawTime(float Time);
	bool SetupTextSize();
	void SetWaitTime(float Time);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	float GetDrawTime() const;
	float GetWaitTime() const;
	bool IsEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILog">();
	}
	static class UUILog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILog>();
	}
};
static_assert(alignof(UUILog) == 0x000008, "Wrong alignment on UUILog");
static_assert(sizeof(UUILog) == 0x000778, "Wrong size on UUILog");

// Class BattlePrototype.UILogParts
// 0x0080 (0x0408 - 0x0388)
class UUILogParts : public UUIBase
{
public:
	float                                         ShuffleSeconds;                                    // 0x0388(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffleIntervalSeconds;                            // 0x038C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2904[0x78];                                    // 0x0390(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextBlock);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILogParts">();
	}
	static class UUILogParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILogParts>();
	}
};
static_assert(alignof(UUILogParts) == 0x000008, "Wrong alignment on UUILogParts");
static_assert(sizeof(UUILogParts) == 0x000408, "Wrong size on UUILogParts");
static_assert(offsetof(UUILogParts, ShuffleSeconds) == 0x000388, "Member 'UUILogParts::ShuffleSeconds' has a wrong offset!");
static_assert(offsetof(UUILogParts, ShuffleIntervalSeconds) == 0x00038C, "Member 'UUILogParts::ShuffleIntervalSeconds' has a wrong offset!");

// Class BattlePrototype.UIMatchID
// 0x0078 (0x0400 - 0x0388)
class UUIMatchID : public UUIBase
{
public:
	float                                         PreShuffleSeconds;                                 // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffuleSeconds;                                   // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShuffuleIntervalSeconds;                           // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2905[0x6C];                                    // 0x0394(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void End();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextID, class UTextBlock* TextName);
	void Start(const class FName CharaID, const class FName ArmyCodeMessageID);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMatchID">();
	}
	static class UUIMatchID* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMatchID>();
	}
};
static_assert(alignof(UUIMatchID) == 0x000008, "Wrong alignment on UUIMatchID");
static_assert(sizeof(UUIMatchID) == 0x000400, "Wrong size on UUIMatchID");
static_assert(offsetof(UUIMatchID, PreShuffleSeconds) == 0x000388, "Member 'UUIMatchID::PreShuffleSeconds' has a wrong offset!");
static_assert(offsetof(UUIMatchID, ShuffuleSeconds) == 0x00038C, "Member 'UUIMatchID::ShuffuleSeconds' has a wrong offset!");
static_assert(offsetof(UUIMatchID, ShuffuleIntervalSeconds) == 0x000390, "Member 'UUIMatchID::ShuffuleIntervalSeconds' has a wrong offset!");

// Class BattlePrototype.UIMenuBattleControl
// 0x01B0 (0x0538 - 0x0388)
class UUIMenuBattleControl : public UUIBase
{
public:
	TSubclassOf<class UUINumberDamage>            ClassNumberDamage;                                 // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIGameOver*                            UIGameOver;                                        // 0x0390(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBossName*                            UIBossName;                                        // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUILog*                                 UILog;                                             // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUITarget*                              UICursorNormal;                                    // 0x03A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL01*                        UIVitalityPL01;                                    // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL02*                        UIVitalityPL02;                                    // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL02*                        UiVitalityPL02Flame;                               // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL03*                        UIVitalityPL03;                                    // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityPL03*                        UiVitalityPL03Flame;                               // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityEN01*                        UIVitalityEN01;                                    // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIVitalityEN01*                        UiVitalityEN01Flame;                               // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBrainGaugeEN*                        UIBrainGaugeEN;                                    // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIBrainGaugeEN*                        UiBrainGaugeENFrame;                               // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIVitalityEN02*>                UIEnemyVitalityWidgetList;                         // 0x03F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUINumberDamage*>                DamageWidgets;                                     // 0x0408(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIDiscover*>                    UIIDiscoverList;                                   // 0x0418(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIPkObjectTimer*>               UIPkObjectTimerList;                               // 0x0428(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagPlayUI;                                        // 0x0438(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagCloseDirect;                                   // 0x0439(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawHpGaugeMain;                               // 0x043A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawHpGaugeSub;                                // 0x043B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawPsychicGauge;                              // 0x043C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainCrashGauge;                           // 0x043D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainCrashGaugeEnemy;                      // 0x043E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawItemMenu;                                  // 0x043F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawSasMenu;                                   // 0x0440(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawMiniMap;                                   // 0x0441(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawLog;                                       // 0x0442(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawDroneGuide;                                // 0x0443(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawTeamBondLv;                                // 0x0444(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawMiniTips;                                  // 0x0445(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainCrashBar;                             // 0x0446(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainCrashBarBoss;                         // 0x0447(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawHpGaugeEnemyBoss;                          // 0x0448(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawShortcutGuide;                             // 0x0449(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawBrainTalk;                                 // 0x044A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawOtherWidget;                               // 0x044B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawTutoOperation;                             // 0x044C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawAreaHere;                                  // 0x044D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawSuccess;                                   // 0x044E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawVisionSimulatorTimer;                      // 0x044F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlagDrawNexusDriveNotice;                          // 0x0450(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2906[0x7];                                     // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIBrainTargetInfo>             CursorBrainTargetList;                             // 0x0458(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CursorBrainTargetOffset2D;                         // 0x0468(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUIEnemyInfo>                   EnemyList;                                         // 0x0470(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnemyHpWidgetVisibleFlag;                          // 0x0480(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2907[0x7];                                     // 0x0481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSCharacterBase*                       CursorTarget;                                      // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DeltaTime;                                         // 0x0490(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BrainGaugeENVisibleFlag;                           // 0x0494(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2908[0xB];                                     // 0x0495(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBrainCrashGauge*                     UIBrainCrashGaugeBoss;                             // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ARSCharacterBase*                       BackupBrainCrashTarget;                            // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUIPkObjectTimerInfo>           PkObjectTimerWork;                                 // 0x04B0(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUINexusDrive*                          UiNexusDrivePL02;                                  // 0x04C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUINexusDrive*                          UiNexusDrivePL03;                                  // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         LogMessageList;                                    // 0x04D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2909[0xC];                                     // 0x04E0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              M_widgetsMaxMove;                                  // 0x04EC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_widgetsMaxMovePerFrame;                          // 0x04F4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_widgetsMaxScaleingMaxMove;                       // 0x04FC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_widgetsMaxScaleingPerFrame;                      // 0x0504(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290A[0x2C];                                    // 0x050C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BrainGaugeENEndField();
	void BrainGaugeENSetGaugeMax(bool IsFull);
	void BrainGaugeENSetPercent(float Percent, float Time);
	void BrainGaugeENSetVisible(bool Param_IsVisible);
	void BrainGaugeENStartField();
	bool ChangePlayUI(bool IsPlay);
	bool ChangeTown(bool IsTown, bool IsAjito);
	void CloseActiveAllBrainTargetCursor(class ARSCharacterBase* PExcludeTarget);
	void CloseAllDamageWidget();
	void CloseAllPkObjectTimer();
	bool CloseMinimap(bool Force);
	bool CloseMiniTips(EHelpTutorial ID);
	void CloseTargetCursor();
	int32 CreateDiscoverIndexList(class UUIDiscover* UIDiscover);
	int32 CreateIndexList(class UUIDiscover* UIDiscover);
	bool EndMinimapBrainField();
	void EnemyHpWidgetDisappearInstantly(class ARSCharacterBase* Target);
	int32 GetBrainTargetCursor(class ARSCharacterBase* PTarget);
	EHelpTutorial GetCurrentMiniTipsID();
	int32 GetEnemyLevel(class ARSCharacterBase* Target);
	class UUINumberDamage* GetFreeDamageWidget();
	void GetFreeHpWidget(class UUIVitalityEN02** Widget);
	EGameOverResult GetGameOverResult();
	void GetHp(class ARSCharacterBase* Character, float* Max, float* Current);
	float GetHPPercent(int32 Param_Index);
	void GetHpTargetCharacter(int32 Param_Index, class ARSCharacterBase** Instance, bool* IsEnable);
	void InitDamage();
	void InitializeThis(class UUILog* Param_UILog, class UUIVitalityPL01* Param_UIVitalityPL01, class UUIVitalityPL02* Param_UIVitalityPL02, class UUIVitalityPL02* Param_UiVitalityPL02Flame, class UUIVitalityPL03* Param_UIVitalityPL03, class UUIVitalityPL03* Param_UiVitalityPL03Flame, class UUIVitalityEN01* Param_UIVitalityEN01, class UUIVitalityEN01* Param_UiVitalityEN01Flame, class UUIBrainGaugeEN* Param_UIBrainGaugeEN, class UUIBrainGaugeEN* Param_UiBrainGaugeENFrame, class UOverlay* OverlayWidgets, class UUINexusDrive* Param_UiNexusDrivePL02, class UUINexusDrive* Param_UiNexusDrivePL03);
	void InitLogMessage();
	bool IsEndGameOver();
	bool IsFlagPlayUINative();
	bool IsPlayBrainTuto();
	bool MiniMapModelDelete();
	void OpenActiveAllBrainTargetCursor();
	void OpenAllActivePkObjectTimer();
	bool OpenBrainTuto();
	bool OpenMinimap(bool Force);
	bool PlayDamageEffect(bool IsCritical);
	bool PlayDecideAnimeBrainTuto();
	void ReleaseCrushBonus();
	bool RemoveDiscoverIndexList(int32 Param_Index);
	bool SasSetChangePageReady(bool ReadyFlagL, bool ReadyFlagR);
	int32 SetBrainCrashEnable(class ARSCharacterBase* PTarget, bool IsEnable);
	void SetBrainCrashTarget(class ARSCharacterBase* PTarget, bool* bSuccess);
	bool SetCrushBonus(class ARSCharacterBase* Target, int32 bonus);
	void SetDamage2D(int32 Damage, const struct FVector2D& Position2D, bool IsPlayer, bool IsCritical, bool IsSasCritical, bool IsBrainCrashCritical, bool IsHeal, bool IsWeak, bool IsNoDamage, class ARSCharacterBase* CrushTarget, int32 CrushBonus);
	void SetDamage3D(int32 Damage, const struct FVector& Position3D, bool IsPlayer, bool IsCritical, bool IsSasCritical, bool IsBrainCrashCritical, bool IsHeal, bool IsWeak, bool IsNoDamage, class ARSCharacterBase* CrushTarget, int32 CrushBonus, const struct FVector2D& Offset);
	void SetEnemyDamage(class ARSCharacterBase* Target, int32 CurrentHp, int32 BaseHp, bool IsAlways, float Time);
	void SetEnemyHpWidgetVisible(bool Param_IsVisible);
	void SetIcon(class ARSCharacterBase* Character, class UUIHealthControl* Widget);
	void SetLogDrawTime(float Time);
	void SetLogMessage(const class FString& LogMessage, const float _drawTime);
	void SetLogMessageSE(const class FString& LogMessage, EUI_SE Se, const float _drawTime);
	void SetLogWaitTime(float Time);
	void SetupPlayerHpGauge();
	void SetUUIVitalityEN02Visible(bool Param_IsVisible);
	void SetVisibleIntercept(bool Param_IsVisible);
	bool SetVisionSimulatorTimerColor(int32 ColorIndex);
	bool SetVisionSimulatorTimerDraw(bool IsDraw);
	void StartGameOver();
	bool StartMinimapBrainField();
	bool StartNexusDrive();
	void StartPkObjectTimer(class ARSCharacterBase* Target, float MaxSecond, float CurrentSecond, bool Param_OpenDirect);
	void StopPkObjectTimer(class ARSCharacterBase* Target);
	bool UpdateDrawWidgetMiniMap();
	bool UpdateGuide();
	void UpdateHpVisible(int32 Param_Index, class ARSCharacterBase* Character);
	void UpdateHpWidgetInformation(class ARSCharacterBase* Actor, int32 Param_Index);
	void UpdateLockTarget();
	void UpdateLogMessage(float DeltaSecond);
	void UpdatePkObjectTimer(class ARSCharacterBase* Target, float MaxSecond, float CurrentSecond);
	void UpdateStateThis(float FDeltaSecond);

	class ARSCharacterBase* GetBackupBossActor() const;
	float GetLogDrawTime() const;
	float GetLogWaitTime() const;
	bool IsLogMessageEmpty() const;
	bool IsUsingBrainField() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMenuBattleControl">();
	}
	static class UUIMenuBattleControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMenuBattleControl>();
	}
};
static_assert(alignof(UUIMenuBattleControl) == 0x000008, "Wrong alignment on UUIMenuBattleControl");
static_assert(sizeof(UUIMenuBattleControl) == 0x000538, "Wrong size on UUIMenuBattleControl");
static_assert(offsetof(UUIMenuBattleControl, ClassNumberDamage) == 0x000388, "Member 'UUIMenuBattleControl::ClassNumberDamage' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIGameOver) == 0x000390, "Member 'UUIMenuBattleControl::UIGameOver' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIBossName) == 0x000398, "Member 'UUIMenuBattleControl::UIBossName' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UILog) == 0x0003A0, "Member 'UUIMenuBattleControl::UILog' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UICursorNormal) == 0x0003A8, "Member 'UUIMenuBattleControl::UICursorNormal' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIVitalityPL01) == 0x0003B0, "Member 'UUIMenuBattleControl::UIVitalityPL01' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIVitalityPL02) == 0x0003B8, "Member 'UUIMenuBattleControl::UIVitalityPL02' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiVitalityPL02Flame) == 0x0003C0, "Member 'UUIMenuBattleControl::UiVitalityPL02Flame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIVitalityPL03) == 0x0003C8, "Member 'UUIMenuBattleControl::UIVitalityPL03' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiVitalityPL03Flame) == 0x0003D0, "Member 'UUIMenuBattleControl::UiVitalityPL03Flame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIVitalityEN01) == 0x0003D8, "Member 'UUIMenuBattleControl::UIVitalityEN01' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiVitalityEN01Flame) == 0x0003E0, "Member 'UUIMenuBattleControl::UiVitalityEN01Flame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIBrainGaugeEN) == 0x0003E8, "Member 'UUIMenuBattleControl::UIBrainGaugeEN' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiBrainGaugeENFrame) == 0x0003F0, "Member 'UUIMenuBattleControl::UiBrainGaugeENFrame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIEnemyVitalityWidgetList) == 0x0003F8, "Member 'UUIMenuBattleControl::UIEnemyVitalityWidgetList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, DamageWidgets) == 0x000408, "Member 'UUIMenuBattleControl::DamageWidgets' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIIDiscoverList) == 0x000418, "Member 'UUIMenuBattleControl::UIIDiscoverList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIPkObjectTimerList) == 0x000428, "Member 'UUIMenuBattleControl::UIPkObjectTimerList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagPlayUI) == 0x000438, "Member 'UUIMenuBattleControl::FlagPlayUI' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagCloseDirect) == 0x000439, "Member 'UUIMenuBattleControl::FlagCloseDirect' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawHpGaugeMain) == 0x00043A, "Member 'UUIMenuBattleControl::FlagDrawHpGaugeMain' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawHpGaugeSub) == 0x00043B, "Member 'UUIMenuBattleControl::FlagDrawHpGaugeSub' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawPsychicGauge) == 0x00043C, "Member 'UUIMenuBattleControl::FlagDrawPsychicGauge' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainCrashGauge) == 0x00043D, "Member 'UUIMenuBattleControl::FlagDrawBrainCrashGauge' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainCrashGaugeEnemy) == 0x00043E, "Member 'UUIMenuBattleControl::FlagDrawBrainCrashGaugeEnemy' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawItemMenu) == 0x00043F, "Member 'UUIMenuBattleControl::FlagDrawItemMenu' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawSasMenu) == 0x000440, "Member 'UUIMenuBattleControl::FlagDrawSasMenu' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawMiniMap) == 0x000441, "Member 'UUIMenuBattleControl::FlagDrawMiniMap' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawLog) == 0x000442, "Member 'UUIMenuBattleControl::FlagDrawLog' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawDroneGuide) == 0x000443, "Member 'UUIMenuBattleControl::FlagDrawDroneGuide' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawTeamBondLv) == 0x000444, "Member 'UUIMenuBattleControl::FlagDrawTeamBondLv' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawMiniTips) == 0x000445, "Member 'UUIMenuBattleControl::FlagDrawMiniTips' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainCrashBar) == 0x000446, "Member 'UUIMenuBattleControl::FlagDrawBrainCrashBar' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainCrashBarBoss) == 0x000447, "Member 'UUIMenuBattleControl::FlagDrawBrainCrashBarBoss' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawHpGaugeEnemyBoss) == 0x000448, "Member 'UUIMenuBattleControl::FlagDrawHpGaugeEnemyBoss' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawShortcutGuide) == 0x000449, "Member 'UUIMenuBattleControl::FlagDrawShortcutGuide' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawBrainTalk) == 0x00044A, "Member 'UUIMenuBattleControl::FlagDrawBrainTalk' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawOtherWidget) == 0x00044B, "Member 'UUIMenuBattleControl::FlagDrawOtherWidget' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawTutoOperation) == 0x00044C, "Member 'UUIMenuBattleControl::FlagDrawTutoOperation' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawAreaHere) == 0x00044D, "Member 'UUIMenuBattleControl::FlagDrawAreaHere' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawSuccess) == 0x00044E, "Member 'UUIMenuBattleControl::FlagDrawSuccess' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawVisionSimulatorTimer) == 0x00044F, "Member 'UUIMenuBattleControl::FlagDrawVisionSimulatorTimer' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, FlagDrawNexusDriveNotice) == 0x000450, "Member 'UUIMenuBattleControl::FlagDrawNexusDriveNotice' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, CursorBrainTargetList) == 0x000458, "Member 'UUIMenuBattleControl::CursorBrainTargetList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, CursorBrainTargetOffset2D) == 0x000468, "Member 'UUIMenuBattleControl::CursorBrainTargetOffset2D' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, EnemyList) == 0x000470, "Member 'UUIMenuBattleControl::EnemyList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, EnemyHpWidgetVisibleFlag) == 0x000480, "Member 'UUIMenuBattleControl::EnemyHpWidgetVisibleFlag' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, CursorTarget) == 0x000488, "Member 'UUIMenuBattleControl::CursorTarget' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, DeltaTime) == 0x000490, "Member 'UUIMenuBattleControl::DeltaTime' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, BrainGaugeENVisibleFlag) == 0x000494, "Member 'UUIMenuBattleControl::BrainGaugeENVisibleFlag' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UIBrainCrashGaugeBoss) == 0x0004A0, "Member 'UUIMenuBattleControl::UIBrainCrashGaugeBoss' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, BackupBrainCrashTarget) == 0x0004A8, "Member 'UUIMenuBattleControl::BackupBrainCrashTarget' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, PkObjectTimerWork) == 0x0004B0, "Member 'UUIMenuBattleControl::PkObjectTimerWork' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiNexusDrivePL02) == 0x0004C0, "Member 'UUIMenuBattleControl::UiNexusDrivePL02' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, UiNexusDrivePL03) == 0x0004C8, "Member 'UUIMenuBattleControl::UiNexusDrivePL03' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, LogMessageList) == 0x0004D0, "Member 'UUIMenuBattleControl::LogMessageList' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, M_widgetsMaxMove) == 0x0004EC, "Member 'UUIMenuBattleControl::M_widgetsMaxMove' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, M_widgetsMaxMovePerFrame) == 0x0004F4, "Member 'UUIMenuBattleControl::M_widgetsMaxMovePerFrame' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, M_widgetsMaxScaleingMaxMove) == 0x0004FC, "Member 'UUIMenuBattleControl::M_widgetsMaxScaleingMaxMove' has a wrong offset!");
static_assert(offsetof(UUIMenuBattleControl, M_widgetsMaxScaleingPerFrame) == 0x000504, "Member 'UUIMenuBattleControl::M_widgetsMaxScaleingPerFrame' has a wrong offset!");

// Class BattlePrototype.UIMiniSubQuestGoal
// 0x0000 (0x0388 - 0x0388)
class UUIMiniSubQuestGoal : public UUIBase
{
public:
	bool SetSubquestActive();
	bool SetSubquestCompActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniSubQuestGoal">();
	}
	static class UUIMiniSubQuestGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniSubQuestGoal>();
	}
};
static_assert(alignof(UUIMiniSubQuestGoal) == 0x000008, "Wrong alignment on UUIMiniSubQuestGoal");
static_assert(sizeof(UUIMiniSubQuestGoal) == 0x000388, "Wrong size on UUIMiniSubQuestGoal");

// Class BattlePrototype.UIMiniBondsQuestGoal
// 0x0000 (0x0388 - 0x0388)
class UUIMiniBondsQuestGoal : public UUIBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMiniBondsQuestGoal">();
	}
	static class UUIMiniBondsQuestGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMiniBondsQuestGoal>();
	}
};
static_assert(alignof(UUIMiniBondsQuestGoal) == 0x000008, "Wrong alignment on UUIMiniBondsQuestGoal");
static_assert(sizeof(UUIMiniBondsQuestGoal) == 0x000388, "Wrong size on UUIMiniBondsQuestGoal");

// Class BattlePrototype.UIMouse
// 0x0040 (0x03C8 - 0x0388)
class UUIMouse : public UUIBase
{
public:
	uint8                                         Pad_2920[0x40];                                    // 0x0388(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetMouseAnimeNone();
	void InitializeAnime(class UWidgetAnimation* Out_focus, class UWidgetAnimation* In_focus, class UWidgetAnimation* Default_focus, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	bool IsFoucus();
	void MouseAnimeNone(bool Flag);
	void SetFoucus();
	void SetUnFoucus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMouse">();
	}
	static class UUIMouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMouse>();
	}
};
static_assert(alignof(UUIMouse) == 0x000008, "Wrong alignment on UUIMouse");
static_assert(sizeof(UUIMouse) == 0x0003C8, "Wrong size on UUIMouse");

// Class BattlePrototype.UINoticeQuest
// 0x0000 (0x0388 - 0x0388)
class UUINoticeQuest : public UUIBase
{
public:
	bool CloseStartBondsQuest(class FName QuestId, float DispTime, bool ManualClose);
	bool CloseStartSubQuest(class FName QuestId, float DispTime, bool ManualClose);
	class FString GetBondsQuestName(class FName QuestId);
	class FString GetSubQuestName(class FName QuestId);
	bool InitializeBondsQuestText(class FName QuestId);
	bool InitializeSubQuestText(class FName QuestId);
	bool OpenStartBondsQuest(class FName QuestId, float DispTime, bool ManualClose);
	bool OpenStartSubQuest(class FName QuestId, float DispTime, bool ManualClose);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINoticeQuest">();
	}
	static class UUINoticeQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINoticeQuest>();
	}
};
static_assert(alignof(UUINoticeQuest) == 0x000008, "Wrong alignment on UUINoticeQuest");
static_assert(sizeof(UUINoticeQuest) == 0x000388, "Wrong size on UUINoticeQuest");

// Class BattlePrototype.UINoticeQuestReward
// 0x00F0 (0x0478 - 0x0388)
class UUINoticeQuestReward : public UUIBase
{
public:
	uint8                                         Pad_2927[0xF0];                                    // 0x0388(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeCategory(class UImage* Category1, class UImage* Category2, class UImage* Category3);
	void InitializeOverlay(class UOverlay* Overlay1, class UOverlay* Overlay2, class UOverlay* Overlay3);
	void InitializeQuestRewardChoiceIndex(int32 Param_Index, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UTextBlock* TextIndex);
	void InitializeRarity(class UImage* Rarity1, class UImage* Rarity2, class UImage* Rarity3);
	bool OpenStartReward(class FName QuestId);
	void SetItemCategoryIcon(class UImage* ImageCategory, EItemIcon Category);
	void SetItemRarity(class UImage* ImageRarity, EItemRarity Rarity);
	bool SetRewardText(class FName QuestId);
	bool UpdateCursor();

	int32 GetQuestRewardResult() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINoticeQuestReward">();
	}
	static class UUINoticeQuestReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINoticeQuestReward>();
	}
};
static_assert(alignof(UUINoticeQuestReward) == 0x000008, "Wrong alignment on UUINoticeQuestReward");
static_assert(sizeof(UUINoticeQuestReward) == 0x000478, "Wrong size on UUINoticeQuestReward");

// Class BattlePrototype.UIParty
// 0x0048 (0x03D0 - 0x0388)
class UUIParty : public UUIBase
{
public:
	struct FVector2D                              RT1_InOut1_Translation;                            // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RT1_Out2_Translation;                              // 0x0390(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_292D[0x20];                                    // 0x0398(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CursorPosMain;                                     // 0x03B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CursorPosSub;                                      // 0x03BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CursorPosLock;                                     // 0x03C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InfoIndex;                                         // 0x03C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InfoLockIndex;                                     // 0x03C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_292E[0x4];                                     // 0x03CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void bonsai10450();
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	void InitializeThis(class UBorder* borderAllColor, class UImage* ImageRT1);
	void PlayContentsIn();
	void PlayContentsOut();
	void PlayContentsOut2();
	void UpdatePartyMouseFocus();
	void UpdateProgramAnimation(float DeltaSeconds);

	bool IsPlayingContentsIn() const;
	bool IsPlayingContentsOut() const;
	bool IsPlayingContentsOut2() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIParty">();
	}
	static class UUIParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIParty>();
	}
};
static_assert(alignof(UUIParty) == 0x000008, "Wrong alignment on UUIParty");
static_assert(sizeof(UUIParty) == 0x0003D0, "Wrong size on UUIParty");
static_assert(offsetof(UUIParty, RT1_InOut1_Translation) == 0x000388, "Member 'UUIParty::RT1_InOut1_Translation' has a wrong offset!");
static_assert(offsetof(UUIParty, RT1_Out2_Translation) == 0x000390, "Member 'UUIParty::RT1_Out2_Translation' has a wrong offset!");
static_assert(offsetof(UUIParty, CursorPosMain) == 0x0003B8, "Member 'UUIParty::CursorPosMain' has a wrong offset!");
static_assert(offsetof(UUIParty, CursorPosSub) == 0x0003BC, "Member 'UUIParty::CursorPosSub' has a wrong offset!");
static_assert(offsetof(UUIParty, CursorPosLock) == 0x0003C0, "Member 'UUIParty::CursorPosLock' has a wrong offset!");
static_assert(offsetof(UUIParty, InfoIndex) == 0x0003C4, "Member 'UUIParty::InfoIndex' has a wrong offset!");
static_assert(offsetof(UUIParty, InfoLockIndex) == 0x0003C8, "Member 'UUIParty::InfoLockIndex' has a wrong offset!");

// Class BattlePrototype.UIPartyCharaInfo
// 0x0010 (0x0398 - 0x0388)
class UUIPartyCharaInfo : public UUIBase
{
public:
	uint8                                         Pad_292F[0x10];                                    // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(const TArray<class UUIBase*>& Charainfolist);
	bool IsCheckMouseCancel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPartyCharaInfo">();
	}
	static class UUIPartyCharaInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPartyCharaInfo>();
	}
};
static_assert(alignof(UUIPartyCharaInfo) == 0x000008, "Wrong alignment on UUIPartyCharaInfo");
static_assert(sizeof(UUIPartyCharaInfo) == 0x000398, "Wrong size on UUIPartyCharaInfo");

// Class BattlePrototype.UIPhotoModeIndexSlider
// 0x0008 (0x0450 - 0x0448)
class UUIPhotoModeIndexSlider : public UUIPhotoModeIndex
{
public:
	uint8                                         Pad_2930[0x8];                                     // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeSlider(class UImage* ImageSlider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPhotoModeIndexSlider">();
	}
	static class UUIPhotoModeIndexSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPhotoModeIndexSlider>();
	}
};
static_assert(alignof(UUIPhotoModeIndexSlider) == 0x000008, "Wrong alignment on UUIPhotoModeIndexSlider");
static_assert(sizeof(UUIPhotoModeIndexSlider) == 0x000450, "Wrong size on UUIPhotoModeIndexSlider");

// Class BattlePrototype.UIPkActionIcon
// 0x0000 (0x0388 - 0x0388)
class UUIPkActionIcon : public UUIBase
{
public:
	EMouseIconType GetMouseIndex(int32 KeyIndex, bool IsEnableMouseMove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPkActionIcon">();
	}
	static class UUIPkActionIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPkActionIcon>();
	}
};
static_assert(alignof(UUIPkActionIcon) == 0x000008, "Wrong alignment on UUIPkActionIcon");
static_assert(sizeof(UUIPkActionIcon) == 0x000388, "Wrong size on UUIPkActionIcon");

// Class BattlePrototype.UIPresent
// 0x0020 (0x03A8 - 0x0388)
class UUIPresent : public UUIBase
{
public:
	EPlayerID                                     M_Target;                                          // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_FlagSelect;                                      // 0x0389(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2932[0x2];                                     // 0x038A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_ItemID;                                          // 0x038C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2933[0x14];                                    // 0x0394(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void backupInputLayout();
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	void RestoreInputLayout();
	void SetTarget(EPlayerID Target);
	void UpdatePresentListMouseFocus();

	class FName GetItemID() const;
	bool GetSelectFlag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPresent">();
	}
	static class UUIPresent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPresent>();
	}
};
static_assert(alignof(UUIPresent) == 0x000008, "Wrong alignment on UUIPresent");
static_assert(sizeof(UUIPresent) == 0x0003A8, "Wrong size on UUIPresent");
static_assert(offsetof(UUIPresent, M_Target) == 0x000388, "Member 'UUIPresent::M_Target' has a wrong offset!");
static_assert(offsetof(UUIPresent, M_FlagSelect) == 0x000389, "Member 'UUIPresent::M_FlagSelect' has a wrong offset!");
static_assert(offsetof(UUIPresent, M_ItemID) == 0x00038C, "Member 'UUIPresent::M_ItemID' has a wrong offset!");

// Class BattlePrototype.UIQuestDetailsBonds
// 0x0048 (0x03D0 - 0x0388)
class UUIQuestDetailsBonds : public UUIBase
{
public:
	uint8                                         Pad_2934[0x48];                                    // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UImage* Image, class UImage* ImageNoise, class UTextBlock* TextTitle, class UREDScrollBoxSimple* ScrollBox, class UUIQuestIcon* UIQuestIcon, class UUIQuestNamePlate* UIQuestNamePlate, class UCanvasPanel* QuestPanel, class UOverlay* OverlayImage);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestDetailsBonds">();
	}
	static class UUIQuestDetailsBonds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestDetailsBonds>();
	}
};
static_assert(alignof(UUIQuestDetailsBonds) == 0x000008, "Wrong alignment on UUIQuestDetailsBonds");
static_assert(sizeof(UUIQuestDetailsBonds) == 0x0003D0, "Wrong size on UUIQuestDetailsBonds");

// Class BattlePrototype.UIQuestListIndex
// 0x01A0 (0x0528 - 0x0388)
class UUIQuestListIndex : public UUIBase
{
public:
	struct FSlateColor                            ActiveColorMain;                                   // 0x0388(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveOutlineColorMain;                            // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            ActiveColorSub;                                    // 0x03C0(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveOutlineColorSub;                             // 0x03E8(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            ActiveColorBonds;                                  // 0x03F8(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveOutlineColorBonds;                           // 0x0420(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            ActiveColorClearGetter;                            // 0x0430(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveOutlineColorClearGetter;                     // 0x0458(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            InactiveColor;                                     // 0x0468(0x0028)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           InactiveOutlineColor;                              // 0x0490(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2935[0x88];                                    // 0x04A0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimDefaultLock, class UWidgetAnimation* AnimSelectLock, class UWidgetAnimation* AnimSelectLockIn, class UImage* ImageNewIcon, class UImage* ImageQuest, class UImage* ImageBlackPattern1, class UImage* ImageBlackPattern2, class UOverlay* OverlayYuito, class UOverlay* OverlayKasane, class UImage* ImageChallenge, class UTextBlock* TextQuestName);
	void SetClearGetterInfo(const class FString& StrTitle, int32 Progress, bool IsNew, bool IsGetReward);
	void SetInfo(EQuestDataType QuestType, const class FName& ID, int32 Progress, int32 Param_Index, bool IsActive);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIQuestListIndex">();
	}
	static class UUIQuestListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIQuestListIndex>();
	}
};
static_assert(alignof(UUIQuestListIndex) == 0x000008, "Wrong alignment on UUIQuestListIndex");
static_assert(sizeof(UUIQuestListIndex) == 0x000528, "Wrong size on UUIQuestListIndex");
static_assert(offsetof(UUIQuestListIndex, ActiveColorMain) == 0x000388, "Member 'UUIQuestListIndex::ActiveColorMain' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveOutlineColorMain) == 0x0003B0, "Member 'UUIQuestListIndex::ActiveOutlineColorMain' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveColorSub) == 0x0003C0, "Member 'UUIQuestListIndex::ActiveColorSub' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveOutlineColorSub) == 0x0003E8, "Member 'UUIQuestListIndex::ActiveOutlineColorSub' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveColorBonds) == 0x0003F8, "Member 'UUIQuestListIndex::ActiveColorBonds' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveOutlineColorBonds) == 0x000420, "Member 'UUIQuestListIndex::ActiveOutlineColorBonds' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveColorClearGetter) == 0x000430, "Member 'UUIQuestListIndex::ActiveColorClearGetter' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, ActiveOutlineColorClearGetter) == 0x000458, "Member 'UUIQuestListIndex::ActiveOutlineColorClearGetter' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, InactiveColor) == 0x000468, "Member 'UUIQuestListIndex::InactiveColor' has a wrong offset!");
static_assert(offsetof(UUIQuestListIndex, InactiveOutlineColor) == 0x000490, "Member 'UUIQuestListIndex::InactiveOutlineColor' has a wrong offset!");

// Class BattlePrototype.UISASActionIcon
// 0x0050 (0x03D8 - 0x0388)
class UUISASActionIcon : public UUIBase
{
public:
	struct FVector2D                              baseOffset;                                        // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isUsable;                                        // 0x0390(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2939[0x7];                                     // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_293A[0x38];                                    // 0x03A0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimIn2, class UWidgetAnimation* AnimOut2, class UWidgetAnimation* AnimSelect);
	void SetIconType(ESASActionIconType Icontype, bool IsUsable);
	void SetOwnerActor(class AActor* Param_OwnerActor);
	void SetUsable(bool IsUsable);
	void SetWorldOffset(const struct FVector& WorldOffset);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsUsable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASActionIcon">();
	}
	static class UUISASActionIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASActionIcon>();
	}
};
static_assert(alignof(UUISASActionIcon) == 0x000008, "Wrong alignment on UUISASActionIcon");
static_assert(sizeof(UUISASActionIcon) == 0x0003D8, "Wrong size on UUISASActionIcon");
static_assert(offsetof(UUISASActionIcon, baseOffset) == 0x000388, "Member 'UUISASActionIcon::baseOffset' has a wrong offset!");
static_assert(offsetof(UUISASActionIcon, M_isUsable) == 0x000390, "Member 'UUISASActionIcon::M_isUsable' has a wrong offset!");
static_assert(offsetof(UUISASActionIcon, OwnerActor) == 0x000398, "Member 'UUISASActionIcon::OwnerActor' has a wrong offset!");

// Class BattlePrototype.UISASFrame2
// 0x0048 (0x03D0 - 0x0388)
class UUISASFrame2 : public UUIBase
{
public:
	uint8                                         Pad_293B[0x48];                                    // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UImage* ImageSasFrame, class UImage* ImageCvFrame, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimFullIn, class UWidgetAnimation* AnimFull, class UWidgetAnimation* AnimFullOut, class UWidgetAnimation* AnimInFull, class UWidgetAnimation* AnimOutFull, class UWidgetAnimation* AnimFullIn2, class UWidgetAnimation* AnimFull2, class UWidgetAnimation* AnimInFull2, class UWidgetAnimation* AnimOutFull2, const struct FLinearColor& ColorDefault, const struct FLinearColor& ColorLockSas, const struct FLinearColor& ColorLockCv);
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASFrame2">();
	}
	static class UUISASFrame2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASFrame2>();
	}
};
static_assert(alignof(UUISASFrame2) == 0x000008, "Wrong alignment on UUISASFrame2");
static_assert(sizeof(UUISASFrame2) == 0x0003D0, "Wrong size on UUISASFrame2");

// Class BattlePrototype.UISASLink
// 0x0038 (0x03C0 - 0x0388)
class UUISASLink : public UUIBase
{
public:
	struct FLinearColor                           ContentsInOutTextColor;                            // 0x0388(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ContentsInOutTextColorMax;                         // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_293C[0x18];                                    // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UOverlay* OverlayAllSet, class UBorder* borderTextBondNum);
	void PlayContentsIn();
	void PlayContentsInMax();
	void PlayContentsOut();
	void PlayContentsOutMax();
	void UpdateProgramAnimation(float DeltaSeconds);

	int32 GetMaxCell() const;
	bool IsPlayingContentsIn() const;
	bool IsPlayingContentsInMax() const;
	bool IsPlayingContentsOut() const;
	bool IsPlayingContentsOutMax() const;
	bool IsPlayingProgramAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASLink">();
	}
	static class UUISASLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASLink>();
	}
};
static_assert(alignof(UUISASLink) == 0x000008, "Wrong alignment on UUISASLink");
static_assert(sizeof(UUISASLink) == 0x0003C0, "Wrong size on UUISASLink");
static_assert(offsetof(UUISASLink, ContentsInOutTextColor) == 0x000388, "Member 'UUISASLink::ContentsInOutTextColor' has a wrong offset!");
static_assert(offsetof(UUISASLink, ContentsInOutTextColorMax) == 0x000398, "Member 'UUISASLink::ContentsInOutTextColorMax' has a wrong offset!");

// Class BattlePrototype.UISASLinkPopup
// 0x0008 (0x0390 - 0x0388)
class UUISASLinkPopup : public UUIBase
{
public:
	uint8                                         Pad_293D[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeScrollBox(class UREDScrollBox* ScrollBox);
	void UpdateSasLinkPopupMouseFocus();

	int32 GetMaxCell() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASLinkPopup">();
	}
	static class UUISASLinkPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASLinkPopup>();
	}
};
static_assert(alignof(UUISASLinkPopup) == 0x000008, "Wrong alignment on UUISASLinkPopup");
static_assert(sizeof(UUISASLinkPopup) == 0x000390, "Wrong size on UUISASLinkPopup");

// Class BattlePrototype.UISASMenuControl
// 0x0018 (0x03A0 - 0x0388)
class UUISASMenuControl : public UUIBase
{
public:
	uint8                                         Pad_293E[0x18];                                    // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BgSetVisible(bool Param_IsVisible, float Speed);
	void BgUpdate(float DeltaSeconds);
	void GetSasKey(ESasKeyType Type, class FName* KeyName, class FName* KeyName2);
	void SetBg(class UImage* PImage);

	bool BgIsUpdate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISASMenuControl">();
	}
	static class UUISASMenuControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISASMenuControl>();
	}
};
static_assert(alignof(UUISASMenuControl) == 0x000008, "Wrong alignment on UUISASMenuControl");
static_assert(sizeof(UUISASMenuControl) == 0x0003A0, "Wrong size on UUISASMenuControl");

// Class BattlePrototype.UISaveLoadChoice
// 0x00F8 (0x0480 - 0x0388)
class UUISaveLoadChoice : public UUIBase
{
public:
	uint8                                         Pad_2941[0xF8];                                    // 0x0388(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeSaveLoadSelectIndex(int32 Param_Index, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UTextBlock* TextIndex);
	void InitializeText(class UTextBlock* TextTitle, class UTextBlock* TextMain, class UVerticalBox* TextVerticalBox, class UOverlay* GuideOverlay);
	bool StartSaveLoadChoice(const class FString& TextTitle, const class FString& TextMain, int32 DefaultIndex, const class FString& TextIndex1, const class FString& TextIndex2, int32 TextNum, bool Cancelable, int32 CancelIndex);
	void UpdateStateSaveLoadChoice(int32 State, int32 SubState, float DeltaSeconds);

	int32 GetResult() const;
	bool GetResultAct() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoadChoice">();
	}
	static class UUISaveLoadChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoadChoice>();
	}
};
static_assert(alignof(UUISaveLoadChoice) == 0x000008, "Wrong alignment on UUISaveLoadChoice");
static_assert(sizeof(UUISaveLoadChoice) == 0x000480, "Wrong size on UUISaveLoadChoice");

// Class BattlePrototype.UISaveLoadList
// 0x0200 (0x0588 - 0x0388)
class UUISaveLoadList : public UUIBase
{
public:
	ESaveLoadListType                             M_SaveLoadListType;                                // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2946[0x1FF];                                   // 0x0389(0x01FF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESaveLoadListType GetSaveDataType();
	void InitializeDataBreakListAnime(class UWidgetAnimation* Decide, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeDataExLoadAnime(class UWidgetAnimation* Decide, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeListAnime(class UWidgetAnimation* Decide, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeListClear(class UOverlay* Clear_01, class UOverlay* Clear_02, class UTextBlock* Textclear_01, class UTextBlock* Textclear_02);
	void InitializeListText(class UImage* ImageScreen, class UTextBlock* TextChapter, class UTextBlock* TextChapterTitle, class UTextBlock* TextInfo, class UTextBlock* TextPlLv, class UTextBlock* PlLvNum, class UTextBlock* PlName, class UTextBlock* TextDayFixTime, class UTextBlock* TextPlEx, class UImage* ImagePlEx, class UTextBlock* TextSlash, class UTextBlock* TextSaveType);
	void InitializeListTextCommon(class UImage* ImageLine, class UImage* ImageClearIcon, class UTextBlock* TextDay1, class UTextBlock* TextDay2, class UTextBlock* TextTime1, class UTextBlock* TextTime2);
	void InitializeListTextTime(class UTextBlock* TextDayTime, class UTextBlock* TextDayhh, class UTextBlock* TextDaymm, class UTextBlock* TextDayss, class UTextBlock* TextTimehh, class UTextBlock* TextTimemm, class UTextBlock* TextTimess);
	void InitializeNoDataListAnime(class UWidgetAnimation* Decide, class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Select, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	bool SetDataFontOutLineColor(ESaveLoadListType DataType, class UTextBlock* Text);
	bool SetFontColor(ESaveLoadListClearType DataType, class UTextBlock* Text);
	bool SetLevelFontColor(bool LevelMax);
	void SetScreenTexture(int32 ImageType, class UTexture2D* ImageData);
	bool SetTitleFontOutLineColor(ESaveLoadListType DataType, class UTextBlock* Text);
	void UpdateStateSaveLoadList(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISaveLoadList">();
	}
	static class UUISaveLoadList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISaveLoadList>();
	}
};
static_assert(alignof(UUISaveLoadList) == 0x000008, "Wrong alignment on UUISaveLoadList");
static_assert(sizeof(UUISaveLoadList) == 0x000588, "Wrong size on UUISaveLoadList");
static_assert(offsetof(UUISaveLoadList, M_SaveLoadListType) == 0x000388, "Member 'UUISaveLoadList::M_SaveLoadListType' has a wrong offset!");

// Class BattlePrototype.UIScarletLogo
// 0x0058 (0x03E0 - 0x0388)
class UUIScarletLogo : public UUIBase
{
public:
	uint8                                         Pad_294E[0x58];                                    // 0x0388(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_, class UWidgetAnimation* Out_title, class UWidgetAnimation* In_title, class UWidgetAnimation* Default_title);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScarletLogo">();
	}
	static class UUIScarletLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScarletLogo>();
	}
};
static_assert(alignof(UUIScarletLogo) == 0x000008, "Wrong alignment on UUIScarletLogo");
static_assert(sizeof(UUIScarletLogo) == 0x0003E0, "Wrong size on UUIScarletLogo");

// Class BattlePrototype.UIShop3DManager
// 0x0000 (0x0230 - 0x0230)
class AUIShop3DManager : public AActor
{
public:
	bool End();
	bool Start();

	bool IsWaitStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShop3DManager">();
	}
	static class AUIShop3DManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIShop3DManager>();
	}
};
static_assert(alignof(AUIShop3DManager) == 0x000008, "Wrong alignment on AUIShop3DManager");
static_assert(sizeof(AUIShop3DManager) == 0x000230, "Wrong size on AUIShop3DManager");

// Class BattlePrototype.UIShopChoice
// 0x00F8 (0x0480 - 0x0388)
class UUIShopChoice : public UUIBase
{
public:
	uint8                                         Pad_294F[0xF8];                                    // 0x0388(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeIndex(int32 Param_Index, class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimBuySellTransfer, class UTextBlock* TextWindowTitle, class UTextBlock* TextMain, class UVerticalBox* MultiGroupParent, class UVerticalBox* ChoiceSet, class UOverlay* GoldSet, class UUIShopPayment* ChildShopPayment, class UUIShopTransfer* ChildShopTransfer, class UOverlay* GuideSet);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopChoice">();
	}
	static class UUIShopChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopChoice>();
	}
};
static_assert(alignof(UUIShopChoice) == 0x000008, "Wrong alignment on UUIShopChoice");
static_assert(sizeof(UUIShopChoice) == 0x000480, "Wrong size on UUIShopChoice");

// Class BattlePrototype.UIShopGetContents
// 0x00B8 (0x0440 - 0x0388)
class UUIShopGetContents : public UUIBase
{
public:
	struct FVector2D                              ListElementSizeMain;                               // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ListOffsetSizeMain;                                // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2951[0x4];                                     // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ListIndexClassMain;                                // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUIShopGetSubListIndex>     M_pSubItemClass;                                   // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2952[0x40];                                    // 0x03A8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIShopGetSubListIndex*>         M_uiSubItemList;                                   // 0x03E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2953[0x38];                                    // 0x03F8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class URSSaveGame*                            M_pSaveSystem;                                     // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USaveLoadScreenParamManager*            M_pSaveLoadSystemParamManager;                     // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeFromShop(class UUIShop* UIShop, class UUIShopChoice* UiChoice);
	void InitializeThis(class UREDScrollBox* ScrollBoxMain, class UREDScrollBoxSimple* ScrollBoxSub, class UUIShopGetSubListIndex* UiSubListIndex, class UTextBlock* TextListTitle, class UImage* ImageSubBaseLine, class USpacer* SpacerDescription);
	void ListFocus(class UUserWidget* Widget);
	void ListFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUnFocus(class UUserWidget* Widget);
	void ListUnFocusMouse(int32 IsMouseScroll, int32 Param_Index, class UUserWidget* Widget);
	void ListUpdateElement(int32 Param_Index, class UUserWidget* Widget);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopGetContents">();
	}
	static class UUIShopGetContents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopGetContents>();
	}
};
static_assert(alignof(UUIShopGetContents) == 0x000008, "Wrong alignment on UUIShopGetContents");
static_assert(sizeof(UUIShopGetContents) == 0x000440, "Wrong size on UUIShopGetContents");
static_assert(offsetof(UUIShopGetContents, ListElementSizeMain) == 0x000388, "Member 'UUIShopGetContents::ListElementSizeMain' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, ListOffsetSizeMain) == 0x000390, "Member 'UUIShopGetContents::ListOffsetSizeMain' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, ListIndexClassMain) == 0x000398, "Member 'UUIShopGetContents::ListIndexClassMain' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, M_pSubItemClass) == 0x0003A0, "Member 'UUIShopGetContents::M_pSubItemClass' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, M_uiSubItemList) == 0x0003E8, "Member 'UUIShopGetContents::M_uiSubItemList' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, M_pSaveSystem) == 0x000430, "Member 'UUIShopGetContents::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(UUIShopGetContents, M_pSaveLoadSystemParamManager) == 0x000438, "Member 'UUIShopGetContents::M_pSaveLoadSystemParamManager' has a wrong offset!");

// Class BattlePrototype.UIShopGetSubListIndex
// 0x0048 (0x03D0 - 0x0388)
class UUIShopGetSubListIndex : public UUIBase
{
public:
	uint8                                         Pad_2955[0x48];                                    // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultMax, class UTextBlock* TextItemName, class UImage* ImageCross, class UTextBlock* TextGetNum, class UOverlay* OverlayNumSet, class UTextBlock* TextNumSum, class UTextBlock* TextNumSlash, class UTextBlock* TextNumMax);
	void SetBondsIcon();
	void SetItemIcon(const class FName& ItemId);
	void SetQuestIcon();
	void UpdateStateThis(int32 State, int32 SubState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopGetSubListIndex">();
	}
	static class UUIShopGetSubListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopGetSubListIndex>();
	}
};
static_assert(alignof(UUIShopGetSubListIndex) == 0x000008, "Wrong alignment on UUIShopGetSubListIndex");
static_assert(sizeof(UUIShopGetSubListIndex) == 0x0003D0, "Wrong size on UUIShopGetSubListIndex");

// Class BattlePrototype.UIShopItemDetails
// 0x0070 (0x03F8 - 0x0388)
class UUIShopItemDetails : public UUIBase
{
public:
	uint8                                         Pad_2956[0x70];                                    // 0x0388(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearItemInfo();
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefaultMax, class UWidgetAnimation* AnimDefaultNoSet, class UImage* ImageNewIcon, class UImage* ImageItemIcon, class UImage* ImageRarityFrame, class UTextBlock* TextItemName, class UTextBlock* TextParameter, class UTextBlock* TextItemDescription, class UTextBlock* TextHave, class UTextBlock* TextItemHaveNum, class UTextBlock* TextItemMaxNum, class UTextBlock* TextItemNumSlash);
	bool SetItemInfo(const class FName& ItemId);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopItemDetails">();
	}
	static class UUIShopItemDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopItemDetails>();
	}
};
static_assert(alignof(UUIShopItemDetails) == 0x000008, "Wrong alignment on UUIShopItemDetails");
static_assert(sizeof(UUIShopItemDetails) == 0x0003F8, "Wrong size on UUIShopItemDetails");

// Class BattlePrototype.UIShopListIndex
// 0x00E8 (0x0470 - 0x0388)
class UUIShopListIndex : public UUIBase
{
public:
	struct FLinearColor                           ColorNumHave;                                      // 0x0388(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorMaxNumHave;                                   // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2958[0xC8];                                    // 0x03A8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UImage* ImageNewIcon, class UTextBlock* TextItemName, class UTextBlock* TextNumHave, class UTextBlock* TextNumPrice, class UTextBlock* TextNumBuySell);
	bool SetItemInfo(const class FName& ItemId, int32 ItemIndex);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopListIndex">();
	}
	static class UUIShopListIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopListIndex>();
	}
};
static_assert(alignof(UUIShopListIndex) == 0x000008, "Wrong alignment on UUIShopListIndex");
static_assert(sizeof(UUIShopListIndex) == 0x000470, "Wrong size on UUIShopListIndex");
static_assert(offsetof(UUIShopListIndex, ColorNumHave) == 0x000388, "Member 'UUIShopListIndex::ColorNumHave' has a wrong offset!");
static_assert(offsetof(UUIShopListIndex, ColorMaxNumHave) == 0x000398, "Member 'UUIShopListIndex::ColorMaxNumHave' has a wrong offset!");

// Class BattlePrototype.UIShopPayment
// 0x0048 (0x03D0 - 0x0388)
class UUIShopPayment : public UUIBase
{
public:
	uint8                                         Pad_295B[0x48];                                    // 0x0388(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimDefault2, class UWidgetAnimation* AnimDefault3, class UTextBlock* TextMoneyInHand, class UTextBlock* TextMoneyAfter, class UTextBlock* TextSubtotal, class UTextBlock* TextNumMoneyInHand, class UTextBlock* TextNumMoneyAfter, class UTextBlock* TextNumSubtotal);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIShopPayment">();
	}
	static class UUIShopPayment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIShopPayment>();
	}
};
static_assert(alignof(UUIShopPayment) == 0x000008, "Wrong alignment on UUIShopPayment");
static_assert(sizeof(UUIShopPayment) == 0x0003D0, "Wrong size on UUIShopPayment");

// Class BattlePrototype.UITips
// 0x00C0 (0x0448 - 0x0388)
class UUITips : public UUIBase
{
public:
	uint8                                         Pad_295C[0xC0];                                    // 0x0388(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeAnime(class UWidgetAnimation* Out, class UWidgetAnimation* In, class UWidgetAnimation* Default_none, class UWidgetAnimation* Default_);
	void InitializeArrow(int32 Param_Index, class UUIHelpParts* Arrow);
	void InitializeTips(class UUIGuide* UGuide, class UTextBlock* TextGuide, class UUITutoTipsParts* Ututotipsdata, class UImage* ImageFade);
	bool SetupTextSize();
	void Start(EHelpTutorial HelpID, bool NotPauseControll, bool NotCloseOfPause, bool IsFade);
	void UpdateStateTips(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITips">();
	}
	static class UUITips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITips>();
	}
};
static_assert(alignof(UUITips) == 0x000008, "Wrong alignment on UUITips");
static_assert(sizeof(UUITips) == 0x000448, "Wrong size on UUITips");

// Class BattlePrototype.UITitleCrossSave_UpdatingWidget
// 0x0030 (0x03B8 - 0x0388)
class UUITitleCrossSave_UpdatingWidget : public UUIBase
{
public:
	uint8                                         Pad_295E[0x30];                                    // 0x0388(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimNoneDefault);
	void SetLoadingColor(const struct FLinearColor& Color);
	void UpdateLoadingMaterial();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleCrossSave_UpdatingWidget">();
	}
	static class UUITitleCrossSave_UpdatingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleCrossSave_UpdatingWidget>();
	}
};
static_assert(alignof(UUITitleCrossSave_UpdatingWidget) == 0x000008, "Wrong alignment on UUITitleCrossSave_UpdatingWidget");
static_assert(sizeof(UUITitleCrossSave_UpdatingWidget) == 0x0003B8, "Wrong size on UUITitleCrossSave_UpdatingWidget");

// Class BattlePrototype.UITitleFirstConfigBrightness
// 0x0118 (0x04A0 - 0x0388)
class UUITitleFirstConfigBrightness final : public UUIBase
{
public:
	int32                                         MinX;                                              // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxX;                                              // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_295F[0x110];                                   // 0x0390(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBrightness(float FValue);
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageSlider, class UTextBlock* TextTopDescription, class UTextBlock* TextBottomDescription, class UREDOverlay* Gauge_set, class USpacer* GuideSpacer);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsBack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfigBrightness">();
	}
	static class UUITitleFirstConfigBrightness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfigBrightness>();
	}
};
static_assert(alignof(UUITitleFirstConfigBrightness) == 0x000008, "Wrong alignment on UUITitleFirstConfigBrightness");
static_assert(sizeof(UUITitleFirstConfigBrightness) == 0x0004A0, "Wrong size on UUITitleFirstConfigBrightness");
static_assert(offsetof(UUITitleFirstConfigBrightness, MinX) == 0x000388, "Member 'UUITitleFirstConfigBrightness::MinX' has a wrong offset!");
static_assert(offsetof(UUITitleFirstConfigBrightness, MaxX) == 0x00038C, "Member 'UUITitleFirstConfigBrightness::MaxX' has a wrong offset!");

// Class BattlePrototype.UITitleFirstConfigDifficulty
// 0x0100 (0x0488 - 0x0388)
class UUITitleFirstConfigDifficulty final : public UUIBase
{
public:
	uint8                                         Pad_2961[0xF0];                                    // 0x0388(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSTitleManager*                        TitleManager;                                      // 0x0478(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2962[0x8];                                     // 0x0480(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UTextBlock* TextDescription, class UTextBlock* TextDifficulty, class USpacer* GuideSpacer);
	void SetTitleManager(class ARSTitleManager* Param_TitleManager);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

	bool IsBack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfigDifficulty">();
	}
	static class UUITitleFirstConfigDifficulty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfigDifficulty>();
	}
};
static_assert(alignof(UUITitleFirstConfigDifficulty) == 0x000008, "Wrong alignment on UUITitleFirstConfigDifficulty");
static_assert(sizeof(UUITitleFirstConfigDifficulty) == 0x000488, "Wrong size on UUITitleFirstConfigDifficulty");
static_assert(offsetof(UUITitleFirstConfigDifficulty, TitleManager) == 0x000478, "Member 'UUITitleFirstConfigDifficulty::TitleManager' has a wrong offset!");

// Class BattlePrototype.UITitleFirstConfirm
// 0x0060 (0x03E8 - 0x0388)
class UUITitleFirstConfirm final : public UUIBase
{
public:
	uint8                                         Pad_2964[0x60];                                    // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UUITitleFirstConfirmChildImage* ChildImage1, class UUITitleFirstConfirmChildImage* ChildImage2, class UUITitleFirstConfirmChildText* ChildText, class UUIGuide* UIGuide);
	void SetCeBank(bool Value);
	void SetTitleManager(class ARSTitleManager* TitleManager);
	void StartAnalytics();
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirm">();
	}
	static class UUITitleFirstConfirm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirm>();
	}
};
static_assert(alignof(UUITitleFirstConfirm) == 0x000008, "Wrong alignment on UUITitleFirstConfirm");
static_assert(sizeof(UUITitleFirstConfirm) == 0x0003E8, "Wrong size on UUITitleFirstConfirm");

// Class BattlePrototype.UITitleFirstConfirmSelect2
// 0x0130 (0x04B8 - 0x0388)
class UUITitleFirstConfirmSelect2 final : public UUIBase
{
public:
	uint8                                         Pad_2965[0x130];                                   // 0x0388(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(int32 Param_Index, class UUserWidget* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UWidgetAnimation* AnimEnable, class UWidgetAnimation* AnimEnableIn, class UWidgetAnimation* AnimEnableOut, class UREDTextBlock* TextIndex);
	void InitializeThis();
	void UpdateStateThis(int32 State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstConfirmSelect2">();
	}
	static class UUITitleFirstConfirmSelect2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstConfirmSelect2>();
	}
};
static_assert(alignof(UUITitleFirstConfirmSelect2) == 0x000008, "Wrong alignment on UUITitleFirstConfirmSelect2");
static_assert(sizeof(UUITitleFirstConfirmSelect2) == 0x0004B8, "Wrong size on UUITitleFirstConfirmSelect2");

// Class BattlePrototype.UITitleFirstLangaugeChange
// 0x00F8 (0x0480 - 0x0388)
class UUITitleFirstLangaugeChange final : public UUIBase
{
public:
	uint8                                         Pad_2968[0xF8];                                    // 0x0388(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeArrowLR(bool IsRight, class UREDHorizonFlipbookWidget* Widget, class UPaperFlipbook* DefaultPF, class UPaperFlipbook* SelectPF, class UPaperFlipbook* SelectInPF, class UPaperFlipbook* SelectOutPF, class UPaperFlipbook* DecisionPF);
	void InitializeIndex(class UUIBase* Widget, class UWidgetAnimation* AnimDefault, class UWidgetAnimation* AnimSelect, class UWidgetAnimation* AnimSelectIn, class UWidgetAnimation* AnimSelectOut, class UWidgetAnimation* AnimDecision, class UREDTextBlock* TextIndex);
	void InitializeThis(class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UWidgetAnimation* AnimDefault, class UREDTextBlock* TextMain, class UREDTextBlock* TextLangauge);
	void SetTitleManager(class ARSTitleManager* TitleManager);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITitleFirstLangaugeChange">();
	}
	static class UUITitleFirstLangaugeChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITitleFirstLangaugeChange>();
	}
};
static_assert(alignof(UUITitleFirstLangaugeChange) == 0x000008, "Wrong alignment on UUITitleFirstLangaugeChange");
static_assert(sizeof(UUITitleFirstLangaugeChange) == 0x000480, "Wrong size on UUITitleFirstLangaugeChange");

// Class BattlePrototype.UITutoOperationParts
// 0x0008 (0x0390 - 0x0388)
class UUITutoOperationParts : public UUIBase
{
public:
	uint8                                         Pad_296A[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeSpacer(class USpacer* Spacer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutoOperationParts">();
	}
	static class UUITutoOperationParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutoOperationParts>();
	}
};
static_assert(alignof(UUITutoOperationParts) == 0x000008, "Wrong alignment on UUITutoOperationParts");
static_assert(sizeof(UUITutoOperationParts) == 0x000390, "Wrong size on UUITutoOperationParts");

// Class BattlePrototype.UITutoTipsParts
// 0x00C8 (0x0450 - 0x0388)
class UUITutoTipsParts : public UUIBase
{
public:
	bool                                          bMovieStopFlag;                                    // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHelpImageType                                ImageType;                                         // 0x0389(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_296B[0x6];                                     // 0x038A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Pathname;                                          // 0x0390(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Load;                                              // 0x03A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Failure;                                           // 0x03A1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_296C[0x2];                                     // 0x03A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PathData;                                          // 0x03A4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETutoMoviePlayType                            PlaySelect;                                        // 0x03AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_296D[0x53];                                    // 0x03AD(0x0053)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UTexture2D*, int32>                ReleaseTipsTextures;                               // 0x0400(0x0050)(NativeAccessSpecifierPrivate)

public:
	void InitializeAnime(class UWidgetAnimation* Default1_, class UWidgetAnimation* Default2_, class UWidgetAnimation* Default_none);
	void InitializeArrow(int32 Param_Index, class UUIHelpParts* Arrow);
	bool InitializeMovie();
	void InitializeText(class UTextBlock* TextTitle, class UTextBlock* TextMain, class UTextBlock* TextPage1, class UTextBlock* TextPage2, class UTextBlock* TextSlash);
	bool IsLoad();
	bool IsLoadFailure();
	bool IsMovieStop();
	bool IsPlayMovie();
	class UTexture2D* LoadTipsTexture(const class FString& Path);
	void SetImageType(const class FString& Param_Pathname, EHelpImageType Param_ImageType);
	void SetPageText(const class FString& MainText, const class FString& TitleText, int32 PageNo, int32 PageMax);
	void SetVisiblePageUI(bool Flag);
	void StopMovieForce();
	void TextureRelease();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITutoTipsParts">();
	}
	static class UUITutoTipsParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITutoTipsParts>();
	}
};
static_assert(alignof(UUITutoTipsParts) == 0x000008, "Wrong alignment on UUITutoTipsParts");
static_assert(sizeof(UUITutoTipsParts) == 0x000450, "Wrong size on UUITutoTipsParts");
static_assert(offsetof(UUITutoTipsParts, bMovieStopFlag) == 0x000388, "Member 'UUITutoTipsParts::bMovieStopFlag' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, ImageType) == 0x000389, "Member 'UUITutoTipsParts::ImageType' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, Pathname) == 0x000390, "Member 'UUITutoTipsParts::Pathname' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, Load) == 0x0003A0, "Member 'UUITutoTipsParts::Load' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, Failure) == 0x0003A1, "Member 'UUITutoTipsParts::Failure' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, PathData) == 0x0003A4, "Member 'UUITutoTipsParts::PathData' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, PlaySelect) == 0x0003AC, "Member 'UUITutoTipsParts::PlaySelect' has a wrong offset!");
static_assert(offsetof(UUITutoTipsParts, ReleaseTipsTextures) == 0x000400, "Member 'UUITutoTipsParts::ReleaseTipsTextures' has a wrong offset!");

// Class BattlePrototype.UIVitalityEN02
// 0x0060 (0x0448 - 0x03E8)
class UUIVitalityEN02 : public UUIHealthControl
{
public:
	uint8                                         Pad_2970[0x48];                                    // 0x03E8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIBrainCrashGauge*                     BrainCrashGauge;                                   // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BrainCrashGaugeDrawFlag;                           // 0x0438(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2971[0xF];                                     // 0x0439(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeThis(class UWidgetAnimation* AnimDefaultNone, class UWidgetAnimation* AnimDefault01, class UWidgetAnimation* AnimDefault02, class UWidgetAnimation* AnimDefault03, class UWidgetAnimation* AnimDefault04, class UWidgetAnimation* AnimDefault05, class UWidgetAnimation* AnimIn, class UWidgetAnimation* AnimOut, class UImage* ImageIcon1, class UImage* ImageIcon2, class UImage* ImageIcon3, class UImage* ImageIcon4, class UImage* ImageIcon5, class UImage* ImageBarNormal, class UImage* ImageBarOverride, class UImage* ImageBarAdd, class UTextBlock* TextEnemyName);
	void SetLevel(int32 Level);
	void SetSubQuestTarget(class FName Param_Name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityEN02">();
	}
	static class UUIVitalityEN02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityEN02>();
	}
};
static_assert(alignof(UUIVitalityEN02) == 0x000008, "Wrong alignment on UUIVitalityEN02");
static_assert(sizeof(UUIVitalityEN02) == 0x000448, "Wrong size on UUIVitalityEN02");
static_assert(offsetof(UUIVitalityEN02, BrainCrashGauge) == 0x000430, "Member 'UUIVitalityEN02::BrainCrashGauge' has a wrong offset!");
static_assert(offsetof(UUIVitalityEN02, BrainCrashGaugeDrawFlag) == 0x000438, "Member 'UUIVitalityEN02::BrainCrashGaugeDrawFlag' has a wrong offset!");

// Class BattlePrototype.UIVitalityPL01
// 0x0000 (0x0468 - 0x0468)
class UUIVitalityPL01 : public UUIVitalityPLBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityPL01">();
	}
	static class UUIVitalityPL01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityPL01>();
	}
};
static_assert(alignof(UUIVitalityPL01) == 0x000008, "Wrong alignment on UUIVitalityPL01");
static_assert(sizeof(UUIVitalityPL01) == 0x000468, "Wrong size on UUIVitalityPL01");

// Class BattlePrototype.UIVitalityPL03
// 0x0000 (0x0468 - 0x0468)
class UUIVitalityPL03 : public UUIVitalityPLBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVitalityPL03">();
	}
	static class UUIVitalityPL03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVitalityPL03>();
	}
};
static_assert(alignof(UUIVitalityPL03) == 0x000008, "Wrong alignment on UUIVitalityPL03");
static_assert(sizeof(UUIVitalityPL03) == 0x000468, "Wrong size on UUIVitalityPL03");

// Class BattlePrototype.CharacterVitalityDataAsset
// 0x0030 (0x0060 - 0x0030)
class UCharacterVitalityDataAsset final : public UDataAsset
{
public:
	float                                         OccurrenceSlowSpeed;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayTimeBeforeNextWave;                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllWaveDeleteTime;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterWaveRandomRangeMin;                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterWaveRandomRangeMax;                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SideWaveRandomRangeMin;                            // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SideWaveRandomRangeMax;                            // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterWaveRandomRightMoveRange;                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterWaveRandomLeftMoveRange;                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SideWaveRandomMinMoveRange;                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SideWaveRandomMaxMoveRange;                        // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialGapBaseValue;                               // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterVitalityDataAsset">();
	}
	static class UCharacterVitalityDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterVitalityDataAsset>();
	}
};
static_assert(alignof(UCharacterVitalityDataAsset) == 0x000008, "Wrong alignment on UCharacterVitalityDataAsset");
static_assert(sizeof(UCharacterVitalityDataAsset) == 0x000060, "Wrong size on UCharacterVitalityDataAsset");
static_assert(offsetof(UCharacterVitalityDataAsset, OccurrenceSlowSpeed) == 0x000030, "Member 'UCharacterVitalityDataAsset::OccurrenceSlowSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, DelayTimeBeforeNextWave) == 0x000034, "Member 'UCharacterVitalityDataAsset::DelayTimeBeforeNextWave' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, AllWaveDeleteTime) == 0x000038, "Member 'UCharacterVitalityDataAsset::AllWaveDeleteTime' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, CenterWaveRandomRangeMin) == 0x00003C, "Member 'UCharacterVitalityDataAsset::CenterWaveRandomRangeMin' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, CenterWaveRandomRangeMax) == 0x000040, "Member 'UCharacterVitalityDataAsset::CenterWaveRandomRangeMax' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SideWaveRandomRangeMin) == 0x000044, "Member 'UCharacterVitalityDataAsset::SideWaveRandomRangeMin' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SideWaveRandomRangeMax) == 0x000048, "Member 'UCharacterVitalityDataAsset::SideWaveRandomRangeMax' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, CenterWaveRandomRightMoveRange) == 0x00004C, "Member 'UCharacterVitalityDataAsset::CenterWaveRandomRightMoveRange' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, CenterWaveRandomLeftMoveRange) == 0x000050, "Member 'UCharacterVitalityDataAsset::CenterWaveRandomLeftMoveRange' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SideWaveRandomMinMoveRange) == 0x000054, "Member 'UCharacterVitalityDataAsset::SideWaveRandomMinMoveRange' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SideWaveRandomMaxMoveRange) == 0x000058, "Member 'UCharacterVitalityDataAsset::SideWaveRandomMaxMoveRange' has a wrong offset!");
static_assert(offsetof(UCharacterVitalityDataAsset, SpecialGapBaseValue) == 0x00005C, "Member 'UCharacterVitalityDataAsset::SpecialGapBaseValue' has a wrong offset!");

// Class BattlePrototype.UIWishList
// 0x0018 (0x03A0 - 0x0388)
class UUIWishList : public UUIBase
{
public:
	uint8                                         Pad_2972[0x18];                                    // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseWishList();
	void InitializeCommonParts(class UTextBlock* TextHelp, class UUIGuide* UiKeyGuide);
	void InitializeThis(class UUIItemTrade* UiTrade, class UUIShopItemDetails* UiItemDetail, class UUIShopPartyStatus* UiPartyStatus);
	void UpdateStateThis(int32 State, int32 SubState, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIWishList">();
	}
	static class UUIWishList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIWishList>();
	}
};
static_assert(alignof(UUIWishList) == 0x000008, "Wrong alignment on UUIWishList");
static_assert(sizeof(UUIWishList) == 0x0003A0, "Wrong size on UUIWishList");

// Class BattlePrototype.UserDataAccessor
// 0x0020 (0x0048 - 0x0028)
class UUserDataAccessor final : public UObject
{
public:
	struct FUserData                              UserData;                                          // 0x0028(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserDataAccessor">();
	}
	static class UUserDataAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserDataAccessor>();
	}
};
static_assert(alignof(UUserDataAccessor) == 0x000008, "Wrong alignment on UUserDataAccessor");
static_assert(sizeof(UUserDataAccessor) == 0x000048, "Wrong size on UUserDataAccessor");
static_assert(offsetof(UUserDataAccessor, UserData) == 0x000028, "Member 'UUserDataAccessor::UserData' has a wrong offset!");

// Class BattlePrototype.UserParamManager
// 0x0680 (0x06A8 - 0x0028)
class UUserParamManager final : public UObject
{
public:
	uint8                                         Pad_2973[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserParam                             M_userParam;                                       // 0x0038(0x0458)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
	class UCharactersParameterManager*            M_pCharaParamManage;                               // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorldmapOpenParam*                     M_worldmapOpenParamM;                              // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorldmapOpenParam*                     M_worldmapOpenParamF;                              // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      M_transObjMap;                                     // 0x04A8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_tradeWishList;                                   // 0x04F8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuestParamManager*                     M_questParamManager;                               // 0x0508(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrainMessageParamManager*              M_brainMessageParamManager;                        // 0x0510(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULoadTipsParamManager*                  M_loadingTipsParamManager;                         // 0x0518(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOptionParam*                           M_optionParam;                                     // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPurposeMessageParamManager*            M_purposeMessageParamManager;                      // 0x0528(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryEnemyParam*                     M_libraryEnemyParam;                               // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULibraryCharacterParam*                 M_libraryCharaParam;                               // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUserSystemParam                       M_UserSystemParam;                                 // 0x0540(0x0006)(Edit, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2974[0x2];                                     // 0x0546(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UPresentInfoParam*                      M_presentInfoParam;                                // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTipsCountParamManager*                 M_tipsCountParamManager;                           // 0x0550(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeepenTheBondsParamManager*            M_deepenTheBondsParamManager;                      // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_seenAjitoPatternList;                            // 0x0560(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBattleLogBuffer*                       M_battleLogBuffer;                                 // 0x0570(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_AllAddContentsNameList;                          // 0x0578(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_AppliedAddContentsNameList;                      // 0x0588(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_NotifiedNotAppliedAddContentsNameList;           // 0x0598(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_BrainTalkBt_ReturnToTheAjito_BeforePlayTime;     // 0x05A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_BrainTalkBt_GiveItemsFromFriendsWithAjito_BeforePlayTime; // 0x05AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_BrainTalkBt_GiveItemsFromFriendsWithField_BeforePlayTime; // 0x05B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2975[0xC];                                     // 0x05B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUserItemInfo>                  M_mapUsableItemList;                               // 0x05C0(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_isForceNewGameFlowFlag;                          // 0x05D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2976[0x17];                                    // 0x05D1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_PurchasedAddContentNameList;                     // 0x05E8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             bondsProgressEvent;                                // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             bondsLevelEvent;                                   // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SasEquipExtendEvent;                               // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SasEquipEvent;                                     // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             SasEquipStatusEvent;                               // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             WmSelectableChangeEvent;                           // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2977[0x8];                                     // 0x0658(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartBondsEpisodeEvent;                          // 0x0660(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndBondsEpisodeEvent;                            // 0x0670(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeNoticeUiStateDelegate;                     // 0x0680(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeNoticeUiStateRemoveDelegate;               // 0x0690(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2978[0x8];                                     // 0x06A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBondsFValue(EPlayerID PlayerId, EPlayerID TargetID, float Value);
	void AddBondsValue(EPlayerID PlayerId, EPlayerID TargetID, int32 Value);
	void AddBrainTalkOnceCheck_InSaveData(const EBrainTalkCategory _Category, const class FName _ID);
	void AddClearLapNum();
	bool AddItemNum(const class FName& ID, const int32 Num, const bool IsUpdateMapUsableItemList_NotUsed, const bool IsDispGetLog, const bool IsLogLongDraw);
	void AddJewelTicketCount(int32 AddCount);
	void AddLibraryEnemyFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void AddLibraryEpisodeFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void AddLibraryTerminologyFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	bool AddMoney(const int32 Value);
	void AddNotifiedNotAppliedAddContentsNameList(class FName AddName);
	void AddSkillPoint(int32 Point);
	void AddTotalSuspendPauseTime(const int32 AddTime);
	bool AddWishList(int32 Content);
	void AppendAppliedAddContentsNameList(class FName AddContentName);
	bool CheckBondsLevelUp(EPlayerID PlayerId, EPlayerID TargetID);
	bool CheckHaveItemCapacity(const class FName& ID, const int32 Num);
	bool CheckHaveItemCapacityWithRetNum(const class FName& ID, const int32 Num, ECanBeAddedItems* CanBeAdded, int32* RetNum);
	bool CheckStartTeamBondsEpisode(EPlayerID PlayerId, int32* EpisodeNo);
	bool CheckTeamBondsLevelUp(EPlayerID PlayerId, int32 ProgressNo);
	void ClearMoneyDirty();
	void ClearWorldmapOpenParamAllFromSelectSenario();
	void DeleteItemAll();
	void DeleteItemKind(const class FName& ID);
	void DeleteLibraryEnemyFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void DeleteLibraryEpisodeFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void DeleteLibraryTerminologyFlag(const int32 ID, const ELIBRARY_FLAG Flag);
	void EndBondsEpisode(bool IsCancel);
	TArray<class FName> GetAllAddContentsNameList();
	TArray<class FName> GetAppliedAddContentsNameList();
	class UBattleLogBuffer* GetBattleLogBuffer();
	float GetBondsFValue(EPlayerID PlayerId, EPlayerID TargetID);
	int32 GetBondsLevel(EPlayerID PlayerId, EPlayerID TargetID);
	int32 GetBondsMaxLevel(EPlayerID PlayerId, EPlayerID TargetID);
	int32 GetBondsProgress(EPlayerID PlayerId, EPlayerID TargetID);
	int32 GetBondsValue(EPlayerID PlayerId, EPlayerID TargetID);
	class UBrainMessageParamManager* GetBrainMessageParamManager();
	int32 GetBrainTalkBt_GiveItemsFromFriendsWithAjito_BeforePlayTime();
	int32 GetBrainTalkBt_GiveItemsFromFriendsWithField_BeforePlayTime();
	int32 GetBrainTalkBt_ReturnToTheAjito_BeforePlayTime();
	bool GetCeBank();
	class UDeepenTheBondsParamManager* GetDeepenTheBondsParamManager();
	bool GetEula();
	bool GetGameClear();
	EHCGameDifficulty GetGameDifficulty();
	bool GetHasPresentedItemInfoList(EPlayerID SendCharaID, EPlayerID RecvCharaID, TArray<struct FPresentInfoData>* ItemList, bool IncludeEvent);
	bool GetIsProgressBondsEpisode(EPlayerID* PlayerId, EPlayerID* TargetID);
	const TArray<struct FUserItemInfo> GetItemList();
	int32 GetJewelTicketCount();
	class ULibraryCharacterParam* GetLibraryCharaParam();
	class ULibraryEnemyParam* GetLibraryEnemyParam();
	class ULoadTipsParamManager* GetLoadTipsParamManager();
	TArray<class FName> GetNotifiedNotAppliedAddContentsNameList();
	int32 GetNpcAccessoryExtendNum(EPlayerID PlayerId);
	class UOptionParam* GetOptionParam();
	class UPresentInfoParam* GetPresentInfoParam();
	bool GetPresentItemInfoList(EPlayerID SendCharaID, EPlayerID RecvCharaID, TArray<struct FPresentInfoData>* ItemList);
	bool GetPrivacyPolicy();
	TArray<class FName> GetPurchasedAddContentNameList();
	class UPurposeMessageParamManager* GetPurposeMessageParamManager();
	class UQuestParamManager* GetQuestParamManager();
	class FName GetSelectedMapUsableItem();
	bool GetSelectNewGame();
	int32 GetSelectSaveSlot();
	int32 GetStartSuspendPauseTime();
	int32 GetTeamBondsLevel(EPlayerID PlayerId);
	class UTipsCountParamManager* GetTipsCountParam();
	bool GetTitleProductFlag();
	int32 GetTotalPlayTime(const bool IsRealData);
	bool GetTransferObject(int32 ItemId, int32* ObjectID, bool IsRemove);
	bool GetTransferObjectByName(const class FName& ItemId, int32* ObjectID, bool IsRemove);
	int32 GetWishListNum();
	class UWorldmapOpenParam* GetWorldmapOpenParam();
	bool GetZeroEpClear();
	bool HaveJewelTicket();
	void InitializeItemParam();
	void InitializeParam(bool IsNewGame);
	void InitializeTotalPlayTime();
	bool IsBattleFieldCheckToWorldMapSystems();
	bool IsBrainTalkOnceCheck_InSaveData_Find(const EBrainTalkCategory _Category, const class FName _ID);
	bool IsEnableCrashVision(EPlayerID PlayerId);
	bool IsEnableNexusDrive(EPlayerID PlayerId);
	bool IsEquipSAS(E_SASKindNative Kind);
	bool IsExistInWishList(int32 Content);
	bool IsExNewGame_TakeOverBrainMap();
	bool IsExNewGame_TakeOverCharacterLevel();
	bool IsExNewGameFlow();
	bool IsForceNewGameFlowFlag();
	bool IsHaveRepairItem();
	bool IsNpcAccesoryExtend1(EPlayerID PlayerId);
	bool IsNpcAccesoryExtend2(EPlayerID PlayerId);
	bool IsReleaseCrashVision();
	bool IsReleaseNexusDrive();
	bool IsSeenAjitoPattern(const class FName AjitoPatternName);
	bool IsSuspendPauseTimeLockFlag();
	void OnSetEventProgressID(int32 ProgressNo);
	void ReCalcSkillPoint();
	void RegisterUseMapGimmick(EMapGimmickType Type);
	void RemoveItemList(const class FName _ID);
	bool RemoveWishList(int32 Content);
	void ResetBattlefieldInfos();
	void ResetLearnedSkill(EPlayerID PlayerId);
	void ResetMapGimmickUseTimes(EMapGimmickType Type);
	void ResetMapGimmickUseTimesAll();
	void ResetTotalPlayTimeCount();
	void SetAllAddContentsNameList(const TArray<class FName>& List);
	void SetAppliedAddContentsNameList(const TArray<class FName>& List);
	void SetBattlefieldInfos(const TMap<class FString, struct FBattlefieldInfo>& Infos);
	void SetBattlefieldRandomSeed(const int32 Seed);
	void SetBondsFValue(EPlayerID PlayerId, EPlayerID TargetID, float Value);
	void SetBondsLevel(EPlayerID PlayerId, EPlayerID TargetID, int32 Level, bool AdjustExp);
	void SetBondsMaxLevel(int32 MaxLevel);
	void SetBondsProgress(EPlayerID PlayerId, EPlayerID TargetID, int32 Progress);
	void SetBondsValue(EPlayerID PlayerId, EPlayerID TargetID, int32 Value);
	void SetBrainTalkBt_GiveItemsFromFriendsWithAjito_BeforePlayTime(const int32 beforePlayTime);
	void SetBrainTalkBt_GiveItemsFromFriendsWithField_BeforePlayTime(const int32 beforePlayTime);
	void SetBrainTalkBt_ReturnToTheAjito_BeforePlayTime(const int32 beforePlayTime);
	void SetCeBank(bool Flag);
	void SetClearLapNum(const int32 Num);
	void SetEnableCrashVision(bool bEnable, EPlayerID PlayerId);
	void SetEnableNexusDrive(bool bEnable, EPlayerID PlayerId);
	void SetEquipSAS(E_SASButton Button, E_SASKindNative Kind);
	void SetEula(bool Flag);
	void SetExtendEquipSAS(bool bExtend);
	void SetGameClear(bool Flag);
	void SetGameClearState(EGameClearState State);
	void SetGameDifficulty(EHCGameDifficulty Diffuculty);
	void SetIsExNewGame_TakeOverBrainMap(const bool Flag);
	void SetIsExNewGame_TakeOverCharacterLevel(const bool Flag);
	void SetIsExNewGameFlow(const bool Flag);
	void SetIsForceNewGameFlowFlag(const bool Flag);
	void SetItemKind(const class FName& ID, const int32 Num);
	void SetItemNum(const class FName& ID, const int32 Num);
	void SetJewelTicketCount(int32 NewCount);
	void SetLearnedSkill(EPlayerID PlayerId, EPlayerSkill SkillID, bool bLearn);
	void SetLibraryEnemyFlag(const int32 ID, const uint8 Flag);
	void SetLibraryEpisodeFlag(const int32 ID, const uint8 Flag);
	void SetLibraryTerminologyFlag(const int32 ID, const uint8 Flag);
	void SetMemberSlotInfo(const int32 Param_Index, const int32 ID);
	void SetMoney(const int32 Value);
	void SetNotifiedNotAppliedAddContentsNameList(const TArray<class FName>& NameList);
	void SetNpcAccessoryExtend1(EPlayerID PlayerId);
	void SetNpcAccessoryExtend2(EPlayerID PlayerId);
	void SetPrivacyPolicy(bool Flag);
	void SetPurchasedAddContentNameList(const TArray<class FName>& List);
	void SetReceiveOrderQuestID(const int32 ID);
	void SetSASEquipStatus(E_SASKindNative Kind, ESASEquipStatus Status, bool bNotEquip);
	void SetSeenAjitoPattern(const class FName AjitoPatternName);
	void SetSelectedMapUsableItem(class FName ItemId);
	void SetSelectedScenario(const int32 Value);
	void SetSelectNewGame(bool SelectSlot);
	void SetSelectSaveSlot(int32 SelectSlot);
	void SetSkillPoint(int32 Point);
	void SetStartSuspendPauseTime(const int32 Time);
	void SetSuspendPauseTimeLockFlag(const bool Flag);
	void SetTeamBondsLevel(EPlayerID PlayerId, int32 TeamBondsLevel);
	void SetTeamBondsProgress(EPlayerID PlayerId, int32 Progress);
	void SetTitleProductFlag(bool Flag);
	bool SetTransferObject(int32 ItemId, int32 ObjectID, bool IsOverwrite);
	bool SetTransferObjectByName(const class FName& ItemId, int32 ObjectID, bool IsOverwrite);
	bool SetWishList(const TArray<int32>& WishList);
	void SetZeroEpClear(bool Flag);
	void StartBondsEpisode(EPlayerID PlayerId, EPlayerID TargetID);
	void TempDisableSkill(bool bDisable);
	bool UpdateBondsLevel(EPlayerID PlayerId, EPlayerID TargetID, bool IsSingleLvUp);
	bool UpdatePresentItemInfo(EPlayerID SendCharaID, EPlayerID RecvCharaID, class FName ItemId);
	bool UpdateTeamBondsLevel(EPlayerID PlayerId, int32 ProgressNo, bool IsSingleLvUp);
	void WorldmapCheckOpenFromProgressID(int32 ProgressId, bool CheckNearly);
	void WorldmapCheckOpenFromProgressIDAndCharaID(EPlayerID PlayerId, int32 ProgressId, bool CheckNearly);
	bool WorldmapCloseLocation(int32 LocationNo, int32 AreaNo, bool IsAreaAll);
	bool WorldmapGetOpenParam(TArray<struct FWorldmapOpenLCParam>* OpenedList);
	bool WorldmapIsAllLocationNotSelectable();
	bool WorldmapIsLocationNewOpen(int32 LocationNo, int32 AreaNo);
	bool WorldmapIsLocationNotSelectable(int32 LocationNo);
	bool WorldmapIsLocationSelectable(int32 LocationNo, int32 AreaNo);
	bool WorldmapOpenLocation(int32 LocationNo, int32 AreaNo, bool IsSelectable);
	bool WorldmapSetAllLocationNotSelectable(bool IsNotSelectable);
	bool WorldmapSetLocationNewOpen(int32 LocationNo, int32 AreaNo, bool IsNewOpen, bool IsAreaAll);
	bool WorldmapSetLocationNotSelectable(int32 LocationNo, bool IsNotSelectable);
	bool WorldmapSetLocationSelectable(int32 LocationNo, int32 AreaNo, bool IsSelectable, bool IsForce, bool IsAreaAll);
	bool WorldmapSetLocationSelectable_WithPortal(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsSelectable, bool IsForce, bool IsAreaAll);

	TMap<class FString, struct FBattlefieldInfo> GetBattlefieldInfos() const;
	int32 GetBattlefieldRandomSeed() const;
	int32 GetClearLapNum() const;
	E_SASKindNative GetEquipSAS(E_SASButton Button) const;
	EGameClearState GetGameClearState() const;
	int32 GetItemNum(const class FName& ID) const;
	int32 GetLastAcquisitionTime(const class FName& ID) const;
	int32 GetLastShopID() const;
	int32 GetLastTradeShopID() const;
	uint8 GetLibraryEnemyFlag(const int32 ID) const;
	uint8 GetLibraryEpisodeFlag(const int32 ID) const;
	uint8 GetLibraryTerminologyFlag(const int32 ID) const;
	TMap<EMapGimmickType, int32> GetMapGimmickUseTimes() const;
	struct FUserItemInfo GetMapUsableItemListInfo(const int32 Param_Index) const;
	int32 GetMapUsableItemListNextIndex(const int32 CurrentIndex) const;
	struct FUserItemInfo GetMapUsableItemListNextInfo(const int32 CurrentIndex) const;
	int32 GetMapUsableItemListNum() const;
	int32 GetMapUsableItemListPrevIndex(const int32 CurrentIndex) const;
	struct FUserItemInfo GetMapUsableItemListPrevInfo(const int32 CurrentIndex) const;
	struct FMemberSlotInfo GetMemberSlotInfo(const int32 Param_Index) const;
	int32 GetMoney() const;
	bool GetMoneyDirty() const;
	int32 GetReceiveOrderQuestID() const;
	ESASEquipStatus GetSASEquipStatus(E_SASKindNative Kind) const;
	int32 GetSelectedScenario() const;
	int32 GetSkillPoint() const;
	int32 GetTeamBondsMaxLevel() const;
	int32 GetTeamBondsProgress(EPlayerID PlayerId) const;
	const TArray<int32> GetWishList() const;
	bool IsExtendEquipSAS() const;
	bool IsLearnedSkill(EPlayerID PlayerId, EPlayerSkill SkillID) const;
	bool IsSASEquipAble(E_SASKindNative Kind) const;
	bool IsValidLibraryEnemyFlag(const int32 ID, const ELIBRARY_FLAG Flag) const;
	bool IsValidLibraryEpisodeFlag(const int32 ID, const ELIBRARY_FLAG Flag) const;
	bool IsValidLibraryTerminologyFlag(const int32 ID, const ELIBRARY_FLAG Flag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserParamManager">();
	}
	static class UUserParamManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserParamManager>();
	}
};
static_assert(alignof(UUserParamManager) == 0x000008, "Wrong alignment on UUserParamManager");
static_assert(sizeof(UUserParamManager) == 0x0006A8, "Wrong size on UUserParamManager");
static_assert(offsetof(UUserParamManager, M_userParam) == 0x000038, "Member 'UUserParamManager::M_userParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_pCharaParamManage) == 0x000490, "Member 'UUserParamManager::M_pCharaParamManage' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_worldmapOpenParamM) == 0x000498, "Member 'UUserParamManager::M_worldmapOpenParamM' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_worldmapOpenParamF) == 0x0004A0, "Member 'UUserParamManager::M_worldmapOpenParamF' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_transObjMap) == 0x0004A8, "Member 'UUserParamManager::M_transObjMap' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_tradeWishList) == 0x0004F8, "Member 'UUserParamManager::M_tradeWishList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_questParamManager) == 0x000508, "Member 'UUserParamManager::M_questParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_brainMessageParamManager) == 0x000510, "Member 'UUserParamManager::M_brainMessageParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_loadingTipsParamManager) == 0x000518, "Member 'UUserParamManager::M_loadingTipsParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_optionParam) == 0x000520, "Member 'UUserParamManager::M_optionParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_purposeMessageParamManager) == 0x000528, "Member 'UUserParamManager::M_purposeMessageParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_libraryEnemyParam) == 0x000530, "Member 'UUserParamManager::M_libraryEnemyParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_libraryCharaParam) == 0x000538, "Member 'UUserParamManager::M_libraryCharaParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_UserSystemParam) == 0x000540, "Member 'UUserParamManager::M_UserSystemParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_presentInfoParam) == 0x000548, "Member 'UUserParamManager::M_presentInfoParam' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_tipsCountParamManager) == 0x000550, "Member 'UUserParamManager::M_tipsCountParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_deepenTheBondsParamManager) == 0x000558, "Member 'UUserParamManager::M_deepenTheBondsParamManager' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_seenAjitoPatternList) == 0x000560, "Member 'UUserParamManager::M_seenAjitoPatternList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_battleLogBuffer) == 0x000570, "Member 'UUserParamManager::M_battleLogBuffer' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_AllAddContentsNameList) == 0x000578, "Member 'UUserParamManager::M_AllAddContentsNameList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_AppliedAddContentsNameList) == 0x000588, "Member 'UUserParamManager::M_AppliedAddContentsNameList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_NotifiedNotAppliedAddContentsNameList) == 0x000598, "Member 'UUserParamManager::M_NotifiedNotAppliedAddContentsNameList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_BrainTalkBt_ReturnToTheAjito_BeforePlayTime) == 0x0005A8, "Member 'UUserParamManager::M_BrainTalkBt_ReturnToTheAjito_BeforePlayTime' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_BrainTalkBt_GiveItemsFromFriendsWithAjito_BeforePlayTime) == 0x0005AC, "Member 'UUserParamManager::M_BrainTalkBt_GiveItemsFromFriendsWithAjito_BeforePlayTime' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_BrainTalkBt_GiveItemsFromFriendsWithField_BeforePlayTime) == 0x0005B0, "Member 'UUserParamManager::M_BrainTalkBt_GiveItemsFromFriendsWithField_BeforePlayTime' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_mapUsableItemList) == 0x0005C0, "Member 'UUserParamManager::M_mapUsableItemList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_isForceNewGameFlowFlag) == 0x0005D0, "Member 'UUserParamManager::M_isForceNewGameFlowFlag' has a wrong offset!");
static_assert(offsetof(UUserParamManager, M_PurchasedAddContentNameList) == 0x0005E8, "Member 'UUserParamManager::M_PurchasedAddContentNameList' has a wrong offset!");
static_assert(offsetof(UUserParamManager, bondsProgressEvent) == 0x0005F8, "Member 'UUserParamManager::bondsProgressEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, bondsLevelEvent) == 0x000608, "Member 'UUserParamManager::bondsLevelEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, SasEquipExtendEvent) == 0x000618, "Member 'UUserParamManager::SasEquipExtendEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, SasEquipEvent) == 0x000628, "Member 'UUserParamManager::SasEquipEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, SasEquipStatusEvent) == 0x000638, "Member 'UUserParamManager::SasEquipStatusEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, WmSelectableChangeEvent) == 0x000648, "Member 'UUserParamManager::WmSelectableChangeEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, OnStartBondsEpisodeEvent) == 0x000660, "Member 'UUserParamManager::OnStartBondsEpisodeEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, OnEndBondsEpisodeEvent) == 0x000670, "Member 'UUserParamManager::OnEndBondsEpisodeEvent' has a wrong offset!");
static_assert(offsetof(UUserParamManager, OnChangeNoticeUiStateDelegate) == 0x000680, "Member 'UUserParamManager::OnChangeNoticeUiStateDelegate' has a wrong offset!");
static_assert(offsetof(UUserParamManager, OnChangeNoticeUiStateRemoveDelegate) == 0x000690, "Member 'UUserParamManager::OnChangeNoticeUiStateRemoveDelegate' has a wrong offset!");

// Class BattlePrototype.UserParameterUtility
// 0x0000 (0x0028 - 0x0028)
class UUserParameterUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AddBattleLogBuffer(class UObject* WorldContextObject, const struct FBattleLogParam& Param);
	static void AddBrainMessageIgnorConditions(class UObject* WorldContextObject, const int32 ThreadNumber, const int32 MessageNum);
	static bool AddItemNum(class UObject* WorldContextObject, const class FName ItemId, const int32 ItemNum, const bool IsUpdateMapUsable, const bool IsDispLog);
	static void AddJewelTicketCount(class UObject* WorldContextObject, int32 AddCount);
	static bool AddMoney(class UObject* WorldContextObject, const int32 Money);
	static void AllOpenBrainMessageIgnorConditionsAndLock(class UObject* WorldContextObject, const int32 TargetThread);
	static bool CheckAppliedAddContent(class UObject* WorldContextObject, class FName ContentName);
	static bool CheckIsNeedRetryTips(class UObject* WorldContextObject);
	static bool CheckStartTeamBondsEpisode(class UObject* WorldContextObject, EPlayerID PlayerId, int32* EpisodeNo);
	static bool CheckTeamBondsLevelUp(class UObject* WorldContextObject, EPlayerID PlayerId, int32 ProgressNo);
	static void ClearRetryTips(class UObject* WorldContextObject);
	static float DisplayTipsOrMiniTipsByHelpID(class UObject* WorldContextObject, EHelpTutorial HelpID, const bool NotPauseControll, const bool NotCloseOfPause, const bool IsPlayableCheck, const bool IsFade);
	static void EndBondsEpisode(class UObject* WorldContextObject, bool IsCancel);
	static int32 GetBeginningTips(class UObject* WorldContextObject, EPlayerID Player, int32 ProgressNo, int32 NextLocation);
	static EGameClearState GetGameClearState(class UObject* WorldContextObject);
	static EHCGameDifficulty GetGameDifficulty(class UObject* WorldContextObject);
	static bool GetHasPresentedItemInfoList(class UObject* WorldContextObject, EPlayerID SendCharaID, EPlayerID RecvCharaID, TArray<struct FPresentInfoData>* ItemList, bool IncludeEvent);
	static bool GetIsProgressBondsEpisode(class UObject* WorldContextObject, EPlayerID* PlayerId, EPlayerID* TargetID);
	static int32 GetItemNum(class UObject* WorldContextObject, const class FName ItemId);
	static int32 GetJewelTicketCount(class UObject* WorldContextObject);
	static int32 GetMoney(class UObject* WorldContextObject);
	static int32 GetNextTips(class UObject* WorldContextObject);
	static bool GetPresentItemInfoList(class UObject* WorldContextObject, EPlayerID SendCharaID, EPlayerID RecvCharaID, TArray<struct FPresentInfoData>* ItemList);
	static class FName GetPurposeMessage(class UObject* WorldContextObject);
	static bool GetSasControllChange(class UObject* WorldContextObject);
	static class USaveLoadExSystemParamManager* GetSaveLoadExSystemParamManager(class UObject* WorldContextObject);
	static void GetSelectedTogetherCharID(class UObject* WorldContextObject, TArray<EPlayerID>* SelectedArray);
	static int32 GetTeamBondsLevel(class UObject* WorldContextObject, EPlayerID PlayerId);
	static int32 GetTeamBondsMaxLevel(class UObject* WorldContextObject);
	static int32 GetTeamBondsProgress(class UObject* WorldContextObject, EPlayerID PlayerId);
	static bool GetTransferObject(class UObject* WorldContextObject, int32 ItemId, int32* ObjectID, bool IsRemove);
	static bool GetTransferObjectByName(class UObject* WorldContextObject, class FName ItemId, int32* ObjectID, bool IsRemove);
	static bool HaveJewelTicket(class UObject* WorldContextObject);
	static bool IsDispTipsOrMiniTips(class UObject* WorldContextObject, EHelpTutorial HelpID);
	static bool IsHelpTutoIDMini(class UObject* WorldContextObject, EHelpTutorial HelpID);
	static bool IsTipsDispEnable(class UObject* WorldContextObject, EHelpTutorial HelpID);
	static void ResetDispTipsState(class UObject* WorldContextObject, EHelpTutorial HelpID);
	static void SetGameClear(class UObject* WorldContextObject, bool ClearFlag);
	static void SetGameClearState(class UObject* WorldContextObject, EGameClearState State);
	static void SetGameDifficulty(class UObject* WorldContextObject, EHCGameDifficulty Diffuculty);
	static void SetJewelTicketCount(class UObject* WorldContextObject, int32 NewCount);
	static void SetTeamBondsProgress(class UObject* WorldContextObject, EPlayerID PlayerId, int32 Progress);
	static void SetTitleProductFlag(class UObject* WorldContextObject, bool EndingAfterFlag);
	static bool SetTransferObject(class UObject* WorldContextObject, int32 ItemId, int32 ObjectID, bool IsOverwrite);
	static bool SetTransferObjectByName(class UObject* WorldContextObject, class FName ItemId, int32 ObjectID, bool IsOverwrite);
	static void SetZeroEpClear(class UObject* WorldContextObject, bool ZeroEpFlag);
	static void StartBondsEpisode(class UObject* WorldContextObject, EPlayerID PlayerId, EPlayerID TargetID, int32 bondsEpNumber);
	static void StartDLCBondsEpisode(class UObject* WorldContextObject, class FName bondsID);
	static bool UpdatePresentItemInfo(class UObject* WorldContextObject, EPlayerID SendCharaID, EPlayerID RecvCharaID, class FName ItemId);
	static bool UpdateTeamBondsLevel(class UObject* WorldContextObject, EPlayerID PlayerId, int32 ProgressNo, bool IsSingleLvUp);
	static void WorldmapCheckOpenFromProgressID(class UObject* WorldContextObject, int32 ProgressId);
	static bool WorldmapCloseLocation(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, bool IsAreaAll);
	static bool WorldmapGetOpenParam(class UObject* WorldContextObject, TArray<struct FWorldmapOpenLCParam>* OpenedList);
	static bool WorldmapIsLocationNewOpen(class UObject* WorldContextObject, int32 LocationId, int32 AreaId);
	static bool WorldmapIsLocationNotSelectable(class UObject* WorldContextObject, int32 LocationId);
	static bool WorldmapIsLocationNotSelectableAll(class UObject* WorldContextObject);
	static bool WorldmapIsLocationSelectable(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo);
	static bool WorldmapOpenLocation(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, bool IsSelectable);
	static bool WorldmapSetLocationNewOpen(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, bool IsNewOpen, bool IsAreaAll);
	static bool WorldmapSetLocationNotSelectable(class UObject* WorldContextObject, int32 LocationId, bool IsNotSelectable);
	static bool WorldmapSetLocationNotSelectableAll(class UObject* WorldContextObject, bool IsNotSelectable);
	static bool WorldmapSetLocationSelectable(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, bool IsSelectable, bool IsForce, bool IsAreaAll);
	static bool WorldmapSetLocationSelectable_WithPortal(class UObject* WorldContextObject, int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsSelectable, bool IsForce, bool IsAreaAll);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserParameterUtility">();
	}
	static class UUserParameterUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserParameterUtility>();
	}
};
static_assert(alignof(UUserParameterUtility) == 0x000008, "Wrong alignment on UUserParameterUtility");
static_assert(sizeof(UUserParameterUtility) == 0x000028, "Wrong size on UUserParameterUtility");

// Class BattlePrototype.WeaponChargeInterface
// 0x0000 (0x0028 - 0x0028)
class IWeaponChargeInterface final : public IInterface
{
public:
	bool CheckWeaponChargeLevelDeficit(int32 CheckLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponChargeInterface">();
	}
	static class IWeaponChargeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeaponChargeInterface>();
	}
};
static_assert(alignof(IWeaponChargeInterface) == 0x000008, "Wrong alignment on IWeaponChargeInterface");
static_assert(sizeof(IWeaponChargeInterface) == 0x000028, "Wrong size on IWeaponChargeInterface");

// Class BattlePrototype.WorldmapBatchOpenData
// 0x0030 (0x0058 - 0x0028)
class UWorldmapBatchOpenData final : public UObject
{
public:
	class UDataTable*                             RefCheckTableM;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             RefCheckTableF;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A00[0x20];                                    // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetMainLocationIDFromSublocationID(int32 SubLocationID);
	bool IsValidResource();
	bool LoadDataTable();
	bool UnloadDataTable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldmapBatchOpenData">();
	}
	static class UWorldmapBatchOpenData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldmapBatchOpenData>();
	}
};
static_assert(alignof(UWorldmapBatchOpenData) == 0x000008, "Wrong alignment on UWorldmapBatchOpenData");
static_assert(sizeof(UWorldmapBatchOpenData) == 0x000058, "Wrong size on UWorldmapBatchOpenData");
static_assert(offsetof(UWorldmapBatchOpenData, RefCheckTableM) == 0x000028, "Member 'UWorldmapBatchOpenData::RefCheckTableM' has a wrong offset!");
static_assert(offsetof(UWorldmapBatchOpenData, RefCheckTableF) == 0x000030, "Member 'UWorldmapBatchOpenData::RefCheckTableF' has a wrong offset!");

// Class BattlePrototype.WorldmapOpenParam
// 0x0068 (0x0090 - 0x0028)
class UWorldmapOpenParam final : public UObject
{
public:
	uint8                                         Pad_2A01[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FWorldmapOpenLCParam>      OpenParam;                                         // 0x0038(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          NotSelectableAll;                                  // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A02[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckOpenFromProgressID(int32 ProgressId, bool CheckNearly);
	void ClearAll();
	bool CloseLocation(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsAllArea);
	bool GetLocationNotSelectableAll_FromBF();
	bool GetOpenedList(TArray<struct FWorldmapOpenLCParam>* OpenedList);
	bool IsLocationNewOpened(int32 LocationNo, int32 AreaNo, int32 PortalNo);
	bool IsLocationNotSelectable(int32 LocationNo);
	bool IsLocationNotSelectableAll();
	bool IsLocationSelectable(int32 LocationNo, int32 AreaNo, int32 PortalNo);
	bool OpenLocation(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsSelectable);
	bool SetLocationNewOpened(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsNewOpened, bool IsAllArea);
	void SetLocationNotSelectable(int32 LocationNo, bool IsNotSelectable);
	void SetLocationNotSelectableAll(bool IsNotSelectable);
	void SetLocationNotSelectableAll_FromBF(bool IsNotSelectable);
	bool SetLocationSelectable(int32 LocationNo, int32 AreaNo, int32 PortalNo, bool IsSelectable, bool IsForce, bool IsAllArea);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldmapOpenParam">();
	}
	static class UWorldmapOpenParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldmapOpenParam>();
	}
};
static_assert(alignof(UWorldmapOpenParam) == 0x000008, "Wrong alignment on UWorldmapOpenParam");
static_assert(sizeof(UWorldmapOpenParam) == 0x000090, "Wrong size on UWorldmapOpenParam");
static_assert(offsetof(UWorldmapOpenParam, OpenParam) == 0x000038, "Member 'UWorldmapOpenParam::OpenParam' has a wrong offset!");
static_assert(offsetof(UWorldmapOpenParam, NotSelectableAll) == 0x000088, "Member 'UWorldmapOpenParam::NotSelectableAll' has a wrong offset!");

// Class BattlePrototype.XGameStreamingManager
// 0x0018 (0x0050 - 0x0038)
class UXGameStreamingManager final : public URSTickableManagerBase
{
public:
	uint8                                         Pad_2A0C[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URSGameInstance*                        _gameInstance;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0D[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsStreaming();
	static void SetNonSkipEventFlag(bool Flag);

	void SetEventPauseFlag(bool Flag);
	void SetFixedLayout(ETouchControlLayout Layout, float Sec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XGameStreamingManager">();
	}
	static class UXGameStreamingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXGameStreamingManager>();
	}
};
static_assert(alignof(UXGameStreamingManager) == 0x000008, "Wrong alignment on UXGameStreamingManager");
static_assert(sizeof(UXGameStreamingManager) == 0x000050, "Wrong size on UXGameStreamingManager");
static_assert(offsetof(UXGameStreamingManager, _gameInstance) == 0x000040, "Member 'UXGameStreamingManager::_gameInstance' has a wrong offset!");

}

