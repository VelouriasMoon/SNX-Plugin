#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RSBattlePlayer

#include "Basic.hpp"

#include "Enum_EnemySound_structs.hpp"
#include "EPlayerComboPattern_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "BattlePrototype_structs.hpp"
#include "ESASCopyStatus_structs.hpp"
#include "Engine_structs.hpp"
#include "PlayerAnimMontageSet_structs.hpp"
#include "EPlayerFacialAnim_structs.hpp"
#include "EPlayerReviveCableStep_structs.hpp"
#include "PsychicGrabButtonType_structs.hpp"
#include "Enum_BattleType_em8000_structs.hpp"
#include "FPlayerBattleParticleData_structs.hpp"
#include "E_SceneType_structs.hpp"
#include "EPlayerCapsuleSize_structs.hpp"
#include "FPlayerBattleVoice_structs.hpp"
#include "EPlayerMaterialManageType_structs.hpp"
#include "F_AssultVisionRequestPool_structs.hpp"
#include "FPlayerBattleVoiceFacialAnimType_structs.hpp"
#include "ECharaExecuteNotifyKind_structs.hpp"
#include "DE_em_ChangeTimeDilation_structs.hpp"
#include "EJustDodgeAttackSlowStep_structs.hpp"
#include "FCombinationVisionData_structs.hpp"
#include "Enum_EnemySpawnState_structs.hpp"
#include "RSBattleCharacter_classes.hpp"
#include "EPlayerAIBattleThinkParam_structs.hpp"
#include "EBulletType_structs.hpp"
#include "EBattlePhase_em8210_structs.hpp"
#include "EPlayerAIBattleThinkType_structs.hpp"
#include "EBattleVoice_em8200_structs.hpp"
#include "ECharaDeadType_structs.hpp"
#include "Enum_BattleType_em8010_structs.hpp"
#include "EPlayerAnimMontage_structs.hpp"
#include "E_SASKind_structs.hpp"
#include "ETelepoMoveType_em8200_structs.hpp"
#include "Enum_EnemyAiType_structs.hpp"
#include "EPlayerUseItemSpeed_structs.hpp"
#include "EPlayerAIMoveMode_structs.hpp"
#include "EBattleBonusAddType_structs.hpp"
#include "EParamAfterEventAction_structs.hpp"
#include "EEnpcMetamorphosisiFinishType_structs.hpp"
#include "EPlayerBattleVoiceType_structs.hpp"
#include "EBonusGhostType_structs.hpp"
#include "EPlayerReviveKind_structs.hpp"
#include "EDeadFactor_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass RSBattlePlayer.RSBattlePlayer_C
// 0x0C00 (0x1CF0 - 0x10F0)
#pragma pack(push, 0x1)
class alignas(0x10) ARSBattlePlayer_C : public ARSBattleCharacter_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_RSBattlePlayer_C;                   // 0x10F0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UBP_EnemySpawnComponent_C*              BP_EnemySpawnComponent;                            // 0x10F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_ReactionDilationComponent_C*        BP_ReactionDilationComponent;                      // 0x1100(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyAddDamageShakeComponent_C*     BP_EnemyAddDamageShakeComponent;                   // 0x1108(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UPlayerAsyncScriptComponent*            PlayerAsyncScript;                                 // 0x1110(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateSASLink_C*         BP_PlayerActionStateSASLink;                       // 0x1118(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateEndBrainCrash_C*   BP_PlayerActionStateEndBrainCrash;                 // 0x1120(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AttachmentManageComponent_C*        BP_AttachmentManageComponent;                      // 0x1128(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateSprintTurnBack_C*  BP_PlayerActionStateSprintTurnBack;                // 0x1130(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UDamagePartCollisionComponent*          DamagePartCollision;                               // 0x1138(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateRessurect_C*       BP_PlayerActionStateRessurect;                     // 0x1140(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateRevive_C*          BP_PlayerActionStateRevive;                        // 0x1148(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateControlPsychicObject_C* BP_PlayerActionStateControlPsychicObject;          // 0x1150(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateEventMotion_C*     BP_PlayerActionStateEventMotion;                   // 0x1158(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateRecoverBlowDamage_C* BP_PlayerActionStateRecoverBlowDamage;             // 0x1160(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateDrive_C*           BP_PlayerActionStateDrive;                         // 0x1168(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerDriveComponent_C*             BP_PlayerDriveComponent;                           // 0x1170(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateCaptureMapGimmick_C* BP_PlayerActionStateCaptureMapGimmick;             // 0x1178(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateCancelMapGimmick_C* BP_PlayerActionStateCancelMapGimmick;              // 0x1180(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerAIEvaluateLocationComponent_C* BP_PlayerAIEvaluateLocationComponent;              // 0x1188(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerCameraComponent_C*            BP_PlayerCameraComponent;                          // 0x1190(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerUpperActionStatePsychicAttack_C* BP_PlayerUpperActionStatePsychicAttack;            // 0x1198(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerUpperActionStateCapture_C*    BP_PlayerUpperActionStateCapture;                  // 0x11A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerMaterialManageComponent_C*    BP_PlayerMaterialManageComponent;                  // 0x11A8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateDamageBrainCrash_C* BP_PlayerActionStateDamageBrainCrash;              // 0x11B0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UPlayerLookAtComponent*                 PlayerLookAtComponent;                             // 0x11B8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class URSStateManageComponent*                RSStateManage_Upper;                               // 0x11C0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class URSStateManageComponent*                RSStateManage;                                     // 0x11C8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UPlayerScriptComponent*                 PlayerScript;                                      // 0x11D0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CounterComponent_C*                 BP_CounterComponent;                               // 0x11D8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_SASTelepoComponent_C*               BP_SASTelepoComponent;                             // 0x11E0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_InterceptComponent_C*               BP_InterceptComponent;                             // 0x11E8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerHardenComponent_C*            BP_PlayerHardenComponent;                          // 0x11F0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_FacialAnim_C*                       BP_FacialAnim;                                     // 0x11F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_WeaponManageComponent_C*            BP_WeaponManageComponent;                          // 0x1200(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerStealthComponent_C*           BP_PlayerStealthComponent;                         // 0x1208(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerUpperActionStateAttack_C*     BP_PlayerUpperActionStateAttack;                   // 0x1210(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateAfterEvent_C*      BP_PlayerActionStateAfterEvent;                    // 0x1218(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerUpperActionStateDamageSAS_C*  BP_PlayerUpperActionStateDamageSAS;                // 0x1220(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerUpperActionStateChangeBattle_C* BP_PlayerUpperActionStateChangeBattle;             // 0x1228(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateWalkRun_C*         BP_PlayerActionStateWalkRun;                       // 0x1230(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateIdle_C*            BP_PlayerActionStateIdle;                          // 0x1238(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_TargetSearchComponent_C*            BP_TargetSearchComponent;                          // 0x1240(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_JumpComponent_C*                    BP_JumpComponent;                                  // 0x1248(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerAIComponent_C*                BP_PlayerAIComponent;                              // 0x1250(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateDead_C*            BP_PlayerActionStateDead;                          // 0x1258(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AttackEmitter_C*                    BP_AttackEmitter;                                  // 0x1260(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateUseItem_C*         BP_PlayerActionStateUseItem;                       // 0x1268(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateBoringIdle_C*      BP_PlayerActionStateBoringIdle;                    // 0x1270(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_UseItemComponent_C*                 BP_ItemUseComponent;                               // 0x1278(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_JustDodge_C*                        BP_JustDodge;                                      // 0x1280(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_BonusGhostBridgeComponent_C*        BP_BonusGhostBridgeComponent;                      // 0x1288(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_BonusGhostTrailComponent_C*         BP_BonusGhostTrailComponent;                       // 0x1290(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_SASCutIn_C*                         BP_SASCutIn;                                       // 0x1298(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerGauge_C*                      BP_PlayerGauge;                                    // 0x12A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateWakeUp_C*          BP_PlayerActionStateWakeUp;                        // 0x12A8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateDown_C*            BP_PlayerActionStateDown;                          // 0x12B0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateDamageBlow_C*      BP_PlayerActionStateDamageBlow;                    // 0x12B8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerDamageReactionInfo_C*         BP_PlayerDamageReactionInfo;                       // 0x12C0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_SASRecastGauge_C*                   BP_SASRecastGauge;                                 // 0x12C8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateEvent_C*           BP_PlayerActionStateEvent;                         // 0x12D0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UPlayerInputComponent_C*                PlayerInputComponent;                              // 0x12D8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AttackAcceleratorBase_C*            BP_AttackAcceleratorBase;                          // 0x12E0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerUpperActionStateIdle_C*       BP_PlayerUpperActionStateIdle;                     // 0x12E8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateDamage_C*          BP_PlayerActionStateDamage;                        // 0x12F0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateAttack_C*          BP_PlayerActionStateAttack;                        // 0x12F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateDodge_C*           BP_PlayerActionStateDodge;                         // 0x1300(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateLand_C*            BP_PlayerActionStateLand;                          // 0x1308(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateFall_C*            BP_PlayerActionStateFall;                          // 0x1310(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateJump_C*            BP_PlayerActionStateJump;                          // 0x1318(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateSprintBrake_C*     BP_PlayerActionStateSprintBrake;                   // 0x1320(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerActionStateSprint_C*          BP_PlayerActionStateSprint;                        // 0x1328(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USprintComponentBP_C*                   SprintBP;                                          // 0x1330(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UStepComponentBP_C*                     StepComponentBP;                                   // 0x1338(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCheatCommandListenerComponent*         CheatCommandListener;                              // 0x1340(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCutCameraComponent*                    CutCamera;                                         // 0x1348(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UAttackInputComponent*                  AttackInput;                                       // 0x1350(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UMoveInputComponent*                    MoveInput;                                         // 0x1358(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UPlayerCameraRotationComponent_C*       PlayerCameraRotationComponent;                     // 0x1360(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UPlayerShadeNoiseComponent*             PlayerShadeNoise;                                  // 0x1368(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCameraComponent*                       Camera;                                            // 0x1370(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USpringArmComponent*                    SpringArm;                                         // 0x1378(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	float                                         BaseTurnRate;                                      // 0x1380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BaseLookUpRate;                                    // 0x1384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DirectionControllRotationSpeed;                    // 0x1388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   PlayerStatusTableRowName;                          // 0x138C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BttleIdleKeepAftAttackSec;                         // 0x1394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   DefaultStatusClaimantName;                         // 0x1398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnMovementCollisionLand;                           // 0x13A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UPlayerAnimControllerComponent*         PlayerAnimConRef;                                  // 0x13B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MoveInputScale;                                    // 0x13B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bJumpMoveInput;                                    // 0x13BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	ERSAttackInputKind                            LastInputAttackType;                               // 0x13BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78C8[0x2];                                     // 0x13BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerLookAtComponent*                 LookAtRef;                                         // 0x13C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<bool>                                  IsSASInput;                                        // 0x13C8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         CameraLagSpeed;                                    // 0x13D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash)
	float                                         CameraLagMaxDistance;                              // 0x13DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsCameraLag;                                       // 0x13E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bInputDodge;                                       // 0x13E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78C9[0x2];                                     // 0x13E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeMontagePlayRate;                             // 0x13E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           ChangeMontageRef;                                  // 0x13E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         StartSpringArmLength;                              // 0x13F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         StartSpringArmPitch;                               // 0x13F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bReserveChangeCombo;                               // 0x13F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bUpdateHUD;                                        // 0x13F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78CA[0x2];                                     // 0x13FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FallVelocity;                                      // 0x13FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerComboPattern                           ComboPatternFirst;                                 // 0x1408(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerComboPattern                           ComboPatternSecond;                                // 0x1409(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78CB[0x2];                                     // 0x140A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerIndex;                                       // 0x140C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerFixParamater_C*               PlayerFixParam;                                    // 0x1410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FRSBeamEffectInfo>              ConnectEffectInfoList;                             // 0x1418(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	TArray<class ABP_WeaponBase_C*>               RegisterThrowWeaponList;                           // 0x1428(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	struct FGameTimer                             BattleOffTimer;                                    // 0x1438(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78CC[0x4];                                     // 0x1444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ThrowWeaponTargetList;                             // 0x1448(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	class FName                                   EventInvalidDamageClaimantName;                    // 0x1458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         EffectHandleBadStateFlooded;                       // 0x1460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         EffectHandleBadStateOil;                           // 0x1468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           UpperBlendAnimMontage;                             // 0x1470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           LowerBlendAnimMontage;                             // 0x1478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FPlayerAnimMontageSet                  AnimMontageSet;                                    // 0x1480(0x00E8)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnChangePsychicObjShow;                            // 0x1568(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnChangePsychicObjEnable;                          // 0x1578(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnChangePsychicObjUse;                             // 0x1588(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnChangePsychicObjCount;                           // 0x1598(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<class FName>                           CheckStartAttackFlag;                              // 0x15A8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         BadStateOilParticleSoftReference;                  // 0x15B8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class UParticleSystem*                        BadStateOilParticle;                               // 0x15E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         BadStateFloodedParticleSoftReference;              // 0x15E8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class UParticleSystem*                        BadStateFloodedParticle;                           // 0x1610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_SASCopyPlayerActor_C*>       CopyPlayerList;                                    // 0x1618(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	ESASCopyStatus                                CopyWeaponStatus;                                  // 0x1628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78CD[0x3];                                     // 0x1629(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             CopyWeaponTImer;                                   // 0x162C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bReserveCopyWeaponVisibleOn;                       // 0x1638(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78CE[0x3];                                     // 0x1639(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InputDodgeMoveStick;                               // 0x163C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_PlayerManager_C*                    PlayerManager;                                     // 0x1648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UBP_ENpcComponent_C*                    ENPCCompRef;                                       // 0x1650(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnChangePsychicObjShow2;                           // 0x1658(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnChangePsychicObjEnable2;                         // 0x1668(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnChangePsychicObjUse2;                            // 0x1678(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnChangePsychicObjCount2;                          // 0x1688(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FVector2D                              FixCameraLeftStick;                                // 0x1698(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bFreeCheck;                                        // 0x16A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78CF[0x3];                                     // 0x16A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FreeCheckNo;                                       // 0x16A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ERSPartyPlayerKind                            PartyPlayerKind;                                   // 0x16A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsInputEnable;                                     // 0x16A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78D0[0x6];                                     // 0x16AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchMontageBlendingOut;                        // 0x16B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UDataTable*                             PresetCameraDataTable;                             // 0x16C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FGameTimer                             DisableCameraControlTimer;                         // 0x16C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bDebugPause;                                       // 0x16D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	ERSGamepadInputName                           AI_BUTTON_ATTACK;                                  // 0x16D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ERSGamepadInputName                           AI_BUTTON_DODGE;                                   // 0x16D6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ERSGamepadInputName                           AI_BUTTON_JUMP;                                    // 0x16D7(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ERSGamepadInputName                           AI_BUTTON_ITEM;                                    // 0x16D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78D1[0x7];                                     // 0x16D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTelepoDodgeBegin;                                // 0x16E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnTelepoDodgeEnd;                                  // 0x16F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             DispatchChangeWalkRunStateKind;                    // 0x1700(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bObstructPsychicActionSAS;                         // 0x1710(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bObstructPsychicActionPsychic;                     // 0x1711(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bObstructPsychicActionAttack;                      // 0x1712(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bObstructPsychicActionDrive;                       // 0x1713(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78D2[0x4];                                     // 0x1714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ObstructAnimMontage;                               // 0x1718(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bObstructPsychicActionBrainCrash;                  // 0x1720(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EPlayerID                                     CoverDamagePlayerID;                               // 0x1721(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bReserveCoverDamage;                               // 0x1722(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EPlayerID                                     LastCoverDamagePlayerID;                           // 0x1723(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78D3[0x4];                                     // 0x1724(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        LastGroundLocation;                                // 0x1728(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class ULevelSequence*                         ObstructSequencer;                                 // 0x1738(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bBeginningBattleState;                             // 0x1740(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	EPlayerReviveCableStep                        ReviveCableStep;                                   // 0x1741(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bUpdateDriveHUD;                                   // 0x1742(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bExecReviveDirection;                              // 0x1743(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	ERSGamepadInputName                           AI_BUTTON_PSYCHIC;                                 // 0x1744(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78D4[0x3];                                     // 0x1745(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             RedCodeDataTable;                                  // 0x1748(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_CableBase_C*>                RedCodeActor;                                      // 0x1750(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<class ABP_CableBase_C*>                BrainCodeActor;                                    // 0x1760(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	int32                                         EyeIndex;                                          // 0x1770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78D5[0x4];                                     // 0x1774(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchMontageEnded;                              // 0x1778(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UAttackComponentBaseBP_C*               CurrentAttackComponent;                            // 0x1788(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerDownType                               EventDownParam;                                    // 0x1790(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          SkillAttack_AirDodgeAttack;                        // 0x1791(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bComboInputEnd;                                    // 0x1792(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bResurrectCameraOn;                                // 0x1793(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78D6[0x4];                                     // 0x1794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBP_SASHologramAttackCheck_C*           SASHologramAttackCheckComponent;                   // 0x1798(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class FName>                           PauseTimerClaimantList;                            // 0x17A0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             DispatchAttackActorHit;                            // 0x17B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UAnimMontage*                           EndBrainCrashMontage;                              // 0x17C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             BattleParticleDataTable;                           // 0x17C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         BattleParticleHeadHandle;                          // 0x17D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         BattleParticleRightHandHandle;                     // 0x17D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         BattleParticleLeftHandHandle;                      // 0x17E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class FName>                           BattleParticleClaimantList;                        // 0x17E8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	EPlayerBattleParticleType                     BattleParticleType;                                // 0x17F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78D7[0x7];                                     // 0x17F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           VisionFogClaimantList;                             // 0x1800(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<struct FWireNeon>                      WireNeonDataTableData;                             // 0x1810(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<struct FFPlayerBattleParticleData>     BattleParticleDataList;                            // 0x1820(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         ForceBrainTalkParticle;                            // 0x1830(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DelayDeactivateBattleParticleTimer;                // 0x1838(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78D8[0x4];                                     // 0x183C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DispatchTimerPause;                                // 0x1840(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bTalkLookAt;                                       // 0x1850(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78D9[0x3];                                     // 0x1851(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TalkLookAtLocation;                                // 0x1854(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             DispatchTalkTurn;                                  // 0x1860(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bEventSprintFlag;                                  // 0x1870(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78DA[0x3];                                     // 0x1871(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultCameraLength;                               // 0x1874(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FCameraTriggerInfo                     BrainFieldCameraSetting;                           // 0x1878(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance)
	bool                                          bInvisibleMask;                                    // 0x18A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bEnablePsychicComboFlag;                           // 0x18A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bIsEnableSAS;                                      // 0x18A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78DB[0x1];                                     // 0x18A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackMoveParam_Distance;                          // 0x18A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AttackMoveParam_Time;                              // 0x18A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EEasingFunc                                   AttackMoveParam_EaseType;                          // 0x18AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78DC[0x3];                                     // 0x18AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackMoveParam_EaseBlendExp;                      // 0x18B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                AttackMoveParam_MoveDir;                           // 0x18B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AttackMove_Timer;                                  // 0x18C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AttackMove_PrevDistance;                           // 0x18C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bAttackMove_RotateTarget;                          // 0x18C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bAttackMove_RotateRight;                           // 0x18C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78DD[0x2];                                     // 0x18CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CrashChanceCursorOffset;                           // 0x18CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                HPGaugeOffset;                                     // 0x18D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIsBindSASStart;                                   // 0x18E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78DE[0x3];                                     // 0x18E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  bContentsOpenFlag;                                 // 0x18E8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bSuspendFlag;                                      // 0x18F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78DF[0x7];                                     // 0x18F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AttackMoveParam_Target;                            // 0x1900(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                AttackMoveParam_BeginLocation;                     // 0x1908(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bCheckChargeTelepo;                                // 0x1914(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78E0[0x3];                                     // 0x1915(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TelepoAttackEnchantTimer;                          // 0x1918(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bExJustDodgeFlag;                                  // 0x191C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78E1[0x3];                                     // 0x191D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExJustDodgeAttackRate;                             // 0x1920(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ExJustDodgeCrashRate;                              // 0x1924(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class FName>                           SuperArmorClaimantList;                            // 0x1928(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bLocationChangeFlag;                               // 0x1938(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EPlayerDownType                               CurrentDownType;                                   // 0x1939(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78E2[0x2];                                     // 0x193A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerAccessoryInvalidDamageAfter;                  // 0x193C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         NpcWarpDitherRate;                                 // 0x1940(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bExecNpcRevive;                                    // 0x1944(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bExecTalkEvent;                                    // 0x1945(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78E3[0x2];                                     // 0x1946(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFPlayerBattleVoice                    BattleVoiceData;                                   // 0x1948(0x0090)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bPlayAbleBattleStartVoice;                         // 0x19D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78E4[0x7];                                     // 0x19D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DisableFootIKClaimantNameList;                     // 0x19E0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bExecDynamicEvent;                                 // 0x19F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78E5[0x3];                                     // 0x19F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddDamageMotionBlendRate;                          // 0x19F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         PlayerDeadCount;                                   // 0x19F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         LastThrowPsychicComboLevel;                        // 0x19FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDisableActionBoringIdle;                          // 0x1A00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78E6[0x3];                                     // 0x1A01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiscoverIconOffset;                                // 0x1A04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableJustDodgeAttack;                            // 0x1A08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bUseENPCOutline;                                   // 0x1A09(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          SkillAttack_JustDodgeAttack;                       // 0x1A0A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78E7[0x5];                                     // 0x1A0B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DamageCollisionInvincibleClaimantList;             // 0x1A10(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class ABP_SeeThroughJustDodgeCutin_C*         SasSeeThroughCutIn;                                // 0x1A20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bExecSasSeeThroughCutIn;                           // 0x1A28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78E8[0x3];                                     // 0x1A29(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SasSeeThroughCutinTimer;                           // 0x1A2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FFPlayerBattleVoiceFacialAnimType      BattleVoiceFacialAnimTypeCache;                    // 0x1A30(0x0012)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78E9[0x6];                                     // 0x1A42(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             BattleVoiceFacialAnimTypeDT;                       // 0x1A48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class USoundAtomCue*>                  GameOverVoiceData;                                 // 0x1A50(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	float                                         FallTimer;                                         // 0x1A60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         PsychicComboEndTimer;                              // 0x1A64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableChaseAttack_PsychicComboTimer;              // 0x1A68(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bBattleEm1500;                                     // 0x1A69(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78EA[0x6];                                     // 0x1A6A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             TutorialSuccess_Jump;                              // 0x1A70(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             TutorialSuccess_Psychic;                           // 0x1A80(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             TutorialSuccess_Lockon;                            // 0x1A90(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             TutorialSuccess_Attack;                            // 0x1AA0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             TutorialSuccess_Dodge;                             // 0x1AB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             TutorialSuccess_ChangeLockon;                      // 0x1AC0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             TutorialSuccess_LaunchAttack;                      // 0x1AD0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             TutorialSuccess_Dash;                              // 0x1AE0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             TutorialSuccess_StepInAttack;                      // 0x1AF0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             TutorialSuccess_PsychicCombo;                      // 0x1B00(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bTutorialFlag;                                     // 0x1B10(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bOldInAerial;                                      // 0x1B11(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bExecMeshFitGround;                                // 0x1B12(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78EB[0x1];                                     // 0x1B13(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SyncResultCounter;                                 // 0x1B14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDecideAttackMoveLocation;                         // 0x1B18(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78EC[0x3];                                     // 0x1B19(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AttackMoveParam_GoalLocation;                      // 0x1B1C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EJustDodgeAttackSlowStep                      JustDodgeAttackSlowStep;                           // 0x1B28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bJustDodgeSlowWeaonAttack;                         // 0x1B29(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78ED[0x2];                                     // 0x1B2A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JustDodgeAttackSlowTimer;                          // 0x1B2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         JustDodgeAttackTimeDilationParam;                  // 0x1B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ParamJustDodgeCutInTimeDilation;                   // 0x1B34(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         JustDodgeAttackSlowTime;                           // 0x1B38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78EE[0x4];                                     // 0x1B3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBP_NPCMetamorphosisComponent_C*        RefNPCMetamorphosis;                               // 0x1B40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         StartBattleWaitTime;                               // 0x1B48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaxStepHeightAtBeginPlay;                          // 0x1B4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             Dispatch_AreaChange;                               // 0x1B50(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	float                                         PossibleBrainCrashRange;                           // 0x1B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerInputSASReadyType                      CurrentInputSasReadyType;                          // 0x1B64(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78EF[0x3];                                     // 0x1B65(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFCombinationVisionData                CombinationVisionData;                             // 0x1B68(0x002C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CombinationVisionLearnLevel;                       // 0x1B94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UBP_EnpcDamageMoveComponent_C*          EnpcDamageMoveCompRef;                             // 0x1B98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableDispNoDamage;                               // 0x1BA0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bCanDropData;                                      // 0x1BA1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78F0[0x6];                                     // 0x1BA2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DisableBehaviorTreeClaimantNameList;               // 0x1BA8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         WeaponEmissiveValue;                               // 0x1BB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bNoCopyAttackFlag;                                 // 0x1BBC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78F1[0x3];                                     // 0x1BBD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StoredStealthDelayTimer;                           // 0x1BC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ERSAttackInputKind                            LastInputAttackTypeSub;                            // 0x1BC4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bStoreLockTargetBeforeBrainCrash;                  // 0x1BC5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bItemUseNoMotion;                                  // 0x1BC6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bUseDirectionControlForAI;                         // 0x1BC7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bFallAbleGroundCheckResult;                        // 0x1BC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bManageCheckFall;                                  // 0x1BC9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78F2[0x6];                                     // 0x1BCA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             TutorialSuccess_AttackSub;                         // 0x1BD0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bInputAttackSUb;                                   // 0x1BE0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bStopEndDriveMode;                                 // 0x1BE1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bReserveInitializeDrive;                           // 0x1BE2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bExecTelepoFadeOut;                                // 0x1BE3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	ERSAttackInputKind                            RegisterAttackKind;                                // 0x1BE4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bExecutedLibraryUpdate;                            // 0x1BE5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78F3[0x2];                                     // 0x1BE6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URSParticleSystemComponentBase*> EventEndParticleList;                              // 0x1BE8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	EVisibilityBasedAnimTickOption                VisibilityBasedAnimTickOptionDefault;              // 0x1BF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bExecuteCombinationAttack;                         // 0x1BF9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bSasAttackTelepoFlag;                              // 0x1BFA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78F4[0x1];                                     // 0x1BFB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SASSelectSlowRate;                                 // 0x1BFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ReserveDriveTime;                                  // 0x1C00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ReserveDriveExtendTime;                            // 0x1C04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             Dispatch_ItemApply;                                // 0x1C08(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bSkipResetEventAction;                             // 0x1C18(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78F5[0x7];                                     // 0x1C19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FF_AssultVisionRequestPool>     PoolAssultVisionRequest;                           // 0x1C20(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bUseMeshFootGroundFromFoot;                        // 0x1C30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bMeshFitChangeLocation;                            // 0x1C31(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsSpawn;                                           // 0x1C32(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78F6[0x1];                                     // 0x1C33(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnStartDistance;                                // 0x1C34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsSpawnNow;                                        // 0x1C38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78F7[0x3];                                     // 0x1C39(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnWaitDelayTime;                                // 0x1C3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SpawnStartDelayTime;                               // 0x1C40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SpawnUpdateTime;                                   // 0x1C44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	Enum_EnemySpawnState                          SpawnState;                                        // 0x1C48(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78F8[0x3];                                     // 0x1C49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnClaimantName;                                 // 0x1C4C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   SpawnCollisionProfileName;                         // 0x1C54(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EMovementMode                                 SpawnMovementMode;                                 // 0x1C5C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_78F9[0x3];                                     // 0x1C5D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             SpawnTimer;                                        // 0x1C60(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bInputLockTargetChanged;                           // 0x1C6C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78FA[0x3];                                     // 0x1C6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 BrainCrashHealPool;                                // 0x1C70(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         BrainCrashHealInterval;                            // 0x1C80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EWireNeonPlayerState                          CurrentWireNeonState;                              // 0x1C84(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EAttackDirOrthoLockon                         OptionAttackDirOrthoLockon;                        // 0x1C85(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EAttackDirOrtho                               OptionAttackDirOrtho;                              // 0x1C86(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ESASCutin                                     OptionSasCutin;                                    // 0x1C87(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         OptionAttackDirOrthoDistance;                      // 0x1C88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         OptionAutoAimOverwriteSpeed;                       // 0x1C8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class USoundAtomCue*>                  BrainCrashHealSoundPool;                           // 0x1C90(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<class UParticleSystem*>                BrainCrashHealEffectPool;                          // 0x1CA0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bInvisibleBFHood;                                  // 0x1CB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78FB[0x3];                                     // 0x1CB1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             BackbodyAttachmentDitherTimer;                     // 0x1CB4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bBackbodyAttachmentVisibility;                     // 0x1CC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78FC[0x3];                                     // 0x1CC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BadStatusCablePlayVoiceDelayTime;                  // 0x1CC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bBattleSimulatorMissionCancel;                     // 0x1CC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bBrainCrashSuccess;                                // 0x1CC9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          PhotoModeBackUp_IsHoodVisibility;                  // 0x1CCA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          PhotoMode_HoodVisibilityFlag;                      // 0x1CCB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	float                                         JustDodgeAttackTimeDilationCalc;                   // 0x1CCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         PhotoModeBackupBoundsScale;                        // 0x1CD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bInitializeMaxStepHeight;                          // 0x1CD4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_78FD[0x3];                                     // 0x1CD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoverAfterInvalidDamageTime;                     // 0x1CD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   RecoverAfterInvalidDamageClaimantName;             // 0x1CDC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void OnMovementCollisionLand__DelegateSignature();
	void OnChangePsychicObjShow__DelegateSignature(EPsychicGrabButtonType Button, bool bShow, int32 Count);
	void OnChangePsychicObjEnable__DelegateSignature(EPsychicGrabButtonType Button, bool bEnable);
	void OnChangePsychicObjUse__DelegateSignature(EPsychicGrabButtonType Button);
	void OnChangePsychicObjCount__DelegateSignature(EPsychicGrabButtonType Button, int32 Count);
	void OnChangePsychicObjShow2__DelegateSignature(bool Unique, bool Show, int32 Obj_count);
	void OnChangePsychicObjEnable2__DelegateSignature(bool Unique, bool Enable);
	void OnChangePsychicObjUse2__DelegateSignature(bool Unique);
	void OnChangePsychicObjCount2__DelegateSignature(bool Unique, int32 Count);
	void DispatchMontageBlendingOut__DelegateSignature(class UAnimMontage* Montage, bool bInterrupted);
	void OnTelepoDodgeBegin__DelegateSignature(class ARSBattlePlayer_C* Player);
	void OnTelepoDodgeEnd__DelegateSignature(class ARSBattlePlayer_C* Player);
	void DispatchChangeWalkRunStateKind__DelegateSignature(EPlayerWalkRunStateKind Kind);
	void DispatchMontageEnded__DelegateSignature(class UAnimMontage* Montage, bool bInterrupted);
	void DispatchAttackActorHit__DelegateSignature(const struct FHCHitResult& HitResult);
	void DispatchTimerPause__DelegateSignature(bool bPause);
	void DispatchTalkTurn__DelegateSignature(float LookAtAngle);
	void TutorialSuccess_Jump__DelegateSignature();
	void TutorialSuccess_Psychic__DelegateSignature();
	void TutorialSuccess_Lockon__DelegateSignature();
	void TutorialSuccess_Attack__DelegateSignature();
	void TutorialSuccess_Dodge__DelegateSignature();
	void TutorialSuccess_ChangeLockon__DelegateSignature();
	void TutorialSuccess_LaunchAttack__DelegateSignature();
	void TutorialSuccess_Dash__DelegateSignature();
	void TutorialSuccess_StepInAttack__DelegateSignature();
	void TutorialSuccess_PsychicCombo__DelegateSignature();
	void Dispatch_AreaChange__DelegateSignature();
	void TutorialSuccess_AttackSub__DelegateSignature();
	void Dispatch_ItemApply__DelegateSignature();
	void ExecuteUbergraph_RSBattlePlayer(int32 EntryPoint);
	void UnbindRecoverAfterInvalidDamage();
	void BindRecoverAfterInvalidDamage();
	void UnbindBadStatusCablePlayVoiceTick();
	void BindBadStatusCablePlayVoiceTick();
	void BndEvt__PlayerScript_K2Node_ComponentBoundEvent_6_PlayerStuckDelegate__DelegateSignature(const struct FVector& ImpactLocation);
	void BindMainMenuClose();
	void BndEvt__BP_TargetSearchComponent_K2Node_ComponentBoundEvent_5_ChangeTargetDelegate__DelegateSignature(class ARSCharacterBase* Target, bool bLockOn, bool bLostTarget);
	void UpdateNpcWarpDither(float DeltaSeconds);
	void UnbindNpcWarpDither();
	void BindNpcWarpDither();
	void ReceiveUnpossessed(class AController* OldController);
	void ReceivePossessed(class AController* NewController);
	void UnbindDeactivateBattleParticleTick();
	void BindDeactivateBattleParticleTick();
	void BndEvt__PlayerScript_K2Node_ComponentBoundEvent_0_PlayerRegenerateDelegate__DelegateSignature(int32 RegenerateHP);
	void OnChangeDisableBattleActionFlag(bool bDisable);
	void BndEvt__AttackInput_K2Node_ComponentBoundEvent_0_ComboInputEndDelegate__DelegateSignature(ERSAttackInputKind AttackInputKind);
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void InputAI_Psychic(bool bPressed);
	void OnFellOutOfWorld();
	void ReceiveChangeWalkRunStateKind(EPlayerWalkRunStateKind Kind);
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_1_BrainCrashAccessOffDelegate__DelegateSignature();
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_0_BrainCrashAccessOnDelegate__DelegateSignature();
	void BindBrainFieldBattleEnd(EBrainFieldEndType EndType);
	void BindBrainFieldBattleStart();
	void InputAI_UseItem(bool bPressed);
	void EventPhysicsIdling(float IdlingSec, float IdleRestoreDelay);
	void InputAI_Jump(bool bPressed);
	void OnReachNavLinkPoint(const struct FVector& Destination);
	void InputAI_Dodge(bool bPressed);
	void InputAI_LeftStick(float X, float Y);
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_1_BadStateOffDelegate__DelegateSignature(EHCBadState bad_state);
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_0_BadStateOnDelegate__DelegateSignature(EHCBadState bad_state, class AActor* Attacker);
	void InputAI_Attack(bool bPressed);
	void ReceiveMontageEnded(class UAnimMontage* Montage, bool Interrupted);
	void ReceiveMontageBlendingOut(class UAnimMontage* Montage, bool Interrupted);
	void ReceiveChangeAnimKind(EPlayerAnimKind NewKind, EPlayerAnimKind OldKind);
	void ReceiveTick(float DeltaSeconds);
	void ReceiveBeginPlay();
	void OnBonusGhostOneShot(float AliveTime);
	void OnBonusGhostFromDT(EBonusGhostType Type);
	void OnBonusGhost(float Time);
	void DebugTick();
	void BndEvt__CheatCommandListener_K2Node_ComponentBoundEvent_0_CheatCommandListenerDelegate__DelegateSignature(const class FName& CommandName, const class FName& ArgName);
	void OnBattleSimulatorEndTick(float DeltaSeconds);
	void UnbindBattleSimulatorEndTick();
	void BindBattleSimulatorEndTick();
	void OnBattleSimulatorMissionEnd(bool bMissionCancel);
	void EquipCostume(int32 CostumeId);
	void CheckHologramAttack(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	void EquipAttachment(EPlayerAttachment Param_Index, int32 AttachmentId);
	void SetEyeControlParameter(float Horizontal, float Vertical);
	void SetEyeControlEnable(bool bEnable, class FName ClaimantName);
	void UpdateParameter(const struct FCharactersParameterTable& Table);
	void EquipAccessory(EPlayerAccessory Param_Index, int32 AccessoryId);
	void EquipWeapon(int32 WeaponId, int32 SkinID);
	void SetAIOrder(EPlayerAIOrder Plan);
	void UnbindBrainCrashHeal();
	void BindBrainCrashHeal();
	void BndEvt__RSStateManage_Upper_K2Node_ComponentBoundEvent_1_EnterStateDelegade__DelegateSignature(int32 NewState, int32 Param);
	void BndEvt__RSStateManage_K2Node_ComponentBoundEvent_0_EnterStateDelegade__DelegateSignature(int32 NewState, int32 Param);
	void OnBrainCrashDead();
	void OnBrainCrashDamage();
	void OnBrainCrashEnd(bool bBeginActor, class UAnimMontage* PlayerEndMontage);
	void OnBrainCrashStart(bool bBeginActor);
	void OnEventBackbodyAttachmentDither(float DeltaSeconds);
	void UnbindEventBackbodyAttachmentDitherTick();
	void BindEventBackbodyAttachmentDitherTick();
	void BndEvt__BP_PlayerMaterialManageComponent_K2Node_ComponentBoundEvent_0_OnCompletedMaterialSetting__DelegateSignature(EPlayerMaterialManageType Type);
	void BndEvt__BP_PlayerDriveComponent_K2Node_ComponentBoundEvent_0_DriveNotifyParameterMax__DelegateSignature();
	void BndEvt__BP_PlayerDriveComponent_K2Node_ComponentBoundEvent_0_DriveNotifyBrainFieldStock__DelegateSignature(int32 StockNum, bool bItemUse, bool bNoEffect);
	void BndEvt__BP_PlayerDriveComponent_K2Node_ComponentBoundEvent_6_DriveGaugeMaxDelegate__DelegateSignature(ENotifyDriveEvent Reason);
	void BndEvt__BP_PlayerDriveComponent_K2Node_ComponentBoundEvent_5_ED_PlayStart__DelegateSignature(class AActor* User, bool bPlayStart);
	void BndEvt__BP_PlayerDriveComponent_K2Node_ComponentBoundEvent_0_ED_PlayFinish__DelegateSignature(class AActor* User, bool bPlayStart);
	void DM_SetMaterial(bool Value);
	void DM_PlayerOpenSwitch();
	void DM_SetVisibleUI(bool Enable);
	void DM_DamageEnemy();
	void DM_StartInputPlayer();
	void BndEvt__BP_PlayerDriveComponent_K2Node_ComponentBoundEvent_0_DriveSetDriveGaugeDelegate__DelegateSignature(float GaugeRate);
	void BndEvt__BP_PlayerDriveComponent_K2Node_ComponentBoundEvent_2_DriveRegenerateDelegate__DelegateSignature(float RegenerateHP);
	void BndEvt__BP_PlayerDriveComponent_K2Node_ComponentBoundEvent_1_DriveEndDelegate__DelegateSignature(bool bInterruption, bool bLocationChange);
	void BndEvt__BP_PlayerDriveComponent_K2Node_ComponentBoundEvent_0_DriveBeginDelegate__DelegateSignature();
	void BrainFieldOpenStart(class AActor* BrainFieldUser, bool IsAttacker);
	void BrainFieldMoveNormalField(class AActor* BrainFieldUser, bool IsAttacker, EBrainFieldEndType EndType);
	void BrainFieldCloseStart(class AActor* BrainFieldUser, bool IsAttacker, EBrainFieldEndType EndType);
	void BrainFieldOpenEnd(class AActor* BrainFieldUser, bool IsAttacker);
	void BrainFieldMoveBrainField(class AActor* BrainFieldUser, bool IsAttacker);
	void AfterTelepoTick(float DeltaSeconds);
	void UnbindTickAfterTelepo();
	void BindTickAfterTelepo();
	void OnReleaseWorldMap(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTriggerWorldMap(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseAssaultVision(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTriggerAssaultVision(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseCVRight(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTriggerCVRight(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseCVLeft(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTriggerCVLeft(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseSVDown(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTriggerCVDown(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseCVUP(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OntriggerCVUP(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseCVMENUCOPEN(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTriggerCVMENUOPEN(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseweaponAttackSub(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTriggerWeaponAttackSub(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseMoveRight(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgMoveRight(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseMoveLeft(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgMoveLeft(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseMoveBackward(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgMoveBackward(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseMoveForward(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgMoveForward(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseDPADEMU_DOWN(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgDPADEMU_DOWN(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseItemUse(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgItemUse(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseItemSelectR(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgItemSelectR(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseItemSelectL(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgItemSelectL(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseLockSwitchR(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgLockSwitchR(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseLockSwitchL(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgLockSwitchL(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseLockOn(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgLockOn(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseCameraReset(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgCameraReset(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleasePsychicField(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgPsychicField(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseBrainField(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgBrainField(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleasePsychicSpecial(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgPsychicSpecial(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnRelasePsychic(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgPsychic(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseJump(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgJump(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseAttack(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgAttack(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseDodge(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgDodge(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseAction(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgAction(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseSasPage(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgSasPage(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseSasStop(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgSasStop(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseSasR(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgSasR(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseSasL(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgSasL(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseSasD(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgSasD(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseSasU(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgSasU(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseSasMenuOpenClose(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgSasMenuOpenClose(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseL3(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgL3(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseL2(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgL2(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseL1(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgL1(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseR3(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgR3(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseR2(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgR2(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseR1(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgR1(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseRRIGHT(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgRRIGHT(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseRLEFT(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgRLEFT(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseRDOWN(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgRDOWN(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseRUP(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgRUP(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseLRIGHT(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgLRIGHT(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseLLEFT(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgLLEFT(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseLDOWN(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgLDOWN(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnReleaseLUP(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void OnTrgLUP(ERSGamepadLayoutType Layout, ERSGamepadInputName Key);
	void BindInputManager();
	void UnbindAccessoryInvalidDamageTick();
	void BindAccessoryInvalidDamageTick();
	void BrainTalk_FirstAttack();
	void BrainTalk_SameSAS(E_SASKindNative SasEffect, const int32 Num);
	void BrainTalk_FallHigh();
	void BrainTalk_ManyDied();
	void BrainTalk_BondsSpecialAttack(const EPlayerID HologramPlayerID);
	void BrainTalk_PsychicCombo();
	void BrainTalk_CoverDamage(const EPlayerID TakeOverCharacter);
	void BrainTalk_BeginBrainField();
	void BrainTalk_Drive();
	void BrainTalk_Revive(EPlayerID Param_RevivePlayer);
	void BrainTalk_ItemRecovery(EPlayerID TargetPlayer);
	void BrainTalk_BadStatus(EHCBadState BadStatus);
	void BrainTalk_FriendDead();
	void BrainTalk_FriendDying();
	void BrainTalk_BrainCrashChance();
	void BrainTalk_BrainCrashDefeated();
	void UnbindPsychicComboResetTick();
	void BindPsychicComboResetTick();
	void UnbindJustDodgeSlowTick();
	void BindJustDodgeSlowTick();
	void IsEnablePlaySpTrigger();
	void SetPsychicEmissionInterface(bool bON, class FName ClaimantName);
	void OnAnimNotifyInputPsychic();
	void SetStealth(bool Flag_in);
	void OnPsychicEnd(const struct FFSASPsychicParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnPsychicStart(const struct FFSASPsychicParam& Param, class AActor* Param_Owner);
	void OnCutInEnd();
	void OnCutInStart();
	void OnCopyEnd(const struct FFSASCopyParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnCopyStart(const struct FFSASCopyParam& Param, class AActor* Param_Owner);
	void OnStealthEnd(const struct FFSASStealthParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnStealthStart(const struct FFSASStealthParam& Param, class AActor* Param_Owner);
	void OnTelepoEnd(const struct FFSASTelepoParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnTelepoStart(const struct FFSASTelepoParam& Param, class AActor* Param_Owner);
	void OnSeeThroughEnd(const struct FFSASSeeThroughParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnSeeThroughStart(const struct FFSASSeeThroughParam& Param, class AActor* Param_Owner);
	void OnMetalEnd(const struct FFSASMetalParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnMetalStart(const struct FFSASMetalParam& Param, class AActor* Param_Owner);
	void OnFireEnd(const struct FFSASFireParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnFireStart(const struct FFSASFireParam& Param, class AActor* Param_Owner);
	void OnElectricEnd(const struct FFSASElectricParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnElectricStart(const struct FFSASElectricParam& Param, class AActor* Param_Owner);
	void OnAcceleratorEnd(const struct FAcceleratorParam& Parameter, class AActor* Param_Owner, float RemainTime, bool bHologram);
	void OnAcceleratorStart(const struct FAcceleratorParam& Parameter, class AActor* Param_Owner, bool bHologram);
	void OnStartSequencer(int32 IndexIn);
	void Em8200_UpdateMoveAssultAttack(int32 NewParam, int32 NewParam1, int32 NewParam2);
	void OnUnDiscovery();
	void OnDiscovery();
	void SetEmPosDiscover(const struct FVector& DiscoverPos);
	void UpdateOutRangeFade_Native(float ToTargetLenge, bool ForceDisp);
	void OnHitCrashVisionAttack();
	void UpdateMoveInputTriger();
	void OnChangeAnimKind(EPlayerAnimKind NewAnimKind, EPlayerAnimKind OldKind, bool* Dummy);
	void ProcessDirectionControll(float DeltaSeconds);
	void SetupAnimController(bool* Dummy);
	void OnTheWaterSurface(bool* Ret);
	void OnTheGroundSurface(bool* Ret);
	void InitializePlayer_DEPRECATED(class UClass* RenderSettingsClass);
	void OnDamageingForPlayer(const struct FHCHitResult& HitResult, float DamageValue);
	void OnDeadPlayerCore();
	void StartDamageAnimFunc(const struct FHCHitResult& HitResult, int32 DamageValue, bool IsDown, bool* Dummy);
	void ProcessLanded();
	void ProcessLandCheck(float DeltaSeconds);
	void GetHeadLocation(struct FVector* Location);
	void OnDamaging(const struct FHCHitResult& HitResult, float DamageValue, bool* Dummy);
	void OnDead(bool* Dummy);
	void SetBattling(bool bBattling, bool* Dummy);
	void CheatCommand_SetBattlePlayerAIMode(class FName AIMode);
	void ResetCamera(float ResetSec);
	void InputAttack(ERSAttackInputKind InputKind, bool bPress, bool* Return);
	void InitializeStateManager();
	void UpdateStateManager();
	void AddPlayerStatus(EPlayerCommonStatus PlayerStatus);
	void ClearPlayerStatus();
	void SubPlayerStatus(EPlayerCommonStatus PlayerStatus);
	void AddActionStatus(EPlayerActionStatus ActionStatus);
	void ClearActionStatus(bool* bDummy);
	void CheckInput(float DeltaSeconds, bool* Dummy);
	void CheckInputPsychic(bool* Dummy);
	void UpdateCameraRotate(float DeltaSeconds);
	void SetActionState(EPlayerActionKind Kind, int32 Param);
	void SetUpperActionState(EPlayerUpperActionKind Kind, int32 Param);
	void PreTick(float DeltaSeconds, bool* Dummy);
	void MainTick(float DeltaSeconds, bool* Dummy);
	void PostTick(float DeltaSeconds, bool* Dummy);
	void CheckDamageReaction();
	void OnAttackActorHit(const struct FHCHitResult& HitResult, bool* Dummy);
	void SubActionStatus(EPlayerActionStatus ActionStatus);
	void InitializeAttackComponent();
	void ItemApply(bool bRevive);
	void SetItemIdFromName(class FName ItemId);
	void InitializePlayer(EPlayerID ID);
	void RegisterCombo(EPlayerComboPattern Pattern);
	void UnregisterCombo(EPlayerComboPattern Pattern);
	void ComboSetting(EPlayerComboPattern First, EPlayerComboPattern Second, bool* Dummy);
	void EndCurrentAttack(ERSAttackInputKind Kind);
	void SetActionStatusFull();
	void AddUpperActionStatus(EPlayerUpperActionStatus ActionStatus);
	void SubUpperActionStatus(EPlayerUpperActionStatus ActionStatus);
	void ClearUpperActionStatus(bool* bDummy);
	void InitializeSAS(bool* bDummy);
	void Initialize();
	void OnRevive(bool* Dummy);
	void SetCharacterVisibility(bool bVisibility, bool* bDummy);
	void ThrowWeapon(EWeaponThrowType ThrowType, float Speed, float Range, float TargetSearchAngle, const struct FVector& Dir, bool* bDummy);
	void TakeBackWeapon(float Time, bool* bDummy);
	void OnBeginConnectEffect(class UParticleSystem* ParticleSystem, class FName ObjectName, EEffectConnectPoint SourceConnectPoint, class FName SourceSocketName, EEffectConnectPoint TargetConnectPoint, class FName TargetSocketName, class USoundAtomCue* PlaySound, bool* bDummy);
	void OnEndConnectEffect(class FName ObjectName, bool* bDummy);
	void UpdateConnectEffect();
	void UpdateDisableAction();
	void PrepareThrowWeapon(int32 WeaponIndex, EWeaponThrowType ThrowType, float Range, float TargetSearchAngle, bool* bOK, class ABP_WeaponBase_C** Weapon, class AActor** Target);
	void UpdateChangeBattle();
	void SetBattleReady(bool bReady, bool bForce, bool* bDummy);
	void OnChangeBattleReady(bool bBattle, bool* bDummy);
	void OnInitialize();
	void ForceWarp(const struct FTransform& Transform, float IdleRestoreDelay);
	void ThrowWeaponEnd(bool* bDummy);
	void BadStateEffectOnOil(bool* bDummy);
	void BadStateEffectOffOil(bool bNoMaterial, bool* bDummy);
	void BadStateEffectOnFlooded(bool* bDummy);
	void BadStateEffectOffFlooded(bool bNoMaterial, bool* bDummy);
	bool SetHoodVisible(bool Visible);
	void SetFootIKEnable(bool Enable, float BlendTime, bool* Dummy);
	void OnUpdateHUD();
	void PlayBlendAnimMontage(class UAnimMontage* UpperAnimMontage, class UAnimMontage* LowerAnimMontage, float PlayRate, class FName SectionName);
	void StopBlendAnimMontage(bool Upper, bool Lower);
	void SetActionStatusUpper();
	void GetAnimMontageFromSet(EPlayerAnimMontage AnimType, class UAnimMontage** Montage);
	bool SetEventVisible(bool Visible);
	void OnAttackWeakHit(const struct FHCHitResult& HitResult, bool* bDummy);
	void OnDestroy(bool* bDummy);
	void CheckExistActorToMoveDir();
	void WarpToTargetActor(class AActor* TargetActor, float Distance, TArray<float>& WarpCandidateAngle, bool bCheckGround, bool* bSuccess);
	void WarpToLocation(const struct FVector& Location, bool bCheckGround);
	void BeginSAS_Telepo(bool bLocationTelepo, float TargetDistance, float DisappearTime, class UParticleSystem* DisappearParticle, class FName SocketName, class UParticleSystem* DisappearParticleSecond, class FName SocketNameSecond, class UParticleSystem* TelepoParticle, class FName SocketNameTelepo, bool bOnlyWeapon, bool bNoCollision, bool bLocationTargetHeight, bool* bBegin);
	void EndSAS_Telepo(float AppearTime, class UParticleSystem* AppearParticle, class FName SocketName, class UParticleSystem* AppearParticleSecond, class FName SocketNameSecond, bool bNoDirection, class UParticleSystem* TelepoParticle, class FName SocketNameTelepo, bool* bEnd);
	void SetShadowEnable(bool bEnable, bool bOnlyWeapon, bool* bDummy);
	void SetHp(int32 HP, bool* bDummy);
	void SetPlayerHidden(bool Param_bHidden, bool bWeaponOnly, bool* bDummy);
	bool CalcAccumulationByDefence(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, float& RefCrashCapCheckRate, class AActor* AttackActor);
	float CalcCritical(float Critical, class AActor* DefenseActor, bool bAssassinAttack);
	float CalcFinalDamageByAttack(float Damage, class AActor* DefenseActor, const struct FHCSkillCommonInfo& SkillInfo);
	float CalcFinalDamageByDefence(float Damage, class AActor* AttackActor);
	bool OverwriteAttackCollisionInfo(struct FHCCollisionCommonInfo& RefCommonInfo, struct FHCSkillCommonInfo& RefSkill);
	bool IsCheckFriendlyFire(class AActor* HitActor);
	void OnPlayerAssetLoad();
	void AddCopyPlayer(class ABP_SASCopyPlayerActor_C* CopyPlayer);
	void CopyWeaponOn(float Time);
	void CopyWeaponOff(float Time);
	void UpdateMaterial_CopyWeapon();
	void UpdateMaterial();
	void SetCopyWeaponMaterialValue(float Value);
	void BulletFire(EBulletType Type, const struct FAttackCollisionInfoBP& CollisionInfo, class FName SkillName_CopyBullet, bool* bDummy);
	void CopyPlayerOnIndex(int32 Param_Index, float AppearTime, bool bAttachOriginal, class UAnimMontage* Montage, bool bWithSubWeapon, bool* bDummy);
	void CopyPlayerOffIndex(int32 Param_Index, float DisappearTime, bool* bDummy);
	void CopyPlayerOn(float AppearTime, bool* bDummy);
	void CopyPlayerOff(float DisappearTime, bool* bDummy);
	void EndBulletFire(EBulletType BulletType, bool* bDummy);
	void ClearActionStatus_Common(bool* bDummy);
	void SetSasStealth(bool Stealth_on_in, bool Hero_order_in, bool Check_delay, bool Check_ignore, bool No_sas_cancel_in, bool From_event_in, bool* Dummy);
	void OnDamageActorHit(struct FHCHitResult& HitResult, bool* Dummy);
	void SetHideSASOutline(bool bHide, class FName ClaimantName, bool* bDummy);
	void RevivePlayer(EPlayerReviveKind Kind, bool* bSuccess);
	void SetEnemyPlayerBattle(bool bBattle, bool bUseBrainField);
	void SetItemID(EConsumeItemID ItemId, bool bHelpPlayer);
	void ReserveUpdateHUD();
	void CopyPlayMontage(class UAnimMontage* Montage, float PlayRate, class FName SectionName);
	void CopyStopMontage();
	void DamageReaction(bool* Dummy);
	void SetDisableButtonInput(bool bDisable);
	void OnEventFadeOutCompleted();
	void BadStateOn(EHCBadState BadState);
	void BadStateOff(EHCBadState BadState);
	void InterruptSAS_Telepo();
	void SetReserveComboSetting();
	void IsEnableActionCounter(bool* Return);
	void SetEnableCounterAnim();
	void IsEnableCounterAnim(bool* Return);
	void CreateWeapon(bool* bDummy);
	void ENpcDead();
	void GetCharactersParameterTable(struct FCharactersParameter* Param);
	void GetCurrentUpperActionState(EPlayerUpperActionKind* Kind);
	void CheckHardenRestriction(EPlayerActionKind Action_kind_in, bool* Dummy);
	void OnInitializeDebug();
	void OnBrainFieldBattleStart();
	void OnBrainFieldBattleEnd(EBrainFieldEndType EndType);
	void OpenBrainFieldSetting(bool* bDummy);
	void CloseBrainFieldSetting(EBrainFieldEndType EndType, bool* bDummy);
	void OnBrainCrashAccessOn();
	void OnBrainCrashAccessOff();
	void SetReserveChangeCombo(bool Reserve);
	void IsEnableActionRecovery(bool* Enable);
	void UpdateAccessoryEffect();
	void OnInputTriggerDodge();
	void OnInputTriggerAttack();
	void OnInputReleaseAttack();
	void OnInputTriggerItemUse();
	void OnInputTriggerTargetLock();
	void BindInputEvent();
	void OnInputTriggerTargetLockChange(bool bLeft);
	void OnInputTriggerResetCamera();
	void OnInputTriggerBrainCrash();
	void OnInputTriggerCapture();
	void OnInputReleaseCapture();
	void OnInputTriggerSASReady();
	void OnInputReleaseSASReady();
	void OnInputTriggerLeftSAS();
	void OnInputTriggerRightSAS();
	void OnInputTriggerUpSAS();
	void OnInputTriggerDownSAS();
	void OnInputTriggerBrainField();
	void OnInputTriggerPsychic();
	void OnInputReleasePsychic();
	void OnInputTriggerPsychicSpecial();
	void OnInputReleasePsychicSpecial();
	void OnInputTriggerIntercept();
	void ClearEarlyInput(bool* bDummy);
	void SetDisableCameraControlTimer(float Time);
	void BrainCrashEventStart();
	void BrainCrashEventEnd(class UAnimMontage* Montage);
	void OnInputTriggerLaunchAttack();
	void OnInputReleaseLaunchAttack();
	void OnInputTriggerMapGimmick();
	void OnInputReleaseMapGimmick();
	void GetLockOnTargetInterface(class AActor** TargetActor);
	void DebugDrawMotionInfo();
	void GetAttackMotionPlayRate(float* PlayRate);
	void OnDriveRegenerate(float RegenerateHPRate);
	void OnBeginDrive(bool* Dummy);
	void OnEndDrive(bool bInterruption, bool bLocationChange, bool* Dummy);
	void DebugDrawDriveInfo();
	void ResetPsychicCombo(bool bNoRushAttack);
	void OnInputTriggerChangeSASSet();
	void OnInputTriggerBrainFieldPsychicUp();
	void OnInputTriggerBrainFieldPsychicLeft();
	void OnInputTriggerBrainFieldPsychicRight();
	void OnInputReleaseBrainFieldPsychicRight();
	void SetObstructPsychic(bool bSAS, bool bPsychic, bool bAttack, bool bDrive, bool bBrainCrash, class UAnimMontage* ObstructAnimation, class ULevelSequence* Param_ObstructSequencer);
	void ClearObstructPsychic();
	void SetActionStateObstructPsychic(bool* bDummy);
	void OnInputTriggerJump();
	void ClearPrecedeInput(bool* bDummy);
	void SetCoverDamagePlayer(EPlayerID InPlayerID, bool* bSuccess);
	void ResetCoverDamagePlayer();
	void ProcFellOutOfWorld();
	void OnInputTriggerRessurect();
	void OnInputReleaseRessurect();
	bool SetPlayerCameraMode(EPlayerCameraMode Mode);
	EPlayerCameraMode GetPlayerCameraMode();
	bool SetPlayerCameraViewTarget(float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	bool SetPlayerCameraFieldOfView(float FOV);
	float GetPlayerCameraFieldOfView();
	bool SetPlayerCameraLocation(const struct FVector& Pos);
	struct FVector GetPlayerCameraLocation();
	bool SetPlayerCameraRotation(const struct FRotator& Rot);
	struct FRotator GetPlayerCameraRotation();
	bool SetPlayerCameraDirection(const struct FVector& Pos);
	struct FVector GetPlayerCameraDirection();
	void GetMeshFitGroundCheckLocation(struct FVector* Location, float* CheckHeight);
	void OnInputTriggerAttackLongPress(bool bInAerial);
	void OnUpdateDriveHUD();
	void OnInputTriggerBackStepAttack();
	void OnInputReleaseBackStepAttack();
	void DamageBefore(bool IgnoreAutoSasMetal, bool* bDummy);
	void SubHardenTime(float SubTime, bool* bDummy);
	void GetHardenParameter(float* RateMin, float* RateMax, float* SubTimeMin, float* SubTimeMax);
	void CheckAutoStealth(bool* bSuccess);
	void DebugDrawStatus();
	void TraceLandCheck(float CheckHeight, bool* bLand, float* LandHeight);
	void DebugGetObjectAnimationName(class FText* AnimationName);
	void OnInputTriggerSASHologramAttack();
	void RegisterCurrentAttack(class UAttackComponentBaseBP_C* AttackComp);
	void UnregisterCurrentAttack(class UAttackComponentBaseBP_C* AttackComp);
	int32 GetWeakNumber();
	void DoEventStart(bool* bDummy);
	void DoEventEnd(bool* bDummy);
	void DoStaticEventStart(bool* bDummy);
	void DoStaticEventEnd(bool* bDummy);
	void DoDynamicEventStart(bool* bDummy);
	void DoDynamicEventEnd(bool* bDummy);
	void ApplySkill();
	void DoApplySkill(bool* bDummy);
	void OnBrainFieldMoveBrainField(bool* bDummy);
	void OnBrainFieldMoveNormalField(bool* bDummy);
	void OnBrainFieldOpenEnd(bool* bDummy);
	void OnBrainFieldCloseStart(bool* bDummy);
	void DebugDrawENPCMotionInfo();
	void DebugDrawMotionInfoCore();
	void DebugDrawPosition();
	void DoBattleSequencerStart(bool bSetEnemyEvent, bool bDriveSequence, bool* bDummy);
	void DoBattleSequencerEnd(bool bSetEnemyEvent, bool bDriveSequence, bool* bDummy);
	void UpdateCameraDither(float DeltaSeconds, bool Param_UseDither, float* CameraDither);
	void SetCameraDither(float SetDitherValue, bool* Dummy);
	void BindDispathers();
	void OnChangeAreaLoadStatus(EChangeAreaStatus Status, bool bIsChangeLocation);
	void AreaChangeBegin(bool* bDummy);
	void AreaChangeEnd(bool* bDummy);
	void SetTimerPause(bool bPause, class FName ClaimantName);
	void DoTimerPause(bool bPause, bool* bDummy);
	void OnEnterActionState(EPlayerActionKind NewState, int32 Param, bool* bDummy);
	void OnEnterUpperActionState(EPlayerUpperActionKind NewState, int32 Param, bool* bDummy);
	void BeginPsychicDither(class FName ParameterName, bool* bDummy);
	void EndPsychicDither(bool bNoInterp, bool* bDummy);
	void UpdatePsychicDither(bool* bDummy);
	void BeginDriveSequence(bool* bSuccess);
	void EndDriveSequence(bool* bSuccess);
	void OnChangedBondsLevel(EPlayerID TargetID, int32 NewLevel);
	void SetSeeThroughSetting(bool bEnable, class FName ClaimantName, bool* bDummy);
	void OnInputTriggerSASAllOff();
	void DoHPEvent(int32 NewHP, int32 PrevHP, bool* bDummy);
	void OnEquipSAS(E_SASButton Button, E_SASKindNative Kind);
	void SASCancelAll(bool bCancelCost);
	void OnDriveGaugeMax(ENotifyDriveEvent Reason, bool* bDummy);
	void RegisterInVisionFog(class FName ClaimantName);
	void UnregisterInVisionFog(class FName ClaimantName);
	void InitializeWireNeon();
	void SetWireNeon(EWireNeonPlayerState NewState, bool bForce);
	void InitializeBattleParticle();
	void SetBattleParticleColor(struct FFPlayerBattleParticleData& Data);
	void GetAnimNotifyCondition(int32 ConditionNo, bool* Result);
	void SpawnForceBrainTalkModeParticle();
	void DestroyForceBrainTalkModeParticle();
	void SetPlayerCapsuleSize(EPlayerCapsuleSize Size);
	void DeactivateBattleParticle();
	void DelayDeactivateBattleParticle(float DeltaSeconds);
	void InitializeDriveParameter();
	void DoTalkEventEnd(bool* bDummy);
	void OnBrainFieldOpenStart(bool* bDummy);
	void InputTriggerAssassinAttack();
	void GetActiveSASNum(int32* Num);
	void OnDriveNotifyBrainFieldStock(int32 InNum, bool bItemUse, bool bNoEffect, bool* bDummy);
	void SetEventSprint(bool bEnable);
	void OnInputTriggerItemSelect(bool bRight);
	void OnInputTriggerItemSelectLeft();
	void OnInputTriggerItemSelectRight();
	void OnInputTriggerPsychicField();
	void OnInputReleasePsychicField();
	void OnPossesController(class AController* Param_Controller);
	void OnUnpossesController(class AController* Param_Controller);
	void OnAreaChange(bool bChangeLocation, bool* bDummy);
	void InitializeDataTable();
	void SetCapsuleCollisionPreset(bool bNpc);
	void OnBrainFieldMoveBrainFieldOther(bool bFriendField, bool* bDummy);
	void OnBrainFieldMoveNormalFieldOther(bool bFriendField, bool* bDummy);
	void SetAsyncParameter();
	void SetBrainCrashDamage();
	void UpdateAttachment();
	void EventRevivePlayer();
	void AfterInitialize();
	void AttackMoveBegin_RotateTarget(float Distance, float Time, EEasingFunc EaseType, float EaseBlendExp, bool* bSuccess);
	void AttackMoveUpdate_RotateCircle(float DeltaSeconds, bool* bEnd);
	void BadStateIconOn(const struct FBadStateAddParticleData& Data, class UParticleSystemComponent** Handle);
	void OnSetStealthMode(bool bStealth, bool* bSuccess);
	void BadStateEffectOnFlame(bool* bDummy);
	void BadStateEffectOnElec(bool* bDummy);
	void OnAreaChangeFadeOut(bool bChangeLocation);
	void BindSASStartEventForENPC();
	void StartENPCSAS(EPlayerID SAS_PlayerID);
	void ChangeWeaponMesh(int32 WeaponId, int32 SkinID, bool* bDummy);
	void InitializeContentsOpen();
	void OnContentsOpen(EContentsOpening Contents, bool bOpen);
	void ResetPlayerActionState();
	void AttackMoveBegin_ToTarget(float MoveTime, class AActor* MoveTarget);
	void AttackMoveUpdate_ToTarget(float DeltaSeconds, bool bAerial, bool* bEnd);
	void ClearAttackMoveParam();
	void SetCheckChargeTelepo(bool bCheck);
	void SetPlayerSuperArmor(bool bON, class FName ClaimantName);
	void GetDummyTest(bool* Dummy);
	void Is_Unique_Effective_Sas(class AActor* AttackActor, bool* IsEffectiveSas, float* WinceRate, float* KnockBackRate, float* DownRate, float* CrashRate);
	void OnChangedInputDevice(ERSInputDeviceType Device);
	void EndDriveMode(bool bInterruption, bool bLocationChange);
	void CheckTelepoDodge(bool* bTelepo);
	void SetBodyMaterialScalarParameter(class FName ParameterName, float ParameterValue);
	void SetBrainCrashReceive();
	void ParameterApplyDrive();
	void SetAccessoryInvincibleDamageAfter(bool bEnable);
	void UpdateAccessoryInvalidDamageAfter(float DeltaSeconds);
	void InitializeParameterFromPlayerInfo();
	bool CheckEmphasisCrashGauge(const struct FHCHitResult& HitResult);
	void AjitoSetting(bool bInAjito);
	void DebugBattleParticleClaimantListOutput();
	void SetExecNpcRevive(bool bExec);
	void SetInvalidKeepOut(bool IsInvalid);
	void PlaySoundBattleVoice(EPlayerBattleVoiceType Voice);
	void PlayBattleStartVoice();
	void IsBrainTalkAble(bool* bTalk);
	void DoDynamicEventBeforeBindCharacter(bool* bDummy);
	bool BattleSequencerStart(bool IsSetEnemyEvent, bool bDriveSequence);
	void DoTalkEventStart(bool* bDummy);
	void PlayPsychicComboCaptureSE(bool* bDummy);
	void StopPsychicComboCaptureSE(bool* bDummy);
	void ChangeCostumeMesh(int32 CostumeItemID);
	void Is_Accumulating_Attacks(bool* Result);
	void GetAsyncCopyParameter(bool* bCheckCopy, struct FVector* Right, struct FVector* Left);
	void SetDelayDeath(bool* Dummy);
	void SetDamageCollisionInvincible(bool bInvincible, class FName ClaimantName);
	void InitializeSasSeeThroughCutIn();
	void GetGameOverVoiceData(int32 VoiceNo, class USoundAtomCue** VoiceData);
	void EnpcDyingEvent();
	void FallInsureProc(float DeltaSeconds);
	void PreTickInput(float DeltaSeconds);
	void AttackMove_AerialTargetLocation(struct FVector* MoveLocation);
	void OnChangeSasEquipStatus(E_SASKindNative Kind, ESASEquipStatus Status);
	void ApplySASEffectPassive(E_SASKindNative Kind, bool* bDummy);
	void ApplySASEffectPassiveAll(bool bLinkAbleOnly, bool* bDummy);
	void ApplySASEffectActive(E_SASKindNative Kind, bool bActivate, bool* bDummy);
	void InitializePreAssetLoad();
	void OnBeginBattleField();
	void PsychicComboResetTimer();
	void TickPsychicComboResetTimer(float DeltaSeconds);
	void OnEnemyPlayerBattle(bool bBattle, bool bUseBrainField, bool* bDummy);
	void SetTutorialMode(bool bTutorial);
	void SetTutorialRestictPsychic(bool bRestrict);
	void SetTutorialRestictAttack(bool bRestrict);
	void WaitLastKarenEvent(bool bWait);
	void IsEnableLastKarenEvent(bool* bEnable);
	void OnInputTriggerLockChangeLeft();
	void OnInputTriggerLockChangeRight();
	void BattleSequenceBadStatusEffectOff();
	void BattleSequenceEndBadStatusEffectOn();
	void UniqueAttackHitEffect(struct FHCHitResult& HitResult, bool* bDummy);
	void OnUpdateParameter(struct FCharactersParameterTable& Table);
	void MeshFitGround(float InterpSpeed, float AngleLimit, bool bEndFit, bool* bDummy);
	void CancelMeshFitGround(bool* bDummy);
	void TickJustDodgeAttackSlow(float DeltaSeconds);
	void BeginJustDodgeAttackSlow(bool bWeaponAttack, bool bCutIn, float SlowTimeDilation, float SlowTime);
	void EndJustDodgeAttackSlow();
	void JustDodgeAttackSlowWeaponAttackSetting();
	bool SetActorAllTickEnabled(bool bEnabled);
	void FinishBattleStartTimer();
	void SetNoCollisionAndStopAiFade(bool bNoColAndStopAi, bool* Dummy);
	bool CalcAccumulationByAttack(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, float& RefCrashCapCheckRate, class AActor* DefenseActor, EHCSkillAttackType AttackType, bool bCopyActor, const struct FHCSkillCommonInfo& SkillInfo);
	void FrameDamage(float Sec);
	void PlayVibrationByDamageReaction(EPlayerDamageKind DamageKind);
	void SetCharacterMovementPerchRadiusThreshold();
	void CheckNeedItemUse(EConsumeItemID ItemId, bool* bOK);
	void SetPlayerHitEffectPriority();
	void OnBeginUseItem(EConsumeItemID ItemId, bool bIsNpc);
	void SetBattleDamage3D(class AHUDMainGame_C* HUD, int32 Damage, const struct FVector& Position3D, bool Param_IsPlayer, bool IsCritical, bool IsSasCritical, bool IsBrainCrashCritical, bool IsHeal, bool IsWeak, bool IsNoDamage, class ARSBattleCharacter_C* CrushTarget, int32 CrushBonus, const struct FVector2D& Offset);
	void ApplyNpcDrive();
	void OnEndDamageCalcArray();
	void OnInputSasReady(EPlayerInputSASReadyType ReadyType);
	void OnInputTriggerCombinationVisionLeft();
	void OnInputTriggerCombinationVisionRight();
	void OnInputTriggerCombinationVisionUp();
	void OnInputTriggerCombinationVisionDown();
	void InputCombinationVision(E_SASKind Kind);
	void CheckExecuteNotifyKind(class AActor* Param_Owner, ECharaExecuteNotifyKind ExecuteKind, bool* IsExecute);
	void CheckCombinationVisionCost(E_SASKind Kind, bool* bOK);
	void GetCombinationVisionCost(E_SASKind Kind, float* Cost);
	bool CheckAttractSelf(const struct FHCHitResult& HitResult);
	void SetNeonNotifyActionFailed();
	void SubCombinationVisionCost(EPlayerID HologramPlayerID, bool* bDummy);
	void SetEnableDispNoDamage(bool bEnable, bool* bDummy);
	void InitializeSasStealth();
	void RestartFootIK(float BlendTime);
	void GetDirectAttackWpPrimitive(class UPrimitiveComponent** OutPrimitive);
	bool SetHiddenCharacterAttachment(bool NewHidden);
	void SetDisableBehaviorTreeByClaimantName(class FName ClaimantName, bool bDisable);
	bool StopBehaviorTree(bool bTickDisable);
	bool RestartBehaviorTree(bool bTickEnable);
	void OnInputTriggerAttackSub();
	void OnInputTriggerAttackLongPressSub(bool bInAerial);
	void OnInputReleaseAttackSub();
	void CheckNoDamagePopUpFromAttacker(bool* bNoPopUp);
	void ClearLockTarget();
	void CheckLockTargetOutOfBattleField(bool* bLockReleased);
	void CheckNpcDrive_EnpcDamageReaction();
	void SetUseDirectionControlForAI(bool bUse);
	void BeginManageCheckFall();
	void EndManageCheckFall();
	void UpdateWeaponVisibilityForEventEnd();
	bool EventManagerEnd(bool RestoreEnableTick, bool RestoreVisibility);
	bool IsPsychicFieldDamageRateToBoss();
	void ChargeSASRemainTime(float ChargeRate);
	void SetStopEndDriveMode(bool FlagIn);
	void OnInitializeHUD(bool* bDummy);
	void ReserveInitializeDriveMode();
	void TelepoFadeOut();
	void TelepoFadeIn(bool bInterrupt);
	void IsCheckTelepoFade(bool* bFade);
	void RegisterEventEndParticle(class URSParticleSystemComponentBase* Particle);
	void StopEventEndParticle();
	void UpdateBattleParticleForEventEnd();
	void ResetVisibilityBasedAnimTickOption();
	void UpdateIgnoreCheckFallFlag();
	void SetExecCombinationAttack(bool bExecute);
	void SetOverwriteSasAttackTelepo(bool bOverwrite);
	void SetCanDrop(bool IsCanDrop);
	void SetTelepoCapsuleCollisionPreset(bool bAttack);
	void On_Sas_Select_Slow(bool bSlow);
	void OnCancelSASCutin(E_SASKind SasKind);
	void SetEventDownParam(EPlayerDownType InDownType);
	bool BattleSequencerEnd(bool IsRestoreTransform, bool IsSetEnemyEvent, bool bDriveSequence);
	void IsPlayingSasSeeThroughCutin(bool* bPlaying);
	void GetPsychicObjectThrowParameter(bool* Apply, float* Directshot_throw_speed, float* Directshot_homing_speed, float* Combo_throw_speed, float* Combo_homing_speed, float* brainfield_throw_speed, float* brainfield_homing_speed, float* Intercept_throw_speed, float* Intercept_homing_speed);
	void SetMeshFitGroundFromFoot(bool bUse);
	void CalcMeshFitGroundVector(struct FVector* UpVector);
	void ResetFlyingCombo();
	void InitSpawnEnpc();
	void UpdateSpawnEnpc(float DeltaSec);
	void OnWaitSpawnStateEnpc(bool bOver);
	void OnStartSpawnStateEnpc(bool bOver);
	void OnUpdateSpawnStateEnpc(bool bOver);
	void SetDeadBeforeHitResultByDirectAttack(const struct FHCHitResult& HitResult);
	void SetCastShadowDeadStaging(bool InNewCastShadow);
	void UpdateDeadStaging(float ParamValue, bool bDestroy);
	void OnMainMenuClose();
	void HealHP(float HealRate, bool bPopupUI, class UParticleSystem* Effect, const struct FVector& EffectScale, class USoundAtomCue* Sound, bool bRevive, bool bRandomLocation);
	void ReserveBrainCrashHeal(float HealRate, class UParticleSystem* Effect, class USoundAtomCue* Sound);
	void BeginBrainCrashHeal();
	void TickBrainCrashHeal(float DeltaSeconds);
	void FlushBrainCrashHeal();
	float GetMaxDamageRateLimit();
	float GetMaxCrashScaleLimit();
	void GetNexusDriveHardenSubTimeRate(float* Rate);
	void IsEnableDirectionControl(bool* bEnable);
	void ApplyOptionParameter();
	void OnInputTriggerSASHologramAttackManual();
	void IsEnableSasCableExColor(E_SASKind SasKind, bool* bEnable);
	void SetChargeLevelForNexusDrive(int32 ChargeLevel, bool* bDummy);
	void OnSimulatorStartDirectionOpen();
	void OnSimulatorStartDirectionClose(float MoveDelaySec);
	bool EventInputRestrictNative(bool Restrict);
	void OnBackGroundStuck(const struct FVector& ImpactLocation);
	void TickEventBackbodyAttachmentDither();
	void BadStatusCablePlayVoiceTick(float DeltaSeconds);
	class FName GetPhotoModeDitherDataName();
	bool BeginPhotoMode();
	bool EndPhotoMode();
	void SetPhotoModeHood(bool bVisible);
	void IsVisiblePhotoModeHood(bool* bVisible);
	void RecoverAfterInvalidDamageTick(float DeltaSeconds);
	void SetLookAtEnable(bool bEnable, bool* bResult);
	void SetEventLookAtLocation(bool bEnable, const struct FVector& LookAtLocation, bool* bDummy);
	void SetEventLookAtActor(bool bEnable, class AActor* LookAtActor, bool* bDummy);
	void EnableRigidBody(bool bEnable, float LerpTime, bool* bDummy);
	void SetPlayerActionSAS(bool* bDummy);
	void SetPlayerBattle(bool bBattle, bool* bDummy);
	void SetSASCodeVisible(bool bVisible, bool* Dummy);
	void SetBrainCodeVisible(bool bVisible, bool bDrive, bool* bDummy);
	void StartSASCode(E_SASKind SasKind, bool* bDummy);
	void SetSASCodeParam(float Param, bool* bDummy);
	void GetBrainCodeActorList(TArray<class ABP_CableBase_C*>* CodeList);
	void GetSASCodeActorList(TArray<class ABP_CableBase_C*>* CodeList);
	void GetBrainFieldTimeRate(float* Rate);
	void IsOpenBrainField(bool* bOpen);
	void PlaySASCodeDirection(ERSCableGravityType Type, bool* bDummy);
	void StopSASCodeDirection(ERSCableGravityType Type, bool* bDummy);
	void ResetSpecialEffects(bool* bDummy);
	void SetPlayerActionAfterEvent(EParamAfterEventAction Param, bool* bDummy);
	void GetSAS_Kind(E_SASButton Button, E_SASKind* Kind);
	void PlayerCameraReset(float InterpSec, bool* Dummy);
	void ForceWarp_Interface(const struct FTransform& Transform, float IdlingSeconds, bool* Dummy);
	void SetPsychicObjectEnableRange(bool Is_Brain_Field_in, float* Range);
	void GetCanAnimOverrideSASColor(bool* Enabled);
	void SetCanAnimOverrideSASColor(bool Enable, bool* Dummy);
	void AddPsychicFlyObj(class ABP_PsychicObjectBasic_C* FlyObj, bool* Dummy);
	void GetPsychicFlyObj(TArray<class AActor*>* FlyObj);
	void AddHitPsychicFlyObj(class ABP_PsychicObjectBasic_C* HitFlyObj, bool* IsAdd);
	void IsUseFog(bool* IsFog);
	void IsEnpcBarrier(bool* IsBarrier);
	void CanBattleAction(EPlayerAIBattleThinkType ThinkType, bool* CanAction);
	void GetENpcKind(ENpcKind* ENpcKind);
	void IsDodgeTargetRot(bool* Param_IsDodgeTargetRot);
	void GetDodgeScale(float* DodgeScale);
	void IsSpecialDown(bool* IsSpDown, float* SpDownWince);
	void GetSpecialDownTimer(float* SpDownTimer);
	void ChangeENpcKind(ENpcKind ENpcKind, bool* Dummy);
	void GetSkillCoreDropProbability(float* Probability);
	void CanSpecialMoveTrigger(bool* CanDo);
	void ReturnMetamorphosis(const struct FVector& Location, const struct FRotator& Rotation, class ARSBattlePlayer_C* SpecifyPlayer, bool* Dummy);
	void OnAttackedEnemyDead(ECharaDeadType DeadType, bool* Dummy);
	void CanEnpcOpenBrainField(bool* CanDo);
	void EnpcBarrierHitNotify(const struct FHCHitResult& Result, bool* Dammy);
	void CreateRedCode(bool* NewParam);
	void DestroyRedCode(bool* NewParam);
	void CheckStickInputTurn(bool* bTurn);
	void GetEnableRigidBody(bool* Enable);
	void SetPlayerInputRestriction(EPlayerInputRestrictionType Type, bool bRestriction, bool* bDummy);
	void IsJumpAreaAble(bool* bAble);
	void IsEnableInputPsychicCombo(bool* bEnable);
	void IsIntense(bool* bIntense);
	void IsEnableSeeThrough(bool* bEnable);
	void SetTalkLookAtTurn(const struct FVector& LookAtLocation, bool* bDummy);
	void EndTalkLookAtTurn(bool* bDummy);
	void EnableUseSeeThrough(bool* bEnable);
	bool CheckTargetableCharacterENPC(class ARSCharacterBase* Chara);
	void RequestBrainFieldHelp(bool* bDummy);
	void SetNpcBrainFieldDrive(bool bDrive, bool* bDummy);
	void OnAnimNotify_EnpcSAS(E_SASKind Kind, bool* bDummy);
	void BeginEnpcSAS(E_SASKind Kind, bool* bDummy);
	void CheckAssassinAttack(EAssassinAttackHit Type, class ARSBattleCharacter_C* DamagedActor, bool* bSuccess, bool* bArmorBreak);
	void ResetCollisionOverlap(bool* bDummy);
	void PlayBrainFieldBattleTalk(bool* bDummy);
	void IsDriveMode(bool* bDrive);
	void EventInputRestrict(bool bRestrict, bool* bDummy);
	void EventInputRestrictAction(bool bRestrict, bool* bDummy);
	void SuspendPlayer(bool* bSuspend);
	void ResumePlayer(bool* bResume);
	void FinishMetamorphosisLastAttack(bool* Dummy);
	void IsEnableCreateCopy(bool* Enable);
	void OnStartReactionChance(bool* Dummy);
	void OnStartEnpcDrive(bool* Dummy);
	void GetReactionChanceEndAction(EPlayerAIBattleThinkType* EndAction);
	void SelectReactionChanceEndAction(const TArray<EPlayerAIBattleThinkType>& InEndAction, EPlayerAIBattleThinkType* OutEndAction);
	void SetNpcWarpDither(bool* bDummy);
	void IsExecNpcRevive(bool* bExec);
	void IsMainPlayer(bool* bMainPlayer);
	void NotifyKillEnemy(class ARSBattleCharacter_C* KillActor, bool* bDummy);
	void DisablePlayerFootIK(bool bDisable, class FName ClaimantName, float BlendTime, bool* bDummy);
	void ElevatorSetting(bool bInElevator, bool* bDummy);
	void IsEnableDrive(bool* Enable);
	void IsEnableRegistSAS(bool* Enable);
	void IsActiveEnpcSasFire(bool* IsActive);
	void IsActiveEnpcSasElectric(bool* IsActive);
	void IsActiveEnpcSasTeleport(bool* IsActive);
	void SetDisableActionBoringIdle(bool bDisable, bool* bDummy);
	void UpdatePlayerActionAfterEvent(EParamAfterEventAction EventAction, bool* Return);
	void EnablePlaySpTrigger(bool bEnable, bool* Return_);
	void SetEnpcSasStealthStart(bool* Dummy);
	void SetEnpcSasStealthEnd(bool* Dummy);
	void BattleSettingEm1500(bool bBattle, bool* bDummy);
	void SetAttackHitStop(class AActor* DamagedActor, const struct FHCHitResult& HitResult, bool* bDummy);
	void BeforeCutSceneEventManagerStart(bool* bDummy);
	void CheckBattleStartTimer(bool* Enable);
	void StoreLockTargetInterface(bool* bDummy);
	void RestoreLockTargetInterface(bool* bDummy);
	void ProcEndBrainCrash(int32 CrashTargetNum, bool* bDummy);
	void AddBattleBonusInterface(EBattleBonusAddType Type, bool* bDummy);
	void IsEnableDriveAttack(bool* Enable);
	void SetDriveAttacked(bool* Dummy);
	void SetAttackCollisionDelayTime(const TArray<float>& AttackDelayTime, bool* Dummy);
	void DebugNextBattleThinkLog(const struct FFPlayerAIBattleThinkTransitionData& InTransitionData, bool* Return);
	void SASCancelEffectAndSEInterface(bool bEffect, bool bSE, bool* bDummy);
	void IsOverwriteAttackAutoAimSpeed(bool* bOverwrite, float* Speed);
	void GetAllSasCodeList(TArray<class ABP_CableBase_C*>* NormalCode);
	void IsNexusDriveSeeThroughBestJustDodge(bool* bBestJustDodge);
	void SetPlayerPhysicsIdlingInterface(float IdlingSeconds, bool bRefreshSkin, bool* bDummy);
	void SetMoveMode(EPlayerAIMoveMode Mode, bool* Dummy);
	void SetEnableInputStick(bool bEnable, bool* Dummy);
	void ResetBattleThink(bool* Dummy);
	void NextBattleThink(bool* Dummy);
	void OnChangeBattleThink(EPlayerAIBattleThinkType NextThinkType, EPlayerAIBattleThinkType PrevThinkType, bool* bDummy);
	void SetAIMoveStick(bool bMoveStick, bool* bDummy);
	void AimEndAI(bool* bDummy);
	void AimStartAI(bool* bDummy);
	void IsUseItemThink(bool* Result);
	void IsInputAI_UseItem(bool* bON);
	void SetEventMove(TArray<struct FVector>& Pos_list_in, TArray<float>& Radius_list_in, bool Walk, bool bAfterWait, float MaxMoveTime, bool* Dummy);
	void GetEventMovePosActor(class AActor** Actor, float* Radius);
	void CheckEventMovePos(bool* Goal);
	void IsSelfRecovery(bool* bResult);
	void NotifyResetBehaviorTree(bool* Dummy);
	void SearchAIPsychicObject(bool* bFiound);
	void CheckAIPsychicObject(bool bCapture, bool bAttack, bool* bOK);
	void IsInputAI_Psychic(bool* bON);
	void IsPsychicAble(bool* bEnable);
	void SetMoveStickBack(bool bBack, bool* bDummy);
	void SetEventWait(bool* bDummy);
	void EndEventWait(bool* bDummy);
	void IsUniqueConditionTransition(int32 UniqueNo, bool* bResult);
	void RestartBattleAI(bool* bDummy);
	void IsBattleActionStartAI(bool* bStart);
	void IsTargetCanBeAttacked(bool* CanDo);
	void CancelUseItem(bool* bDummy);
	void BehaviorTreeTaskExit_Attack(EPlayerAIBattleThinkTypeCPP ExitThinkType, bool* bDummy);
	void GetCurrentBattleThinkInterface(EPlayerAIBattleThinkTypeCPP* ThinkType);
	void ResetWeaponMaterialColor_PsychicEmission(class FName ClaimantName, bool* bDummy);
	void ResetWeaponMaterialAlpha_PsychicEmission(class FName ClaimantName, bool* bDummy);
	void SetWeaponMaterialAlpha_PsychicEmission(float Alpha, class FName ClaimantName, bool* bDummy);
	void SetWeaponMaterialColor_PsychicEmission(float R, float G, float B, class FName ClaimantName, bool* bDummy);
	void SetWeaponEmissive(float Emissive, bool* bDummy);
	void SetWeaponEmissiveColor(E_SASKind SasKind, bool* bDummy);
	void ResetWeaponEmissiveColor(E_SASKind SasKind, bool* bDummy);
	bool CheckJumpCount();
	bool IsActiveSAS_Telepo();
	bool IsActiveSAS_Stealth();
	bool IsActiveSAS_SeeThrough();
	bool IsActiveSAS_Psychic();
	bool IsActiveSAS_Metal();
	bool IsActiveSAS_Fire();
	bool IsActiveSAS_Electric();
	bool IsActiveSAS_Copy();
	bool IsActiveSAS_Accelerator();
	bool CheckRareArrangeItemBySAS();
	bool IsAIPlayer();
	bool OpenBrainField();
	bool CloseBrainField(bool bCrash);
	bool IsInputOverwriteENPCBrainField();
	bool IsAbleOverwriteENPCBrainField();
	ERSPartyPlayerKind SetPartyPlayerKind(ERSPartyPlayerKind Kind);
	bool OnAnimNotifyEnableAction();
	void EndControlPsychicObject(class AActor** TargetActor);
	void BeginControlPsychicObject(class AActor** TargetActor);
	bool SetPlayerCamera(class ACameraActor* PCameraActor, bool bPitch, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	bool CheckFriendCoverDamage(float DamageValue);
	float BeforeTakeDamage(float DamageValue, const struct FHCHitResult& HitResult);
	void GetCurrentSASGaugeRate(E_SASButton SASButton, float* SASGaugeRate);
	void GetSASActiveSeconds(E_SASButton SASButton, float* RemainingSec);
	void GetSAS_MaxActiveSeconds(E_SASKindNative SasKind, float* ActivationSeconds);
	bool SetEventEndDown(bool bFront);
	bool IsEnableSASHologramAttack(ESASHologramAttackTiming Timing);
	bool IsEnableSASEffectHologram(EPlayerID PlayerId);
	EPlayerActionKind GetCurrentActionStateInterface();
	bool ClearBattleParticle(class FName ClaimantName, bool bForceClear);
	bool SpawnBattleParticle(class FName ClaimantName);
	bool SetBattleParticleType(EPlayerBattleParticleType Type);
	bool OnAnimNotifyEnablePsychic();
	bool OnAnimNotifyEnableAttack();
	struct FPlayerInfo UpdateMenuParameter(const struct FPlayerInfo& CurrentParameter);
	bool IsEnableCheckActionIcon();
	bool IsEnableBackStepAttack();
	bool IsEnableSASCoverDamageFromPlayerID(EPlayerID CoverPlayerID);
	bool SetMoveStickBack_CallFromCPP(bool bBack);
	bool SetMoveMode_CallFromCPP(EPlayerAIMoveModeCPP MoveModeCPP);
	bool SetEventWait_CallFromCPP();
	bool SetEnableInputStick_CallFromCPP(bool bEnable);
	bool SetAIMoveStick_CallFromCPP(bool bMoveStick);
	bool SearchAIPsychicObject_CallFromCPP();
	bool RestartBattleAI_CallFromCPP();
	bool ResetBattleThink_CallFromCPP();
	ERSAttackInputKind OverwriteAttackInputKindAI_CallFromCPP(EPlayerAIBattleThinkTypeCPP Think, ERSAttackInputKind Kind);
	bool OnChangeBattleThink_CallFromCPP(EPlayerAIBattleThinkTypeCPP Next, EPlayerAIBattleThinkTypeCPP Prev);
	bool NotifyResetBehaviorTree_CallFromCPP();
	bool NextBattleThink_CallFromCPP();
	bool IsUseItemThink_CallFromCPP();
	bool IsUniqueConditionTransition_CallFromCPP(int32 UniqueNo);
	bool IsSelfRecovery_CallFromCPP();
	bool IsPsychicAble_CallFromCPP();
	bool IsPlayerStatusAI_CallFromCPP(EPlayerCommonStatus Status);
	bool IsInputAI_UseItem_CallFromCPP();
	bool IsInputAI_Psychic_CallFromCPP();
	bool IsBattleThinkParam_CallFromCPP(EPlayerAIBattleThinkParamCPP Param);
	bool IsBattleThink_CallFromCPP(EPlayerAIBattleThinkTypeCPP Type);
	bool IsBattleActionStartAI_CallFromCPP();
	bool IsAIMoveMode_CallFromCPP(EPlayerAIMoveModeCPP MoveModeCPP);
	bool IsActionStatusAI_CallFromCPP(EPlayerActionStatus Status);
	void GetEventMovePosActor_CallFromCPP(class AActor** OutActor, float* OutRadius);
	class AActor* GetBattleTargetActor_CallFromCPP();
	bool EndEventWait_CallFromCPP();
	bool CheckEventMovePos_CallFromCPP();
	bool CheckAIPsychicObject_CallFromCPP(bool bCapture, bool bAttack);
	bool AimStartAI_CallFromCPP();
	bool AimEndAI_CallFromCPP();
	bool SetEventMove_CallFromCPP(const TArray<struct FVector>& Pos_list_in, const TArray<float>& Radius_list_in, bool Walk, bool bAfterWait);
	bool InputAI_UseItem_CallFromCPP(bool bPressed);
	bool InputAI_Psychic_CallFromCPP(bool bPressed);
	bool InputAI_LeftStick_CallFromCPP(float X, float Y);
	bool InputAI_Jump_CallFromCPP(bool bPressed);
	bool InputAI_Dodge_CallFromCPP(bool bPressed);
	bool InputAI_Attack_CallFromCPP(bool bPressed);
	bool SetPlayerInputRestriction_CallFromCPP(EPlayerInputRestrictionType Type, bool bRistriction);
	bool RestoreMaxSpeed_CallFromCPP(const class FName& ClaimantName);
	bool IsEnemyPlayer_CallFromCPP();
	bool IsEnableActionCounter_CallFromCPP();
	bool CheckAutoCounter_CallFromCPP();
	bool CanBattleAction_CallFromCPP(EPlayerAIBattleThinkTypeCPP ThinkType);
	bool ScaleMaxSpeed_CallFromCPP(float Scale, class FName ClaimantName);
	bool IsUseAbleSASRecastGauge(E_SASKindNative SasKind);
	bool GetSASEffectFixParam(E_SASKindNative InKind, TArray<struct F_SASParamNative>* OutFixParam);
	float GetMaxSpeedScale_CallFromCPP();
	bool ForceWarp_CallFromCPP(const struct FTransform& Transform, float IdleRestoreDelay);
	bool IsUniqueEffectiveSas_CallFromCPP(class AActor* InAttackActor, float* OutWinceRate, float* OutKnockbackRate, float* OutDownRate, float* OutCrashRate);
	bool IsReactionChance_CallFromCPP();
	bool IsSpecialDown_CallFromCPP(float* OutSpDownWince);
	bool SetStealthReactionInterval_CallFromCPP();
	bool SetSasStealth_CallFromCPP(bool Stealth_on_in, bool Hero_order_in, bool Check_delay, bool Check_ignore, bool No_sas_cancel_in);
	EPlayerBrainFieldDanger GetBrainFieldDangerLV();
	bool SetReserveCoverDamage_CallFromCPP(bool Flag);
	bool ResetCoverDamagePlayer_CallFromCPP();
	bool SetMaterialScalarParameterOther(class FName ParamName, float Value);
	void GetSASRecastAndActiveGaugeRate(E_SASButton SASButton, float* SASGaugeRate, bool* IsActive);
	bool IsIgnoreStealthVelocity();
	bool IsUseAbleCombinationVision(E_SASKindNative InKind);
	bool ResetAnimLeftStickPower();
	bool SetForceLockTargetSelf_CallFromCPP();
	bool ForceEndSAS_Telepo();
	bool IsEnableSasSelectSlow();
	bool IsDriveMode_CallFromCPP();
	bool IsManualHologramAttack();
	bool IsEnableSasInterface();
	float GetManualAssaultVisionSasGaugeRate();
	bool SetSasStealthVisible_CallFromCPP(bool Stealth_on_in, const struct FPlayerStealthDelayParam& DelayParam_in, struct FPlayerStealthDelayParam* DelayParam_out);
	bool SetSasMetalVisible_CallFromCPP(bool Metal_on_in, const struct FGameTimer& Gametimer_in, struct FGameTimer* Gametimer_out);
	void SetEnemyBrainCrashParam(float BrainCrashTimer, float BrainCrashMissScale, bool* Return);
	void SetEnemyStealthSeeEnable(bool On, bool ShadowChange, bool* Return);
	void OnSwitchVisibleBrainFieldLevel(bool Visible, bool* Unused);
	void ResetEnemyWait(bool* NewParam);
	void SetEnemyWait(bool* NewParam);
	void GetEnemyGroundTransform(const struct FTransform& Transform, struct FTransform* Return);
	void SetEnemyBrainFieldEnd(bool MoveBrainField, bool* NewParam);
	void SetEnemyBrainFieldStart(bool MoveBrainField, bool* NewParam);
	void SetEnemyDamageReaction(bool* NewParam);
	void ResetEnemyTarget(bool* NewParam);
	void SetEnemyTarget(bool* NewParam);
	void SetEnemyBrainCrashPerformance(bool* Return);
	void IsEnemyBossActive(bool* Return);
	void IsEnemyStateAction(bool* Return);
	void IsEnemyStateMove(bool* Return);
	void IsEnemyStateDamageDown(bool* Return);
	void IsEnemyStateDamage(bool* Return);
	void IsEnemyStateAttack(bool* Return);
	void IsEnemyDamageBlow(bool* Bool);
	void IsEnemyDamageknockBack(bool* Bool);
	void IsEnemyDamageLaunch(bool* Bool);
	void IsEnemyAction(EnemyActionAnimKind Action, bool* Bool);
	void BeginEnemyAction(EnemyActionAnimKind Action, bool* Bool);
	void IsEnemyDamageDown(bool* Bool);
	void IsEnemyDamageWince(bool* Bool);
	void IsEnemyMove(EnemyMoveAnimKind Move, bool* Bool);
	void BeginEnemyMove(EnemyMoveAnimKind Move, bool* Bool);
	void IsEnemyAttack(EnemyAttackAnimKind Attack, bool* Bool);
	void BeginEnemyAttack(EnemyAttackAnimKind Attack, bool* Bool);
	void GetEnemyInterfaceSound(Enum_EnemySound* Enum);
	void IsEnableEnemyMoveRange(bool* bReturn);
	void PlayerActionForEnemyReaction(BattlePrototype::EPsychicObjectAttackType PsychicObjectType, const struct FVector& PsychicObjLocation, bool* Dummy);
	void EnemyDataDrop(const struct FVector& Param_SpawnLocation, const struct FVector& SpawnDir, bool* IsDrop);
	void SetEnemySpawn(bool Spawn, bool* Return);
	void SpawnStart(bool* Return);
	void IsHideWeak(bool* Param_IsHideWeak);
	void ReturnStart(bool* Return);
	void IsAttacking(bool* IsAttack);
	void GetTargetKind(ERSPartyPlayerKind* TargetKind);
	void GetBrainCore(class ABP_co2000Base_C** CoreObject);
	void IsEnemyStateFloating(bool* IsFloating);
	void CalcCameraShake(class UClass* InputShakeClass, float InputScale, const struct FVector& ShakeLocation, class UClass** OutputShakeClass, float* OutputScale);
	void SetEnemyPressDownEnd(bool* Dammy);
	void EndUniqueObjState(bool* Dummy);
	void StartUniqueObjState(class ABP_PsychicObjectBasic_C* AttackObject, bool* Dummy);
	void CheckUniqueObjState(const struct FHCHitResult& HitResult, bool* Dummy);
	void IsUniqueObjState(bool* ReturnState);
	void SwitchDispCore(bool DisplayOn, bool* Dummy);
	void OnStartCrashChance(bool* bStart);
	void OnEndCrashChance(bool* bEnd);
	void IsPossibleTargetAttack(class AActor* Attacker, bool* bPossible);
	void IsDisableLostAction(bool* bDisable);
	void GetCoreCollision(class UDamagePartCollisionComponent** CoreCollision);
	void OnSpawnMoveStart(bool* Dummy);
	void OnEnemyBrainFieldResetAction(bool bMoveBrainField, bool* bReset);
	void OnEnemyBrainFieldFinishWeapon(bool bMoveBrainField, bool* Dummy);
	void OnEnemyBrainFieldResetStatus(bool bMoveBrainField, bool* Dummy);
	void SetEnemyBrainFieldMoveInner(bool MoveBrainField, bool* Dummy);
	void SetEnemyBrainFieldMoveNormal(bool MoveBrainField, bool* Dummy);
	void OnEnemyBrainFieldCutChange(bool* Dummy);
	void ChangeAiType(Enum_EnemyAiType Param_ChangeAiType, bool* bFailed);
	void CheckChangeAiTypeForHpRate(bool* Failed);
	void IsChangeAiTypeAction(Enum_EnemyAiType InAiType, bool* bPossible);
	void Em1200_ChangePhaseParamSetting(bool* Dummy);
	void Em1210_AddPSychicFlyObj(class ABP_PsychicObjectBasic_C* FlyObj, bool* Dummy);
	void StartReactionDilation(uint8 ReactionKind, bool AddDamage, bool* Return);
	void IsEnemyDiscoveredOnceInterface(bool* bDiscoverd);
	void Em0700_EnableInvalidDamage(bool* bEnable);
	void Em1400_StartDither(float TotalDuration, bool* Return);
	void Em1400_EndDither(bool* Return);
	void Em1400_UpdateDither(EEasingFunc EasingFunc, float DeltaSec, bool* Return);
	void Em1400_SetSpawnTransform(const struct FTransform& SpawnTransform, bool* Return);
	void Em1400_GetSpawnTransform(struct FTransform* SpawTransform);
	void IsBrainFieldEnemyAlive(bool* bEnemyAlive);
	void IsSwitchAttackCollisionInfo(bool* IsSwitch);
	void SetEnemyUpDownWait(bool DownWait, bool* Dummy);
	void IsEnemyUpDownWait(bool* bUpDownWait);
	void StartCriticalHitSlow(const struct FHCHitResult& InHitResult, bool* Return);
	void Em1130_EnableWeak(bool bEnable, bool* Return);
	void GetEnemySpawnConditionCheck(bool* IsSpawnOK);
	void StartEnemyCrashVisionHitEffect(bool* NewParam);
	void StartEnemyCrashVisionHitUniqueEffect(bool* NewParam);
	void BindingCrashVisionEnemy(bool* NewParam);
	void Em8300_DeadBattleSimulator(bool* Dummy);
	void IsEnemyRepop(bool* Repop);
	void SAS_CommonEnd(E_SASKind SAS_Kind, bool bCancelSASCost, bool* bDummy, float* RemainTime);
	void SAS_CommonStart(const struct FFSASCommand& SAS_Command, bool* Dummy);
	void GetBarrierComponent(class UBP_EnemyBarrierComponent_C** Component);
	void GetEnpcComponent(class UBP_ENpcComponent_C** Component);
	void GetEnpcSequencerComponent(class UBP_ENPCSequencerComponent_C** Component);
	void Em8000_GetPartner(class AActor** PartnerActor);
	void Em8200_BulletAttackEnd(EBulletType BulletType, bool* bEnd);
	void Em8200_StartTelepoMove(bool* Dummy);
	void Em8200_EndTelepoMove(bool* Dummy);
	void Em8200_CalcTelepoMoveLocation(ETelepoMoveType_em8200 TelepoType, struct FVector* TelepoMoveLocation);
	void Em8200_GetTelepoMoveLocation(struct FVector* OutputTelepoMoveLocation);
	void Em8200_SetTelepoMoveLocation(const struct FVector& InputTelepoMoveLocation, bool* Dummy);
	void Em8200_CopyActorPlayMontage(int32 Param_Index, class UAnimMontage* Montage, bool* Dummy);
	void Em8200_CopyActorUpdate(int32 Param_Index, float DeltaSec, int32* NextState, bool* bEnd);
	void Em8200_CopyActorActive(bool bActive, int32 Param_Index, bool* Dummy);
	void Em8200_GetCopyActorAssultTotalTime(int32 Param_Index, float* TotalTime);
	void Em8200_GetCopyActorActive(int32 Param_Index, bool* bActive);
	void Em8200_SetCopyActorLocation(int32 Param_Index, const struct FVector& NewLocation, bool* Dummy);
	void Em8200_SetCopyActorRotation(int32 Param_Index, const struct FRotator& NewRotation, bool* Dummy);
	void Em8200_GetTargetableCopyActor(int32 Param_Index, class ARSBattleCharacter_C** RSBattleCharacter);
	void Em8200_StoreHomingElecStartEnd(const struct FVector& StartLocation, const struct FVector& EndLocation, bool* Dummy);
	void Em8200_StartSeeThrough(bool* Dummy);
	void IsSpStart(bool* bSpStart);
	void SetSpStart(bool bSpStart, bool* Dummy);
	void Em8200_PillarIceExtendTime(float ExtendTime, bool* Dummy);
	void Em8200_SetSpShockWaveLocation(const struct FVector& Location, bool* Dummy);
	void Em8210_ApplyCommonBranch(bool* Dummy);
	void Em8000_IsAttackDriveMode(bool* bEnable);
	void Em8000_IsAttackBrainField(bool* bEnable);
	void Em8000_FireBomb(class AActor* Parent, bool bHard, bool* Dummy);
	void Em8000_SetBattleProcess(int32 Process, bool* Dummy);
	void CheckAbleInterceptInReactionChance(bool* bAbleIntercept);
	void Em8010_SetAutoAimRate(float NewRate, bool* Dummy);
	void Ch0500_StartSeeThrough(bool* Dummy);
	void Em8000_SetTriggerLocation(bool* Dummy);
	void SetStealthReactionInterval(bool* Dummy);
	void Np1100_SelectChakramCombo(class FString* ComboType);
	void Np1100_GetChakramComboList(TArray<uint8>* ChakramComboList);
	void Ch0900_CreateCopy(bool* Dummy);
	void Np1100_StartHidden(bool* Dummy);
	void Np1100_EndHidden(bool* Dummy);
	void Np1100_SetBattlePhase(int32 Phase, bool* Dummy);
	void Em8000_SetChangeEm8010Process(int32 Value, bool* Dummy);
	void Em8000_GetChangeEm8010Process(int32* Process);
	void Em8000_ExecChangeEm8010(bool* Dummy);
	void Np1100_SetThrowCount(bool bAdd, bool* Dummy);
	void ForceFinishMetamorphosis(bool bBrainFieldCancel, bool* Dummy);
	void Np1100_UseAttack_BrainTalk(bool* Return);
	void Np1100_UseSpTrigger_BrainTalk(bool* Return);
	void Em8200_UseAttackEnd_BrainTalk(bool* Return);
	void Np1100UseAfterSpAttack_BrainTalk(bool* NewParam);
	void Np1100_StartSpTriggerMove(bool* NewParam);
	void Np1100_EndSpTriggerMove(bool* NewParam);
	void Em8200_SetBattlePhase(EBattlePhase_em8210 BattlePhase, bool* Return);
	void Em8200_GetBattlePhase(EBattlePhase_em8210* BattlePhase);
	void Em8200_CanPlayExtraSasCutin(ESASCutinExtraID CutinID, bool* CanPlay);
	void Em8200_SetCanPlayExtraSasCutin(bool bCanPlay, ESASCutinExtraID CutinID, bool* Return);
	void PassedStartBrainFieldStartHp(bool* bDummy);
	void Em8200_StartDodgeMove(bool* Return);
	void Em8210_CanStartDodgeMove(bool* CanStart);
	void Em8210_EndDodgeMove(bool* Return);
	void Em8200_EnableDodgeJust(bool bEnable, bool* Return);
	void Em8200_IsEnableDodgeJust(bool* bEnable);
	void EnpcBulletAttackEnd(bool* bDummy);
	void Em8010_SetFakeUniqueName(class FName FakeName, bool* bDummy);
	void Em8000_SetFakeUniqueName(class FName FakeName, bool* bDummy);
	void Is_Unique_Enpc_Type(bool* IsUnique);
	void Em8200_AttachMask(bool* Return);
	void Em8200_SetLastPhaseHpRate(bool* Return);
	void Np1100_StartSpAfterVoice(bool* Return);
	void GetEnpcDyingHpRate(float* EnpcDyingHpRate);
	void Em8200_PlayBattleVoice(EBattleVoice_em8200 EBattleVoiceType, bool* Return);
	void Em8010_SetExecRush(bool bExec, bool* bDummy);
	void Em8200_SuicideInformOwner(bool* Return);
	void Em8000_NotifyDead(bool* bDummy);
	void Em8200_HomingElecEnd_BrainTalk(bool* Return);
	void Em8200_SetWaitEventParty(bool InWait, bool* Return);
	void Em8000_SetAction(EPlayerAIBattleThinkType AiType, bool* Dummy);
	void Em8200_UpdateDodgeJust(float DeltaSec, bool* Return);
	void Em8290_StartAppearEffect(bool InAppear, bool* Return);
	void Em8290_SetSafeDestroy(bool* Return);
	void Em8290_StartDisappear(bool* Return);
	void Ch0900_ForceCopyDead(bool* Dummy);
	void Em8200_StartDodgeJustFlash(float FlashIntervalTime, bool* Return);
	void Em8200_UpdateDodgeJustFlash(float DeltaSec, bool* Return);
	void Em8200_EndDodgeJustFlash(bool* Return);
	void Em8200_SetMaskVisibility(bool NewVisibility, bool* Return);
	void Em8200_EnableTargetableCopyActor(int32 Param_Index, bool* Return);
	void Em8200_SetEyeMaterial(bool On, bool* Return);
	void Em8000_1stAttack(bool* bDummy);
	void IsTemporaryDriveMode(bool* IsTempDrive);
	void Em8010_StartFinishMetamorphosis(bool* bDummy);
	void IsUniqueCondition_OpenBrainField(bool* bOK);
	void Em8210_EndUniqueNoDead(bool* Return);
	void Em8200_IsRegisterTelepoMoveLocation(bool* IsRegister);
	void IsUniqueCondition_Drive(bool* bOK);
	void Em8200_IsAttachMask(bool* bAttach);
	void Em8200_IsMaskVisible(bool* IsVisible);
	void Em8200_CopyActorWarmUp(bool* Return);
	void Em8200_StartSpPsychic(int32 StartPsychicType, bool Shot, bool* Return);
	void Em8200_EnableAimCopyActor(bool bEnable, bool* Return);
	void Em8200_StartAimCopyActor(float AimSpeed, float MaxAimAngle, bool InternalLock, bool ToCamera, class FName SocketName, bool* Return);
	void Em8200_TriggerSequenceAfter(bool bAfter, bool* Return);
	void StartDamageMove(const struct FVector& DamageDir, float Power, bool DeadMove, bool* Duumy);
	void Em8200_EnableIntenceVoice(bool* Return);
	void Em8000_GetShockwaveEffectArray(TArray<class URSParticleSystemComponentBase*>* EffectArray);
	void Em8000_ShockwaveEffect_Clear(bool* bDummy);
	void Em8000_ShockwaveEffect_SetElem(int32 Param_Index, class URSParticleSystemComponentBase* Particle, bool* bDummy);
	void Em8000_ShockwaveEffect_Get(int32 Param_Index, class URSParticleSystemComponentBase** Particle);
	void Em8000_ShockwaveEffect_Add(class URSParticleSystemComponentBase* Particle, int32* Param_Index);
	void Em8000_ShockwaveEffect_Deactivate(bool* bDummy);
	void Em8000_PermitBrainField(bool* bDummy);
	void Em8010_GetMetamorphosisParent(class AActor** ParentActor);
	void GetEnpcOutlineAppendMesh(TArray<class UMeshComponent*>* MeshComps);
	void Em8290_ExecAttack(bool* bDummy);
	void Em8220_GetBattlePhase(int32* BattlePhase);
	void Em8220_SetBattlePhase(int32 BattlePhase, bool* Return);
	void Em8220_BeginDispAttackCable(int32 CableIndex, float BeginTime, bool* Return);
	void Em8220_EndDispAttackCable(int32 CableIndex, float EndTime, bool* Return);
	void Em8220_PlayAttackCableAnim(const struct FST_em8220_CableInfo& CableInfo, bool* Return);
	void Em8220_EndAttackCableAnim(int32 CableIndex, bool* Return);
	void Em8200_EndAllAttackCable(bool bForce, float EndTime, bool* Return);
	void Em8220_BeginCablePiller(bool* Return);
	void Em8220_GetCablePillerLocationList(class AActor* IgnoreActor, TArray<struct FVector>* LocationList);
	void Em8220_BeginNextCableSpike(bool* Return);
	void Em8220_BulletAttackHit(EBulletType BulletType, class AActor* HitActor, bool* Return);
	void Em8220_SetCableSpikeStartEffectTime(float StartEffectTime, bool* Return);
	void Em8220_GetCableSpikeStartEffectTime(float* StartEffectTime);
	void EnterDownEnpc(EPlayerDownType DownType, bool* Return);
	void EntryBrainCrashAccessEnpc(bool* Return);
	void Em8220_SetHighSpdLocation(const struct FVector& InLocation, bool* Return);
	void Em8220_GetHighSpdLocation(struct FVector* OutLocation);
	void Em8220_SetHighSpdDistance(float HighSpdDistance, bool* Return);
	void Em8220_GetHighSpdDistance(float* HighSpdDistance);
	void Em8220_RegisterShotData(const struct FFRegisterShotData& RegisterShotData, bool* Return);
	void Em8220_UnregisterAllShotData(bool* Return);
	void Em8220_UpdateShotData(float DeltaSec, bool* Return);
	void Em8220_ChangeAccelerator(bool bStart, bool* Return);
	void Em8220_StartSpCount(bool* Return);
	void Em8220_StartCopyActorSpTimer(class ARSCharacterBase* InActor, bool* Return);
	void Em8220_EndCopyActorSpTimer(class ARSCharacterBase* InActor, bool* Return);
	void PreStartSequencerEnpc(int32 IndexIn, bool* Return);
	void FinishedSequencerEnpc(int32 IndexIn, bool* Return);
	void PostStartSequencerEnpc(int32 IndexIn, bool* Return);
	void GetSequenceActorEnpc(class AActor** SequenceActorEnpc);
	void StartSpSequenceEnpc(bool* Return);
	void Em8220_SetVisibleSpTimer(bool bVisible, bool* Return);
	void Em8220_CalcAttackCollisionInfo(const struct FHCAttackCollisionInfo& CollisionInfo, bool* Return);
	void Em8220_StoreCollisionInfo(const struct FHCSkillCommonInfo& SkillInfo, bool* Return);
	void Em8220_RestoreCollisionInfo(bool* Return);
	void PostFinishedSequencerEnpc(int32 IndexIn, bool* Return);
	void OnSpawnStartEnpc(bool* Return);
	void GetAttachedCharacterMesh(EPlayerID EquipPlayerID, int32 EquipMeshIndex, class USkeletalMeshComponent** Param_Mesh);
	void EquipAttachmentInterface(EPlayerAttachment Param_Index, int32 AttachmentItemID, EPlayerID EquipPlayerID, int32 EquipMeshIndex, bool* bDummy);
	void DestroyAttachmentMeshComponent(class USceneComponent* DestroyMeshComponent, bool* bDummy);
	void AttachmentVisibilityOffOnHead(bool bOff, bool* bDummy);
	void AttachmentVisibilityOffOnBackBody(bool bVisibility, float FadeTime, bool* bDummy);
	void EndAim(bool* bDummy);
	void StartAim(float LimitAngle, bool* bDummy);
	void GetEmPosDiscover(struct FVector* DiscoverPos);
	bool IsPlayerCopy();
	bool IsExistPlayerCopy();
	bool UpdateFall_Native();
	void UpdateDamageAnim_Native(bool* DamageEnd, bool* DamageDownEnd);
	bool SwitchDispCore_Native(bool DisplayOn);
	bool StoreWeakState_Native();
	bool StopCrashChanceLoopEffect_Native();
	bool StartVanish_Native(float VanishSec, float StartVanish, float EndVanish);
	void StartFallIfFlyingIF(bool* bDummy);
	bool StartDamageFloating_Native();
	bool SetWeakEmissiveOff_Native(const class FString& WeakSlotName);
	bool SetUseWaitNoInterpolation_Native(bool Use);
	bool SetReserveAction_Native(uint8 Action, float Param00, float Param01);
	bool SetLanding_Native(bool bLanding);
	bool SetIsMoveAnim_Native(bool NewIsMoveAnim);
	bool SetIsLaunchDown_Native(bool NewIsLaunchDown);
	bool SetIsLandCheck_Native(bool NewIsLandCheck);
	bool SetIsBrainAccess_Native(bool NewIsBrainAccess);
	bool SetIdleMove_Native(bool IsIdle);
	bool SetHp_Native(int32 HP);
	bool SetDownTimer_Native(float NewTime);
	bool SetDamageCollisionDisable_Native(const class FName& ClaimantName);
	bool SafeDestroy_Native(class AActor* Actor);
	bool RestoreWeakState_Native();
	bool RestoreWeakEmissive_Native(const class FString& WeakSlotName);
	bool ResetStateReceivedExecuteAi_Native();
	bool ResetCore_Native(class AActor* Enemy, bool RemoveCore);
	bool ResetAction_Native();
	void ReceivedNotifyAnimEnd_Native(bool* Received);
	bool OutputLogCrashChanceEnd_Native();
	bool OnEndCrashChance_Native();
	void OnEndAnimDieIF(bool* bDummy);
	bool LeaveBrainCrashAccess_Native(class ARSCharacterBase* Character);
	void LaunchDown_Native(bool* IsEnd);
	bool KickCrashChanceLoopEffect_Native();
	bool IsPossibleTargetAttack_CallFromCPP(class AActor* Actor);
	bool IsMotionEnd_Native();
	void IsIgnoreLandingCheck_Native(bool* bIgnoreLandingCheck);
	bool IsEnemyStateAttack_CallFromCPP();
	void IsEnemyLandingCheck_Native(bool* bHit);
	void IsBrainCrashMiss_Native(bool* IsMiss);
	class USearchingComponent* GetSearchingComponent_Native();
	void GetLostData_Native(float* LostMoveTimeMin, float* LostMoveTimeMax, float* LostMoveRotationRate, float* SpeedScale, bool* IsNoMoveAnim);
	void GetHitObjectType_Native(TArray<EObjectTypeQuery>* ObjectType);
	bool GetFall_Native();
	bool GetFailedFall_Native();
	void GetCurrentActionTime_Native(float* ActionTime);
	void FlyDown_Native(bool* IsEnd);
	bool EntryBrainCrashAccess_Native(class ARSCharacterBase* Character);
	bool EndDamageFloating_Native();
	bool EnableFitGroundTmp_Native();
	bool EnableAllWeak_Native(bool bEnable);
	bool DropFlyingEnemy_Native(class AActor* Enemy);
	bool DisableFitGroundTmp_Native();
	bool DeadStart_Native();
	bool DamageMotionEnd_Native(float DeltaTime);
	bool DamageFloatEnd_Native();
	bool CheckSASHologramAttack_Native(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	bool CheckNpcDrive_Native(ENpcDriveCheckType CheckType, class AActor* EnemyActor);
	bool CameraAttentionEnd_Native(class UCurveFloat* FovCurveOut);
	bool CallFuncDamageDownStart_Native();
	bool CallFuncDamageDownLoop_Native();
	bool CallFuncDamageDownEnd_Native();
	bool CallDead_Native();
	bool BrainCrashLock_Native();
	bool UpdateMoveMaxSpeed();
	bool EnemyUpdateEvDitherNative(float DeltaSec);
	bool EnemyStartEvDitherNative(bool bDisp, float DitherTime);
	bool EnemyEndEvDitherNative(bool bDisp);
	bool IsFlyEnemyCheck_Native();
	bool IsEnemyDamageDown_CallFromCPP();
	bool StartReactionDilation_CallFromCPP(uint8 ReactionKind, bool bAddDamage);
	bool IsCheckLookScrollTick(const struct FVector& Start, const struct FVector& End);
	bool SetTickEnableMeshOnly(bool bMeshOnly);
	bool IsCheckSameCompareGroundLoaction();
	bool SetEnemyConsiderDownDead(bool bEnable);
	EEnemyTribe GetEnemyTribe();
	bool OnCrashVisionDead();
	bool OnNotifyPlayerDead();
	void GetPlayerWeaponManage(class UBP_WeaponManageComponent_C** WeaponManage);

	void GetCurrentTargetActor(class AActor** TargetActor) const;
	void IsBattling(bool* bBatting) const;
	void GetCameraRotation(struct FRotator* CameraRotate) const;
	void IsPlayerStatus(EPlayerCommonStatus PlayerStatus, bool* Result) const;
	void IsActionStatus(EPlayerActionStatus ActionStatus, bool* Result) const;
	void IsEnableActionJump(bool* bEnable) const;
	void IsEnableActionDodge(bool bIgnoreBadStatus, bool* bEnable) const;
	void IsEnableActionAttack(bool* bEnable) const;
	void IsEnableActionPsychic(bool bPsychicEx, bool* bEnable) const;
	void IsEnableActionSprint(bool* bEnable) const;
	void GetSASParamForKind(E_SASKind SasKind, int32 SASParam, float* Param) const;
	void IsEnableActionCommon(bool* bEnable) const;
	void IsEnableActionIdleWalkRun(bool* bEnable) const;
	void IsEnableActionDamage(bool* bEnable) const;
	void GetTargetBoss(class AActor** LockBoss) const;
	void IsActiveSAS_ForKind(E_SASKind SAS_Kind, bool* IsActive) const;
	void IsForceCritical(bool* bResult) const;
	void GetActorDeltaSeconds(float* ActorDeltaSeconds) const;
	void IsLockTarget(bool* Param_IsLockTarget) const;
	void IsControlAI(bool* bAI) const;
	void GetIsBattleMode(bool* IsBattleMode) const;
	void GetDefaultCameraRotation(struct FRotator* DefaultCameraRotation) const;
	void IsUpperActionStatus(EPlayerUpperActionStatus ActionStatus, bool* bResult) const;
	void IsEnableActionBrainCrash(bool* Enable) const;
	void GetPlayerWeapon(int32 Param_Index, class ABP_WeaponBase_C** Weapon) const;
	void GetPlayerWeaponPure(int32 Param_Index, class ABP_WeaponBase_C** Weapon) const;
	void GetConnectEffectLocation(bool bSource, EEffectConnectPoint ConnectPoint, class FName SocketName, int32 Param, struct FVector* Location) const;
	void IsDisableAction(bool* bEnable) const;
	void GetCameraPitch(float* Rotation) const;
	void IsPlayBlendAnimMontage(bool* bPlay) const;
	void CheckExistActorByCapsule(const struct FVector& Offset, EObjectTypeQuery ActorObjectType, class AActor* Actor, bool IgnoreActorHeight, bool* bExist) const;
	void IsNoBattleWeaponDispOff(bool* bOff) const;
	void IsCompleteTelepoDisappear(bool* bComplete) const;
	void IsEnableAddMovementInput(bool* bEnable) const;
	void GetWeaponSocketName(int32 Param_Index, bool bBattle, bool ForceBattle, class FName* SocketName) const;
	void IsEnableSASEffect(E_SASKind Kind, ESASEffect Effect, bool* bEnable, float* Param0, float* Param1, float* Param2, float* Param3) const;
	void GetSASParamDataCurrentLevel(E_SASKind Kind, struct FF_SASParam* Param) const;
	void GetCopyPlayerList(TArray<class ABP_SASCopyPlayerActor_C*>* Param_CopyPlayerList) const;
	void IsSearchAbleActionIcon(bool* bEnable) const;
	void IsMetalMode(bool* bMetal) const;
	void IsEnableAssist(bool* bEnable) const;
	void CheckWaitEnableAssist(bool* bEnable) const;
	void DebugDrawAiInfo() const;
	void IsEnableActionChangeBattle(bool* bEnable) const;
	void GetCurrentActionState(EPlayerActionKind* Kind) const;
	void IsAbleTransitionBrainField(bool* bOK) const;
	void GetPlayerAccessoryEffect(EEffecacyType EffectType, bool* bEquip, float* Param) const;
	void GetWeakTargetPoint(const struct FVector& AttackerPos, struct FVector* Point) const;
	bool IsEnableMetalMode() const;
	bool IsGuardBadCondition(EHCSkillAttribute Attr) const;
	void GetReviveCableSocketName(int32 Param_Index, class FName* SocketName) const;
	void GetUseItemSpeed(EPlayerUseItemSpeed* Speed) const;
	void CheckFlyingAttackKind(ERSAttackInputKind AttackKind, bool* bFlying) const;
	void GetHpGaugePoint(struct FVector* Point) const;
	void GetCrashChanceCursorPoint(struct FVector* Point) const;
	bool IsBrainCrashSuccess() const;
	bool IsBrainCrashAccess() const;
	void IsComboInputEnd(bool* NewParam) const;
	void GetBadStateIconParam(EHCBadState BadType, struct FBadStateAddParticleData* ParamData) const;
	void GetCameraDitherTableRowName(class FName* RowName) const;
	void GetDriveParameterName(class FName* Param_Name) const;
	void IsWeaponAttachMode(bool* bBattle) const;
	void GetSASTimeParameter(E_SASKind Kind, float* RecastSec, float* ActivationSec) const;
	void BadStateEffectDispSwitch(bool bInDisp, bool* bSuccess) const;
	void IsContentsOpen(EContentsOpening Contents, bool* bOpen) const;
	void IsPlayerSuperArmor(bool* bSuperArmor) const;
	void GetCharacterLV(int32* LV) const;
	EAssassinAttackHit GetAssasinAttackHitType() const;
	void GetBodyMeshes(TArray<class USkeletalMeshComponent*>* Meshes) const;
	bool IsControlPlayer() const;
	void IsDisableBoringIdle(bool* bDisable) const;
	void IsDamageCollisionInvincible(bool* bInvincible) const;
	float GetBrainCrashRange() const;
	void NeedsDispNoDamage(bool* bNeedsDipsNoDamage) const;
	void IsEnableDispNoDamage(bool* bEnable) const;
	void IsAutoStealth(bool* bAuto) const;
	void IsDisableBehaviorTree(bool* bDisable) const;
	void GetWeaponEmissiveValue(float* Emmisive) const;
	void NeedsWeaponVisibility(bool* bNeedsVisibility) const;
	void IsBrainFieldUser(bool* bIsUser) const;
	void CheckDisableBeginSAS_Telepo(bool* bDisable) const;
	void IsStealthFromEvent(bool* bFromEvent) const;
	bool IsInvisibleMiniMap() const;
	void IsAttackerMainPlayer(bool* bMainPlayer) const;
	void IsSpawnWait(bool* bSpawnWait) const;
	bool IsDebugInvincible() const;
	void IsLookAtEnable(bool* bEnable) const;
	void GetPlayerIndex(int32* Param_Index) const;
	void GetPlayerWeaponList(EGetPlayerWeaponType Type, TArray<class ABP_WeaponBase_C*>* WeaponList) const;
	void IsEnemyPlayer(bool* bEnemyPlayer) const;
	void IsForceWarpAble_Interface(bool* bWarpAble) const;
	void GetSkillParameter(EPlayerSkill Skill, bool* bLearned, float* Parameter) const;
	void IsPlayerInputRestriction(EPlayerInputRestrictionType Type, bool* bRestriction) const;
	void GetEnpcComp(class UBP_ENpcComponent_C** ReturnComp) const;
	void IsAnimationEndTalkTurn(bool* bAnimation) const;
	void GetTalkLookAtLocation(bool* Param_bTalkLookAt, struct FVector* Location) const;
	void IsCameraControl(bool* bControl) const;
	void IsEnpcSASLinkAble(E_SASKind Kind, bool* bOK) const;
	void IsDying(bool* bDying) const;
	void IsAutoTakenItem(bool* bAuto) const;
	void GetBrainCrashStartTransform(struct FTransform* Transform) const;
	void IsExecTalkEvent(bool* bTalk) const;
	void IsUsingItem(bool* bUsing, EConsumeItemID* ItemId) const;
	void GetControlPlayerDist(struct FVector* Dist) const;
	void IsMoveAble(bool* bEnable) const;
	void GetMovePosActor(class AActor** MovePosActor) const;
	void IsAttackAble(bool* bEnable) const;
	void IsActionStatusAI(EPlayerActionStatus ActionStatus, bool* bResult) const;
	void IsPlayerStatusAI(EPlayerCommonStatus PlayerStatus, bool* bResult) const;
	void IsInputAI_Attack(bool* bON) const;
	void IsInputAI_Dodge(bool* bON) const;
	void IsDodgeAble(bool* bEnable) const;
	void IsAIMoveMode(EPlayerAIMoveMode Mode, bool* Result) const;
	void IsBattleThink(EPlayerAIBattleThinkType Type, bool* Result) const;
	void IsBattleThinkParam(EPlayerAIBattleThinkParam Param, bool* bResult) const;
	void GetBattleTargetActor(class AActor** TargetActor) const;
	void IsInputAI_Jump(bool* bON) const;
	void IsJumpAble(bool* bEnable) const;
	void GetAttackCountAI(int32* Count) const;
	void OverwriteAttackInputKindAI(EPlayerAIBattleThinkType ThinkType, ERSAttackInputKind InputKind, ERSAttackInputKind* Kind) const;
	void IsEventMove(bool* Result) const;
	void IsEventMoveEnd(bool* Result) const;
	void IsResetBehaviorTree(bool* bReset) const;
	void IsEventWait(bool* bWait) const;
	void GetUseItemID(EConsumeItemID* ItemId) const;
	EPlayerID GetPlayerID() const;
	ERSPartyPlayerKind GetPartyPlayerKind() const;
	void IsLockTargetInterface(bool* IsLockTarget) const;
	void GetTargetBossInterface(class AActor** LockBoss) const;
	void GetCurrentTargetActorInterface(class AActor** TargetActor) const;
	void IsActiveSAS_ForButton(E_SASButton SASButton, bool* IsSAS) const;
	bool IsOnReadySAS() const;
	void IsCanSAS_Use(E_SASButton SASButton, bool* IsSASUse) const;
	void GetSASKindforButton(E_SASButton SASButton, E_SASKindNative* SasKind) const;
	void IsInputSAS(E_SASButton SASButton, bool* Param_IsInputSAS) const;
	bool IsLockTargetLostInterface() const;
	bool IsEnableBrainCrash_Native() const;
	bool IsResetBehaviorTree_CallFromCPP() const;
	bool IsMoveAble_CallFromCPP() const;
	bool IsJumpAble_CallFromCPP() const;
	bool IsInputAI_Jump_CallFromCPP() const;
	bool IsInputAI_Dodge_CallFromCPP() const;
	bool IsInputAI_Attack_CallFromCPP() const;
	bool IsEventWait_CallFromCPP() const;
	bool IsEventMoveEnd_CallFromCPP() const;
	bool IsEnableActionDodge_CallFromCPP() const;
	bool IsDodgeAble_CallFromCPP() const;
	bool IsAttackAble_CallFromCPP() const;
	class AActor* GetMovePosActor_CallFromCPP() const;
	struct FVector GetControlPlayerDist_CallFromCPP() const;
	int32 GetAttackCountAI_CallFromCPP() const;
	bool IsEventMove_CallFromCPP() const;
	bool IsMetalMode_CallFromCPP() const;
	bool IsEnableActionJump_CallFromCPP() const;
	bool IsControlAI_CallFromCPP() const;
	bool IsDying_CallFromCPP() const;
	void GetPlayerAccessoryEffect_CallFromCPP(EEffecacyType EffectType, bool* bOutEquip, float* OutParam) const;
	EPlayerID GetCoverDamagePlayerID_CallFromCPP() const;
	bool IsPlayerSuperArmor_CallFromCPP() const;
	bool IsDamageCollisionInvincible_CallFromCPP() const;
	bool IsEnemyForceWait_CallFromCPP() const;
	void IsEnableSASEffectInterface(E_SASKindNative Kind, ESASEffect Effect, bool* OutEnable, float* OutParam0, float* OutParam1, float* OutParam2, float* OutParam3) const;
	void IsEnemyActive(bool* Return) const;
	void IsBossEnemy(bool* bBoss) const;
	void GetDistanceToPlayer(float* Distance) const;
	void GetTargetDistance(float* Distance) const;
	void GetEnemySpawn(bool* Return) const;
	void GetHeightCheckFlag(bool* NewParam) const;
	void IsFlyEnemyCheck(bool* NewParam) const;
	void GetBrainCrashSequence(bool IsUnique, class ULevelSequence** Sequence) const;
	void GetMoveToTargetAnim(EnemyMoveAnimKind* MoveAnim) const;
	void GetMainPlayerDistance(float* Distance) const;
	void IsRealThings(bool* bReal) const;
	void IsEnemySpawnNow(bool* SpawnNow) const;
	void IsNotFindPlayer(bool* bNotFind) const;
	void IsEnemyTickDisableCondition(bool* bDisableCondition) const;
	void Em8310_IsMaskMan(bool* bMaskMan) const;
	void IsAccelerating(bool* Accelerating) const;
	void IsAcceleratorValid(bool* Valid) const;
	void GetENpcParam(class UBP_ENpc_ParamBase_C** Param) const;
	void Em8000_GetBattleType(Enum_BattleType_em8000* BattleType) const;
	void IsActiveEnpcSAS(E_SASKind Kind, bool* bActive) const;
	void Em8210_IsHomingEnd(bool* bEnd) const;
	void Em8000_GetBattleProcess(int32* CurProcess) const;
	void Em8010_GetBattleType(Enum_BattleType_em8010* BattleType) const;
	void IsNotRequirementPartner(bool* bNotRequirement) const;
	void IsIgnoreForceFinishMetamorphosis(bool* bIgnore) const;
	void Em8010_IsMetamophosis_BaseChara(bool* bIsMetamorphosis) const;
	void Em8010_IsMetamophosis_ChangeChara(bool* bIsMetamorphosis) const;
	void Em8010_IsMetamorphosis_Disappear(bool* bDisappear) const;
	void Em8010_IsMetamorphosis_Appear(bool* bAppear) const;
	void Em8010_GetParameterTableAttackScale(float* Scale) const;
	void Em8220_IsSpFieldOpen(bool* bOpen) const;
	bool IsUpdateEnemyTickEnable() const;
	bool IsUpdateEnemySpawn() const;
	bool IsTickDisableCondition() const;
	bool IsReflectContainer() const;
	bool IsPressDown_Native() const;
	bool IsLaunchDown_Native() const;
	bool IsExecLowProcess() const;
	bool IsEnemySpawn_Interface() const;
	bool IsEnemyFalling_Interface() const;
	bool IsDisableUroAction_Interface() const;
	bool IsDamageMotionEnd_Native() const;
	bool IsCheckLookTargetTick(const struct FVector& Start, const struct FVector& End) const;
	bool IsCheckHeightChangeTick() const;
	bool IsBrainSuccess_Native() const;
	struct FVector GetTopHeightLocation() const;
	class AActor* GetTargetCharacter_Native() const;
	bool GetPressDownLoop_Native() const;
	bool GetNewDamageFloating_Native() const;
	void GetLostActionInfoList_Native(TArray<struct FEmLostActionInfo>* LostActionInfo) const;
	bool GetIsLandCheck() const;
	bool GetIsJumpEnd() const;
	class UHateTargetComponent* GetHateTarget_Native() const;
	class UEnemyScriptComponent* GetEnemyScriptComponent() const;
	class UEnemyAnimControllerComponent* GetEnemyAnimControllerComponent() const;
	class UEnemyAiComponentBase* GetEnemyAiComponent() const;
	EnemyMoveAnimKind GetDownUpMoveAnimKind_Native() const;
	float GetDownTimer_Native() const;
	bool GetDebugEnemyDownInfinity_Native() const;
	struct FVector GetDamageHitDirectionIF() const;
	class AActor* GetCurrentTarget() const;
	class UCapsuleComponent* GetCapsuleComponent_Native() const;
	bool IsWeakUiDamageHit_CallFromCPP() const;
	bool IsNotFindPlayer_CallFromCPP() const;
	bool IsUniqueAroundEffectPause() const;
	float GetUniqueTickEnableRange() const;
	bool IsBossEnemy_CallFromCPP() const;
	bool IsSpawned() const;
	bool IsDisableDownMotionInterface() const;
	bool IsSuspendFollowAttackInterface() const;
	bool IsInvincible_Native() const;
	bool IsEnemyConsiderDownDead() const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"RSBattlePlayer_C">();
	}
	static class ARSBattlePlayer_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSBattlePlayer_C>();
	}
};
#pragma pack(pop)
static_assert(alignof(ARSBattlePlayer_C) == 0x000010, "Wrong alignment on ARSBattlePlayer_C");
static_assert(sizeof(ARSBattlePlayer_C) == 0x001CF0, "Wrong size on ARSBattlePlayer_C");
static_assert(offsetof(ARSBattlePlayer_C, UberGraphFrame_RSBattlePlayer_C) == 0x0010F0, "Member 'ARSBattlePlayer_C::UberGraphFrame_RSBattlePlayer_C' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_EnemySpawnComponent) == 0x0010F8, "Member 'ARSBattlePlayer_C::BP_EnemySpawnComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_ReactionDilationComponent) == 0x001100, "Member 'ARSBattlePlayer_C::BP_ReactionDilationComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_EnemyAddDamageShakeComponent) == 0x001108, "Member 'ARSBattlePlayer_C::BP_EnemyAddDamageShakeComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerAsyncScript) == 0x001110, "Member 'ARSBattlePlayer_C::PlayerAsyncScript' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateSASLink) == 0x001118, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateSASLink' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateEndBrainCrash) == 0x001120, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateEndBrainCrash' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_AttachmentManageComponent) == 0x001128, "Member 'ARSBattlePlayer_C::BP_AttachmentManageComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateSprintTurnBack) == 0x001130, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateSprintTurnBack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DamagePartCollision) == 0x001138, "Member 'ARSBattlePlayer_C::DamagePartCollision' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateRessurect) == 0x001140, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateRessurect' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateRevive) == 0x001148, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateRevive' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateControlPsychicObject) == 0x001150, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateControlPsychicObject' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateEventMotion) == 0x001158, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateEventMotion' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateRecoverBlowDamage) == 0x001160, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateRecoverBlowDamage' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateDrive) == 0x001168, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateDrive' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerDriveComponent) == 0x001170, "Member 'ARSBattlePlayer_C::BP_PlayerDriveComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateCaptureMapGimmick) == 0x001178, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateCaptureMapGimmick' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateCancelMapGimmick) == 0x001180, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateCancelMapGimmick' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerAIEvaluateLocationComponent) == 0x001188, "Member 'ARSBattlePlayer_C::BP_PlayerAIEvaluateLocationComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerCameraComponent) == 0x001190, "Member 'ARSBattlePlayer_C::BP_PlayerCameraComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerUpperActionStatePsychicAttack) == 0x001198, "Member 'ARSBattlePlayer_C::BP_PlayerUpperActionStatePsychicAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerUpperActionStateCapture) == 0x0011A0, "Member 'ARSBattlePlayer_C::BP_PlayerUpperActionStateCapture' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerMaterialManageComponent) == 0x0011A8, "Member 'ARSBattlePlayer_C::BP_PlayerMaterialManageComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateDamageBrainCrash) == 0x0011B0, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateDamageBrainCrash' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerLookAtComponent) == 0x0011B8, "Member 'ARSBattlePlayer_C::PlayerLookAtComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, RSStateManage_Upper) == 0x0011C0, "Member 'ARSBattlePlayer_C::RSStateManage_Upper' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, RSStateManage) == 0x0011C8, "Member 'ARSBattlePlayer_C::RSStateManage' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerScript) == 0x0011D0, "Member 'ARSBattlePlayer_C::PlayerScript' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_CounterComponent) == 0x0011D8, "Member 'ARSBattlePlayer_C::BP_CounterComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_SASTelepoComponent) == 0x0011E0, "Member 'ARSBattlePlayer_C::BP_SASTelepoComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_InterceptComponent) == 0x0011E8, "Member 'ARSBattlePlayer_C::BP_InterceptComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerHardenComponent) == 0x0011F0, "Member 'ARSBattlePlayer_C::BP_PlayerHardenComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_FacialAnim) == 0x0011F8, "Member 'ARSBattlePlayer_C::BP_FacialAnim' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_WeaponManageComponent) == 0x001200, "Member 'ARSBattlePlayer_C::BP_WeaponManageComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerStealthComponent) == 0x001208, "Member 'ARSBattlePlayer_C::BP_PlayerStealthComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerUpperActionStateAttack) == 0x001210, "Member 'ARSBattlePlayer_C::BP_PlayerUpperActionStateAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateAfterEvent) == 0x001218, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateAfterEvent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerUpperActionStateDamageSAS) == 0x001220, "Member 'ARSBattlePlayer_C::BP_PlayerUpperActionStateDamageSAS' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerUpperActionStateChangeBattle) == 0x001228, "Member 'ARSBattlePlayer_C::BP_PlayerUpperActionStateChangeBattle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateWalkRun) == 0x001230, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateWalkRun' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateIdle) == 0x001238, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateIdle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_TargetSearchComponent) == 0x001240, "Member 'ARSBattlePlayer_C::BP_TargetSearchComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_JumpComponent) == 0x001248, "Member 'ARSBattlePlayer_C::BP_JumpComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerAIComponent) == 0x001250, "Member 'ARSBattlePlayer_C::BP_PlayerAIComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateDead) == 0x001258, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateDead' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_AttackEmitter) == 0x001260, "Member 'ARSBattlePlayer_C::BP_AttackEmitter' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateUseItem) == 0x001268, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateUseItem' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateBoringIdle) == 0x001270, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateBoringIdle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_ItemUseComponent) == 0x001278, "Member 'ARSBattlePlayer_C::BP_ItemUseComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_JustDodge) == 0x001280, "Member 'ARSBattlePlayer_C::BP_JustDodge' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_BonusGhostBridgeComponent) == 0x001288, "Member 'ARSBattlePlayer_C::BP_BonusGhostBridgeComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_BonusGhostTrailComponent) == 0x001290, "Member 'ARSBattlePlayer_C::BP_BonusGhostTrailComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_SASCutIn) == 0x001298, "Member 'ARSBattlePlayer_C::BP_SASCutIn' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerGauge) == 0x0012A0, "Member 'ARSBattlePlayer_C::BP_PlayerGauge' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateWakeUp) == 0x0012A8, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateWakeUp' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateDown) == 0x0012B0, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateDown' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateDamageBlow) == 0x0012B8, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateDamageBlow' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerDamageReactionInfo) == 0x0012C0, "Member 'ARSBattlePlayer_C::BP_PlayerDamageReactionInfo' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_SASRecastGauge) == 0x0012C8, "Member 'ARSBattlePlayer_C::BP_SASRecastGauge' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateEvent) == 0x0012D0, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateEvent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerInputComponent) == 0x0012D8, "Member 'ARSBattlePlayer_C::PlayerInputComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_AttackAcceleratorBase) == 0x0012E0, "Member 'ARSBattlePlayer_C::BP_AttackAcceleratorBase' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerUpperActionStateIdle) == 0x0012E8, "Member 'ARSBattlePlayer_C::BP_PlayerUpperActionStateIdle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateDamage) == 0x0012F0, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateDamage' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateAttack) == 0x0012F8, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateDodge) == 0x001300, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateDodge' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateLand) == 0x001308, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateLand' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateFall) == 0x001310, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateFall' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateJump) == 0x001318, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateJump' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateSprintBrake) == 0x001320, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateSprintBrake' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BP_PlayerActionStateSprint) == 0x001328, "Member 'ARSBattlePlayer_C::BP_PlayerActionStateSprint' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SprintBP) == 0x001330, "Member 'ARSBattlePlayer_C::SprintBP' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, StepComponentBP) == 0x001338, "Member 'ARSBattlePlayer_C::StepComponentBP' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CheatCommandListener) == 0x001340, "Member 'ARSBattlePlayer_C::CheatCommandListener' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CutCamera) == 0x001348, "Member 'ARSBattlePlayer_C::CutCamera' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackInput) == 0x001350, "Member 'ARSBattlePlayer_C::AttackInput' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, MoveInput) == 0x001358, "Member 'ARSBattlePlayer_C::MoveInput' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerCameraRotationComponent) == 0x001360, "Member 'ARSBattlePlayer_C::PlayerCameraRotationComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerShadeNoise) == 0x001368, "Member 'ARSBattlePlayer_C::PlayerShadeNoise' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, Camera) == 0x001370, "Member 'ARSBattlePlayer_C::Camera' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpringArm) == 0x001378, "Member 'ARSBattlePlayer_C::SpringArm' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BaseTurnRate) == 0x001380, "Member 'ARSBattlePlayer_C::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BaseLookUpRate) == 0x001384, "Member 'ARSBattlePlayer_C::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DirectionControllRotationSpeed) == 0x001388, "Member 'ARSBattlePlayer_C::DirectionControllRotationSpeed' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerStatusTableRowName) == 0x00138C, "Member 'ARSBattlePlayer_C::PlayerStatusTableRowName' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BttleIdleKeepAftAttackSec) == 0x001394, "Member 'ARSBattlePlayer_C::BttleIdleKeepAftAttackSec' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DefaultStatusClaimantName) == 0x001398, "Member 'ARSBattlePlayer_C::DefaultStatusClaimantName' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnMovementCollisionLand) == 0x0013A0, "Member 'ARSBattlePlayer_C::OnMovementCollisionLand' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerAnimConRef) == 0x0013B0, "Member 'ARSBattlePlayer_C::PlayerAnimConRef' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, MoveInputScale) == 0x0013B8, "Member 'ARSBattlePlayer_C::MoveInputScale' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bJumpMoveInput) == 0x0013BC, "Member 'ARSBattlePlayer_C::bJumpMoveInput' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, LastInputAttackType) == 0x0013BD, "Member 'ARSBattlePlayer_C::LastInputAttackType' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, LookAtRef) == 0x0013C0, "Member 'ARSBattlePlayer_C::LookAtRef' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, IsSASInput) == 0x0013C8, "Member 'ARSBattlePlayer_C::IsSASInput' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CameraLagSpeed) == 0x0013D8, "Member 'ARSBattlePlayer_C::CameraLagSpeed' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CameraLagMaxDistance) == 0x0013DC, "Member 'ARSBattlePlayer_C::CameraLagMaxDistance' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, IsCameraLag) == 0x0013E0, "Member 'ARSBattlePlayer_C::IsCameraLag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bInputDodge) == 0x0013E1, "Member 'ARSBattlePlayer_C::bInputDodge' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ChangeMontagePlayRate) == 0x0013E4, "Member 'ARSBattlePlayer_C::ChangeMontagePlayRate' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ChangeMontageRef) == 0x0013E8, "Member 'ARSBattlePlayer_C::ChangeMontageRef' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, StartSpringArmLength) == 0x0013F0, "Member 'ARSBattlePlayer_C::StartSpringArmLength' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, StartSpringArmPitch) == 0x0013F4, "Member 'ARSBattlePlayer_C::StartSpringArmPitch' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bReserveChangeCombo) == 0x0013F8, "Member 'ARSBattlePlayer_C::bReserveChangeCombo' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bUpdateHUD) == 0x0013F9, "Member 'ARSBattlePlayer_C::bUpdateHUD' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, FallVelocity) == 0x0013FC, "Member 'ARSBattlePlayer_C::FallVelocity' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ComboPatternFirst) == 0x001408, "Member 'ARSBattlePlayer_C::ComboPatternFirst' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ComboPatternSecond) == 0x001409, "Member 'ARSBattlePlayer_C::ComboPatternSecond' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerIndex) == 0x00140C, "Member 'ARSBattlePlayer_C::PlayerIndex' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerFixParam) == 0x001410, "Member 'ARSBattlePlayer_C::PlayerFixParam' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ConnectEffectInfoList) == 0x001418, "Member 'ARSBattlePlayer_C::ConnectEffectInfoList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, RegisterThrowWeaponList) == 0x001428, "Member 'ARSBattlePlayer_C::RegisterThrowWeaponList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleOffTimer) == 0x001438, "Member 'ARSBattlePlayer_C::BattleOffTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ThrowWeaponTargetList) == 0x001448, "Member 'ARSBattlePlayer_C::ThrowWeaponTargetList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, EventInvalidDamageClaimantName) == 0x001458, "Member 'ARSBattlePlayer_C::EventInvalidDamageClaimantName' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, EffectHandleBadStateFlooded) == 0x001460, "Member 'ARSBattlePlayer_C::EffectHandleBadStateFlooded' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, EffectHandleBadStateOil) == 0x001468, "Member 'ARSBattlePlayer_C::EffectHandleBadStateOil' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, UpperBlendAnimMontage) == 0x001470, "Member 'ARSBattlePlayer_C::UpperBlendAnimMontage' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, LowerBlendAnimMontage) == 0x001478, "Member 'ARSBattlePlayer_C::LowerBlendAnimMontage' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AnimMontageSet) == 0x001480, "Member 'ARSBattlePlayer_C::AnimMontageSet' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnChangePsychicObjShow) == 0x001568, "Member 'ARSBattlePlayer_C::OnChangePsychicObjShow' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnChangePsychicObjEnable) == 0x001578, "Member 'ARSBattlePlayer_C::OnChangePsychicObjEnable' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnChangePsychicObjUse) == 0x001588, "Member 'ARSBattlePlayer_C::OnChangePsychicObjUse' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnChangePsychicObjCount) == 0x001598, "Member 'ARSBattlePlayer_C::OnChangePsychicObjCount' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CheckStartAttackFlag) == 0x0015A8, "Member 'ARSBattlePlayer_C::CheckStartAttackFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BadStateOilParticleSoftReference) == 0x0015B8, "Member 'ARSBattlePlayer_C::BadStateOilParticleSoftReference' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BadStateOilParticle) == 0x0015E0, "Member 'ARSBattlePlayer_C::BadStateOilParticle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BadStateFloodedParticleSoftReference) == 0x0015E8, "Member 'ARSBattlePlayer_C::BadStateFloodedParticleSoftReference' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BadStateFloodedParticle) == 0x001610, "Member 'ARSBattlePlayer_C::BadStateFloodedParticle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CopyPlayerList) == 0x001618, "Member 'ARSBattlePlayer_C::CopyPlayerList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CopyWeaponStatus) == 0x001628, "Member 'ARSBattlePlayer_C::CopyWeaponStatus' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CopyWeaponTImer) == 0x00162C, "Member 'ARSBattlePlayer_C::CopyWeaponTImer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bReserveCopyWeaponVisibleOn) == 0x001638, "Member 'ARSBattlePlayer_C::bReserveCopyWeaponVisibleOn' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, InputDodgeMoveStick) == 0x00163C, "Member 'ARSBattlePlayer_C::InputDodgeMoveStick' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerManager) == 0x001648, "Member 'ARSBattlePlayer_C::PlayerManager' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ENPCCompRef) == 0x001650, "Member 'ARSBattlePlayer_C::ENPCCompRef' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnChangePsychicObjShow2) == 0x001658, "Member 'ARSBattlePlayer_C::OnChangePsychicObjShow2' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnChangePsychicObjEnable2) == 0x001668, "Member 'ARSBattlePlayer_C::OnChangePsychicObjEnable2' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnChangePsychicObjUse2) == 0x001678, "Member 'ARSBattlePlayer_C::OnChangePsychicObjUse2' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnChangePsychicObjCount2) == 0x001688, "Member 'ARSBattlePlayer_C::OnChangePsychicObjCount2' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, FixCameraLeftStick) == 0x001698, "Member 'ARSBattlePlayer_C::FixCameraLeftStick' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bFreeCheck) == 0x0016A0, "Member 'ARSBattlePlayer_C::bFreeCheck' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, FreeCheckNo) == 0x0016A4, "Member 'ARSBattlePlayer_C::FreeCheckNo' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PartyPlayerKind) == 0x0016A8, "Member 'ARSBattlePlayer_C::PartyPlayerKind' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, IsInputEnable) == 0x0016A9, "Member 'ARSBattlePlayer_C::IsInputEnable' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DispatchMontageBlendingOut) == 0x0016B0, "Member 'ARSBattlePlayer_C::DispatchMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PresetCameraDataTable) == 0x0016C0, "Member 'ARSBattlePlayer_C::PresetCameraDataTable' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DisableCameraControlTimer) == 0x0016C8, "Member 'ARSBattlePlayer_C::DisableCameraControlTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bDebugPause) == 0x0016D4, "Member 'ARSBattlePlayer_C::bDebugPause' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AI_BUTTON_ATTACK) == 0x0016D5, "Member 'ARSBattlePlayer_C::AI_BUTTON_ATTACK' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AI_BUTTON_DODGE) == 0x0016D6, "Member 'ARSBattlePlayer_C::AI_BUTTON_DODGE' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AI_BUTTON_JUMP) == 0x0016D7, "Member 'ARSBattlePlayer_C::AI_BUTTON_JUMP' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AI_BUTTON_ITEM) == 0x0016D8, "Member 'ARSBattlePlayer_C::AI_BUTTON_ITEM' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnTelepoDodgeBegin) == 0x0016E0, "Member 'ARSBattlePlayer_C::OnTelepoDodgeBegin' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OnTelepoDodgeEnd) == 0x0016F0, "Member 'ARSBattlePlayer_C::OnTelepoDodgeEnd' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DispatchChangeWalkRunStateKind) == 0x001700, "Member 'ARSBattlePlayer_C::DispatchChangeWalkRunStateKind' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bObstructPsychicActionSAS) == 0x001710, "Member 'ARSBattlePlayer_C::bObstructPsychicActionSAS' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bObstructPsychicActionPsychic) == 0x001711, "Member 'ARSBattlePlayer_C::bObstructPsychicActionPsychic' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bObstructPsychicActionAttack) == 0x001712, "Member 'ARSBattlePlayer_C::bObstructPsychicActionAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bObstructPsychicActionDrive) == 0x001713, "Member 'ARSBattlePlayer_C::bObstructPsychicActionDrive' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ObstructAnimMontage) == 0x001718, "Member 'ARSBattlePlayer_C::ObstructAnimMontage' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bObstructPsychicActionBrainCrash) == 0x001720, "Member 'ARSBattlePlayer_C::bObstructPsychicActionBrainCrash' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CoverDamagePlayerID) == 0x001721, "Member 'ARSBattlePlayer_C::CoverDamagePlayerID' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bReserveCoverDamage) == 0x001722, "Member 'ARSBattlePlayer_C::bReserveCoverDamage' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, LastCoverDamagePlayerID) == 0x001723, "Member 'ARSBattlePlayer_C::LastCoverDamagePlayerID' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, LastGroundLocation) == 0x001728, "Member 'ARSBattlePlayer_C::LastGroundLocation' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ObstructSequencer) == 0x001738, "Member 'ARSBattlePlayer_C::ObstructSequencer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bBeginningBattleState) == 0x001740, "Member 'ARSBattlePlayer_C::bBeginningBattleState' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ReviveCableStep) == 0x001741, "Member 'ARSBattlePlayer_C::ReviveCableStep' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bUpdateDriveHUD) == 0x001742, "Member 'ARSBattlePlayer_C::bUpdateDriveHUD' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExecReviveDirection) == 0x001743, "Member 'ARSBattlePlayer_C::bExecReviveDirection' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AI_BUTTON_PSYCHIC) == 0x001744, "Member 'ARSBattlePlayer_C::AI_BUTTON_PSYCHIC' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, RedCodeDataTable) == 0x001748, "Member 'ARSBattlePlayer_C::RedCodeDataTable' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, RedCodeActor) == 0x001750, "Member 'ARSBattlePlayer_C::RedCodeActor' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BrainCodeActor) == 0x001760, "Member 'ARSBattlePlayer_C::BrainCodeActor' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, EyeIndex) == 0x001770, "Member 'ARSBattlePlayer_C::EyeIndex' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DispatchMontageEnded) == 0x001778, "Member 'ARSBattlePlayer_C::DispatchMontageEnded' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CurrentAttackComponent) == 0x001788, "Member 'ARSBattlePlayer_C::CurrentAttackComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, EventDownParam) == 0x001790, "Member 'ARSBattlePlayer_C::EventDownParam' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SkillAttack_AirDodgeAttack) == 0x001791, "Member 'ARSBattlePlayer_C::SkillAttack_AirDodgeAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bComboInputEnd) == 0x001792, "Member 'ARSBattlePlayer_C::bComboInputEnd' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bResurrectCameraOn) == 0x001793, "Member 'ARSBattlePlayer_C::bResurrectCameraOn' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SASHologramAttackCheckComponent) == 0x001798, "Member 'ARSBattlePlayer_C::SASHologramAttackCheckComponent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PauseTimerClaimantList) == 0x0017A0, "Member 'ARSBattlePlayer_C::PauseTimerClaimantList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DispatchAttackActorHit) == 0x0017B0, "Member 'ARSBattlePlayer_C::DispatchAttackActorHit' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, EndBrainCrashMontage) == 0x0017C0, "Member 'ARSBattlePlayer_C::EndBrainCrashMontage' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleParticleDataTable) == 0x0017C8, "Member 'ARSBattlePlayer_C::BattleParticleDataTable' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleParticleHeadHandle) == 0x0017D0, "Member 'ARSBattlePlayer_C::BattleParticleHeadHandle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleParticleRightHandHandle) == 0x0017D8, "Member 'ARSBattlePlayer_C::BattleParticleRightHandHandle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleParticleLeftHandHandle) == 0x0017E0, "Member 'ARSBattlePlayer_C::BattleParticleLeftHandHandle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleParticleClaimantList) == 0x0017E8, "Member 'ARSBattlePlayer_C::BattleParticleClaimantList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleParticleType) == 0x0017F8, "Member 'ARSBattlePlayer_C::BattleParticleType' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, VisionFogClaimantList) == 0x001800, "Member 'ARSBattlePlayer_C::VisionFogClaimantList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, WireNeonDataTableData) == 0x001810, "Member 'ARSBattlePlayer_C::WireNeonDataTableData' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleParticleDataList) == 0x001820, "Member 'ARSBattlePlayer_C::BattleParticleDataList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ForceBrainTalkParticle) == 0x001830, "Member 'ARSBattlePlayer_C::ForceBrainTalkParticle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DelayDeactivateBattleParticleTimer) == 0x001838, "Member 'ARSBattlePlayer_C::DelayDeactivateBattleParticleTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DispatchTimerPause) == 0x001840, "Member 'ARSBattlePlayer_C::DispatchTimerPause' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bTalkLookAt) == 0x001850, "Member 'ARSBattlePlayer_C::bTalkLookAt' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TalkLookAtLocation) == 0x001854, "Member 'ARSBattlePlayer_C::TalkLookAtLocation' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DispatchTalkTurn) == 0x001860, "Member 'ARSBattlePlayer_C::DispatchTalkTurn' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bEventSprintFlag) == 0x001870, "Member 'ARSBattlePlayer_C::bEventSprintFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DefaultCameraLength) == 0x001874, "Member 'ARSBattlePlayer_C::DefaultCameraLength' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BrainFieldCameraSetting) == 0x001878, "Member 'ARSBattlePlayer_C::BrainFieldCameraSetting' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bInvisibleMask) == 0x0018A0, "Member 'ARSBattlePlayer_C::bInvisibleMask' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bEnablePsychicComboFlag) == 0x0018A1, "Member 'ARSBattlePlayer_C::bEnablePsychicComboFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bIsEnableSAS) == 0x0018A2, "Member 'ARSBattlePlayer_C::bIsEnableSAS' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMoveParam_Distance) == 0x0018A4, "Member 'ARSBattlePlayer_C::AttackMoveParam_Distance' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMoveParam_Time) == 0x0018A8, "Member 'ARSBattlePlayer_C::AttackMoveParam_Time' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMoveParam_EaseType) == 0x0018AC, "Member 'ARSBattlePlayer_C::AttackMoveParam_EaseType' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMoveParam_EaseBlendExp) == 0x0018B0, "Member 'ARSBattlePlayer_C::AttackMoveParam_EaseBlendExp' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMoveParam_MoveDir) == 0x0018B4, "Member 'ARSBattlePlayer_C::AttackMoveParam_MoveDir' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMove_Timer) == 0x0018C0, "Member 'ARSBattlePlayer_C::AttackMove_Timer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMove_PrevDistance) == 0x0018C4, "Member 'ARSBattlePlayer_C::AttackMove_PrevDistance' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bAttackMove_RotateTarget) == 0x0018C8, "Member 'ARSBattlePlayer_C::bAttackMove_RotateTarget' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bAttackMove_RotateRight) == 0x0018C9, "Member 'ARSBattlePlayer_C::bAttackMove_RotateRight' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CrashChanceCursorOffset) == 0x0018CC, "Member 'ARSBattlePlayer_C::CrashChanceCursorOffset' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, HPGaugeOffset) == 0x0018D8, "Member 'ARSBattlePlayer_C::HPGaugeOffset' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bIsBindSASStart) == 0x0018E4, "Member 'ARSBattlePlayer_C::bIsBindSASStart' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bContentsOpenFlag) == 0x0018E8, "Member 'ARSBattlePlayer_C::bContentsOpenFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bSuspendFlag) == 0x0018F8, "Member 'ARSBattlePlayer_C::bSuspendFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMoveParam_Target) == 0x001900, "Member 'ARSBattlePlayer_C::AttackMoveParam_Target' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMoveParam_BeginLocation) == 0x001908, "Member 'ARSBattlePlayer_C::AttackMoveParam_BeginLocation' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bCheckChargeTelepo) == 0x001914, "Member 'ARSBattlePlayer_C::bCheckChargeTelepo' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TelepoAttackEnchantTimer) == 0x001918, "Member 'ARSBattlePlayer_C::TelepoAttackEnchantTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExJustDodgeFlag) == 0x00191C, "Member 'ARSBattlePlayer_C::bExJustDodgeFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ExJustDodgeAttackRate) == 0x001920, "Member 'ARSBattlePlayer_C::ExJustDodgeAttackRate' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ExJustDodgeCrashRate) == 0x001924, "Member 'ARSBattlePlayer_C::ExJustDodgeCrashRate' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SuperArmorClaimantList) == 0x001928, "Member 'ARSBattlePlayer_C::SuperArmorClaimantList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bLocationChangeFlag) == 0x001938, "Member 'ARSBattlePlayer_C::bLocationChangeFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CurrentDownType) == 0x001939, "Member 'ARSBattlePlayer_C::CurrentDownType' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TimerAccessoryInvalidDamageAfter) == 0x00193C, "Member 'ARSBattlePlayer_C::TimerAccessoryInvalidDamageAfter' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, NpcWarpDitherRate) == 0x001940, "Member 'ARSBattlePlayer_C::NpcWarpDitherRate' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExecNpcRevive) == 0x001944, "Member 'ARSBattlePlayer_C::bExecNpcRevive' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExecTalkEvent) == 0x001945, "Member 'ARSBattlePlayer_C::bExecTalkEvent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleVoiceData) == 0x001948, "Member 'ARSBattlePlayer_C::BattleVoiceData' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bPlayAbleBattleStartVoice) == 0x0019D8, "Member 'ARSBattlePlayer_C::bPlayAbleBattleStartVoice' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DisableFootIKClaimantNameList) == 0x0019E0, "Member 'ARSBattlePlayer_C::DisableFootIKClaimantNameList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExecDynamicEvent) == 0x0019F0, "Member 'ARSBattlePlayer_C::bExecDynamicEvent' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AddDamageMotionBlendRate) == 0x0019F4, "Member 'ARSBattlePlayer_C::AddDamageMotionBlendRate' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PlayerDeadCount) == 0x0019F8, "Member 'ARSBattlePlayer_C::PlayerDeadCount' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, LastThrowPsychicComboLevel) == 0x0019FC, "Member 'ARSBattlePlayer_C::LastThrowPsychicComboLevel' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bDisableActionBoringIdle) == 0x001A00, "Member 'ARSBattlePlayer_C::bDisableActionBoringIdle' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DiscoverIconOffset) == 0x001A04, "Member 'ARSBattlePlayer_C::DiscoverIconOffset' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bEnableJustDodgeAttack) == 0x001A08, "Member 'ARSBattlePlayer_C::bEnableJustDodgeAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bUseENPCOutline) == 0x001A09, "Member 'ARSBattlePlayer_C::bUseENPCOutline' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SkillAttack_JustDodgeAttack) == 0x001A0A, "Member 'ARSBattlePlayer_C::SkillAttack_JustDodgeAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DamageCollisionInvincibleClaimantList) == 0x001A10, "Member 'ARSBattlePlayer_C::DamageCollisionInvincibleClaimantList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SasSeeThroughCutIn) == 0x001A20, "Member 'ARSBattlePlayer_C::SasSeeThroughCutIn' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExecSasSeeThroughCutIn) == 0x001A28, "Member 'ARSBattlePlayer_C::bExecSasSeeThroughCutIn' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SasSeeThroughCutinTimer) == 0x001A2C, "Member 'ARSBattlePlayer_C::SasSeeThroughCutinTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleVoiceFacialAnimTypeCache) == 0x001A30, "Member 'ARSBattlePlayer_C::BattleVoiceFacialAnimTypeCache' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BattleVoiceFacialAnimTypeDT) == 0x001A48, "Member 'ARSBattlePlayer_C::BattleVoiceFacialAnimTypeDT' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, GameOverVoiceData) == 0x001A50, "Member 'ARSBattlePlayer_C::GameOverVoiceData' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, FallTimer) == 0x001A60, "Member 'ARSBattlePlayer_C::FallTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PsychicComboEndTimer) == 0x001A64, "Member 'ARSBattlePlayer_C::PsychicComboEndTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bEnableChaseAttack_PsychicComboTimer) == 0x001A68, "Member 'ARSBattlePlayer_C::bEnableChaseAttack_PsychicComboTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bBattleEm1500) == 0x001A69, "Member 'ARSBattlePlayer_C::bBattleEm1500' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_Jump) == 0x001A70, "Member 'ARSBattlePlayer_C::TutorialSuccess_Jump' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_Psychic) == 0x001A80, "Member 'ARSBattlePlayer_C::TutorialSuccess_Psychic' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_Lockon) == 0x001A90, "Member 'ARSBattlePlayer_C::TutorialSuccess_Lockon' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_Attack) == 0x001AA0, "Member 'ARSBattlePlayer_C::TutorialSuccess_Attack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_Dodge) == 0x001AB0, "Member 'ARSBattlePlayer_C::TutorialSuccess_Dodge' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_ChangeLockon) == 0x001AC0, "Member 'ARSBattlePlayer_C::TutorialSuccess_ChangeLockon' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_LaunchAttack) == 0x001AD0, "Member 'ARSBattlePlayer_C::TutorialSuccess_LaunchAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_Dash) == 0x001AE0, "Member 'ARSBattlePlayer_C::TutorialSuccess_Dash' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_StepInAttack) == 0x001AF0, "Member 'ARSBattlePlayer_C::TutorialSuccess_StepInAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_PsychicCombo) == 0x001B00, "Member 'ARSBattlePlayer_C::TutorialSuccess_PsychicCombo' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bTutorialFlag) == 0x001B10, "Member 'ARSBattlePlayer_C::bTutorialFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bOldInAerial) == 0x001B11, "Member 'ARSBattlePlayer_C::bOldInAerial' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExecMeshFitGround) == 0x001B12, "Member 'ARSBattlePlayer_C::bExecMeshFitGround' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SyncResultCounter) == 0x001B14, "Member 'ARSBattlePlayer_C::SyncResultCounter' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bDecideAttackMoveLocation) == 0x001B18, "Member 'ARSBattlePlayer_C::bDecideAttackMoveLocation' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, AttackMoveParam_GoalLocation) == 0x001B1C, "Member 'ARSBattlePlayer_C::AttackMoveParam_GoalLocation' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, JustDodgeAttackSlowStep) == 0x001B28, "Member 'ARSBattlePlayer_C::JustDodgeAttackSlowStep' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bJustDodgeSlowWeaonAttack) == 0x001B29, "Member 'ARSBattlePlayer_C::bJustDodgeSlowWeaonAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, JustDodgeAttackSlowTimer) == 0x001B2C, "Member 'ARSBattlePlayer_C::JustDodgeAttackSlowTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, JustDodgeAttackTimeDilationParam) == 0x001B30, "Member 'ARSBattlePlayer_C::JustDodgeAttackTimeDilationParam' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ParamJustDodgeCutInTimeDilation) == 0x001B34, "Member 'ARSBattlePlayer_C::ParamJustDodgeCutInTimeDilation' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, JustDodgeAttackSlowTime) == 0x001B38, "Member 'ARSBattlePlayer_C::JustDodgeAttackSlowTime' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, RefNPCMetamorphosis) == 0x001B40, "Member 'ARSBattlePlayer_C::RefNPCMetamorphosis' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, StartBattleWaitTime) == 0x001B48, "Member 'ARSBattlePlayer_C::StartBattleWaitTime' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, MaxStepHeightAtBeginPlay) == 0x001B4C, "Member 'ARSBattlePlayer_C::MaxStepHeightAtBeginPlay' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, Dispatch_AreaChange) == 0x001B50, "Member 'ARSBattlePlayer_C::Dispatch_AreaChange' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PossibleBrainCrashRange) == 0x001B60, "Member 'ARSBattlePlayer_C::PossibleBrainCrashRange' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CurrentInputSasReadyType) == 0x001B64, "Member 'ARSBattlePlayer_C::CurrentInputSasReadyType' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CombinationVisionData) == 0x001B68, "Member 'ARSBattlePlayer_C::CombinationVisionData' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CombinationVisionLearnLevel) == 0x001B94, "Member 'ARSBattlePlayer_C::CombinationVisionLearnLevel' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, EnpcDamageMoveCompRef) == 0x001B98, "Member 'ARSBattlePlayer_C::EnpcDamageMoveCompRef' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bEnableDispNoDamage) == 0x001BA0, "Member 'ARSBattlePlayer_C::bEnableDispNoDamage' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bCanDropData) == 0x001BA1, "Member 'ARSBattlePlayer_C::bCanDropData' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, DisableBehaviorTreeClaimantNameList) == 0x001BA8, "Member 'ARSBattlePlayer_C::DisableBehaviorTreeClaimantNameList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, WeaponEmissiveValue) == 0x001BB8, "Member 'ARSBattlePlayer_C::WeaponEmissiveValue' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bNoCopyAttackFlag) == 0x001BBC, "Member 'ARSBattlePlayer_C::bNoCopyAttackFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, StoredStealthDelayTimer) == 0x001BC0, "Member 'ARSBattlePlayer_C::StoredStealthDelayTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, LastInputAttackTypeSub) == 0x001BC4, "Member 'ARSBattlePlayer_C::LastInputAttackTypeSub' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bStoreLockTargetBeforeBrainCrash) == 0x001BC5, "Member 'ARSBattlePlayer_C::bStoreLockTargetBeforeBrainCrash' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bItemUseNoMotion) == 0x001BC6, "Member 'ARSBattlePlayer_C::bItemUseNoMotion' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bUseDirectionControlForAI) == 0x001BC7, "Member 'ARSBattlePlayer_C::bUseDirectionControlForAI' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bFallAbleGroundCheckResult) == 0x001BC8, "Member 'ARSBattlePlayer_C::bFallAbleGroundCheckResult' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bManageCheckFall) == 0x001BC9, "Member 'ARSBattlePlayer_C::bManageCheckFall' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, TutorialSuccess_AttackSub) == 0x001BD0, "Member 'ARSBattlePlayer_C::TutorialSuccess_AttackSub' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bInputAttackSUb) == 0x001BE0, "Member 'ARSBattlePlayer_C::bInputAttackSUb' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bStopEndDriveMode) == 0x001BE1, "Member 'ARSBattlePlayer_C::bStopEndDriveMode' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bReserveInitializeDrive) == 0x001BE2, "Member 'ARSBattlePlayer_C::bReserveInitializeDrive' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExecTelepoFadeOut) == 0x001BE3, "Member 'ARSBattlePlayer_C::bExecTelepoFadeOut' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, RegisterAttackKind) == 0x001BE4, "Member 'ARSBattlePlayer_C::RegisterAttackKind' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExecutedLibraryUpdate) == 0x001BE5, "Member 'ARSBattlePlayer_C::bExecutedLibraryUpdate' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, EventEndParticleList) == 0x001BE8, "Member 'ARSBattlePlayer_C::EventEndParticleList' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, VisibilityBasedAnimTickOptionDefault) == 0x001BF8, "Member 'ARSBattlePlayer_C::VisibilityBasedAnimTickOptionDefault' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bExecuteCombinationAttack) == 0x001BF9, "Member 'ARSBattlePlayer_C::bExecuteCombinationAttack' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bSasAttackTelepoFlag) == 0x001BFA, "Member 'ARSBattlePlayer_C::bSasAttackTelepoFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SASSelectSlowRate) == 0x001BFC, "Member 'ARSBattlePlayer_C::SASSelectSlowRate' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ReserveDriveTime) == 0x001C00, "Member 'ARSBattlePlayer_C::ReserveDriveTime' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, ReserveDriveExtendTime) == 0x001C04, "Member 'ARSBattlePlayer_C::ReserveDriveExtendTime' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, Dispatch_ItemApply) == 0x001C08, "Member 'ARSBattlePlayer_C::Dispatch_ItemApply' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bSkipResetEventAction) == 0x001C18, "Member 'ARSBattlePlayer_C::bSkipResetEventAction' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PoolAssultVisionRequest) == 0x001C20, "Member 'ARSBattlePlayer_C::PoolAssultVisionRequest' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bUseMeshFootGroundFromFoot) == 0x001C30, "Member 'ARSBattlePlayer_C::bUseMeshFootGroundFromFoot' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bMeshFitChangeLocation) == 0x001C31, "Member 'ARSBattlePlayer_C::bMeshFitChangeLocation' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, IsSpawn) == 0x001C32, "Member 'ARSBattlePlayer_C::IsSpawn' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpawnStartDistance) == 0x001C34, "Member 'ARSBattlePlayer_C::SpawnStartDistance' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, IsSpawnNow) == 0x001C38, "Member 'ARSBattlePlayer_C::IsSpawnNow' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpawnWaitDelayTime) == 0x001C3C, "Member 'ARSBattlePlayer_C::SpawnWaitDelayTime' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpawnStartDelayTime) == 0x001C40, "Member 'ARSBattlePlayer_C::SpawnStartDelayTime' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpawnUpdateTime) == 0x001C44, "Member 'ARSBattlePlayer_C::SpawnUpdateTime' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpawnState) == 0x001C48, "Member 'ARSBattlePlayer_C::SpawnState' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpawnClaimantName) == 0x001C4C, "Member 'ARSBattlePlayer_C::SpawnClaimantName' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpawnCollisionProfileName) == 0x001C54, "Member 'ARSBattlePlayer_C::SpawnCollisionProfileName' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpawnMovementMode) == 0x001C5C, "Member 'ARSBattlePlayer_C::SpawnMovementMode' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, SpawnTimer) == 0x001C60, "Member 'ARSBattlePlayer_C::SpawnTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bInputLockTargetChanged) == 0x001C6C, "Member 'ARSBattlePlayer_C::bInputLockTargetChanged' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BrainCrashHealPool) == 0x001C70, "Member 'ARSBattlePlayer_C::BrainCrashHealPool' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BrainCrashHealInterval) == 0x001C80, "Member 'ARSBattlePlayer_C::BrainCrashHealInterval' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, CurrentWireNeonState) == 0x001C84, "Member 'ARSBattlePlayer_C::CurrentWireNeonState' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OptionAttackDirOrthoLockon) == 0x001C85, "Member 'ARSBattlePlayer_C::OptionAttackDirOrthoLockon' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OptionAttackDirOrtho) == 0x001C86, "Member 'ARSBattlePlayer_C::OptionAttackDirOrtho' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OptionSasCutin) == 0x001C87, "Member 'ARSBattlePlayer_C::OptionSasCutin' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OptionAttackDirOrthoDistance) == 0x001C88, "Member 'ARSBattlePlayer_C::OptionAttackDirOrthoDistance' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, OptionAutoAimOverwriteSpeed) == 0x001C8C, "Member 'ARSBattlePlayer_C::OptionAutoAimOverwriteSpeed' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BrainCrashHealSoundPool) == 0x001C90, "Member 'ARSBattlePlayer_C::BrainCrashHealSoundPool' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BrainCrashHealEffectPool) == 0x001CA0, "Member 'ARSBattlePlayer_C::BrainCrashHealEffectPool' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bInvisibleBFHood) == 0x001CB0, "Member 'ARSBattlePlayer_C::bInvisibleBFHood' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BackbodyAttachmentDitherTimer) == 0x001CB4, "Member 'ARSBattlePlayer_C::BackbodyAttachmentDitherTimer' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bBackbodyAttachmentVisibility) == 0x001CC0, "Member 'ARSBattlePlayer_C::bBackbodyAttachmentVisibility' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, BadStatusCablePlayVoiceDelayTime) == 0x001CC4, "Member 'ARSBattlePlayer_C::BadStatusCablePlayVoiceDelayTime' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bBattleSimulatorMissionCancel) == 0x001CC8, "Member 'ARSBattlePlayer_C::bBattleSimulatorMissionCancel' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bBrainCrashSuccess) == 0x001CC9, "Member 'ARSBattlePlayer_C::bBrainCrashSuccess' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PhotoModeBackUp_IsHoodVisibility) == 0x001CCA, "Member 'ARSBattlePlayer_C::PhotoModeBackUp_IsHoodVisibility' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PhotoMode_HoodVisibilityFlag) == 0x001CCB, "Member 'ARSBattlePlayer_C::PhotoMode_HoodVisibilityFlag' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, JustDodgeAttackTimeDilationCalc) == 0x001CCC, "Member 'ARSBattlePlayer_C::JustDodgeAttackTimeDilationCalc' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, PhotoModeBackupBoundsScale) == 0x001CD0, "Member 'ARSBattlePlayer_C::PhotoModeBackupBoundsScale' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, bInitializeMaxStepHeight) == 0x001CD4, "Member 'ARSBattlePlayer_C::bInitializeMaxStepHeight' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, RecoverAfterInvalidDamageTime) == 0x001CD8, "Member 'ARSBattlePlayer_C::RecoverAfterInvalidDamageTime' has a wrong offset!");
static_assert(offsetof(ARSBattlePlayer_C, RecoverAfterInvalidDamageClaimantName) == 0x001CDC, "Member 'ARSBattlePlayer_C::RecoverAfterInvalidDamageClaimantName' has a wrong offset!");

}

