#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RSBattleCharacter

#include "Basic.hpp"

#include "ECharaExecuteNotifyKind_structs.hpp"
#include "FNotifyAttackData_structs.hpp"
#include "Engine_structs.hpp"
#include "ECharaDeadType_structs.hpp"
#include "ST_DisplayDamageBrainCrashInfo_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "EAnimNotifyTimeDilationMode_structs.hpp"
#include "BattlePrototype_structs.hpp"
#include "BattlePrototype_classes.hpp"
#include "EAttackAttribute_structs.hpp"
#include "EBonusGhostType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass RSBattleCharacter.RSBattleCharacter_C
// 0x07F0 (0x10F0 - 0x0900)
class ARSBattleCharacter_C : public ARSCharacterBase
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0900(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UBP_DamageFloatingControlComponent_C*   BP_DamageFloatingControlComponent;                 // 0x0908(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBPC_RenderScarComponent_C*             BPC_RenderScarComponent;                           // 0x0910(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_HpEventComponent_C*                 BP_HpEventComponent;                               // 0x0918(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_RSCharacterCommonDataComponent_C*   BP_RSCharacterCommonDataComponent;                 // 0x0920(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AssetLoadComponent_C*               BP_AssetLoadComponent;                             // 0x0928(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UParticleManageComponent_C*             WeakDamageParticleManageComponent;                 // 0x0930(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCapsuleComponent*                      CharacterOverlapCapsuleComponent;                  // 0x0938(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EventParamComponent_C*              BP_CharacterEventComponent;                        // 0x0940(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_GhostTrailComponent_C*              BP_GhostTrailComponent;                            // 0x0948(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UHateTargetComponent*                   HateTarget;                                        // 0x0950(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCharactersParameterComponent*          CharactersParameter;                               // 0x0958(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UDamageArrayComponent*                  DamageArray;                                       // 0x0960(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UDynamicMaterialControllerComponent*    DynamicMaterialController;                         // 0x0968(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UAutoAimComponent*                      AutoAim;                                           // 0x0970(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UHoveringComponent*                     Hovering;                                          // 0x0978(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UContinualMoveComponent*                ContinualMove;                                     // 0x0980(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UMoveImpulseComponent*                  MoveImpulse;                                       // 0x0988(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UHitStopComponent*                      HitStop;                                           // 0x0990(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UHitBitComponent*                       HitBit;                                            // 0x0998(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UHitCheckReceiverComponent*             HitCheckReceiver;                                  // 0x09A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UDamageResponseComponent*               DamageResponse;                                    // 0x09A8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UDamageAcceptComponent*                 DamageAccept;                                      // 0x09B0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UDamageCalcComponent*                   DamageCalc;                                        // 0x09B8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UTeamComponent*                         Team;                                              // 0x09C0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UDamagePropertyMediatorComponent*       DamagePropertyMediator;                            // 0x09C8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UMovementPropertyMediator*              MovementPropertyMediator;                          // 0x09D0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class FName                                   BattleCharaClaimantName;                           // 0x09D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CharactersParameterOffset;                         // 0x09E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseCharactersParameterName;                        // 0x09E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EB5[0x3];                                     // 0x09E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharactersParameterName;                           // 0x09E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             CharactersParameterTable;                          // 0x09F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseDeadCharacterName;                              // 0x09F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EB6[0x3];                                     // 0x09F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HateParamName;                                     // 0x09FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3EB7[0x4];                                     // 0x0A04(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             HateParamTable;                                    // 0x0A08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bNotifyAnimEnd;                                    // 0x0A10(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bReserveAnimEnd;                                   // 0x0A11(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EB8[0x2];                                     // 0x0A12(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinRadomX;                                         // 0x0A14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaxRadomX;                                         // 0x0A18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MinRadomY;                                         // 0x0A1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaxRadomY;                                         // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MinRadomZ;                                         // 0x0A24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MaxRandomZ;                                        // 0x0A28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bNotDamageMotion;                                  // 0x0A2C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	ECharaDeadType                                CharaDeadType;                                     // 0x0A2D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3EB9[0x2];                                     // 0x0A2E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FrameDamageTimer;                                  // 0x0A30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3EBA[0x4];                                     // 0x0A34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BadStateFlameParticle;                             // 0x0A38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         BadStateFlameSoftReference;                        // 0x0A40(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         BadStateFlameParticleHandle;                       // 0x0A68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CurrentAttackAttribute;                            // 0x0A70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3EBB[0x4];                                     // 0x0A74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BadStateElecParticle;                              // 0x0A78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         BadStateElecSoftReference;                         // 0x0A80(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         BadStateElecParticleHandle;                        // 0x0AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FGameTimer                             BadEffectWetChangeTimer;                           // 0x0AB0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EBC[0x4];                                     // 0x0ABC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AttackHitActorList;                                // 0x0AC0(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         AreaChangeGravityScale;                            // 0x0AD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         OutlineMaterialIndex;                              // 0x0AD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          OutlineMaterialEnabled;                            // 0x0AD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          OutlineMaterialForceEnabled;                       // 0x0AD9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EBD[0x2];                                     // 0x0ADA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutlineMaterialLength;                             // 0x0ADC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UseDefaultCapsuleShadow;                           // 0x0AE0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          UseForceMeshShadow;                                // 0x0AE1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EBE[0x6];                                     // 0x0AE2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharactersParameterTable              CharacterParameterTableData;                       // 0x0AE8(0x01F8)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UMaterialInstanceDynamic*               SkinMaterial;                                      // 0x0CE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AreaChangeSave;                                    // 0x0CE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EBF[0x7];                                     // 0x0CE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BadStateConfusionParticle;                         // 0x0CF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         BadStateConfusionSoftReference;                    // 0x0CF8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash)
	struct FVector                                BadStateConfusionParticleScale;                    // 0x0D20(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   BadStateConfusionParticleSocketName;               // 0x0D2C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3EC0[0x4];                                     // 0x0D34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         BadStateConfusionParticleHandle;                   // 0x0D38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         GroupID;                                           // 0x0D40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsEventWeak;                                       // 0x0D44(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	uint8                                         Pad_3EC1[0x3];                                     // 0x0D45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProvokeParticleScale;                              // 0x0D48(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3EC2[0x4];                                     // 0x0D54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       InvalidDamageRequests;                             // 0x0D58(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<class FName, class UParticleSystemComponent*> AnimNotifyStateEffectHandle;                       // 0x0DA8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          IsGraceDamage;                                     // 0x0DF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EC3[0x3];                                     // 0x0DF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IgnoreEffectLoopSeconds;                           // 0x0DFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsRatioDamage;                                     // 0x0E00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EC4[0x3];                                     // 0x0E01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubGroupID;                                        // 0x0E04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHitDelayDeath;                                   // 0x0E08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EC5[0x3];                                     // 0x0E09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFNotifyAttackData                     NotifyAttackData;                                  // 0x0E0C(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3EC6[0x4];                                     // 0x0E1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FinishActor;                                       // 0x0E20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bAccelerating;                                     // 0x0E28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bBadEffectWetDirEnable;                            // 0x0E29(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EC7[0x2];                                     // 0x0E2A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WetOnChangeSeconds;                                // 0x0E2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         WetOffChangeSeconds;                               // 0x0E30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bInBeginPlay;                                      // 0x0E34(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bBindHitSlow;                                      // 0x0E35(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          UseDither;                                         // 0x0E36(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, Interp, NoDestructor)
	bool                                          UseDitherBefore;                                   // 0x0E37(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	struct FCharacterDither                       CameraDitherData;                                  // 0x0E38(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          SetupCelLookMat;                                   // 0x0E58(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EC8[0x7];                                     // 0x0E59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               BadStateIconHandle;                                // 0x0E60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class URSParticleSystemComponentBase*> CameraDitherParticleList;                          // 0x0E68(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	class UDataTable*                             CameraDitherDataTableAsset;                        // 0x0E78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bOccupiedCameraAttention;                          // 0x0E80(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EC9[0x7];                                     // 0x0E81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       SuperArmorRequests;                                // 0x0E88(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          MeshFitGroundMultipleChecks;                       // 0x0ED8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsLeader;                                          // 0x0ED9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ECA[0x2];                                     // 0x0EDA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RushBrainFieldLocation;                            // 0x0EDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          RushBrainFieldLongAway;                            // 0x0EE0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ECB[0x7];                                     // 0x0EE1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 BrainCrashEvent;                                   // 0x0EE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsPartsInvincible;                                 // 0x0EF0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bAreaChange;                                       // 0x0EF1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bNoTipsCheckBadStatusOil;                          // 0x0EF2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bNoTipsCheckBadStatusFlooded;                      // 0x0EF3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bIsBrainCrashEventFlag;                            // 0x0EF4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ECC[0x3];                                     // 0x0EF5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DTEnemyAnimScaleHitStop;                           // 0x0EF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EHCSkillAttackType                            ReceiveAttackType;                                 // 0x0F00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableNormalAttackReactionCoefficient;            // 0x0F01(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bEnablePsychicAttackReactionCoefficient;           // 0x0F02(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ECD[0x1];                                     // 0x0F03(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReactionCoefficientReactionSRate;                  // 0x0F04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ReactionCoefficientReactionLRate;                  // 0x0F08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ReactionCoefficientDownRate;                       // 0x0F0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ReactionCoefficientCrashRate;                      // 0x0F10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHitDDInstantKill;                                // 0x0F14(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ECE[0x3];                                     // 0x0F15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BrainCrashDamageDisplayOffset;                     // 0x0F18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDamageDisplayOffset;                              // 0x0F20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsNoFinishBrainCrash;                              // 0x0F21(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ECF[0x6];                                     // 0x0F22(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_DisplayDamageBrainCrashInfo        DisplayBrainCrashDamageInfo;                       // 0x0F28(0x0030)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsDisplayBossHp;                                   // 0x0F58(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED0[0x3];                                     // 0x0F59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BossDispBCDamageSecond;                            // 0x0F5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   BrainCrashDamageDisplayPointName;                  // 0x0F60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         InScreenTolerance;                                 // 0x0F68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BossDelayResetCrashSecond;                         // 0x0F6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BattlefieldFenceAppearRate;                        // 0x0F70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsFindBattlefieldFenceOnce;                        // 0x0F74(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bCanSetTick;                                       // 0x0F75(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsFrameDamage;                                     // 0x0F76(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED1[0x9];                                     // 0x0F77(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BrainFieldNormalTransform;                         // 0x0F80(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsStartFindBattlefieldFence;                       // 0x0FB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	ERootMotionMode                               LastRootMotionMode;                                // 0x0FB1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDisableMeshFitGround;                             // 0x0FB2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED2[0x5];                                     // 0x0FB3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DiableMeshFitGroundClaimantList;                   // 0x0FB8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         UnaffectedTimeDilation;                            // 0x0FC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         UnaffectedDilationTimer;                           // 0x0FCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EAnimNotifyTimeDilationMode                   UnaffectedDilationMode;                            // 0x0FD0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsActiveUpdateUnaffectedTimeDilation;              // 0x0FD1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED3[0x6];                                     // 0x0FD2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ClaimantNameUnaffectedTimeDilation;                // 0x0FD8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	class UCurveFloat*                            UnaffectedCameraAttentionActorCurveOut;            // 0x0FE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCurveFloat*                            UnaffectedCameraAttentionFovCurveOut;              // 0x0FF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         UnaffectedCameraAttentionTimer;                    // 0x0FF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsActiveUpdateUnaffectedCameraAttention;           // 0x0FFC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsEnableSpawnCondition;                            // 0x0FFD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsCheckSpawnCondition;                             // 0x0FFE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED4[0x1];                                     // 0x0FFF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        SpawnLocation;                                     // 0x1000(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<class FName>                           DisableCrashVisionNames;                           // 0x1010(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<class FName>                           InvincibleCrashVisionDamageNames;                  // 0x1020(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          CheckRareSpawnHpRate;                              // 0x1030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED5[0x3];                                     // 0x1031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HpRateRareSpawnHpRate;                             // 0x1034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ARSBattleCharacter_C*                   EnemyActorRareSpawnHpRate;                         // 0x1038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IgnoreDisableOutOfBattlefield;                     // 0x1040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bReserveCrashVisionShockWave;                      // 0x1041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED6[0x2];                                     // 0x1042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrashVisionEffectDelayTime;                        // 0x1044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIgnoreVisionSimulatorScore;                       // 0x1048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bCanSetTickDistance;                               // 0x1049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsCableDamage;                                     // 0x104A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED7[0x1];                                     // 0x104B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CableDamageTimer;                                  // 0x104C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        BadStateCableParticle;                             // 0x1050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         BadStateCableSoftReference;                        // 0x1058(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         BadStateCableParticleHandle;                       // 0x1080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBossBrainCrashDifferentEnemyLock;                // 0x1088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED8[0x7];                                     // 0x1089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FST_DisplayDamageBrainCrashInfo        DisplayBrainCrashDamageInfo_Simulator;             // 0x1090(0x0030)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bReserveVisionSimulatorBrainCrashDamage;           // 0x10C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bSimulatorStartDirection;                          // 0x10C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3ED9[0x6];                                     // 0x10C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSCharacterBase*                       BossBrainCrashDifferentLockEnemy;                  // 0x10C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BackupCameraDitherValue;                           // 0x10D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bPhotoModeBackupGenerateOverlap;                   // 0x10D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EDA[0x3];                                     // 0x10D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PhotoModeBackupProfileName;                        // 0x10D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bAcceptAllReactionCoefficient;                     // 0x10E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3EDB[0x3];                                     // 0x10E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PhotoModeBackupLod;                                // 0x10E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bPhotoModeBackupOutline;                           // 0x10E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)

public:
	void ExecuteUbergraph_RSBattleCharacter(int32 EntryPoint);
	void OnBrainCrashStart(bool bBeginActor);
	void RegisterEffectInterface(class URSParticleSystemComponentBase* Particle);
	void RegisterInterruptTelepoEffectInterface(class URSParticleSystemComponentBase* Particle);
	void SetNoCrashChanceEvent(bool NoCrashChanceEvent);
	void SetNoDeadEvent(bool NoDeadEvent);
	void EndNoDeadNoCrashChanceEvent();
	void UnBindUnaffectedCameraAttention();
	void BindUnaffectedCameraAttention();
	void UnBindUnaffectedTimeDilationTick();
	void BindUnaffectedTimeDilationTick();
	void BrainFieldCloseEnd(class AActor* BrainFieldUser, bool IsAttacker, EBrainFieldEndType EndType);
	void BrainFieldCloseStart(class AActor* BrainFieldUser, bool IsAttacker, EBrainFieldEndType EndType);
	void BndEvt__HitCheckReceiver_K2Node_ComponentBoundEvent_3_HitResultDelegate__DelegateSignature(const struct FHCHitResult& Result);
	void AreaChangeFadeOut();
	void DisEnableNoDeadTutorial();
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_0_BadStateOffDelegate__DelegateSignature(EHCBadState bad_state);
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_6_BadStateOnDelegate__DelegateSignature(EHCBadState bad_state, class AActor* Attacker);
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void UnbindHitSlowDispatcher();
	void OnHitSlow();
	void BindHitSlowDispatcher();
	void BndEvt__DamageAccept_K2Node_ComponentBoundEvent_5_DamageHitDelegate__DelegateSignature(const struct FHCHitResult& HitResult, int32 Damage);
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_2_NotifyFinishActor__DelegateSignature(class AActor* Finisher);
	void ReceiveUniqueInputEnd();
	void BndEvt__CharacterOverlapCapsuleComponent_K2Node_ComponentBoundEvent_1_ComponentEndOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void BndEvt__CharacterOverlapCapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_0_HpDelegate__DelegateSignature(int32 Current_hp, int32 base_hp);
	void BndEvt__DamageResponse_K2Node_ComponentBoundEvent_0_DamageResponceDelegate__DelegateSignature(const struct FHCHitResult& HitResult, int32 Damage);
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_0_SimpleMulticastDelegateBP__DelegateSignature();
	void BndEvt__DamageResponse_K2Node_ComponentBoundEvent_4_DamageResponceDelegate__DelegateSignature(const struct FHCHitResult& HitResult, int32 Damage);
	void BndEvt__HitCheckReceiver_K2Node_ComponentBoundEvent_291_HitResultDelegate__DelegateSignature(const struct FHCHitResult& Result);
	void ReceiveTick(float DeltaSeconds);
	void ReceiveBeginPlay();
	void SetGhostActive(bool Active);
	void OnGhostOneShot(float AliveTime);
	void UnbindBadStateCableDamageTick();
	void BindBadStateCableDamageTick();
	void OnBrainCrashEnd(bool bBeginActor, class UAnimMontage* PlayerEndMontage);
	void UnbindBadStateFlameDamageTick();
	void BindBadStateFlameDamageTick();
	void SetInvalidDamageInterface(bool bInvalidDamage, class FName ClaimantName, int32 Param);
	void ProcDamageBefore(bool IgnoreAutoSasMetal);
	void ProcDamageActorHit(const struct FHCHitResult& HitResult);
	void ProcDamageAfter(const TArray<struct FHCHitResult>& Result);
	void BndEvt__DamageAccept_K2Node_ComponentBoundEvent_6_DamagePopupDelegate__DelegateSignature(const struct FVector& Location, int32 Damage, float CrashDamage, EDamagePointKind Kind, bool IsCritical, bool IsWeakhit, bool IsStealthCritical, bool IsBrainCrash, class AActor* AttackActor);
	void BndEvt__DamageAccept_K2Node_ComponentBoundEvent_5_StartDamageAnimDelegate__DelegateSignature(const struct FHCHitResult& HitResult, int32 Damage, bool IsDamage);
	void BndEvt__HitCheckReceiver_K2Node_ComponentBoundEvent_294_HitResultDelegate__DelegateSignature(const struct FHCHitResult& Result);
	void UnbindDelayCrashVision_Effect();
	void BindDelayCrashVisionEffect();
	void SetCounter();
	void SetCounterWait(bool Wait_on_in);
	void IsBadStausMetalMode();
	void OnBrainCrashTargetFloating();
	void OnBrainCrashStartUserMotion();
	void OnBrainCrashDead();
	void OnBrainCrashDamage();
	void BrainFieldOverrideStart(class AActor* BrainFieldUser, bool IsAttacker);
	void BrainFieldMoveNormalField(class AActor* BrainFieldUser, bool IsAttacker, EBrainFieldEndType EndType);
	void BrainFieldMoveBrainField(class AActor* BrainFieldUser, bool IsAttacker);
	void BrainFieldOpenEnd(class AActor* BrainFieldUser, bool IsAttacker);
	void BrainFieldOpenStart(class AActor* BrainFieldUser, bool IsAttacker);
	void OnBonusGhostOneShot(float AliveTime);
	void OnBonusGhostFromDT(EBonusGhostType Type);
	void OnBonusGhost(float Time);
	void EventPhysicsIdling(float IdlingSec, float IdleRestoreDelay);
	void DebugMovementModePrint();
	void OnDead(bool* Dummy);
	void OnDeadCoreBattleChara();
	void OnAttackActorHit(const struct FHCHitResult& HitResult, bool* Dummy);
	void OnDamageActorHit(struct FHCHitResult& HitResult, bool* Dummy);
	void IsExecGuard(bool* IsExec);
	void ShakeCameraInDamage(struct FHCHitResult& HitResult);
	void GetBulletAimTarget(class AActor** Target);
	void StartDamageAnimFunc(const struct FHCHitResult& HitResult, int32 DamageValue, bool IsDown, bool* Dummy);
	void OnDamaging(const struct FHCHitResult& HitResult, float DamageValue, bool* Dummy);
	void Revive();
	void OnRevive(bool* Dummy);
	void SetBattling(bool bBattling, bool* Dummy);
	void GetCharactersParameterTable(struct FCharactersParameter* Param);
	void SetCharactersParameterAll();
	void GetHitNearCharacter(float Length, TArray<class AActor*>* Actor);
	void DamageAfter(TArray<struct FHCHitResult>& Result);
	void GetHateParamTable(struct FHateParamData* Return);
	void SetHateParam();
	void PreTick(float DeltaSeconds, bool* Dummy);
	void MainTick(float DeltaSeconds, bool* Dummy);
	void PostTick(float DeltaSeconds, bool* Dummy);
	void SetRootMotionMode(ERootMotionMode Mode);
	void AddRandomLocation(const struct FVector& Vector, struct FVector* Return);
	void SetInvalidDamage(bool bInvalid, int32 Param, class FName ClaimantName, bool* Dummy);
	void IsSuperArmor(bool* bSuperArmor);
	void SetSuperArmor(bool bSuperArmor, class FName ClaimantName);
	void FrameDamage(float Sec);
	void BadStateEffectOn(EHCBadState bad);
	void BadStateEffectOff(EHCBadState bad);
	void BadStateEffectAllOff();
	void AddCurrentAttackAttribute(EAttackAttribute Attribute);
	void ClearCurrentAttackAttribute();
	void SetBrainAndBadStatusParam(float BrainCrashTimer, float BrainCrashMissScale);
	void BadStateEffectOffFlame(bool* bDummy);
	void BadStateEffectOffElec(bool* bDummy);
	void BadStateEffectOnFlame(bool* bDummy);
	void BadStateEffectOnElec(bool* bDummy);
	void BadStateEffectOnFlooded(bool* bDummy);
	void BadStateEffectOnOil(bool* bDummy);
	void BadStateEffectOnConfusion(bool* bDummy);
	void BadStateEffectOffFlooded(bool bNoMaterial, bool* bDummy);
	void BadStateEffectOffOil(bool bNoMaterial, bool* bDummy);
	void BadStateEffectOffConfusion(bool* bDummy);
	void UpdateBadStateEffect(bool* bDummy);
	void SetFootIKEnable(bool Enable, float BlendTime, bool* Dummy);
	void PrevCheckOnAttackActorHit(const struct FHCHitResult& HitResult, bool* bOK);
	void OnAttackWeakHit(const struct FHCHitResult& HitResult, bool* bDummy);
	void AreaChangeStart();
	void AreaStart();
	void AreaChangeFadeOut_Internal();
	void UpdateMaterialVisibility(bool* ChangeVisibility, bool* NewVisibility);
	void InitializeMaterialVisibility();
	void SetForceMaterialOutlineVisibility(bool ForceEnabled);
	void InitializeShadow();
	void SetForceMeshShadow(bool ForceMeshShadow);
	void SetCharactersParameterData(const struct FCharactersParameterTable& ParamTable);
	void InitializeMaterial();
	void DamageAfterCommon();
	void DebugDisplayStatus();
	void IsStealthEnable(bool* Return);
	void OnCharacterAssetLoad(bool* Return);
	void IsEyesCheck(const struct FVector& StartLocation, const struct FVector& TargetLocation, bool* IsEyes);
	void DirectAttack(bool UseFixDamage, int32 FixDamage, class UDataTable* DataTable, class FName SkillName, class AActor* Attacker, class AActor* AttackerOwner, bool IgnoreInvalid, const struct FHCHitEffectInfo& Effect_Info, bool UseHitPosition, const struct FVector& HitPosition, bool NoDamageDisplay, bool bNotifyAttackActorHit);
	void BrainCrashLock();
	void GetAnimNotifyCondition(int32 ConditionNo, bool* Result);
	void IsNotDamageMotion(bool* Param_bNotDamageMotion);
	void SetNotDamageMotion(bool Param_bNotDamageMotion);
	void GetBulletDirection(const struct FVector& FireLocation, const struct FVector& TargetLocation, const struct FVector& FireForwardVector, float MaxAngle_XY, float MaxAngle_Z, struct FVector* BulletDirection);
	void ReceivedNotifyAnimEnd(bool* Received);
	void SetNotifyAnimEnd();
	void SetDelayDeath(bool* Dummy);
	void CheckDelayDeath(const struct FHCHitResult& HitResult);
	void RequestHitStop(TArray<struct FHCHitResult>& HitResult);
	void ReceiveDamageScar(const struct FHCHitResult& HitResult);
	void CheckHateCalc(const struct FHCHitResult& HitResult, int32 Damage);
	void IsPlayShakeCamera(struct FHCHitResult& HitResult, bool* bCanPlay);
	void ShakeCameraInRange(class UClass* ShakeClass, float Scale, const struct FVector& ShakeLocation);
	void SelectShake(class UClass* ShakeClass, float Scale, const struct FVector& ShakeLocation, class UClass** ReturnClass, float* ReturnScale);
	void DamageBefore(bool IgnoreAutoSasMetal, bool* bDummy);
	void DoEventStart(bool* bDummy);
	void DoEventEnd(bool* bDummy);
	void DoStaticEventStart(bool* bDummy);
	void DoStaticEventEnd(bool* bDummy);
	void DoDynamicEventStart(bool* bDummy);
	void DoDynamicEventEnd(bool* bDummy);
	void DoTalkEventStart(bool* bDummy);
	void DoTalkEventEnd(bool* bDummy);
	void DoBattleSequencerStart(bool bSetEnemyEvent, bool bDriveSequence, bool* bDummy);
	void DoBattleSequencerEnd(bool bSetEnemyEvent, bool bDriveSequence, bool* bDummy);
	void LoadCameraDitherData();
	void CheckCameraDitherApply(const struct FVector& WorldLocation, float HalfHeight, const struct FRotator& WorldRotation, bool* Apply);
	bool SetHiddenCharacterAttachment(bool NewHidden);
	void SetupCelLookMaterialNonPlayer();
	void FinalizeCelLookMaterial();
	void IsPlayVibrationController(struct FHCHitResult& HitResult, bool* bCanPlay);
	void VibrationControllerInDamage(struct FHCHitResult& HitResult);
	bool SetActorAllTickEnabled(bool bEnabled);
	void DoHPEvent(int32 NewHP, int32 PrevHP, bool* bDummy);
	void BadStateIconOn(const struct FBadStateAddParticleData& Data, class UParticleSystemComponent** Handle);
	void BadStateIconOff(bool* Dummy);
	void RegisterCameraDitherParticleHandle(class URSParticleSystemComponentBase* Particle);
	void UnregisterCameraDitherParticleHandle(class URSParticleSystemComponentBase* Particle);
	void SetCameraDitherToParticle(float DeitherValue);
	void CameraAttentionStart(class UCurveFloat* ActorCurveIn, bool bChangeFov, float TargetFov, class UCurveFloat* FovCurveIn, bool bEnableOffsetAngleVt, float OffsetAngleVtIn, bool bEnableOffsetDist, float OffsetDistIn, bool* Dummy);
	void CameraAttentionEnd(class UCurveFloat* ActorCurveOut, class UCurveFloat* FovCurveOut, bool* Dummy);
	void CallDead(bool* Dummy);
	void GetMeshFitGroundCheckLocationArray(TArray<struct FVector>* Location, float* CheckHeight);
	void CheckExecuteNotifyKind(class AActor* Param_Owner, ECharaExecuteNotifyKind ExecuteKind, bool* IsExecute);
	void CalculateBrainCrashDamage(int32* Damage);
	void IsLastBrainCrash(bool* IsLast);
	void IsEnableCharacterTick(bool* bEnable);
	void OnSetStealthMode(bool bStealth, bool* bSuccess);
	void DebugSetCharaParam(class FName DebugParamName);
	void CheckBadStatusTips(EHCBadState BadStatus);
	void CameraAttentionStart_LookAtPos(class UCurveFloat* ActorCurveIn, bool bChangeFov, float TargetFov, class UCurveFloat* FovCurveIn, bool bEnableOffsetAngleVt, float OffsetAngleVtIn, bool bEnableOffsetDist, float OffsetDistIn, const struct FVector& LookAtPos, bool* Dummy);
	void SetBodyMaterialScalarParameter(class FName ParameterName, float ParameterValue);
	void CheckReceiveStealthCritical(const struct FHCHitResult& HitResult, bool* Return);
	void DoDynamicEventBeforeBindCharacter(bool* bDummy);
	void SetupMaterialOutlineIndex();
	void ResetSelfHateFromEnemy();
	void IsBossHpDisp(bool* IsDisp);
	void InitializeDifficulty(bool* bDummy);
	void CalcDirectDamageValue(class UDataTable* DataTable, class FName SkillName, class AActor* Attacker, class AActor* AttackerOwner, int32* DamageValue);
	struct FVector GetLookAtTargetLocation();
	struct FVector GetAutoAimTargetLocation();
	void SetCharactersParameterName();
	void GetAssumptionData(bool bondsIn, EPlayerID bondsPlayerID_In, EPlayerID bondsTargetID_In, bool* Retrun_enable, int32* OutAssumptionLv, bool* OutRelativeLv, bool* OutIsFreeLv);
	bool AddScarFromHitDamageInfoInterface(class AActor* Actor, const struct FHitDamageInfo& HitDamageInfo);
	bool IsEnableSlashEffectInterface(const struct FHCHitResult& HitResult);
	bool IsHitWeakChangeDefaultEffectInterface();
	bool IsDisableAtomCuePlayInterface();
	void OnDamageArmorBreak(bool* bDummy);
	void EnableSetCanTick();
	void DisenableSetCanTick();
	bool IsCounterWaitInterface();
	bool SetCounterInterface();
	bool IsSuperArmorInterface();
	struct FVector GetDamageReactionDirInterface(const struct FHCHitResult& HitResult);
	void SetBrainCrashMissAccumulationScale(bool IsBoss);
	void SetNoCollisionAndStopAiFade(bool bNoColAndStopAi, bool* Dummy);
	bool ShakeCameraInDamageInterface(const struct FHCHitResult& HitResult);
	bool VibrationControllerInDamageInterface(const struct FHCHitResult& HitResult);
	void SetBattleDamage3D(class AHUDMainGame_C* HUD, int32 Damage, const struct FVector& Position3D, bool Param_IsPlayer, bool IsCritical, bool IsSasCritical, bool IsBrainCrashCritical, bool IsHeal, bool IsWeak, bool IsNoDamage, class ARSBattleCharacter_C* CrushTarget, int32 CrushBonus, const struct FVector2D& Offset);
	void DamagePopupCore(const struct FVector& InLocation, int32 InDamage, float InCrashDamage, EDamagePointKind InKind, bool InIsCritical, bool InIsWeakhit, bool InIsStealthCritical, bool InIsBrainCrash, class AActor* AttackActor);
	void OnEndDamageCalcArray();
	void GetDirectAttackWpPrimitive(class UPrimitiveComponent** OutPrimitive);
	bool StopBehaviorTree(bool bTickDisable);
	bool RestartBehaviorTree(bool bTickEnable);
	bool SetBehaviorTreeTickEnable(bool bEnable);
	void StopBehaviorTreeCore(bool bTickDisable);
	void RestartBehaviorTreeCore(bool bTickEnable);
	void ModifyParameterTable_Attack(float Scale, int32* NewAttack);
	void SetDisableMeshFitGround(bool bDisable, class FName ClaimantName);
	void Start_Unaffected_Time_Dilation(float TimeDilation, float DilationTime, EAnimNotifyTimeDilationMode DilationMode);
	void UpdateUnaffectedTimeDilation(float DeltaSec);
	void StartUnaffectedCameraAttention(class UCurveFloat* ActorCurveOut, class UCurveFloat* FovCurveOut, float AttentionTime, bool* IsStart);
	void UpdateUnaffectedCameraAttention(float DeltaSec);
	void OnHitDamage(const struct FHCHitResult& Result, bool* Return);
	void StopUnaffectedTimeDilation();
	void StopUnaffectedCameraAttention();
	void SetGroupID(int32 NewGroupID);
	void CalcMeshFitGroundVector(struct FVector* UpVector);
	void IsDisableMeshFitGround(bool* bDisable);
	bool SufferDamageBeforeInterface(const struct FHCHitResult& HitResult, int32 Damage);
	void SetSpawnLocation();
	bool IsBadStatusOilCPP();
	bool IsBadStatusFloodedCPP();
	bool IsBadStatusFlameCPP();
	bool IsBadStatusElectricCPP();
	bool IsBadStatusConfusionCPP();
	void GetDeadBeforeHitResult(struct FHCHitResult* HitResult);
	void SetDeadBeforeHitResultByDirectAttack(const struct FHCHitResult& HitResult);
	void RareSpawnToEnemyHpRate();
	void SetRareSpawnEnemyHpRate(float HpRate, class AActor* RareSpawnEnemy);
	void IsEnableSpawnByConditionEnemyHpRate(bool* IsSpawnOK);
	bool SetRareSpawnEnemyHpRateCPP(float HpRate, class AActor* RareSpawnEnemy);
	void RareEnemySelfDestroy();
	void SetActorTags(TArray<class FName>& InTags);
	void OnCompleteEventManagerEnd();
	void TickCrashVisionEffect(float Dummy);
	void ReservationCrashCutSceneRareSpawn(bool Hidden);
	void CableDamage(float Sec);
	void OnSimulatorStartDirectionOpen();
	void OnSimulatorStartDirectionClose(float MoveDelaySec);
	void IsBadStateCableDamage(bool* CableDamage);
	void BadStateEffectOffCable(bool* bDummy);
	void BadStateEffectOnCable(bool* bDummy);
	void SetBrainCrashBossHpGage();
	void ResetBrainCrashBossHpGage();
	void ReserveBrainCrashDamageScorePopup(int32 Damage, int32 Score);
	void OnSimulatorCancelMission();
	struct FVector GetTargetCursorLocation();
	bool IsPsychicObjectShieldActive();
	class AActor* GetPsychicObjectShield();
	void GetCapsuleRadius(float* Radius);
	void GetFlightAltitude(float* FlightAltitude);
	void GetHeadLocation(struct FVector* Location);
	void IsFlying(bool* Param_IsFlying);
	void EndMoveBackward(bool* Result);
	void BeginMoveBackward(bool* Result);
	void RestoreMaxSpeed(class FName ClaimantName, bool* Result);
	void ScaleMaxSpeed(float Scale, class FName ClaimantName, bool* Result);
	void IsAbleMove(bool* IsAble);
	void AddSpringArm(class USpringArmComponent** SpringArm);
	void DestroySpringArm(class USpringArmComponent* SpringArm, bool* Dummy);
	void GetCapsuleHalfHeight(float* HalfHeight);
	void SetHp(int32 HP, bool* bDummy);
	void IsBadStatusAny(bool* bBadStatus);
	void SetCharacterVisibility(bool bVisibility, bool* bDummy);
	void IsCounterSuccess(bool* Success);
	void StartVisionFog(bool* Dummy);
	void GetActorStartPoint(struct FVector* StartLocation);
	void SetNotifyAttackData(const struct FFNotifyAttackData& Data, bool* Dummy);
	void GetLockOnTargetInterface(class AActor** TargetActor);
	void GetAccelerating(bool* Accelerating);
	void SetAccelerating(bool Accelerating, bool* Dammy);
	void MeshFitGround(float InterpSpeed, float AngleLimit, bool bEndFit, bool* bDummy);
	void GetMeshFitGroundCheckLocation(struct FVector* Location, float* CheckHeight);
	void CancelMeshFitGround(bool* bDummy);
	void StartSASChance(float Time, bool* Dammy);
	void EndSASChance(bool* Dammy);
	void SetHitStopInterface(EHCRestictedHitStopType HitStopType, bool bCritical, bool* bDummy);
	void UpdateCameraDither(float DeltaSeconds, bool Param_UseDither, float* CameraDither);
	void SetCameraDither(float SetDitherValue, bool* Dummy);
	void SetUseCameraDither(bool bUse, bool* bDummy);
	void IsCounterWait(bool* bWait);
	void RequestDie(bool* bDummy);
	void EndVisionFog(bool* Dummy);
	void EnableReactionCoefficient(bool bNormalAttack, bool bPsychicAttack, float ReactionSRate, float ReactionLRate, float DownRate, float CrashRate, bool bAcceptAll, bool* Return);
	void DisableReactionCoefficient(bool bNormalAttack, bool bPsychicAttack, bool* Return);
	void SpawnSequencerEffectInterface(class FName ClaimantName, class UParticleSystem* Template, const struct FTransform& Transform, class FName AttachName, bool* Return);
	void EndSequencerEffectInterface(class FName ClaimantName, bool* Return);
	void UpdateSequencerEffectInterface(float DeltaSec, bool* Return);
	void IsInScreen(bool* InScreen);
	void Get_Event_Bind_Mesh_Component(TArray<class UStaticMeshComponent*>* MeshComponent);
	void RegisterBrainFieldNormalTransform(const struct FTransform& InNormalTransform, bool* Return);
	void CheckNoDamagePopUpFromAttacker(bool* bNoPopUp);
	void GetGroupIDInterface(bool* bSuccess, int32* Param_GroupID, int32* Param_SubGroupID);
	void StopMovementImmediately(bool* bDummy);
	void GetPsychicObjectThrowParameter(bool* Apply, float* Directshot_throw_speed, float* Directshot_homing_speed, float* Combo_throw_speed, float* Combo_homing_speed, float* brainfield_throw_speed, float* brainfield_homing_speed, float* Intercept_throw_speed, float* Intercept_homing_speed);
	void GetCharacterSkillTableWithReplace(class UDataTable*& OrgTable, class FName SkillName, struct FHCSkillCommonInfo* SkillCommonInfo);
	void ReserveCrashVisionShockWave(float EffectDelayTime, bool* bDummy);
	void SetIgnoreVisionSimulatorScore(bool bIgnore, bool* bDummy);
	void GetBrainCrashDamageLocation(struct FVector* WorldLocation);
	void GetLandingTemplate(EPhysicalSurface SurfaceType, class UParticleSystem** Template);
	void GetFootStepTemplate(EPhysicalSurface SurfaceType, class UParticleSystem** Template);
	void OnBeginConnectEffect(class UParticleSystem* ParticleSystem, class FName ObjectName, EEffectConnectPoint SourceConnectPoint, class FName SourceSocketName, EEffectConnectPoint TargetConnectPoint, class FName TargetSocketName, class USoundAtomCue* PlaySound, bool* bDummy);
	void OnEndConnectEffect(class FName ObjectName, bool* bDummy);
	bool TalkEventStart();
	bool TalkEventEnd(bool IsRestoreTransform);
	bool StaticEventStart();
	bool StaticEventEnd(bool IsRestoreTransform);
	bool EventStart();
	bool EventEnd();
	bool DynamicEventStart();
	bool DynamicEventEnd(bool IsRestoreTransform);
	bool SetHoodVisible(bool Visible);
	bool StopEventAnimMontage(class UAnimMontage* AnimMontage);
	bool PlayEventAnimMontage(class UAnimMontage* AnimMontage, class FName Section, float InPlayRate);
	bool IsEndEventAnimMontage(class UAnimMontage* AnimMontage);
	bool SetEventVisible(bool Visible);
	bool SetShadowOffsetTexture(class UTexture2D* Texture);
	bool SetShadowOffsetMapID(EMaterialShadowOffsetID ShadowOffsetID);
	bool ResetShadowOffset();
	bool BattleSequencerStart(bool IsSetEnemyEvent, bool bDriveSequence);
	bool BattleSequencerEnd(bool IsRestoreTransform, bool IsSetEnemyEvent, bool bDriveSequence);
	bool DynamicEventBeforeBindCharacter();
	bool EventInputRestrictNative(bool Restrict);
	bool EventManagerStart(bool EnableTick, bool Visibility);
	bool EventManagerEnd(bool RestoreEnableTick, bool RestoreVisibility);
	struct FCharactersParameterTable GetCharactersParameterTableInterface();
	bool CalcDefence(float& RefPhysicsDefence, float& RefObjDefence, float& RefFlameDefence, float& RefElectricPhysics);
	bool CalcDamageByDefence(float& RefPhysicsDamage, float& RefObjDamage, float& RefFlameDamage, float& RefElectricDamage, float& RefCriticalDamageRate, class AActor* AttackActor);
	bool CalcDamageByAttack(float& RefPhysicsDamage, float& RefObjDamage, float& RefFlameDamage, float& RefElectricDamage, float& RefCriticalDamageRate, class AActor* DefenseActor);
	float CalcCritical(float Critical, class AActor* DefenseActor, bool bAssassinAttack);
	bool CalcAccumulationByDefence(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, float& RefCrashCapCheckRate, class AActor* AttackActor);
	bool CalcAccumulationByAttack(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, float& RefCrashCapCheckRate, class AActor* DefenseActor, EHCSkillAttackType AttackType, bool bCopyActor, const struct FHCSkillCommonInfo& SkillInfo);
	float CalcFinalDamageByDefence(float Damage, class AActor* AttackActor);
	float CalcFinalDamageByAttack(float Damage, class AActor* DefenseActor, const struct FHCSkillCommonInfo& SkillInfo);
	bool OverwriteAttackCollisionInfo(struct FHCCollisionCommonInfo& RefCommonInfo, struct FHCSkillCommonInfo& RefSkill);
	bool IsPsychicFieldDamageRateToBoss();
	float GetMaxDamageRateLimit();
	float GetMaxCrashScaleLimit();
	bool IsIgnoreCritical();
	bool IsIgnoreHitCheck(class UPrimitiveComponent* PPrimitive, const struct FVector& HitPosition);
	bool IsCheckFriendlyFire(class AActor* HitActor);
	bool IsObstacleHitCheck(class UPrimitiveComponent* PPrimitive, class AActor* PAttacker, const struct FVector& EndPosition);
	bool IsIgnoreAccelerator(EHCSkillExtraType Type);
	bool IsObstacleHitCheckToActor(class AActor* PTarget);
	class AActor* GetHitCheckIgnoredActor();
	bool BrainCrashUnlock();
	int32 GetWeakNumber();
	bool SetEmphasisCrashGauge(bool bEmphasisCrashGauge);
	bool IsStartDamageAnimAdditional(const struct FHCHitResult& HitResult, int32 Damage, bool IsDown);
	struct FVector GetCameraLookAtPos();
	bool SetPlayerCameraViewTarget(float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	bool SetPlayerCameraRotation(const struct FRotator& Rot);
	bool SetPlayerCameraMode(EPlayerCameraMode Mode);
	bool SetPlayerCameraLocation(const struct FVector& Pos);
	bool SetPlayerCameraFieldOfView(float FOV);
	bool SetPlayerCameraDirection(const struct FVector& Pos);
	struct FRotator GetPlayerCameraRotation();
	EPlayerCameraMode GetPlayerCameraMode();
	struct FVector GetPlayerCameraLocation();
	float GetPlayerCameraFieldOfView();
	struct FVector GetPlayerCameraDirection();
	struct FRotator GetRemoteActorRotation();
	struct FVector GetRemoteActorLocation();
	bool SetFlyingInterface(const class FName& ClaimantName);
	bool ClearFlyingInterface(const class FName& ClaimantName);
	bool ClearFlyingForceInterface();
	void CheckExecuteAnimNotifyCharacterKind(ECharaExecuteNotifyKind Kind, bool* bExecute);
	bool IsInvincibleCrashVisionDamage();
	bool IsDisableCrashVision();
	bool SetInvincibleCrashVisionDamage(bool bInvincible, const class FName ClaimantName);
	bool SetDisableCrashVision(bool bDisable, const class FName ClaimantName);
	bool SetPhotoModeDither(float Value);
	bool EndPhotoMode();
	bool BeginPhotoMode();
	class USkeletalMeshComponent* GetPhotoModeSkeletalMesh();
	class FName GetPhotoModeDitherDataName();
	bool IsPhotoModeManualOverlap();
	class UCapsuleComponent* GetPhotoModeManualOverlapCapsule();
	bool PhotoModeTick();

	void IsBattling(bool* bBatting) const;
	void IsCurrentAttackAttribute(EAttackAttribute Attribute, bool* bResult) const;
	void GetRootLocation(struct FVector* RootLocation) const;
	void IsArmor(class UPrimitiveComponent* Prim, bool* Return) const;
	void GetGroundLocation(struct FVector* GroundLocation) const;
	void IsInvalidDamage(bool* InvalidDamage) const;
	class UCharactersParameterComponent* GetCharactersParameterComponent() const;
	void GetMaxSpeedScale(float* Scale) const;
	void GetDamageReactionDir(struct FHCHitResult& HitResult, struct FVector* ReactionDir) const;
	struct FVector GetGroundLocationSimple(bool bIncludeObject) const;
	bool IsBrainCrashSuccess() const;
	bool IsBrainCrashAccess() const;
	void GetBodyMeshes(TArray<class USkeletalMeshComponent*>* Meshes) const;
	struct FVector GetCharacterMovementLocationSimple() const;
	void GetGroundInfo(bool* bFind, struct FHitResult* HitResult) const;
	bool GetCharacterMovementGroundInfoSimple(struct FHitResult* Result) const;
	void IsInBeginPlay(bool* InBegin) const;
	void GetBadStateIconParam(EHCBadState BadType, struct FBadStateAddParticleData* ParamData) const;
	void GetBadStateIconCameraOffset(float* Value) const;
	bool IsAttackerTargetSelf(const struct FHCHitResult& HitResult) const;
	void GetCameraDitherTableRowName(class FName* RowName) const;
	int32 GetCharaKind() const;
	void BadStateEffectDispSwitch(bool bInDisp, bool* bSuccess) const;
	bool IsDeadPsychicObjComboOnly() const;
	bool IsDeadChaseAttackOnly() const;
	bool IsCrashMaxWithGuts() const;
	bool IsDeadLaunchAttackOnly() const;
	bool IsDeadPsychicObjOnly() const;
	bool IsDeadPhysicsAttackOnly() const;
	bool IsNoDeadTutorial() const;
	bool IsEnableReactionCoefficientInterface(float* OutReactionSRate, float* OutReactionLRate, float* OutDownRate, float* OutCrashRate, bool* OutAcceptAll) const;
	void CanSetTick(bool* Result) const;
	bool IsAttractSelfInterface() const;
	int32 GetGroupID() const;
	void GetRootMotionMode(uint8* Mode) const;
	struct FVector GetWeakTargetPointInterface(const struct FVector& AttackerPos) const;
	bool IsNoDeadEvent() const;
	bool IsNoCrashChanceEvent() const;
	bool IsRareSpawnEnemy() const;
	bool CheckRareSpawnHpRateCPP() const;
	void CanSetTickDistance(bool* Result) const;
	void IsSimulatorStartDirection(bool* Result) const;
	void IsNotApplyPhotoModeMeshProfile(bool* bNotApply) const;
	bool IsControlPlayer() const;
	bool IsBerserkCharacter() const;
	void GetIsBattleMode(bool* IsBattleMode) const;
	void IsCurrentAttackAttributeAI(EAttackAttribute Attribute, bool* bResult) const;
	void IsDead(bool* bDead) const;
	void IsBadStatusConfusion(bool* bBadStatus) const;
	void IsBadStatusOil(bool* bBadStatus) const;
	void IsBadStatusFlooded(bool* bBadStatus) const;
	void IsBadStatusElectric(bool* bBadStatus) const;
	void IsBadStatusFrame(bool* bBadStatus) const;
	void GetMaxHp(int32* MaxHp) const;
	void GetHp(int32* HP) const;
	void GetHPPercent(float* Percent) const;
	void IsForceCritical(bool* bResult) const;
	void GetTeam(ETeamKind* Param_Team) const;
	void IsPlayer(bool* bPlayer) const;
	void IsEnemy(bool* bEnemy) const;
	void IsMetalMode(bool* bMetal) const;
	void GetWeakTargetPoint(const struct FVector& AttackerPos, struct FVector* Point) const;
	void GetTopTargetPoint(struct FVector* Point) const;
	void GetWeakUIPoint(int32 Param_Index, struct FVector* Point) const;
	void GetWeakTargetComponent(class USceneComponent** WeakComponent) const;
	void GetNotifyAttackData(struct FFNotifyAttackData* Data) const;
	void CanTakeBrainField(bool* CanTake) const;
	void IsHitWeak_ChangeDefaultEffect(bool* ChangeDefault) const;
	void IsEnableSlashEffect(struct FHCHitResult& HitResult, bool* bEnable) const;
	void IsBrainCrashAccessInterface(bool* bAccess) const;
	void GetAutoAimRate(float* Rate) const;
	void GetCharacterLV(int32* LV) const;
	void IsEnableReactionCoefficient(bool* bEnable, float* ReactionSRate, float* ReactionLRate, float* DownRate, float* CrashRate, bool* bAcceptAll) const;
	void IsAttackerMainPlayer(bool* bMainPlayer) const;
	void GetCharacterReplaceSkillTable(class UDataTable* Original, class UDataTable** SkillTable) const;
	bool IsOnGround(bool bIncludeObject) const;
	bool IsDisableDamageHit() const;
	void IsInvisibleHPGauge(bool* bInvisible) const;
	void GetTargetCursorPoint(struct FVector* Point) const;
	void GetHpGaugePoint(struct FVector* Point) const;
	void GetCrashChanceCursorPoint(struct FVector* Point) const;
	void IsSpawnWait(bool* bSpawnWait) const;
	bool IsInvisibleMiniMap() const;
	void IsHpGaugeAlwaysMax(bool* bAlwaysMax) const;
	bool IsEmphasisCrashGauge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"RSBattleCharacter_C">();
	}
	static class ARSBattleCharacter_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSBattleCharacter_C>();
	}
};
static_assert(alignof(ARSBattleCharacter_C) == 0x000010, "Wrong alignment on ARSBattleCharacter_C");
static_assert(sizeof(ARSBattleCharacter_C) == 0x0010F0, "Wrong size on ARSBattleCharacter_C");
static_assert(offsetof(ARSBattleCharacter_C, UberGraphFrame) == 0x000900, "Member 'ARSBattleCharacter_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BP_DamageFloatingControlComponent) == 0x000908, "Member 'ARSBattleCharacter_C::BP_DamageFloatingControlComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BPC_RenderScarComponent) == 0x000910, "Member 'ARSBattleCharacter_C::BPC_RenderScarComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BP_HpEventComponent) == 0x000918, "Member 'ARSBattleCharacter_C::BP_HpEventComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BP_RSCharacterCommonDataComponent) == 0x000920, "Member 'ARSBattleCharacter_C::BP_RSCharacterCommonDataComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BP_AssetLoadComponent) == 0x000928, "Member 'ARSBattleCharacter_C::BP_AssetLoadComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, WeakDamageParticleManageComponent) == 0x000930, "Member 'ARSBattleCharacter_C::WeakDamageParticleManageComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CharacterOverlapCapsuleComponent) == 0x000938, "Member 'ARSBattleCharacter_C::CharacterOverlapCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BP_CharacterEventComponent) == 0x000940, "Member 'ARSBattleCharacter_C::BP_CharacterEventComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BP_GhostTrailComponent) == 0x000948, "Member 'ARSBattleCharacter_C::BP_GhostTrailComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, HateTarget) == 0x000950, "Member 'ARSBattleCharacter_C::HateTarget' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CharactersParameter) == 0x000958, "Member 'ARSBattleCharacter_C::CharactersParameter' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DamageArray) == 0x000960, "Member 'ARSBattleCharacter_C::DamageArray' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DynamicMaterialController) == 0x000968, "Member 'ARSBattleCharacter_C::DynamicMaterialController' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, AutoAim) == 0x000970, "Member 'ARSBattleCharacter_C::AutoAim' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, Hovering) == 0x000978, "Member 'ARSBattleCharacter_C::Hovering' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, ContinualMove) == 0x000980, "Member 'ARSBattleCharacter_C::ContinualMove' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, MoveImpulse) == 0x000988, "Member 'ARSBattleCharacter_C::MoveImpulse' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, HitStop) == 0x000990, "Member 'ARSBattleCharacter_C::HitStop' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, HitBit) == 0x000998, "Member 'ARSBattleCharacter_C::HitBit' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, HitCheckReceiver) == 0x0009A0, "Member 'ARSBattleCharacter_C::HitCheckReceiver' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DamageResponse) == 0x0009A8, "Member 'ARSBattleCharacter_C::DamageResponse' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DamageAccept) == 0x0009B0, "Member 'ARSBattleCharacter_C::DamageAccept' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DamageCalc) == 0x0009B8, "Member 'ARSBattleCharacter_C::DamageCalc' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, Team) == 0x0009C0, "Member 'ARSBattleCharacter_C::Team' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DamagePropertyMediator) == 0x0009C8, "Member 'ARSBattleCharacter_C::DamagePropertyMediator' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, MovementPropertyMediator) == 0x0009D0, "Member 'ARSBattleCharacter_C::MovementPropertyMediator' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BattleCharaClaimantName) == 0x0009D8, "Member 'ARSBattleCharacter_C::BattleCharaClaimantName' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CharactersParameterOffset) == 0x0009E0, "Member 'ARSBattleCharacter_C::CharactersParameterOffset' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UseCharactersParameterName) == 0x0009E4, "Member 'ARSBattleCharacter_C::UseCharactersParameterName' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CharactersParameterName) == 0x0009E8, "Member 'ARSBattleCharacter_C::CharactersParameterName' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CharactersParameterTable) == 0x0009F0, "Member 'ARSBattleCharacter_C::CharactersParameterTable' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UseDeadCharacterName) == 0x0009F8, "Member 'ARSBattleCharacter_C::UseDeadCharacterName' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, HateParamName) == 0x0009FC, "Member 'ARSBattleCharacter_C::HateParamName' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, HateParamTable) == 0x000A08, "Member 'ARSBattleCharacter_C::HateParamTable' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bNotifyAnimEnd) == 0x000A10, "Member 'ARSBattleCharacter_C::bNotifyAnimEnd' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bReserveAnimEnd) == 0x000A11, "Member 'ARSBattleCharacter_C::bReserveAnimEnd' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, MinRadomX) == 0x000A14, "Member 'ARSBattleCharacter_C::MinRadomX' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, MaxRadomX) == 0x000A18, "Member 'ARSBattleCharacter_C::MaxRadomX' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, MinRadomY) == 0x000A1C, "Member 'ARSBattleCharacter_C::MinRadomY' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, MaxRadomY) == 0x000A20, "Member 'ARSBattleCharacter_C::MaxRadomY' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, MinRadomZ) == 0x000A24, "Member 'ARSBattleCharacter_C::MinRadomZ' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, MaxRandomZ) == 0x000A28, "Member 'ARSBattleCharacter_C::MaxRandomZ' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bNotDamageMotion) == 0x000A2C, "Member 'ARSBattleCharacter_C::bNotDamageMotion' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CharaDeadType) == 0x000A2D, "Member 'ARSBattleCharacter_C::CharaDeadType' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, FrameDamageTimer) == 0x000A30, "Member 'ARSBattleCharacter_C::FrameDamageTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateFlameParticle) == 0x000A38, "Member 'ARSBattleCharacter_C::BadStateFlameParticle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateFlameSoftReference) == 0x000A40, "Member 'ARSBattleCharacter_C::BadStateFlameSoftReference' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateFlameParticleHandle) == 0x000A68, "Member 'ARSBattleCharacter_C::BadStateFlameParticleHandle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CurrentAttackAttribute) == 0x000A70, "Member 'ARSBattleCharacter_C::CurrentAttackAttribute' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateElecParticle) == 0x000A78, "Member 'ARSBattleCharacter_C::BadStateElecParticle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateElecSoftReference) == 0x000A80, "Member 'ARSBattleCharacter_C::BadStateElecSoftReference' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateElecParticleHandle) == 0x000AA8, "Member 'ARSBattleCharacter_C::BadStateElecParticleHandle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadEffectWetChangeTimer) == 0x000AB0, "Member 'ARSBattleCharacter_C::BadEffectWetChangeTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, AttackHitActorList) == 0x000AC0, "Member 'ARSBattleCharacter_C::AttackHitActorList' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, AreaChangeGravityScale) == 0x000AD0, "Member 'ARSBattleCharacter_C::AreaChangeGravityScale' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, OutlineMaterialIndex) == 0x000AD4, "Member 'ARSBattleCharacter_C::OutlineMaterialIndex' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, OutlineMaterialEnabled) == 0x000AD8, "Member 'ARSBattleCharacter_C::OutlineMaterialEnabled' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, OutlineMaterialForceEnabled) == 0x000AD9, "Member 'ARSBattleCharacter_C::OutlineMaterialForceEnabled' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, OutlineMaterialLength) == 0x000ADC, "Member 'ARSBattleCharacter_C::OutlineMaterialLength' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UseDefaultCapsuleShadow) == 0x000AE0, "Member 'ARSBattleCharacter_C::UseDefaultCapsuleShadow' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UseForceMeshShadow) == 0x000AE1, "Member 'ARSBattleCharacter_C::UseForceMeshShadow' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CharacterParameterTableData) == 0x000AE8, "Member 'ARSBattleCharacter_C::CharacterParameterTableData' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, SkinMaterial) == 0x000CE0, "Member 'ARSBattleCharacter_C::SkinMaterial' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, AreaChangeSave) == 0x000CE8, "Member 'ARSBattleCharacter_C::AreaChangeSave' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateConfusionParticle) == 0x000CF0, "Member 'ARSBattleCharacter_C::BadStateConfusionParticle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateConfusionSoftReference) == 0x000CF8, "Member 'ARSBattleCharacter_C::BadStateConfusionSoftReference' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateConfusionParticleScale) == 0x000D20, "Member 'ARSBattleCharacter_C::BadStateConfusionParticleScale' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateConfusionParticleSocketName) == 0x000D2C, "Member 'ARSBattleCharacter_C::BadStateConfusionParticleSocketName' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateConfusionParticleHandle) == 0x000D38, "Member 'ARSBattleCharacter_C::BadStateConfusionParticleHandle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, GroupID) == 0x000D40, "Member 'ARSBattleCharacter_C::GroupID' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsEventWeak) == 0x000D44, "Member 'ARSBattleCharacter_C::IsEventWeak' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, ProvokeParticleScale) == 0x000D48, "Member 'ARSBattleCharacter_C::ProvokeParticleScale' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, InvalidDamageRequests) == 0x000D58, "Member 'ARSBattleCharacter_C::InvalidDamageRequests' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, AnimNotifyStateEffectHandle) == 0x000DA8, "Member 'ARSBattleCharacter_C::AnimNotifyStateEffectHandle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsGraceDamage) == 0x000DF8, "Member 'ARSBattleCharacter_C::IsGraceDamage' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IgnoreEffectLoopSeconds) == 0x000DFC, "Member 'ARSBattleCharacter_C::IgnoreEffectLoopSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsRatioDamage) == 0x000E00, "Member 'ARSBattleCharacter_C::IsRatioDamage' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, SubGroupID) == 0x000E04, "Member 'ARSBattleCharacter_C::SubGroupID' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsHitDelayDeath) == 0x000E08, "Member 'ARSBattleCharacter_C::IsHitDelayDeath' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, NotifyAttackData) == 0x000E0C, "Member 'ARSBattleCharacter_C::NotifyAttackData' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, FinishActor) == 0x000E20, "Member 'ARSBattleCharacter_C::FinishActor' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bAccelerating) == 0x000E28, "Member 'ARSBattleCharacter_C::bAccelerating' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bBadEffectWetDirEnable) == 0x000E29, "Member 'ARSBattleCharacter_C::bBadEffectWetDirEnable' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, WetOnChangeSeconds) == 0x000E2C, "Member 'ARSBattleCharacter_C::WetOnChangeSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, WetOffChangeSeconds) == 0x000E30, "Member 'ARSBattleCharacter_C::WetOffChangeSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bInBeginPlay) == 0x000E34, "Member 'ARSBattleCharacter_C::bInBeginPlay' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bBindHitSlow) == 0x000E35, "Member 'ARSBattleCharacter_C::bBindHitSlow' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UseDither) == 0x000E36, "Member 'ARSBattleCharacter_C::UseDither' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UseDitherBefore) == 0x000E37, "Member 'ARSBattleCharacter_C::UseDitherBefore' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CameraDitherData) == 0x000E38, "Member 'ARSBattleCharacter_C::CameraDitherData' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, SetupCelLookMat) == 0x000E58, "Member 'ARSBattleCharacter_C::SetupCelLookMat' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateIconHandle) == 0x000E60, "Member 'ARSBattleCharacter_C::BadStateIconHandle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CameraDitherParticleList) == 0x000E68, "Member 'ARSBattleCharacter_C::CameraDitherParticleList' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CameraDitherDataTableAsset) == 0x000E78, "Member 'ARSBattleCharacter_C::CameraDitherDataTableAsset' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bOccupiedCameraAttention) == 0x000E80, "Member 'ARSBattleCharacter_C::bOccupiedCameraAttention' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, SuperArmorRequests) == 0x000E88, "Member 'ARSBattleCharacter_C::SuperArmorRequests' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, MeshFitGroundMultipleChecks) == 0x000ED8, "Member 'ARSBattleCharacter_C::MeshFitGroundMultipleChecks' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsLeader) == 0x000ED9, "Member 'ARSBattleCharacter_C::IsLeader' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, RushBrainFieldLocation) == 0x000EDC, "Member 'ARSBattleCharacter_C::RushBrainFieldLocation' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, RushBrainFieldLongAway) == 0x000EE0, "Member 'ARSBattleCharacter_C::RushBrainFieldLongAway' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BrainCrashEvent) == 0x000EE8, "Member 'ARSBattleCharacter_C::BrainCrashEvent' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsPartsInvincible) == 0x000EF0, "Member 'ARSBattleCharacter_C::IsPartsInvincible' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bAreaChange) == 0x000EF1, "Member 'ARSBattleCharacter_C::bAreaChange' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bNoTipsCheckBadStatusOil) == 0x000EF2, "Member 'ARSBattleCharacter_C::bNoTipsCheckBadStatusOil' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bNoTipsCheckBadStatusFlooded) == 0x000EF3, "Member 'ARSBattleCharacter_C::bNoTipsCheckBadStatusFlooded' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bIsBrainCrashEventFlag) == 0x000EF4, "Member 'ARSBattleCharacter_C::bIsBrainCrashEventFlag' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DTEnemyAnimScaleHitStop) == 0x000EF8, "Member 'ARSBattleCharacter_C::DTEnemyAnimScaleHitStop' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, ReceiveAttackType) == 0x000F00, "Member 'ARSBattleCharacter_C::ReceiveAttackType' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bEnableNormalAttackReactionCoefficient) == 0x000F01, "Member 'ARSBattleCharacter_C::bEnableNormalAttackReactionCoefficient' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bEnablePsychicAttackReactionCoefficient) == 0x000F02, "Member 'ARSBattleCharacter_C::bEnablePsychicAttackReactionCoefficient' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, ReactionCoefficientReactionSRate) == 0x000F04, "Member 'ARSBattleCharacter_C::ReactionCoefficientReactionSRate' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, ReactionCoefficientReactionLRate) == 0x000F08, "Member 'ARSBattleCharacter_C::ReactionCoefficientReactionLRate' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, ReactionCoefficientDownRate) == 0x000F0C, "Member 'ARSBattleCharacter_C::ReactionCoefficientDownRate' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, ReactionCoefficientCrashRate) == 0x000F10, "Member 'ARSBattleCharacter_C::ReactionCoefficientCrashRate' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsHitDDInstantKill) == 0x000F14, "Member 'ARSBattleCharacter_C::IsHitDDInstantKill' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BrainCrashDamageDisplayOffset) == 0x000F18, "Member 'ARSBattleCharacter_C::BrainCrashDamageDisplayOffset' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bDamageDisplayOffset) == 0x000F20, "Member 'ARSBattleCharacter_C::bDamageDisplayOffset' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsNoFinishBrainCrash) == 0x000F21, "Member 'ARSBattleCharacter_C::IsNoFinishBrainCrash' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DisplayBrainCrashDamageInfo) == 0x000F28, "Member 'ARSBattleCharacter_C::DisplayBrainCrashDamageInfo' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsDisplayBossHp) == 0x000F58, "Member 'ARSBattleCharacter_C::IsDisplayBossHp' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BossDispBCDamageSecond) == 0x000F5C, "Member 'ARSBattleCharacter_C::BossDispBCDamageSecond' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BrainCrashDamageDisplayPointName) == 0x000F60, "Member 'ARSBattleCharacter_C::BrainCrashDamageDisplayPointName' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, InScreenTolerance) == 0x000F68, "Member 'ARSBattleCharacter_C::InScreenTolerance' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BossDelayResetCrashSecond) == 0x000F6C, "Member 'ARSBattleCharacter_C::BossDelayResetCrashSecond' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BattlefieldFenceAppearRate) == 0x000F70, "Member 'ARSBattleCharacter_C::BattlefieldFenceAppearRate' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsFindBattlefieldFenceOnce) == 0x000F74, "Member 'ARSBattleCharacter_C::IsFindBattlefieldFenceOnce' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bCanSetTick) == 0x000F75, "Member 'ARSBattleCharacter_C::bCanSetTick' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsFrameDamage) == 0x000F76, "Member 'ARSBattleCharacter_C::IsFrameDamage' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BrainFieldNormalTransform) == 0x000F80, "Member 'ARSBattleCharacter_C::BrainFieldNormalTransform' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsStartFindBattlefieldFence) == 0x000FB0, "Member 'ARSBattleCharacter_C::IsStartFindBattlefieldFence' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, LastRootMotionMode) == 0x000FB1, "Member 'ARSBattleCharacter_C::LastRootMotionMode' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bDisableMeshFitGround) == 0x000FB2, "Member 'ARSBattleCharacter_C::bDisableMeshFitGround' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DiableMeshFitGroundClaimantList) == 0x000FB8, "Member 'ARSBattleCharacter_C::DiableMeshFitGroundClaimantList' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UnaffectedTimeDilation) == 0x000FC8, "Member 'ARSBattleCharacter_C::UnaffectedTimeDilation' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UnaffectedDilationTimer) == 0x000FCC, "Member 'ARSBattleCharacter_C::UnaffectedDilationTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UnaffectedDilationMode) == 0x000FD0, "Member 'ARSBattleCharacter_C::UnaffectedDilationMode' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsActiveUpdateUnaffectedTimeDilation) == 0x000FD1, "Member 'ARSBattleCharacter_C::IsActiveUpdateUnaffectedTimeDilation' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, ClaimantNameUnaffectedTimeDilation) == 0x000FD8, "Member 'ARSBattleCharacter_C::ClaimantNameUnaffectedTimeDilation' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UnaffectedCameraAttentionActorCurveOut) == 0x000FE8, "Member 'ARSBattleCharacter_C::UnaffectedCameraAttentionActorCurveOut' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UnaffectedCameraAttentionFovCurveOut) == 0x000FF0, "Member 'ARSBattleCharacter_C::UnaffectedCameraAttentionFovCurveOut' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, UnaffectedCameraAttentionTimer) == 0x000FF8, "Member 'ARSBattleCharacter_C::UnaffectedCameraAttentionTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsActiveUpdateUnaffectedCameraAttention) == 0x000FFC, "Member 'ARSBattleCharacter_C::IsActiveUpdateUnaffectedCameraAttention' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsEnableSpawnCondition) == 0x000FFD, "Member 'ARSBattleCharacter_C::IsEnableSpawnCondition' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsCheckSpawnCondition) == 0x000FFE, "Member 'ARSBattleCharacter_C::IsCheckSpawnCondition' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, SpawnLocation) == 0x001000, "Member 'ARSBattleCharacter_C::SpawnLocation' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DisableCrashVisionNames) == 0x001010, "Member 'ARSBattleCharacter_C::DisableCrashVisionNames' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, InvincibleCrashVisionDamageNames) == 0x001020, "Member 'ARSBattleCharacter_C::InvincibleCrashVisionDamageNames' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CheckRareSpawnHpRate) == 0x001030, "Member 'ARSBattleCharacter_C::CheckRareSpawnHpRate' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, HpRateRareSpawnHpRate) == 0x001034, "Member 'ARSBattleCharacter_C::HpRateRareSpawnHpRate' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, EnemyActorRareSpawnHpRate) == 0x001038, "Member 'ARSBattleCharacter_C::EnemyActorRareSpawnHpRate' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IgnoreDisableOutOfBattlefield) == 0x001040, "Member 'ARSBattleCharacter_C::IgnoreDisableOutOfBattlefield' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bReserveCrashVisionShockWave) == 0x001041, "Member 'ARSBattleCharacter_C::bReserveCrashVisionShockWave' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CrashVisionEffectDelayTime) == 0x001044, "Member 'ARSBattleCharacter_C::CrashVisionEffectDelayTime' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bIgnoreVisionSimulatorScore) == 0x001048, "Member 'ARSBattleCharacter_C::bIgnoreVisionSimulatorScore' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bCanSetTickDistance) == 0x001049, "Member 'ARSBattleCharacter_C::bCanSetTickDistance' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsCableDamage) == 0x00104A, "Member 'ARSBattleCharacter_C::IsCableDamage' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, CableDamageTimer) == 0x00104C, "Member 'ARSBattleCharacter_C::CableDamageTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateCableParticle) == 0x001050, "Member 'ARSBattleCharacter_C::BadStateCableParticle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateCableSoftReference) == 0x001058, "Member 'ARSBattleCharacter_C::BadStateCableSoftReference' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BadStateCableParticleHandle) == 0x001080, "Member 'ARSBattleCharacter_C::BadStateCableParticleHandle' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, IsBossBrainCrashDifferentEnemyLock) == 0x001088, "Member 'ARSBattleCharacter_C::IsBossBrainCrashDifferentEnemyLock' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, DisplayBrainCrashDamageInfo_Simulator) == 0x001090, "Member 'ARSBattleCharacter_C::DisplayBrainCrashDamageInfo_Simulator' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bReserveVisionSimulatorBrainCrashDamage) == 0x0010C0, "Member 'ARSBattleCharacter_C::bReserveVisionSimulatorBrainCrashDamage' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bSimulatorStartDirection) == 0x0010C1, "Member 'ARSBattleCharacter_C::bSimulatorStartDirection' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BossBrainCrashDifferentLockEnemy) == 0x0010C8, "Member 'ARSBattleCharacter_C::BossBrainCrashDifferentLockEnemy' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, BackupCameraDitherValue) == 0x0010D0, "Member 'ARSBattleCharacter_C::BackupCameraDitherValue' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bPhotoModeBackupGenerateOverlap) == 0x0010D4, "Member 'ARSBattleCharacter_C::bPhotoModeBackupGenerateOverlap' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, PhotoModeBackupProfileName) == 0x0010D8, "Member 'ARSBattleCharacter_C::PhotoModeBackupProfileName' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bAcceptAllReactionCoefficient) == 0x0010E0, "Member 'ARSBattleCharacter_C::bAcceptAllReactionCoefficient' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, PhotoModeBackupLod) == 0x0010E4, "Member 'ARSBattleCharacter_C::PhotoModeBackupLod' has a wrong offset!");
static_assert(offsetof(ARSBattleCharacter_C, bPhotoModeBackupOutline) == 0x0010E8, "Member 'ARSBattleCharacter_C::bPhotoModeBackupOutline' has a wrong offset!");

}

