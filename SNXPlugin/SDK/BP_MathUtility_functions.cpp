#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_MathUtility

#include "Basic.hpp"

#include "BP_MathUtility_classes.hpp"
#include "BP_MathUtility_parameters.hpp"


namespace SDK
{

// Function BP_MathUtility.BP_MathUtility_C.CheckDistanceFromVector
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Dist                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Distance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnoreHeight                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_MathUtility_C::CheckDistanceFromVector(struct FVector& Dist, float Distance, bool bIgnoreHeight, class UObject* __WorldContext, bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "CheckDistanceFromVector");

	Params::BP_MathUtility_C_CheckDistanceFromVector Parms{};

	Parms.Dist = std::move(Dist);
	Parms.Distance = Distance;
	Parms.bIgnoreHeight = bIgnoreHeight;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Dist = std::move(Parms.Dist);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BP_MathUtility.BP_MathUtility_C.CalcRate
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Min                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Max                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bClamp                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Rate                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::CalcRate(float Value, float Min, float Max, bool bClamp, class UObject* __WorldContext, float* Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "CalcRate");

	Params::BP_MathUtility_C_CalcRate Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.bClamp = bClamp;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Rate != nullptr)
		*Rate = Parms.Rate;
}


// Function BP_MathUtility.BP_MathUtility_C.RandomLotSequence
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<float>                           HitArray                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   HitIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::RandomLotSequence(TArray<float>& HitArray, class UObject* __WorldContext, int32* HitIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "RandomLotSequence");

	Params::BP_MathUtility_C_RandomLotSequence Parms{};

	Parms.HitArray = std::move(HitArray);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	HitArray = std::move(Parms.HitArray);

	if (HitIndex != nullptr)
		*HitIndex = Parms.HitIndex;
}


// Function BP_MathUtility.BP_MathUtility_C.UpDownVector
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Src                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Out                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::UpDownVector(const struct FVector& Src, float Angle, class UObject* __WorldContext, struct FVector* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "UpDownVector");

	Params::BP_MathUtility_C_UpDownVector Parms{};

	Parms.Src = std::move(Src);
	Parms.Angle = Angle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Out != nullptr)
		*Out = std::move(Parms.Out);
}


// Function BP_MathUtility.BP_MathUtility_C.TurnToTargetRotation
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         Src                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FRotator                         Dst                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         NewRotate                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_MathUtility_C::TurnToTargetRotation(const struct FRotator& Src, const struct FRotator& Dst, float Angle, class UObject* __WorldContext, struct FRotator* NewRotate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "TurnToTargetRotation");

	Params::BP_MathUtility_C_TurnToTargetRotation Parms{};

	Parms.Src = std::move(Src);
	Parms.Dst = std::move(Dst);
	Parms.Angle = Angle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewRotate != nullptr)
		*NewRotate = std::move(Parms.NewRotate);
}


// Function BP_MathUtility.BP_MathUtility_C.TurnToTargetVector
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Src                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Dst                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          NewVector                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::TurnToTargetVector(const struct FVector& Src, const struct FVector& Dst, float Angle, class UObject* __WorldContext, struct FVector* NewVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "TurnToTargetVector");

	Params::BP_MathUtility_C_TurnToTargetVector Parms{};

	Parms.Src = std::move(Src);
	Parms.Dst = std::move(Dst);
	Parms.Angle = Angle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewVector != nullptr)
		*NewVector = std::move(Parms.NewVector);
}


// Function BP_MathUtility.BP_MathUtility_C.CalcAnySearchBase
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          baseLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          BaseDir                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::CalcAnySearchBase(class UObject* __WorldContext, struct FVector* baseLocation, struct FVector* BaseDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "CalcAnySearchBase");

	Params::BP_MathUtility_C_CalcAnySearchBase Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (baseLocation != nullptr)
		*baseLocation = std::move(Parms.baseLocation);

	if (BaseDir != nullptr)
		*BaseDir = std::move(Parms.BaseDir);
}


// Function BP_MathUtility.BP_MathUtility_C.CalcScreenRectFromBounds
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  BoundsComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FBox2D                           BoxSize                                                (Parm, OutParm, ZeroConstructor, NoDestructor)
// struct FBox2D                           BoxUV                                                  (Parm, OutParm, ZeroConstructor, NoDestructor)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_MathUtility_C::CalcScreenRectFromBounds(class USceneComponent* BoundsComponent, class UObject* __WorldContext, struct FBox2D* BoxSize, struct FBox2D* BoxUV, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "CalcScreenRectFromBounds");

	Params::BP_MathUtility_C_CalcScreenRectFromBounds Parms{};

	Parms.BoundsComponent = BoundsComponent;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (BoxSize != nullptr)
		*BoxSize = std::move(Parms.BoxSize);

	if (BoxUV != nullptr)
		*BoxUV = std::move(Parms.BoxUV);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BP_MathUtility.BP_MathUtility_C.ClampVectorLimitAngle
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          BaseVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          CheckVector                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LimitDegree                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ClampVector                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::ClampVectorLimitAngle(const struct FVector& BaseVector, const struct FVector& CheckVector, float LimitDegree, class UObject* __WorldContext, struct FVector* ClampVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "ClampVectorLimitAngle");

	Params::BP_MathUtility_C_ClampVectorLimitAngle Parms{};

	Parms.BaseVector = std::move(BaseVector);
	Parms.CheckVector = std::move(CheckVector);
	Parms.LimitDegree = LimitDegree;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ClampVector != nullptr)
		*ClampVector = std::move(Parms.ClampVector);
}


// Function BP_MathUtility.BP_MathUtility_C.ClampRotationLimitAngle
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         baseRot                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FRotator                         CheckRot                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   LimitDegree                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         ClampRot                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_MathUtility_C::ClampRotationLimitAngle(const struct FRotator& baseRot, const struct FRotator& CheckRot, float LimitDegree, class UObject* __WorldContext, struct FRotator* ClampRot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "ClampRotationLimitAngle");

	Params::BP_MathUtility_C_ClampRotationLimitAngle Parms{};

	Parms.baseRot = std::move(baseRot);
	Parms.CheckRot = std::move(CheckRot);
	Parms.LimitDegree = LimitDegree;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ClampRot != nullptr)
		*ClampRot = std::move(Parms.ClampRot);
}


// Function BP_MathUtility.BP_MathUtility_C.GetTargetAngle
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          BaseDirection                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TargetDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TargeDegreetAngle                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::GetTargetAngle(const struct FVector& BaseDirection, const struct FVector& TargetDirection, class UObject* __WorldContext, float* TargeDegreetAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "GetTargetAngle");

	Params::BP_MathUtility_C_GetTargetAngle Parms{};

	Parms.BaseDirection = std::move(BaseDirection);
	Parms.TargetDirection = std::move(TargetDirection);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (TargeDegreetAngle != nullptr)
		*TargeDegreetAngle = Parms.TargeDegreetAngle;
}


// Function BP_MathUtility.BP_MathUtility_C.checkDistance
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          RefPos1                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          RefPos2                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Distance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnoreHeight                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_MathUtility_C::CheckDistance(struct FVector& RefPos1, struct FVector& RefPos2, float Distance, bool bIgnoreHeight, class UObject* __WorldContext, bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "checkDistance");

	Params::BP_MathUtility_C_CheckDistance Parms{};

	Parms.RefPos1 = std::move(RefPos1);
	Parms.RefPos2 = std::move(RefPos2);
	Parms.Distance = Distance;
	Parms.bIgnoreHeight = bIgnoreHeight;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	RefPos1 = std::move(Parms.RefPos1);
	RefPos2 = std::move(Parms.RefPos2);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BP_MathUtility.BP_MathUtility_C.GetTargetRangeAngle
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          BaseDirection                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TargetDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   RangeAngle                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::GetTargetRangeAngle(const struct FVector& BaseDirection, const struct FVector& TargetDirection, class UObject* __WorldContext, float* RangeAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "GetTargetRangeAngle");

	Params::BP_MathUtility_C_GetTargetRangeAngle Parms{};

	Parms.BaseDirection = std::move(BaseDirection);
	Parms.TargetDirection = std::move(TargetDirection);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (RangeAngle != nullptr)
		*RangeAngle = Parms.RangeAngle;
}


// Function BP_MathUtility.BP_MathUtility_C.RandomLot
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// float                                   HitPer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsHit                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_MathUtility_C::RandomLot(float HitPer, class UObject* __WorldContext, bool* IsHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "RandomLot");

	Params::BP_MathUtility_C_RandomLot Parms{};

	Parms.HitPer = HitPer;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsHit != nullptr)
		*IsHit = Parms.IsHit;
}


// Function BP_MathUtility.BP_MathUtility_C.RandomLotSum
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// TArray<int32>                           HitArray                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   HitIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::RandomLotSum(TArray<int32>& HitArray, class UObject* __WorldContext, int32* HitIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "RandomLotSum");

	Params::BP_MathUtility_C_RandomLotSum Parms{};

	Parms.HitArray = std::move(HitArray);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	HitArray = std::move(Parms.HitArray);

	if (HitIndex != nullptr)
		*HitIndex = Parms.HitIndex;
}


// Function BP_MathUtility.BP_MathUtility_C.ClampCircleAngle
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// float                                   BaseAngle                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ClampAngle                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_MathUtility_C::ClampCircleAngle(float BaseAngle, class UObject* __WorldContext, float* ClampAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "ClampCircleAngle");

	Params::BP_MathUtility_C_ClampCircleAngle Parms{};

	Parms.BaseAngle = BaseAngle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ClampAngle != nullptr)
		*ClampAngle = Parms.ClampAngle;
}


// Function BP_MathUtility.BP_MathUtility_C.IsInCameraSimple
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FVector                          CheckLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bin                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_MathUtility_C::IsInCameraSimple(const struct FVector& CheckLocation, class UObject* __WorldContext, bool* bin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_MathUtility_C", "IsInCameraSimple");

	Params::BP_MathUtility_C_IsInCameraSimple Parms{};

	Parms.CheckLocation = std::move(CheckLocation);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bin != nullptr)
		*bin = Parms.bin;
}

}

