#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_PlayerAIInterface

#include "Basic.hpp"

#include "EPlayerAIBattleThinkType_structs.hpp"
#include "BattlePrototype_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "EPlayerAIBattleThinkParam_structs.hpp"
#include "EPlayerAIMoveMode_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BPI_PlayerAIInterface.BPI_PlayerAIInterface_C
// 0x0000 (0x0028 - 0x0028)
class IBPI_PlayerAIInterface_C final : public IInterface
{
public:
	void SetMoveMode(EPlayerAIMoveMode Mode, bool* Dummy);
	void InputAI_Attack(bool bPressed);
	void InputAI_LeftStick(float X, float Y);
	void InputAI_Dodge(bool bPressed);
	void SetEnableInputStick(bool bEnable, bool* Dummy);
	void NextBattleThink(bool* Dummy);
	void ResetBattleThink(bool* Dummy);
	void InputAI_Jump(bool bPressed);
	void OnChangeBattleThink(EPlayerAIBattleThinkType NextThinkType, EPlayerAIBattleThinkType PrevThinkType, bool* bDummy);
	void SetAIMoveStick(bool bMoveStick, bool* bDummy);
	void AimStartAI(bool* bDummy);
	void AimEndAI(bool* bDummy);
	void IsUseItemThink(bool* Result);
	void InputAI_UseItem(bool bPressed);
	void IsInputAI_UseItem(bool* bON);
	void SetEventMove(TArray<struct FVector>& Pos_list_in, TArray<float>& Radius_list_in, bool Walk, bool bAfterWait, float MaxMoveTime, bool* Dummy);
	void GetEventMovePosActor(class AActor** Actor, float* Radius);
	void CheckEventMovePos(bool* Goal);
	void IsSelfRecovery(bool* bResult);
	void NotifyResetBehaviorTree(bool* Dummy);
	void SearchAIPsychicObject(bool* bFiound);
	void CheckAIPsychicObject(bool bCapture, bool bAttack, bool* bOK);
	void InputAI_Psychic(bool bPressed);
	void IsInputAI_Psychic(bool* bON);
	void IsPsychicAble(bool* bEnable);
	void SetMoveStickBack(bool bBack, bool* bDummy);
	void SetEventWait(bool* bDummy);
	void EndEventWait(bool* bDummy);
	void IsUniqueConditionTransition(int32 UniqueNo, bool* bResult);
	void RestartBattleAI(bool* bDummy);
	void IsBattleActionStartAI(bool* bStart);
	void IsTargetCanBeAttacked(bool* CanDo);
	void CancelUseItem(bool* bDummy);
	void BehaviorTreeTaskExit_Attack(EPlayerAIBattleThinkTypeCPP ExitThinkType, bool* bDummy);
	void GetCurrentBattleThinkInterface(EPlayerAIBattleThinkTypeCPP* ThinkType);

	void GetControlPlayerDist(struct FVector* Dist) const;
	void IsMoveAble(bool* bEnable) const;
	void GetMovePosActor(class AActor** MovePosActor) const;
	void IsAttackAble(bool* bEnable) const;
	void IsActionStatusAI(EPlayerActionStatus ActionStatus, bool* bResult) const;
	void IsPlayerStatusAI(EPlayerCommonStatus PlayerStatus, bool* bResult) const;
	void IsInputAI_Attack(bool* bON) const;
	void IsInputAI_Dodge(bool* bON) const;
	void IsDodgeAble(bool* bEnable) const;
	void IsAIMoveMode(EPlayerAIMoveMode Mode, bool* Result) const;
	void IsBattleThink(EPlayerAIBattleThinkType Type, bool* Result) const;
	void IsBattleThinkParam(EPlayerAIBattleThinkParam Param, bool* bResult) const;
	void GetBattleTargetActor(class AActor** TargetActor) const;
	void IsInputAI_Jump(bool* bON) const;
	void IsJumpAble(bool* bEnable) const;
	void GetAttackCountAI(int32* Count) const;
	void OverwriteAttackInputKindAI(EPlayerAIBattleThinkType ThinkType, ERSAttackInputKind InputKind, ERSAttackInputKind* Kind) const;
	void IsEventMove(bool* Result) const;
	void IsEventMoveEnd(bool* Result) const;
	void IsResetBehaviorTree(bool* bReset) const;
	void IsEventWait(bool* bWait) const;
	void GetUseItemID(EConsumeItemID* ItemId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BPI_PlayerAIInterface_C">();
	}
	static class IBPI_PlayerAIInterface_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBPI_PlayerAIInterface_C>();
	}
};
static_assert(alignof(IBPI_PlayerAIInterface_C) == 0x000008, "Wrong alignment on IBPI_PlayerAIInterface_C");
static_assert(sizeof(IBPI_PlayerAIInterface_C) == 0x000028, "Wrong size on IBPI_PlayerAIInterface_C");

}

