#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PsychicObjectBasic

#include "Basic.hpp"

#include "E_SASKind_structs.hpp"
#include "Engine_structs.hpp"
#include "BattlePrototype_structs.hpp"
#include "BattlePrototype_classes.hpp"
#include "PsychicObjectID_structs.hpp"
#include "PsychicObjectAttackType_structs.hpp"
#include "PsyObjType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_PsychicObjectBasic.BP_PsychicObjectBasic_C
// 0x0290 (0x05B0 - 0x0320)
#pragma pack(push, 0x1)
class alignas(0x10) ABP_PsychicObjectBasic_C : public APsychicObjectBasicC
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0320(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class USplineComponent*                       Spline;                                            // 0x0328(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PsychicObjectComponent_C*           BP_PsychicObjectComponent;                         // 0x0330(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UArrowComponent*                        AttackSwingArrow;                                  // 0x0338(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UArrowComponent*                        AttackDropArrow;                                   // 0x0340(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UPsychicObjectSoundComponent*           PsychicObjectSound;                                // 0x0348(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PsychicComponentMain_C*             BP_PsychicComponentMain;                           // 0x0350(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UPsychicSasParticleComponent_C*         PsychicSasParticleComponent;                       // 0x0358(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UInertialMoveComponent_C*               InertialMoveComponent;                             // 0x0360(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EventParamComponent_C*              BP_EventParamComponent;                            // 0x0368(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CollisionHitSoundComponent_C*       BP_CollisionHitSoundComponent;                     // 0x0370(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UHitCheckReceiverComponent*             HitCheckReceiver;                                  // 0x0378(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UTeamComponent*                         Team;                                              // 0x0380(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UArrowComponent*                        AttackArrow;                                       // 0x0388(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCapsuleComponent*                      AttackCapsule;                                     // 0x0390(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USphereComponent*                       AttackSphere;                                      // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x03A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	BattlePrototype::EPsychicObjectID             ObjectID;                                          // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ECollisionEnabled                             PsychicObjectCollision;                            // 0x03A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          PsychicObjectSimulate;                             // 0x03AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          PsychicObjectGravity;                              // 0x03AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bFloatObject;                                      // 0x03AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bSwingType;                                        // 0x03AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bPhysMassOverwrite;                                // 0x03AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8844[0x1];                                     // 0x03AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PhysMassOverwrhiteKg;                              // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bUseSizeParameterName;                             // 0x03B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8845[0x3];                                     // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SizeParameterName;                                 // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bCaptureTimeNormalEx;                              // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8846[0x3];                                     // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CaptureTimeNormalEx;                               // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSoftClassPtr<class UClass>                   DestructibleSoftClass;                             // 0x03C8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class UClass*                                 DestructibleClass;                                 // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   PsychicObjectName;                                 // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	PsychicObjectID::EPsychicObjectID             PsychicObjectID;                                   // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPsyObjType                                   PsychicObjectType;                                 // 0x0401(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8847[0x6];                                     // 0x0402(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AttackHitActorList;                                // 0x0408(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          Cinematic;                                         // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          UseDebrisParticle;                                 // 0x0419(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          UseDebrisOverrideMaterial;                         // 0x041A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8848[0x1];                                     // 0x041B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebrisOverrideMaterialIndex;                       // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        DebrisParticle;                                    // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UBP_UniqueObjectComponentBase_C*        RefUniqueObjComponent;                             // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   UniqueDitherParameterName;                         // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        EffectExplosion;                                   // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DestroyExplosionRadius;                            // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DestroyExplosionTime;                              // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FHCCollisionCommonInfo                 DestroyExplosionCommonInfo;                        // 0x0448(0x0070)(Edit, BlueprintVisible)
	struct FHCSkillCommonInfo                     DestroyExplosionSkillInfo;                         // 0x04B8(0x00F0)(Edit, BlueprintVisible)

public:
	void ExecuteUbergraph_BP_PsychicObjectBasic(int32 EntryPoint);
	void SetPsychicObjectVisibility(bool Flag_in, bool Is_mesh_only);
	void ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void SetPsychicObjectActive(bool IsActive);
	void BndEvt__HitCheckReceiver_K2Node_ComponentBoundEvent_0_HitResultDelegate__DelegateSignature(const struct FHCHitResult& Result);
	void ReceiveTick(float DeltaSeconds);
	void ReceiveBeginPlay();
	void OnCutInEnd();
	void OnCutInStart();
	void OnStealthEnd(const struct FFSASStealthParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnStealthStart(const struct FFSASStealthParam& Param, class AActor* Param_Owner);
	void OnTelepoEnd(const struct FFSASTelepoParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnTelepoStart(const struct FFSASTelepoParam& Param, class AActor* Param_Owner);
	void OnSeeThroughEnd(const struct FFSASSeeThroughParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnSeeThroughStart(const struct FFSASSeeThroughParam& Param, class AActor* Param_Owner);
	void OnMetalEnd(const struct FFSASMetalParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnMetalStart(const struct FFSASMetalParam& Param, class AActor* Param_Owner);
	void OnAcceleratorEnd(const struct FAcceleratorParam& Parameter, class AActor* Param_Owner, float RemainTime, bool bHologram);
	void OnAcceleratorStart(const struct FAcceleratorParam& Parameter, class AActor* Param_Owner, bool bHologram);
	void OnCopyEnd(const struct FFSASCopyParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnElectricEnd(const struct FFSASElectricParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnFireEnd(const struct FFSASFireParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnCopyStart(const struct FFSASCopyParam& Param, class AActor* Param_Owner);
	void OnFireStart(const struct FFSASFireParam& Param, class AActor* Param_Owner);
	void OnElectricStart(const struct FFSASElectricParam& Param, class AActor* Param_Owner);
	void OnPsychicEnd(const struct FFSASPsychicParam& Param, class AActor* Param_Owner, float RemainTime);
	void OnPsychicStart(const struct FFSASPsychicParam& Param, class AActor* Param_Owner);
	void UserConstructionScript();
	void Initialize(bool* Return);
	void Update(float Delta_second_in, bool* Return);
	void DebugDisplay(bool* Return);
	void On_Hit_Attack(const struct FHCHitResult& Hit_result_in, bool* Return);
	void SetActivePsyObjOld(bool bActive_in, bool* Return);
	void SetThrow(class AActor*& Target_in, bool Force_throw_in, bool Psychic_combo_in, bool* Return);
	void CanPsychicAction(bool* Return);
	void SetPsychicAction(class AActor* Target_actor_in, bool Psychic_combo_in, bool* Return);
	void RequestPsychicCombo(bool* Return);
	void SetGrab(bool Flag_in, class ARsBattleHero_C* Grab_owner_in, int32 Grab_index_in);
	void CheckGrabIndex(int32 Grab_index_in, bool* Return);
	void ReloadGrab(int32 Grab_index_in, bool bCombo);
	void SetDestroy(bool Force_in, bool* Return);
	void DestroyPsyObj();
	void SetGrabStart();
	void GetAnimationLength(float* Length);
	void IsGrab(bool* Return);
	void CheckAttackType(PsychicObjectAttackType::EPsychicObjectAttackType Attack_type_in, bool* Return);
	void GetAttackCollision(bool Throw_in, class UPrimitiveComponent** Attack_collision);
	void SetVisibilityPsyObj(bool Flag_in, bool Mesh_only, bool* Return);
	void SetCollisionPsyObj(bool Flag_in, bool Is_capsule_in, bool* Return);
	void IsBrainCapture(bool* Return);
	void IsUnique(bool* Return);
	void CallbackHitEnemy(bool* Return);
	void IsPsychicActiveOld(bool* Return);
	void SetTickEnable(bool Flag_in);
	void GetCameraShakeData(class UClass** Camera_shake_class, float* Scale);
	void GetAttackDirection(bool Is_swing_direction, bool* Return, struct FVector* Attack_direction);
	void CheckPsychicObjectType(EPsyObjType Psychic_object_type_in, bool* Return);
	void GetGrabIndex(int32* Grab_index);
	void GetBrainIndex(int32* brain_index);
	void GetRequestIndex(int32* Request_index);
	void IsBrainFieldSpawn(bool* Return);
	void GetBrainSwingIndex(int32* Param_Index);
	void Finalize();
	void CheckRepeatHitAttackActor(const struct FHCHitResult& HitResult, bool* bOK);
	void IsTickOn(bool* Return);
	void SetEnemyPsychicObjectActive(bool Active_in, const struct FVector& Obj_pos_in);
	void SetEnemyPsychicObjectThrow(class AActor* Target_actor_in, float Throw_speed_in, float Homing_speed_in);
	void CheckPsychicObjectID(TArray<BattlePrototype::EPsychicObjectID>& Check_list_in, bool* Return);
	void GetPsychicObjectID(BattlePrototype::EPsychicObjectID* Psychic_object_id);
	void SetPsychicActiveOld(bool Flag_in);
	void GetPsychicObjectState(EPsychicObjectState* Return);
	bool GetDebrisEffectBase(class UMeshComponent* TargetMesh, class UParticleSystem** Particle, class UMaterialInterface** OverrideMaterial);
	void SetDebrisEffectParameter(bool InUseDebris, TSoftObjectPtr<class UParticleSystem> InDebrisParticle, bool InUseDebrisOverrideMaterial, int32 InDebrisOverideMaterialIndex);
	bool GetDebrisEffect(EEffectObjectDebrisType* Type, class UMaterialInterface** OverrideMaterial);
	bool GetDebrisEffectData(class UParticleSystem** ParticleTemplate, class UMaterialInterface** OverrideMaterial);
	class UAnimMontage* GetUniqueObjectPlayerMontage(EPsychicObjectUniqueMontageIndex MontageIndex, bool bLeft, bool bMaleHero);
	bool GetUniqueObjectAttackParameter(struct FHCCollisionCommonInfo* OutCommonInto, struct FHCSkillCommonInfo* OutSkillInfo);
	void SetEnemyPsychicObjectInfo(const struct FHCCollisionCommonInfo& In_common_info, const struct FHCSkillCommonInfo& In_skill_info);
	bool IsCopyPsychicObject();
	bool InitializeCopyPsychicObject();
	bool RequestEndUniqueObjectState(class AActor* PActor);
	struct FVector GetUnqObjCamTargetPos();
	bool SetEffectFocus(bool Flag);
	struct FVector GetUniqueObjectCameraLookAtPos(float LookAtRate);
	struct FVector GetUnqObjMoveVelocity();
	struct FRotator GetUniqueObjectCameraOwnerRotation();
	void SetNoRespawn();
	EPsychicObjectSizeType GetPsychicObjectSize();
	void PrevInitialize();
	bool SetPsychicObjectTickC(class FName RefName, bool Flag);
	bool SetPsychicObjectActiveC(bool Flag);
	void IsEnemyPsychicObjectOccupied(bool* Occupied);
	void SetDestroyExplosion();
	struct FVector GetCameraLookAtPos();
	bool SetPlayerCameraViewTarget(float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp);
	bool SetPlayerCameraRotation(const struct FRotator& Rot);
	bool SetPlayerCameraMode(EPlayerCameraMode Mode);
	bool SetPlayerCameraLocation(const struct FVector& Pos);
	bool SetPlayerCameraFieldOfView(float FOV);
	bool SetPlayerCameraDirection(const struct FVector& Pos);
	struct FRotator GetPlayerCameraRotation();
	EPlayerCameraMode GetPlayerCameraMode();
	struct FVector GetPlayerCameraLocation();
	float GetPlayerCameraFieldOfView();
	struct FVector GetPlayerCameraDirection();
	bool SetPsychicObjectFellOutOfWorld(const class UDamageType* PDmgType);
	bool CheckPsychicObjectStillInWorld(float KillZ);
	bool SetDuelPoleType(bool bDuelType);
	void ResetRepeatHitAttackActor();
	bool IsFloatObjectC();
	bool SetDistanceDestroyC();
	bool SetPsychicObjectEventC(bool bStart, bool bTick, bool bVisibility);
	void IsPsychicObject(bool* bResult);
	void IsPsychicObjectActive(bool* IsActive);
	void GetPsychicObjectType(EPsyObjType* Psychic_object_type);
	void GetPsychicObjectWeightGaugePos(struct FVector* Weight_gauge_pos);
	void GetPsychicObjectCentrePos(struct FVector* Centre_pos);
	void GetPsychicObjectVhsParam(class UCurveVector** ParamCurve, class UCurveVector** ColorCurve, float* VhsSeconds);
	void SAS_CommonEnd(E_SASKind SAS_Kind, bool bCancelSASCost, bool* bDummy, float* RemainTime);
	void SAS_CommonStart(const struct FFSASCommand& SAS_Command, bool* Dummy);
	void InterceptAttack(class ARSBattleCharacter_C* Intercepter, class ARSBattleCharacter_C* NewTarget, bool* bDummy);
	void InterceptReserve(bool* bDummy);
	void InterceptCancel(bool* bDummy);
	void IsInterceptFail(bool* bFail);
	void GetDamageCameraShakeData(bool* bEnable, class UClass** CameraShakeClass, float* Scale);
	EFHitEffectPriority GetHitEffectPriorityInterface();

	void IsPsychicCombo(bool* Return) const;
	void GetTriangleData(struct FMeshTriangleData* Triangle_data) const;
	void IsPsychicComboAttack(bool* bComboAttack) const;
	void GetUniqueObjectCaptureMontage(EPlayerID PlayerId, bool bBack, bool bLeft, bool* bUseBlend, class UAnimMontage** StartMontage, class UAnimMontage** CancelMontage) const;
	void IsKarenUniqueObject(bool* bKaren) const;
	void IsAccelerating(bool* Accelerating) const;
	void IsAcceleratorValid(bool* Valid) const;
	struct FMeshTriangleData GetMeshTriangleData() const;
	int32 GetDataRevision() const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_PsychicObjectBasic_C">();
	}
	static class ABP_PsychicObjectBasic_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_PsychicObjectBasic_C>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABP_PsychicObjectBasic_C) == 0x000010, "Wrong alignment on ABP_PsychicObjectBasic_C");
static_assert(sizeof(ABP_PsychicObjectBasic_C) == 0x0005B0, "Wrong size on ABP_PsychicObjectBasic_C");
static_assert(offsetof(ABP_PsychicObjectBasic_C, UberGraphFrame) == 0x000320, "Member 'ABP_PsychicObjectBasic_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, Spline) == 0x000328, "Member 'ABP_PsychicObjectBasic_C::Spline' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, BP_PsychicObjectComponent) == 0x000330, "Member 'ABP_PsychicObjectBasic_C::BP_PsychicObjectComponent' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, AttackSwingArrow) == 0x000338, "Member 'ABP_PsychicObjectBasic_C::AttackSwingArrow' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, AttackDropArrow) == 0x000340, "Member 'ABP_PsychicObjectBasic_C::AttackDropArrow' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, PsychicObjectSound) == 0x000348, "Member 'ABP_PsychicObjectBasic_C::PsychicObjectSound' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, BP_PsychicComponentMain) == 0x000350, "Member 'ABP_PsychicObjectBasic_C::BP_PsychicComponentMain' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, PsychicSasParticleComponent) == 0x000358, "Member 'ABP_PsychicObjectBasic_C::PsychicSasParticleComponent' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, InertialMoveComponent) == 0x000360, "Member 'ABP_PsychicObjectBasic_C::InertialMoveComponent' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, BP_EventParamComponent) == 0x000368, "Member 'ABP_PsychicObjectBasic_C::BP_EventParamComponent' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, BP_CollisionHitSoundComponent) == 0x000370, "Member 'ABP_PsychicObjectBasic_C::BP_CollisionHitSoundComponent' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, HitCheckReceiver) == 0x000378, "Member 'ABP_PsychicObjectBasic_C::HitCheckReceiver' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, Team) == 0x000380, "Member 'ABP_PsychicObjectBasic_C::Team' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, AttackArrow) == 0x000388, "Member 'ABP_PsychicObjectBasic_C::AttackArrow' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, AttackCapsule) == 0x000390, "Member 'ABP_PsychicObjectBasic_C::AttackCapsule' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, AttackSphere) == 0x000398, "Member 'ABP_PsychicObjectBasic_C::AttackSphere' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, DefaultSceneRoot) == 0x0003A0, "Member 'ABP_PsychicObjectBasic_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, ObjectID) == 0x0003A8, "Member 'ABP_PsychicObjectBasic_C::ObjectID' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, PsychicObjectCollision) == 0x0003A9, "Member 'ABP_PsychicObjectBasic_C::PsychicObjectCollision' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, PsychicObjectSimulate) == 0x0003AA, "Member 'ABP_PsychicObjectBasic_C::PsychicObjectSimulate' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, PsychicObjectGravity) == 0x0003AB, "Member 'ABP_PsychicObjectBasic_C::PsychicObjectGravity' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, bFloatObject) == 0x0003AC, "Member 'ABP_PsychicObjectBasic_C::bFloatObject' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, bSwingType) == 0x0003AD, "Member 'ABP_PsychicObjectBasic_C::bSwingType' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, bPhysMassOverwrite) == 0x0003AE, "Member 'ABP_PsychicObjectBasic_C::bPhysMassOverwrite' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, PhysMassOverwrhiteKg) == 0x0003B0, "Member 'ABP_PsychicObjectBasic_C::PhysMassOverwrhiteKg' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, bUseSizeParameterName) == 0x0003B4, "Member 'ABP_PsychicObjectBasic_C::bUseSizeParameterName' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, SizeParameterName) == 0x0003B8, "Member 'ABP_PsychicObjectBasic_C::SizeParameterName' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, bCaptureTimeNormalEx) == 0x0003C0, "Member 'ABP_PsychicObjectBasic_C::bCaptureTimeNormalEx' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, CaptureTimeNormalEx) == 0x0003C4, "Member 'ABP_PsychicObjectBasic_C::CaptureTimeNormalEx' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, DestructibleSoftClass) == 0x0003C8, "Member 'ABP_PsychicObjectBasic_C::DestructibleSoftClass' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, DestructibleClass) == 0x0003F0, "Member 'ABP_PsychicObjectBasic_C::DestructibleClass' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, PsychicObjectName) == 0x0003F8, "Member 'ABP_PsychicObjectBasic_C::PsychicObjectName' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, PsychicObjectID) == 0x000400, "Member 'ABP_PsychicObjectBasic_C::PsychicObjectID' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, PsychicObjectType) == 0x000401, "Member 'ABP_PsychicObjectBasic_C::PsychicObjectType' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, AttackHitActorList) == 0x000408, "Member 'ABP_PsychicObjectBasic_C::AttackHitActorList' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, Cinematic) == 0x000418, "Member 'ABP_PsychicObjectBasic_C::Cinematic' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, UseDebrisParticle) == 0x000419, "Member 'ABP_PsychicObjectBasic_C::UseDebrisParticle' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, UseDebrisOverrideMaterial) == 0x00041A, "Member 'ABP_PsychicObjectBasic_C::UseDebrisOverrideMaterial' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, DebrisOverrideMaterialIndex) == 0x00041C, "Member 'ABP_PsychicObjectBasic_C::DebrisOverrideMaterialIndex' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, DebrisParticle) == 0x000420, "Member 'ABP_PsychicObjectBasic_C::DebrisParticle' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, RefUniqueObjComponent) == 0x000428, "Member 'ABP_PsychicObjectBasic_C::RefUniqueObjComponent' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, UniqueDitherParameterName) == 0x000430, "Member 'ABP_PsychicObjectBasic_C::UniqueDitherParameterName' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, EffectExplosion) == 0x000438, "Member 'ABP_PsychicObjectBasic_C::EffectExplosion' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, DestroyExplosionRadius) == 0x000440, "Member 'ABP_PsychicObjectBasic_C::DestroyExplosionRadius' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, DestroyExplosionTime) == 0x000444, "Member 'ABP_PsychicObjectBasic_C::DestroyExplosionTime' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, DestroyExplosionCommonInfo) == 0x000448, "Member 'ABP_PsychicObjectBasic_C::DestroyExplosionCommonInfo' has a wrong offset!");
static_assert(offsetof(ABP_PsychicObjectBasic_C, DestroyExplosionSkillInfo) == 0x0004B8, "Member 'ABP_PsychicObjectBasic_C::DestroyExplosionSkillInfo' has a wrong offset!");

}

