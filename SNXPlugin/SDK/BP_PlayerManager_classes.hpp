#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PlayerManager

#include "Basic.hpp"

#include "E_SASKind_structs.hpp"
#include "Engine_structs.hpp"
#include "BattlePrototype_structs.hpp"
#include "BattlePrototype_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "SPlayerAIAssistThinkData_structs.hpp"
#include "EHologramKind_structs.hpp"
#include "CharactersSkillData_structs.hpp"
#include "EPlayerFacialAnim_structs.hpp"
#include "EPlayerCapsuleSize_structs.hpp"
#include "E_SceneType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_PlayerManager.BP_PlayerManager_C
// 0x01A0 (0x0590 - 0x03F0)
class ABP_PlayerManager_C final : public APlayerManager
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x03F0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UBP_PlayerRessurectComponent_C*         BP_PlayerRessurectRight;                           // 0x03F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerRessurectComponent_C*         BP_PlayerRessurecttLeft;                           // 0x0400(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_CalcParameterComponent_C*           BP_CalcParameterComponent;                         // 0x0408(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_GameOverSystemComponent_C*          GameOverSystem;                                    // 0x0410(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_PlayerFixParamater_C*               FixParam;                                          // 0x0418(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0420(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	float                                         PartnerWarpLimitDistance;                          // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         PartnerWarpLimitDistanceBattle;                    // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FVector>                        PartnerWarpOffset;                                 // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<struct FSPlayerAIAssistThinkData>      HpAssistThinkTable;                                // 0x0440(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<struct FSPlayerAIAssistThinkData>      StatusAssistThinkTable;                            // 0x0450(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<struct FSPlayerAIAssistThinkData>      RevivalAssistThinkTable;                           // 0x0460(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	int32                                         HpAssistCount;                                     // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         StatusAssistCount;                                 // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         RevivalAssistCount;                                // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bForceBrainField;                                  // 0x047C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bDisableGameOver;                                  // 0x047D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bInitSkillList;                                    // 0x047E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B6B[0x1];                                     // 0x047F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharactersSkillData>           SkillList;                                         // 0x0480(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bDisableBrainFieldFlag;                            // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B6C[0x7];                                     // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  SkillIdCh0100;                                     // 0x0498(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<bool>                                  SkillIdCh0200;                                     // 0x04A8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class ABP_PlayerHologram_C*                   HologramManageActor;                               // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             DispatchSuccessResurrect;                          // 0x04C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<class ABP_CableBase_C*>                ResurrectCableList;                                // 0x04D0(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         DebugDPS;                                          // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DebugDPS_DamageSum;                                // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DebugDPSTimer;                                     // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DebugDPSLastTime;                                  // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DebugDPSInterval;                                  // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         PreviousStealthOpacity;                            // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         StealthOpacityUpTime;                              // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4B6D[0x4];                                     // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSBattlePlayer_C*                      ChildYuitoActor;                                   // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bSpawnChildYuito;                                  // 0x0508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B6E[0x7];                                     // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSBattlePlayer_C*                      SASLinkENPCActor;                                  // 0x0510(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_MenuPlayerBase_C*>           MenuBGPlayerList;                                  // 0x0518(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bEnableBrainCrashAccessExtraTime;                  // 0x0528(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B6F[0x3];                                     // 0x0529(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrainCrashAccessExtraTime;                         // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bNewSkill;                                         // 0x0530(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B70[0x7];                                     // 0x0531(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSBattlePlayer_C*                      RessurrectedPlayer;                                // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bNpcThinkAssistAttack_0;                           // 0x0540(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B71[0x7];                                     // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_NpcReviveDirectionActor_C*          NpcReviveDirectionActor;                           // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FSPlayerAIAssistThinkData>      HpAssistThinkTable_OrderLimit;                     // 0x0550(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          SteapthOpacityMove;                                // 0x0560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B72[0x3];                                     // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PartnerWarp_LimitBattleField;                      // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bReservedMainPlayerDeadSequence;                   // 0x0568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B73[0x3];                                     // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             RequestStatusAssistTimer;                          // 0x056C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bBackupEventSetoMask;                              // 0x0578(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B74[0x7];                                     // 0x0579(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 BackupEquipAttachmentItemID;                       // 0x0580(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)

public:
	void DispatchSuccessResurrect__DelegateSignature(class AActor* RevivePlayer);
	void ExecuteUbergraph_BP_PlayerManager(int32 EntryPoint);
	void SetPhotoModeHood_Native(ERSPartyPlayerKind Kind, bool bVisible);
	void PlayPhotoModeFacialAnim_Native(ERSPartyPlayerKind Kind, EPlayerFacialAnim_Native Anim);
	void DelayBeginPlay();
	void SetBattleMember(ERSPartyPlayerKind Kind, EPlayerID ID, bool bSpawn);
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void ExecPartnerWarpCheck();
	void PlayerSetting(ERSPartyPlayerKind Kind, class ARSCharacterBase* Player);
	void EventManagerRigitBodyEmptyUpdateSeconds(float RigitBodyEmptyUpdateSeconds);
	void ReceiveTick(float DeltaSeconds);
	void ReceiveBeginPlay();
	void EventGameOverRevivePlayer();
	void EventBrainTalkRevival();
	void EventCameraTopView();
	void EventStartCutEvent();
	void EventEraseHUD();
	void EventRecoverCamera();
	void EventRecoverAnimationNPC();
	void EventPlayerStandup();
	void EventWaitStandupNPC();
	void EventRecoverEffectPlayer();
	void EventRecoverEffectNPC();
	void EventBrainFieldOut();
	void EventChangeDeadCamera();
	void EventPlayerAnimationDead();
	void EventBrainTalkDead();
	void EventBrainTalkDeadBlur();
	void EventStartUIGameOver();
	void Set_Assist_Count(int32 HP, int32 BadStatus, int32 Revive);
	void IPresetAddPartyMember(class FName PresetName, bool IsCheckBattleMemberMain);
	void ResetAssistThinkData();
	void ResetSkill(EPlayerID Player_id_in);
	void AddSkill(EPlayerID Player_id_in, EPlayerSkill Skill_id_in);
	void InitializePlayer();
	void BndEvt__BP_PlayerRessurectRight_K2Node_ComponentBoundEvent_1_RessurectSuccessDelegate__DelegateSignature(class AActor* RevivePlayer);
	void BndEvt__BP_PlayerRessurecttLeft_K2Node_ComponentBoundEvent_0_RessurectSuccessDelegate__DelegateSignature(class AActor* RevivePlayer);
	void EventReviveBattleMember();
	void UserConstructionScript();
	void UpdateWarpPartner();
	void AllPlayerRigitBodyEmptyUpdate(float EmptyUpdateSeconds);
	void ForceWarpToMainPlayer(ERSPartyPlayerKind Kind, float Delay, bool EventIn);
	void ForceWarp(ERSPartyPlayerKind Kind, const struct FTransform& Transform, float IdleRestoreDelay);
	void GetLeftPlayer(class ARSBattlePlayer_C** Player);
	void GetRightPlayer(class ARSBattlePlayer_C** Player);
	void GetMainPlayer(class ARSBattlePlayer_C** Player);
	void GetPlayersAll(TArray<class ARSBattlePlayer_C*>* Player);
	void InitializeAssistThink();
	void RequestHpAssist(float Hp_percentage);
	void RequestStatusAssist();
	void RequestRevivalAssist(bool* Is_revival, class ARSBattlePlayer_C** AssistPlayer);
	void ResetAssistThinkData_Internal();
	void DecAssistCount(EConsumeItemID Item_id_in);
	void ChangePlayerFromClass(ERSPartyPlayerKind Kind, TSoftClassPtr<class UClass> PlayerClass);
	void DoPlayerSetting(ERSPartyPlayerKind Kind, class ARSBattlePlayer_C* Player);
	void SetSasStealth(bool Stealth_on_in);
	void StartDeadGameOver();
	void StartDeadRecover(class ARSBattleCharacter_C* RecoverCharacter);
	void IsPlayingDeadGameOver(bool* Playing);
	void IsPlayingAnyDead(bool* Playing);
	void ChangeAreaLocation(E_SceneType SceneType);
	TSoftClassPtr<class UClass> GetPlayerBPSoftRef(EPlayerID PlayerId, bool bENPC, bool bMetamorphosis);
	void SetForceBrainField(bool bEnable);
	void SetDisableGameOver(bool bDisable);
	struct FCharactersParameterTable UpdatePlayerParameter(EPlayerID PlayerId, bool bMaxHP);
	void InitializeSkillList();
	void AddSkill_Internal(EPlayerID Player_id_in, EPlayerSkill Skill_id_in);
	void AddExp(int32 Exp_value_in, int32 EnemyLevelIn, bool bDirect, int32* OutMainPlayerExp);
	void SetDisableBrainFieldFlag(bool bDisable);
	void SubSkill(EPlayerID Player_id_in, EPlayerSkill Skill_id_in);
	void ResetSkill_Internal(EPlayerID Player_id_in);
	void DebugPrintSkillList();
	void SpawnNotPartyPlayer(EPlayerID PlayerId, bool bENPC, bool bMetamorphosis, const struct FTransform& Transform, class AActor* CreateOwner, class ARSBattlePlayer_C** Player);
	void InitializeHologram();
	void FinalizeHologram();
	void PlayHologramAnimation(EPlayerID PlayerId, class UAnimMontage* AnimMontage, class UAnimMontage* WeaponMontage, bool bHologramRootMotion, int32 MotionIndex, EHologramKind HologramKind);
	void StopHologramAnimation();
	void HologramOn();
	void HologramOff(bool bForceOff);
	void PresetAddPartyMember(class FName PresetName, bool IsCheckBattleMemberMain, bool bNotEquipSAS);
	void RecoverAllHp(bool bUseParticle);
	void RecoverAllBadState();
	void PlayHologramAnimationSequence(EPlayerID PlayerId, EPlayerHologramAnimKind Kind);
	void ActivateResurrectIcon(class ARSBattlePlayer_C* DeadPlayer);
	void DeactivateResurrectIcon(class ARSBattlePlayer_C* DeadPlayer);
	void GetRessurectComponent(class ARSBattlePlayer_C* DeadPlayer, class UPlayerRessurectComponent** Comp);
	void GetResurrectAblePlayer(class ARSBattlePlayer_C** DeadPlayer);
	void BeginResurrect(class ARSBattlePlayer_C* DeadPlayer, float TimeRate);
	void SuspendResurrection();
	void SetPlayerCameraViewTarget(float Blend_Time, EViewTargetBlendFunction Blend_Func, float Blend_Exp);
	void InitializeRevive();
	void GetResurrectCableList(TArray<class ABP_CableBase_C*>* Param_ResurrectCableList);
	void ChangeAccelerator(float NewCustomTImeDilation);
	void DebugCalcDPS(struct FHCHitResult& HitResult, int32 Damage);
	void DebugUpdateCalcDPS();
	void IsSkillLearnAble(EPlayerID InPlayerID, EPlayerSkill InSkillID, bool* bOK);
	void LearnSkill(EPlayerID InPlayerID, EPlayerSkill InSkillID, bool* bSuccess);
	void CheckSASHologramAttack(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	void UpdateMaterials(float DeltaSeconds);
	int32 GetAccessoryEquipNum(EPlayerID PlayerId);
	void SetAttentionCamera(bool Flag_in, bool Look_at_actor, const struct FVector& Look_at_pos_in, class AActor* Target_actor_in, class UCurveFloat* Actor_curve_in, bool Change_fov, float Target_fov_in, class UCurveFloat* Fov_curve_in);
	void SetAttentionCameraOption(bool Offset_angle_vt, float Offset_angle_vt_in, bool Offset_angle_Hz, float Offset_angle_Hz_in);
	bool IsPlayerInputTrgBrainField();
	void SpawnChildYuito(const struct FTransform& InTransform, class ARSBattlePlayer_C** OutChildYuito);
	void RegisterChildYuito(class ARSBattlePlayer_C* InChildYuito);
	void ControlChildYuito(bool bControl);
	void CheckNpcDrive(ENpcDriveCheckType CheckType, class AActor* EnemyActor, EPlayerID CombinationVisionPlayerID);
	void RegisterSasLinkEnpc(class ARSBattlePlayer_C* LinkPlayer);
	void ClearSasLinkActor();
	void SasLinkEnpc(E_SASKind Kind);
	void UpdateBattleMemberAttachment();
	void OnAreaChangeNoneBattleLocation();
	void GetAssistCheckPlayerList(TMap<class ARSBattlePlayer_C*, int32>* AssistList);
	void ResetPlayerCollisionOverlap();
	void AddMenuBGPlayerList(class ABP_MenuPlayerBase_C* Player);
	void ClearMenuBGPlayerList();
	void GetMenuBGPlayerList(TArray<class ABP_MenuPlayerBase_C*>* PlayerList);
	void UpdateMenuBGPlayer(EPlayerID PlayerId, const struct FPlayerInfo& PlayerInfo);
	void SetEnableBrainCrashExtraTime(bool bEnable, float ExtraTime);
	void SetNpcThinkAssistAttack(bool Flag_in);
	void IsNpcThinkAssistAttack(bool* Return);
	void PostSetBattleMember(ERSPartyPlayerKind Kind, EPlayerID ID, bool Spawn);
	bool IsPlayerStatus(ERSPartyPlayerKind Kind, EPlayerCommonStatus PlayerStatus);
	void DoEndPlay();
	void GetNpcReviveDirectionManage(class ABP_NpcReviveDirectionActor_C** Manage);
	void OnEventBattleMameberRevive();
	void AreaChangeForceWarp(const struct FTransform& InTransform, float InIdleRestoreDelay);
	void CalcMenuParameterEquipWeapon(EPlayerID InPlayerID, int32 InWeaponID, bool* bSuccess, int32* Attack, int32* Psychic, int32* Defence);
	void CalcMenuParameterEquipAccessory(EPlayerID InPlayerID, EPlayerAccessory InSlot, int32 InAccessoryID, bool* bSuccess, int32* Attack, int32* Psychic, int32* Defence, int32* HP);
	void CalcMenuParameterSkill(EPlayerID InPlayerID, EPlayerSkill InSkill, bool* bSuccess, int32* Attack, int32* Psychic, int32* Defence);
	void AddBondsValue(EAddBondsType Type, EPlayerID TargetPlayer);
	int32 GetNpcAssistCountHP();
	int32 GetNpcAssistCountBadStatus();
	int32 GetNpcAssistCountRevive();
	void Set_Assist_Count_Internal(int32 HP, int32 BadStatus, int32 Revive);
	void GetSkillLearnPoint(EPlayerID InPlayerID, EPlayerSkill InSkillID, int32* Point);
	void InitializeLevelDifferentExpRateData();
	int32 DebugCalcCurrentSkillPoint(EPlayerID ID);
	int32 ReCalcRemainingSkillPoint(EPlayerID ID);
	void ReserveMainPlayerDeadSequence();
	void StartMainPlayerDeadSequence();
	void ClearResuestStatusAssist();
	void DoStatusAssist();
	void UpdateAssist();
	bool IsNeedFrameWait();
	bool InitializeManager(EManagerProcTiming Timing);
	bool SetBattleMemberCore(ERSPartyPlayerKind Kind, EPlayerID ID, bool bSpawn);
	void GetHologramManageActor(class ABP_PlayerHologram_C** Param_HologramManageActor);
	void EventEquipSetoMaskBegin();
	void EventEquipSetoMaskEnd();
	void UpdateTriggerEffect();
	void GetAjitoNpcWarpOffset(struct FVector* Offset);
	bool IsCanSASUse_fromNative(E_SASButton Button);
	void CheckNpcDriveDefeatedCombinationVision(struct FHCSkillCommonInfo& SkillInfo);
	void CheckNpcDriveCombinationVisionHit(struct FHCSkillCommonInfo& SkillInfo);
	bool DoNotifyBattleSimulatorEnd(bool bMissionCancel);
	void GetPhotoModeFacialList(ERSPartyPlayerKind Kind, TArray<EPlayerFacialAnim>* FacialList);
	void PlayPhotoModeFacialAnim(ERSPartyPlayerKind Kind, EPlayerFacialAnim Anim);
	void SetPhotoModeHood(ERSPartyPlayerKind Kind, bool bVisible);
	void IsVisiblePhotoModeHood(ERSPartyPlayerKind Kind, bool* bVisible);
	TArray<EPlayerFacialAnim_Native> GetPhotoModeFacialList_Native(ERSPartyPlayerKind Kind);
	bool IsVisiblePhotoModeHood_Native(ERSPartyPlayerKind Kind);
	bool IsEnablePhotoModePlayer(ERSPartyPlayerKind Kind);
	bool IsHoodCostumeID(EPlayerID PlayerId, int32 CostumeId);
	bool EventManagerStart(bool EnableTick, bool Visibility);
	bool EventManagerEnd(bool RestoreEnableTick, bool RestoreVisibility);
	void GetCommandAccelerator(struct FAcceleratorParam* Command, bool* IsEnable);
	void GetPlayerWeaponActorList(class AActor* OwnerPlayer, EGetPlayerWeaponType Type, TArray<class AActor*>* WeaponList);
	void GetMainPlayerCostumeID(int32* CostumeId);
	void GetCameraPitchMaxAngle(float* MaxLowAngle, float* MaxUpAngle);

	void IsInAntiWarpField(bool* bInAntiWarp) const;
	void IsPlayingDeadRecover(bool* Playing) const;
	void IsForceBrainField(bool* bInfinite) const;
	void IsDisableGameOver(bool* Param_bDisableGameOver) const;
	void GetSkillData(EPlayerSkill Skill_id_in, bool* Return, struct FCharactersSkillData* Skill_data) const;
	void IsDisableBrainFieldFlag(bool* Param_bDisableBrainFieldFlag) const;
	void IsSkillLearned(EPlayerID Player_id_in, EPlayerSkill Skill_id_in, bool* Learned) const;
	void GetPlayerSkillPoint(EPlayerID Player_id_in, int32* Skill_point) const;
	void GetLearnedSkillParameter(EPlayerID PlayerId, EPlayerSkill Skill, bool* bLearned, float* Parameter, float* Parameter2) const;
	void IsHologramOn(bool* bON) const;
	void IsEnpcSASLinkAble(bool* bOK) const;
	void IsBrainCrashAccessExtraTime(bool* bEnable, float* ExtraTime) const;
	void IsExecResurrect(bool* bExec) const;
	void IsExecNpcReviveDirection(bool* bExec) const;
	bool IsExecNpcReviveDirection_CallFromCPP() const;
	bool IsExecResurrect_CallFromCPP() const;
	bool IsPlayingDeadRecover_CallFromCPP() const;
	bool IsPlayingDead_CallFromCPP() const;
	bool IsPlayingRecover_CallFromCPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_PlayerManager_C">();
	}
	static class ABP_PlayerManager_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_PlayerManager_C>();
	}
};
static_assert(alignof(ABP_PlayerManager_C) == 0x000008, "Wrong alignment on ABP_PlayerManager_C");
static_assert(sizeof(ABP_PlayerManager_C) == 0x000590, "Wrong size on ABP_PlayerManager_C");
static_assert(offsetof(ABP_PlayerManager_C, UberGraphFrame) == 0x0003F0, "Member 'ABP_PlayerManager_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, BP_PlayerRessurectRight) == 0x0003F8, "Member 'ABP_PlayerManager_C::BP_PlayerRessurectRight' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, BP_PlayerRessurecttLeft) == 0x000400, "Member 'ABP_PlayerManager_C::BP_PlayerRessurecttLeft' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, BP_CalcParameterComponent) == 0x000408, "Member 'ABP_PlayerManager_C::BP_CalcParameterComponent' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, GameOverSystem) == 0x000410, "Member 'ABP_PlayerManager_C::GameOverSystem' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, FixParam) == 0x000418, "Member 'ABP_PlayerManager_C::FixParam' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, DefaultSceneRoot) == 0x000420, "Member 'ABP_PlayerManager_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, PartnerWarpLimitDistance) == 0x000428, "Member 'ABP_PlayerManager_C::PartnerWarpLimitDistance' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, PartnerWarpLimitDistanceBattle) == 0x00042C, "Member 'ABP_PlayerManager_C::PartnerWarpLimitDistanceBattle' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, PartnerWarpOffset) == 0x000430, "Member 'ABP_PlayerManager_C::PartnerWarpOffset' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, HpAssistThinkTable) == 0x000440, "Member 'ABP_PlayerManager_C::HpAssistThinkTable' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, StatusAssistThinkTable) == 0x000450, "Member 'ABP_PlayerManager_C::StatusAssistThinkTable' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, RevivalAssistThinkTable) == 0x000460, "Member 'ABP_PlayerManager_C::RevivalAssistThinkTable' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, HpAssistCount) == 0x000470, "Member 'ABP_PlayerManager_C::HpAssistCount' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, StatusAssistCount) == 0x000474, "Member 'ABP_PlayerManager_C::StatusAssistCount' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, RevivalAssistCount) == 0x000478, "Member 'ABP_PlayerManager_C::RevivalAssistCount' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bForceBrainField) == 0x00047C, "Member 'ABP_PlayerManager_C::bForceBrainField' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bDisableGameOver) == 0x00047D, "Member 'ABP_PlayerManager_C::bDisableGameOver' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bInitSkillList) == 0x00047E, "Member 'ABP_PlayerManager_C::bInitSkillList' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, SkillList) == 0x000480, "Member 'ABP_PlayerManager_C::SkillList' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bDisableBrainFieldFlag) == 0x000490, "Member 'ABP_PlayerManager_C::bDisableBrainFieldFlag' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, SkillIdCh0100) == 0x000498, "Member 'ABP_PlayerManager_C::SkillIdCh0100' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, SkillIdCh0200) == 0x0004A8, "Member 'ABP_PlayerManager_C::SkillIdCh0200' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, HologramManageActor) == 0x0004B8, "Member 'ABP_PlayerManager_C::HologramManageActor' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, DispatchSuccessResurrect) == 0x0004C0, "Member 'ABP_PlayerManager_C::DispatchSuccessResurrect' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, ResurrectCableList) == 0x0004D0, "Member 'ABP_PlayerManager_C::ResurrectCableList' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, DebugDPS) == 0x0004E0, "Member 'ABP_PlayerManager_C::DebugDPS' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, DebugDPS_DamageSum) == 0x0004E4, "Member 'ABP_PlayerManager_C::DebugDPS_DamageSum' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, DebugDPSTimer) == 0x0004E8, "Member 'ABP_PlayerManager_C::DebugDPSTimer' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, DebugDPSLastTime) == 0x0004EC, "Member 'ABP_PlayerManager_C::DebugDPSLastTime' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, DebugDPSInterval) == 0x0004F0, "Member 'ABP_PlayerManager_C::DebugDPSInterval' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, PreviousStealthOpacity) == 0x0004F4, "Member 'ABP_PlayerManager_C::PreviousStealthOpacity' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, StealthOpacityUpTime) == 0x0004F8, "Member 'ABP_PlayerManager_C::StealthOpacityUpTime' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, ChildYuitoActor) == 0x000500, "Member 'ABP_PlayerManager_C::ChildYuitoActor' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bSpawnChildYuito) == 0x000508, "Member 'ABP_PlayerManager_C::bSpawnChildYuito' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, SASLinkENPCActor) == 0x000510, "Member 'ABP_PlayerManager_C::SASLinkENPCActor' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, MenuBGPlayerList) == 0x000518, "Member 'ABP_PlayerManager_C::MenuBGPlayerList' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bEnableBrainCrashAccessExtraTime) == 0x000528, "Member 'ABP_PlayerManager_C::bEnableBrainCrashAccessExtraTime' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, BrainCrashAccessExtraTime) == 0x00052C, "Member 'ABP_PlayerManager_C::BrainCrashAccessExtraTime' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bNewSkill) == 0x000530, "Member 'ABP_PlayerManager_C::bNewSkill' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, RessurrectedPlayer) == 0x000538, "Member 'ABP_PlayerManager_C::RessurrectedPlayer' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bNpcThinkAssistAttack_0) == 0x000540, "Member 'ABP_PlayerManager_C::bNpcThinkAssistAttack_0' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, NpcReviveDirectionActor) == 0x000548, "Member 'ABP_PlayerManager_C::NpcReviveDirectionActor' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, HpAssistThinkTable_OrderLimit) == 0x000550, "Member 'ABP_PlayerManager_C::HpAssistThinkTable_OrderLimit' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, SteapthOpacityMove) == 0x000560, "Member 'ABP_PlayerManager_C::SteapthOpacityMove' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, PartnerWarp_LimitBattleField) == 0x000564, "Member 'ABP_PlayerManager_C::PartnerWarp_LimitBattleField' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bReservedMainPlayerDeadSequence) == 0x000568, "Member 'ABP_PlayerManager_C::bReservedMainPlayerDeadSequence' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, RequestStatusAssistTimer) == 0x00056C, "Member 'ABP_PlayerManager_C::RequestStatusAssistTimer' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, bBackupEventSetoMask) == 0x000578, "Member 'ABP_PlayerManager_C::bBackupEventSetoMask' has a wrong offset!");
static_assert(offsetof(ABP_PlayerManager_C, BackupEquipAttachmentItemID) == 0x000580, "Member 'ABP_PlayerManager_C::BackupEquipAttachmentItemID' has a wrong offset!");

}

