#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Ai_Enemy

#include "Basic.hpp"

#include "BP_Ai_Enemy_classes.hpp"
#include "BP_Ai_Enemy_parameters.hpp"


namespace SDK
{

// Function BP_Ai_Enemy.BP_Ai_Enemy_C.ExecuteUbergraph_BP_Ai_Enemy
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Ai_Enemy_C::ExecuteUbergraph_BP_Ai_Enemy(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "ExecuteUbergraph_BP_Ai_Enemy");

	Params::BP_Ai_Enemy_C_ExecuteUbergraph_BP_Ai_Enemy Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Ai_Enemy_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "ReceiveTick");

	Params::BP_Ai_Enemy_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBP_Ai_Enemy_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsRandomCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsRandomCheck(float Value, bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsRandomCheck");

	Params::BP_Ai_Enemy_C_IsRandomCheck Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsTimerCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsTimerCheck(float Value, bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsTimerCheck");

	Params::BP_Ai_Enemy_C_IsTimerCheck Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsIdleMove
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsIdleMove(bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsIdleMove");

	Params::BP_Ai_Enemy_C_IsIdleMove Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsDamage(bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsDamage");

	Params::BP_Ai_Enemy_C_IsDamage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsHpPercentDown
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Percent                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Error                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsHpPercentDown(float Percent, bool* Return, bool* Error)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsHpPercentDown");

	Params::BP_Ai_Enemy_C_IsHpPercentDown Parms{};

	Parms.Percent = Percent;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;

	if (Error != nullptr)
		*Error = Parms.Error;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.GetAiData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   Enum                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ThroughNotFound                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EEnemyThinkActionType                   ThinkActionType                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Probability                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Range                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   NoRange                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Angle                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   NoAngle                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   HP                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<uint8>                           UniqueConditions                                       (Parm, OutParm, HasGetValueTypeHash)

void UBP_Ai_Enemy_C::GetAiData(uint8 Enum, bool ThroughNotFound, EEnemyThinkActionType* ThinkActionType, float* Probability, float* Range, float* NoRange, float* Angle, float* NoAngle, float* HP, TArray<uint8>* UniqueConditions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "GetAiData");

	Params::BP_Ai_Enemy_C_GetAiData Parms{};

	Parms.Enum = Enum;
	Parms.ThroughNotFound = ThroughNotFound;

	UObject::ProcessEvent(Func, &Parms);

	if (ThinkActionType != nullptr)
		*ThinkActionType = Parms.ThinkActionType;

	if (Probability != nullptr)
		*Probability = Parms.Probability;

	if (Range != nullptr)
		*Range = Parms.Range;

	if (NoRange != nullptr)
		*NoRange = Parms.NoRange;

	if (Angle != nullptr)
		*Angle = Parms.Angle;

	if (NoAngle != nullptr)
		*NoAngle = Parms.NoAngle;

	if (HP != nullptr)
		*HP = Parms.HP;

	if (UniqueConditions != nullptr)
		*UniqueConditions = std::move(Parms.UniqueConditions);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.SetAction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   Enum                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Ai_Enemy_C::SetAction(uint8 Enum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "SetAction");

	Params::BP_Ai_Enemy_C_SetAction Parms{};

	Parms.Enum = Enum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.GetAiDataDistance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// uint8                                   Enum                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NotAngle                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NotHeight                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::GetAiDataDistance(uint8 Enum, bool NotAngle, bool NotHeight, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "GetAiDataDistance");

	Params::BP_Ai_Enemy_C_GetAiDataDistance Parms{};

	Parms.Enum = Enum;
	Parms.NotAngle = NotAngle;
	Parms.NotHeight = NotHeight;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.GetAiDataDistanceAngleCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// uint8                                   Enum                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NotHeight                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::GetAiDataDistanceAngleCheck(uint8 Enum, bool NotHeight, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "GetAiDataDistanceAngleCheck");

	Params::BP_Ai_Enemy_C_GetAiDataDistanceAngleCheck Parms{};

	Parms.Enum = Enum;
	Parms.NotHeight = NotHeight;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsEvent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Ret                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsEvent(bool* Ret)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsEvent");

	Params::BP_Ai_Enemy_C_IsEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Ret != nullptr)
		*Ret = Parms.Ret;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.SelectAction
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_Ai_Enemy_C::SelectAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "SelectAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.MoveAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::MoveAction(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "MoveAction");

	Params::BP_Ai_Enemy_C_MoveAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.NotMoveAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::NotMoveAction(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "NotMoveAction");

	Params::BP_Ai_Enemy_C_NotMoveAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsAiAction
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// uint8                                   Enum                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NotHeight                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NotProbability                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsAiAction(uint8 Enum, bool NotHeight, bool NotProbability, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsAiAction");

	Params::BP_Ai_Enemy_C_IsAiAction Parms{};

	Parms.Enum = Enum;
	Parms.NotHeight = NotHeight;
	Parms.NotProbability = NotProbability;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.SelectParamAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<uint8>                           ActionEnums                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// bool                                    NotHeight                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// uint8                                   Param_Action                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Ai_Enemy_C::SelectParamAction(TArray<uint8>& ActionEnums, bool NotHeight, uint8* Param_Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "SelectParamAction");

	Params::BP_Ai_Enemy_C_SelectParamAction Parms{};

	Parms.ActionEnums = std::move(ActionEnums);
	Parms.NotHeight = NotHeight;

	UObject::ProcessEvent(Func, &Parms);

	ActionEnums = std::move(Parms.ActionEnums);

	if (Param_Action != nullptr)
		*Param_Action = Parms.Param_Action;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsTimerOK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// uint8                                   Enum                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsTimerOK(uint8 Enum, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsTimerOK");

	Params::BP_Ai_Enemy_C_IsTimerOK Parms{};

	Parms.Enum = Enum;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.SelectRangeAction
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NotHeight                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// uint8                                   SelectAction                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Ai_Enemy_C::SelectRangeAction(bool NotHeight, uint8* SelectAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "SelectRangeAction");

	Params::BP_Ai_Enemy_C_SelectRangeAction Parms{};

	Parms.NotHeight = NotHeight;

	UObject::ProcessEvent(Func, &Parms);

	if (SelectAction != nullptr)
		*SelectAction = Parms.SelectAction;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.SetReserveAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   Param_Action                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Param00                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Param01                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::SetReserveAction(uint8 Param_Action, float Param00, float Param01, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "SetReserveAction");

	Params::BP_Ai_Enemy_C_SetReserveAction Parms{};

	Parms.Param_Action = Param_Action;
	Parms.Param00 = Param00;
	Parms.Param01 = Param01;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.ResetReserveAction
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Ai_Enemy_C::ResetReserveAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "ResetReserveAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.SetActionFromReserved
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::SetActionFromReserved(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "SetActionFromReserved");

	Params::BP_Ai_Enemy_C_SetActionFromReserved Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.ResetAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::ResetAction(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "ResetAction");

	Params::BP_Ai_Enemy_C_ResetAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.WinceCounterAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   Enum                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsSet                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::WinceCounterAction(uint8 Enum, bool* IsSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "WinceCounterAction");

	Params::BP_Ai_Enemy_C_WinceCounterAction Parms{};

	Parms.Enum = Enum;

	UObject::ProcessEvent(Func, &Parms);

	if (IsSet != nullptr)
		*IsSet = Parms.IsSet;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.KnockBackCounterAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   Enum                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsSet                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::KnockBackCounterAction(uint8 Enum, bool* IsSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "KnockBackCounterAction");

	Params::BP_Ai_Enemy_C_KnockBackCounterAction Parms{};

	Parms.Enum = Enum;

	UObject::ProcessEvent(Func, &Parms);

	if (IsSet != nullptr)
		*IsSet = Parms.IsSet;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsPreConditionOK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FAiParamEnemy                    AiParam                                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    bOK                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsPreConditionOK(const struct FAiParamEnemy& AiParam, bool* bOK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsPreConditionOK");

	Params::BP_Ai_Enemy_C_IsPreConditionOK Parms{};

	Parms.AiParam = std::move(AiParam);

	UObject::ProcessEvent(Func, &Parms);

	if (bOK != nullptr)
		*bOK = Parms.bOK;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.SetIdleMoveAction
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Ai_Enemy_C::SetIdleMoveAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "SetIdleMoveAction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.CheckIdleMoveAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   Param_Action                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsIdleMoveAction                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::CheckIdleMoveAction(uint8 Param_Action, bool* IsIdleMoveAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "CheckIdleMoveAction");

	Params::BP_Ai_Enemy_C_CheckIdleMoveAction Parms{};

	Parms.Param_Action = Param_Action;

	UObject::ProcessEvent(Func, &Parms);

	if (IsIdleMoveAction != nullptr)
		*IsIdleMoveAction = Parms.IsIdleMoveAction;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.GetAiTimer_FromNative
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// uint8                                   ActionEnym                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float UBP_Ai_Enemy_C::GetAiTimer_FromNative(uint8 ActionEnym)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "GetAiTimer_FromNative");

	Params::BP_Ai_Enemy_C_GetAiTimer_FromNative Parms{};

	Parms.ActionEnym = ActionEnym;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.BossBattleBeginAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::BossBattleBeginAction(bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "BossBattleBeginAction");

	Params::BP_Ai_Enemy_C_BossBattleBeginAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.OnStartFade
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Ai_Enemy_C::OnStartFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "OnStartFade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.OnEndFade
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Ai_Enemy_C::OnEndFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "OnEndFade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsReservedAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    Reserved                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsReservedAction(bool* Reserved) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsReservedAction");

	Params::BP_Ai_Enemy_C_IsReservedAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Reserved != nullptr)
		*Reserved = Parms.Reserved;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsUniqueConditionCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// TArray<uint8>                           Conditions                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsUniqueConditionCheck(TArray<uint8>& Conditions, bool* bResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsUniqueConditionCheck");

	Params::BP_Ai_Enemy_C_IsUniqueConditionCheck Parms{};

	Parms.Conditions = std::move(Conditions);

	UObject::ProcessEvent(Func, &Parms);

	Conditions = std::move(Parms.Conditions);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.GetActionTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// uint8                                   CurAction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Seconds                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Ai_Enemy_C::GetActionTime(uint8 CurAction, float* Seconds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "GetActionTime");

	Params::BP_Ai_Enemy_C_GetActionTime Parms{};

	Parms.CurAction = CurAction;

	UObject::ProcessEvent(Func, &Parms);

	if (Seconds != nullptr)
		*Seconds = Parms.Seconds;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsPossibleAttack
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    IgnoreOutofScreen                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IgnoreRestrictAttackOther                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPossible                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsPossibleAttack(bool IgnoreOutofScreen, bool IgnoreRestrictAttackOther, bool* bPossible) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsPossibleAttack");

	Params::BP_Ai_Enemy_C_IsPossibleAttack Parms{};

	Parms.IgnoreOutofScreen = IgnoreOutofScreen;
	Parms.IgnoreRestrictAttackOther = IgnoreRestrictAttackOther;

	UObject::ProcessEvent(Func, &Parms);

	if (bPossible != nullptr)
		*bPossible = Parms.bPossible;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsCommonAreaOK
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EEnemyThinkActionType                   ActionType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bOK                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsCommonAreaOK(EEnemyThinkActionType ActionType, bool* bOK) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsCommonAreaOK");

	Params::BP_Ai_Enemy_C_IsCommonAreaOK Parms{};

	Parms.ActionType = ActionType;

	UObject::ProcessEvent(Func, &Parms);

	if (bOK != nullptr)
		*bOK = Parms.bOK;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsAttackingOtherEnemy
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class ARSBattlePlayer_C*                TargetPlayer                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bAttacking                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsAttackingOtherEnemy(class ARSBattlePlayer_C* TargetPlayer, bool* bAttacking) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsAttackingOtherEnemy");

	Params::BP_Ai_Enemy_C_IsAttackingOtherEnemy Parms{};

	Parms.TargetPlayer = TargetPlayer;

	UObject::ProcessEvent(Func, &Parms);

	if (bAttacking != nullptr)
		*bAttacking = Parms.bAttacking;
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.GetAiDataTable
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// uint8                                   Enum                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ThroughNotFound                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FAiParamEnemy                    DataTable                                              (Parm, OutParm, HasGetValueTypeHash)

void UBP_Ai_Enemy_C::GetAiDataTable(uint8 Enum, bool ThroughNotFound, struct FAiParamEnemy* DataTable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "GetAiDataTable");

	Params::BP_Ai_Enemy_C_GetAiDataTable Parms{};

	Parms.Enum = Enum;
	Parms.ThroughNotFound = ThroughNotFound;

	UObject::ProcessEvent(Func, &Parms);

	if (DataTable != nullptr)
		*DataTable = std::move(Parms.DataTable);
}


// Function BP_Ai_Enemy.BP_Ai_Enemy_C.IsPossibleMove
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    IgnoreOutofScreen                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IgnoreRestrictAttackOther                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPossible                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Ai_Enemy_C::IsPossibleMove(bool IgnoreOutofScreen, bool IgnoreRestrictAttackOther, bool* bPossible) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Ai_Enemy_C", "IsPossibleMove");

	Params::BP_Ai_Enemy_C_IsPossibleMove Parms{};

	Parms.IgnoreOutofScreen = IgnoreOutofScreen;
	Parms.IgnoreRestrictAttackOther = IgnoreRestrictAttackOther;

	UObject::ProcessEvent(Func, &Parms);

	if (bPossible != nullptr)
		*bPossible = Parms.bPossible;
}

}

