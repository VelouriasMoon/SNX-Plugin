#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PlayerAIComponent

#include "Basic.hpp"

#include "EPlayerAIBattleThinkType_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "BattlePrototype_structs.hpp"
#include "BattlePrototype_classes.hpp"
#include "Engine_structs.hpp"
#include "EPlayerAIMoveMode_structs.hpp"
#include "EPlayerAIThinkTableType_structs.hpp"
#include "EPlayerAIBattleThinkParam_structs.hpp"
#include "SNpcSelfRecoveryData_structs.hpp"
#include "EPlayerAIBattleThinkTransition_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_PlayerAIComponent.BP_PlayerAIComponent_C
// 0x02D8 (0x0698 - 0x03C0)
class UBP_PlayerAIComponent_C final : public UPlayerAIBaseComponent
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x03C0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	EPlayerAIMoveMode                             MoveMode_0;                                        // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_6847[0x7];                                     // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSBattlePlayer_C*                      OwnerPlayer;                                       // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ARSBattlePlayer_C*                      ControlPlayer;                                     // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bLeftPos_0;                                        // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6848[0x3];                                     // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ControlPlayerDist_0;                               // 0x03E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ARSCharacterBase*                       BattleTargetActor_0;                               // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerAITargetSearchModeCPP                  TargetSearchMode;                                  // 0x03F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_6849[0x3];                                     // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             UpdateTargetTimer_0;                               // 0x03FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bUpdateBattleTarget_0;                             // 0x0408(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_684A[0x3];                                     // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LeftStick_0;                                       // 0x040C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDodgeAble_0;                                      // 0x0414(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_684B[0x3];                                     // 0x0415(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       bEnableInputStick_0;                               // 0x0418(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	EPlayerAIBattleThinkType                      CurrentBattleThink_0;                              // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_684C[0x7];                                     // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ThinkTable_Free;                                   // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bAttackHit_0;                                      // 0x0478(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_684D[0x3];                                     // 0x0479(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BattleTargetDist_0;                                // 0x047C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bBattleModeFlag_0;                                 // 0x0488(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_684E[0x3];                                     // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MOVE_AIM_CIRRCLE_SPEED_old;                        // 0x048C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RotateCircleAngle;                                 // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bCircleDirClockwise_0;                             // 0x0494(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_684F[0x3];                                     // 0x0495(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveCircleSpeed_0;                                 // 0x0498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerAIBattleThinkParam                     CurrentBattleThinkParam_0;                         // 0x049C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDodgeAttack_0;                                    // 0x049D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6850[0x2];                                     // 0x049E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             DodgeIntervalTimer_0;                              // 0x04A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	struct FVector                                JumpDestination_0;                                 // 0x04AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         OrderJumpNum_0;                                    // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bForceUpdateTarget_0;                              // 0x04BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6851[0x3];                                     // 0x04BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AttackCount_0;                                     // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CONFUSION_FRIEND_PRIORITY_OFFSET_old;              // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ThinkDistance_0;                                   // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bUseItemThink_0;                                   // 0x04CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EConsumeItemID                                UseItemID_0;                                       // 0x04CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_6852[0x2];                                     // 0x04CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerAIBattleThinkType>              StealthThinkTypeList;                              // 0x04D0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<int32>                                 StealthThinkRateList_0;                            // 0x04E0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bEventMove_0;                                      // 0x04F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6853[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        EventMovePosList_0;                                // 0x04F8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<float>                                 EventMoveRadiusList_0;                             // 0x0508(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         EventMoveWalkScale_0;                              // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerAIOrder                                Order_0;                                           // 0x051C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_6854[0x3];                                     // 0x051D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ThinkTable_BF;                                     // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             ThinkTable_BFEnd;                                  // 0x0528(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             ThinkTable_Strong;                                 // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             ThinkTable_Caution;                                // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             ThinkTable_Escape;                                 // 0x0540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MOVE_CIRCLE_SPEED_FAR_old;                         // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bSelfRecoveryFlag_0;                               // 0x054C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bAssistItem_0;                                     // 0x054D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6855[0x2];                                     // 0x054E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelfRecoveryNum_0;                                 // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerAIBattleThinkType                      ReserveThinkType_0;                                // 0x0554(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerAIBattleThinkParam                     ReserveThinkParam_0;                               // 0x0555(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bReserveNextThink_0;                               // 0x0556(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6856[0x1];                                     // 0x0557(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoAttackTime_0;                                    // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bOwnerENPC_0;                                      // 0x055C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6857[0x3];                                     // 0x055D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CommonBranch;                                      // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_6858[0x4];                                     // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           EvaluateLocationTimerHandle_0;                     // 0x0568(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          bDebugDrawLocationEvaluate_0;                      // 0x0570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bBeginEvaluateLocation_0;                          // 0x0571(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6859[0x2];                                     // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentGoalBaseLocation_0;                         // 0x0574(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_PlayerAiGoalActor_C*                BPMoveGoalActor;                                   // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CurrentGoalArmLength_0;                            // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CurrentGoalYaw_0;                                  // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bFirstEvaluate_0;                                  // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_685A[0x3];                                     // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PrevThinkLastActorForward_0;                       // 0x0594(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bCircleNear_0;                                     // 0x05A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_685B[0x3];                                     // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             NearCircleMoveTimer_0;                             // 0x05A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	float                                         NearCircleMoveNearDist_0;                          // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         NearCircleMoveFarDist_0;                           // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                BattleDodgeDir_0;                                  // 0x05B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_685C[0x4];                                     // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             TargetEvaluateTable;                               // 0x05C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FPlayerAIEvaluateTargetParameter> TargetEvaluateTableData;                           // 0x05D0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bResetBehaviorTree_0;                              // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_685D[0x3];                                     // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialTargetLength_0;                             // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   ClaimantNameEventMove_0;                           // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BattleTargetAngle_0;                               // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDodgeRangeAttack_0;                               // 0x05F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_685E[0x3];                                     // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DodgeRangeAttackDir_0;                             // 0x05F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                JumpDir_0;                                         // 0x0604(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bMoveStickBack_0;                                  // 0x0610(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	ECharacterHitPriority                         StoreCharacterHitPriority_0;                       // 0x0611(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bStoreCharacterHitPriority_0;                      // 0x0612(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bEventMoveAfterWait_0;                             // 0x0613(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	float                                         DodgeIntervalTime_0;                               // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEventWait_0;                                      // 0x0618(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          OpenBrainField;                                    // 0x0619(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EPlayerAIThinkTableType                       CurrentThinkTableType_0;                           // 0x061A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableInterruptAction;                            // 0x061B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_685F[0x4];                                     // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ThinkTable_Drive;                                  // 0x0620(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FSNpcSelfRecoveryData>          SelfRecoveryDataCommon;                            // 0x0628(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<struct FSNpcSelfRecoveryData>          SelfRecoveryDataWary;                              // 0x0638(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bFinishMetamorphosis_0;                            // 0x0648(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6860[0x3];                                     // 0x0649(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ThinkPhaseTransition_0;                            // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDisableTargetChangeResetThink_0;                  // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6861[0x7];                                     // 0x0651(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ThinkTable_Unique00;                               // 0x0658(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FSNpcSelfRecoveryData>          SelfRecoveryDataLimit;                             // 0x0660(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bInvalidKeepOut_0;                                 // 0x0670(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_6862[0x7];                                     // 0x0671(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ThinkTable_Unique01;                               // 0x0678(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             ThinkTable_Unique02;                               // 0x0680(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             PlayerAIParameterTable;                            // 0x0688(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bBattleActionStartFlag_0;                          // 0x0690(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bReserveBehaviorTreeRun;                           // 0x0691(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bRunBehaviorTree;                                  // 0x0692(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bMetamorphosisCharacter;                           // 0x0693(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bStartLastAttack;                                  // 0x0694(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)

public:
	void ExecuteUbergraph_BP_PlayerAIComponent(int32 EntryPoint);
	void OnCheckBattleActionStartTick(float DeltaSeconds);
	void UnbindCheckBattleActionStart();
	void BindCheckBattleActionStart();
	void OnUpdateAI();
	void OnInitializeAI();
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void ReceiveBeginPlay();
	void RegisterLocationEvalueateTimerEvent();
	void EndEvaluateLocation();
	void BeginEvaluateLocation();
	void Update();
	void UpdateMovePos();
	void Initialize();
	void SetMoveMode(EPlayerAIMoveModeCPP ModeCPP);
	void Update_Data();
	void Update_Battle_Target_Actor();
	void SetBattleTarget(class ARSCharacterBase* TargetActor);
	void SetBattleMode(bool bBattle);
	void UpdateMovePos_ApproachTarget();
	void PreUpdate();
	void MainUpdate();
	void PostUpdate();
	void UpdateDodge();
	void UpdateDodge_Battle();
	void UpdateDodge_FollowPlayer();
	void CalcStickDir(struct FVector2D* Stick);
	void EnableStickInput(class FName ClaimantName);
	void DisableStickInput(class FName ClaimantName);
	void OnAttackHit();
	void NextBattleThink();
	void ResetBattleThink();
	void Set_Battle_Think(EPlayerAIBattleThinkType Action, EPlayerAIBattleThinkParam Param);
	void Set_Move_Mode_From_Think(EPlayerAIBattleThinkTypeCPP ThinkCPP);
	void DebugUpdate();
	void GetAttackInputKind(ERSAttackInputKind* AttackKind);
	void CalcStickDir_BattleDodge(struct FVector* Dir);
	void UpdateMovePos_Circle();
	void UpdateChainAttack();
	void JumpOrder(const struct FVector& Destination);
	void OnMovementCollisionLand();
	void OnJump();
	void InitializeParam();
	void NotifyForceWarp();
	void NotifyAttackStart();
	void Request_Use_Item(EConsumeItemID Item_id_in, bool bAssist);
	void IsUseItemThink(bool* Return);
	void SetupUseItem();
	void IsAttackThink(EPlayerAIBattleThinkType Think_type_in, bool* Return);
	void GetStealthThink(EPlayerAIBattleThinkType* Return);
	void SetEventMove(TArray<struct FVector>& Pos_list_in, TArray<float>& Radius_list_in, bool bWalk, bool bAfterWait, float MaxMoveTime);
	void IsEventMove(bool* Result);
	void GetEventMovePosActor(class AActor** Pos_actor, float* Accept_Radius);
	void CheckEventMovePos(bool Check_distance, bool* Goal);
	void IsEventMoveEnd(bool* Result);
	void UpdateEventMove();
	void GetEventMoveLeftStickX(float* Value);
	void GetEventMoveLeftStickY(float* Value);
	void SetTargetSearchMode(EPlayerAITargetSearchModeCPP Param_TargetSearchMode);
	void SetOrder(EPlayerAIOrder Param_Order);
	void SearchTarget(TArray<class ARSCharacterBase*>& TargetList, class ARSCharacterBase** Target);
	void CalcThinkTransitionProbability(int32 Probability, EPlayerAIBattleThinkType Action, int32* Result);
	void CheckSelfRecovery();
	void Cancel_Use_Item();
	void DecreaseSelfRecoveryNum();
	void UpdateCounter();
	void ReserveNextThink(EPlayerAIBattleThinkType ThinkType, EPlayerAIBattleThinkParam Param);
	void RegisterEvaluateLocation();
	void SetMoveLocation(const struct FVector& Location, float ArmLength, float Yaw);
	void SetThinkKeepOut();
	void UpdateMovePos_FollowPlayer();
	void OnUpdateUpdateEvaluateLocation();
	void CheckGoalLocationKeepOut();
	void CheckInAttackArea(const struct FVector& CheckLocation, bool* bin);
	void UpdateBattleDodgeDir();
	void CalcTargetEvaluate(class ARSCharacterBase* EvaluateTarget, float* EvaluateValue);
	void Calc_Distance_Target_Evaluate(const struct FVector& TargetLocation, float* EvaluateValue);
	void NotifyResetBehaviorTree();
	void CheckMovePos(bool* bReset);
	void CheckPsychicObject(bool bCapture, bool bAttack, bool* bOK);
	void IsPsychicAble(bool* bEnable);
	void CheckMoveWall(EPlayerAIMoveWallCPP* Wall, struct FVector* Location);
	void SetMoveStickBack(bool bBack);
	void EndEventMove();
	void On_Event_Start();
	void IsPsychicComboThink(bool* bResult);
	void SetEventWait();
	void End_Event_Wait();
	void ChangeThinkTableType(EPlayerAIThinkTableType ThinkTableType, bool bResetThink);
	void ResetSelfRecoveryData();
	void SetFinishMetamorphosis(bool bFinish, bool* Dummy);
	void SetThinkPhaseTransition(int32 NewPhase, bool* Dummy);
	void SetDisableChangeTargetResetThink(bool InDisable);
	void SetInvalidKeepOut(bool IsInvalid);
	void RestartBattleAI(bool bInEvent, bool bInAvatar);
	void IsBattleActionStart(bool* bStart);
	void Update_Check_Battle_Action_Start(bool* bActionStart);
	void NotifyMoveBrainField(bool bToBrainField);
	void SetBattleThink_CPPType(EPlayerAIBattleThinkTypeCPP ActionCPP, EPlayerAIBattleThinkParamCPP ParamCPP);
	void ReserveNextThink_CPPType(EPlayerAIBattleThinkTypeCPP ThinkTypeCPP, EPlayerAIBattleThinkParamCPP ParamCPP);
	void GetStealthThink_CPPType(EPlayerAIBattleThinkTypeCPP* Return);
	bool BeginEvaluateLocation_CallFromCPP();
	bool BindCheckBattleActionStart_CallFromCPP();
	bool UnbindCheckBattleActionStart_CallFromCPP();
	bool RestartBattleAI_CallFromCPP(bool bInEvent);
	bool CheckInAttackArea_CallFromCPP(const struct FVector& CheckLocation);
	bool EndEvaluateLocation_CallFromCPP();
	bool CheckBattleThinkTransition_CallFromCPP(EPlayerAIBattleThinkTransitionCPP Transition);
	bool DebugUpdate_CallFromCPP();
	bool NextBattleThink_CallFromCPP();
	bool SetBattleThink_CallFromCPP(EPlayerAIBattleThinkTypeCPP Action, EPlayerAIBattleThinkParamCPP Param);
	bool UpdateBattleDodgeDir_CallFromCPP();
	void UpdateDodgeBattle_Enpc_BPImplement(bool* bOK, bool* OutDodgeNormalAttack, bool* OutDodgeRangeAttack, bool* OutForceDodge);
	bool PreUpdateCPP_RangeAttack_BPImplement();
	bool SetupUseItem_CallFromCPP();
	bool CheckSelfRecoveryCallFromCPP();
	void RunBehaviorTree();
	float CalcTargetEvaluate_CallFromCPP(class ARSCharacterBase* EvaluateTarget);
	bool CheckSelfRecovery_CallFromCPP();
	TArray<EObjectTypeQuery> GetCollisionObjectTypesForGroundHit_CallFromCPP();

	void GetMoveMode(EPlayerAIMoveMode* MoveMode) const;
	void IsUpdate(bool* bUpdate) const;
	void GetControlPlayerDist(struct FVector* Dist) const;
	void GetMoveMode_CPPType(EPlayerAIMoveModeCPP* MoveMode) const;
	void GetMovePosActor(class AActor** MovePosActor) const;
	void GetBattleTargetActor(class AActor** Target) const;
	void IsAttackAble(bool* bEnable) const;
	void IsDodgeAble(bool* bEnable) const;
	void IsEnableStickInput(bool* bEnable) const;
	void CheckBattleThinkTransition(EPlayerAIBattleThinkTransition Transition, bool* bOK) const;
	void IsRangeNear(const struct FVector& Dist, bool* bResult) const;
	void IsRangeMiddle(const struct FVector& Dist, bool* bResult) const;
	void IsRangeFar(const struct FVector& Dist, bool* bResult) const;
	void GetCurrentThinkTable(class UDataTable** Table) const;
	void CalcStickDir_BattleAttack(struct FVector* Dir) const;
	void IsBattleThink(EPlayerAIBattleThinkType Type, bool* bResult) const;
	void GetCurrentBattleThinkParam(EPlayerAIBattleThinkParam* Param) const;
	void IsJumpAble(bool* bEnable) const;
	void GetAttackCount(int32* Count) const;
	void IsRangeTooFar(const struct FVector& Dist, bool* bResutlt) const;
	void IsSelfRecovery(bool* bRecovery) const;
	void GetUseItemID(EConsumeItemID* ItemId) const;
	void GetCurrentBattleThink(EPlayerAIBattleThinkType* NewParam) const;
	void GetTargetEvaluateData(struct FPlayerAIEvaluateTargetParameter* Data) const;
	void IsResetBehaviorTree(bool* Param_bResetBehaviorTree) const;
	void SearchPsychicObject(bool* bFound) const;
	void GetCurrentBattleThink_CPPType(EPlayerAIBattleThinkTypeCPP* NewParam) const;
	void IsWaitBattleStart(bool* bWait) const;
	void Check_Under_Siege(bool* bSiege) const;
	void IsEventWait(bool* bWait) const;
	void IsFinishMetamorphosis(bool* bFinish) const;
	void GetThinkPhaseTransition(int32* CurPhase) const;
	void Get_Order(EPlayerAIOrder* Param_Order) const;
	void CheckNpcRevive(float InDistance, bool* bRevive) const;
	void GetCurrentBattleThinkParam_CPPType(EPlayerAIBattleThinkParamCPP* Param) const;
	class UDataTable* GetCurrentThinkTable_CallFromCPP() const;
	void GetTargetEvaluateData_CallFromCPP(struct FPlayerAIEvaluateTargetParameter* OutParam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_PlayerAIComponent_C">();
	}
	static class UBP_PlayerAIComponent_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_PlayerAIComponent_C>();
	}
};
static_assert(alignof(UBP_PlayerAIComponent_C) == 0x000008, "Wrong alignment on UBP_PlayerAIComponent_C");
static_assert(sizeof(UBP_PlayerAIComponent_C) == 0x000698, "Wrong size on UBP_PlayerAIComponent_C");
static_assert(offsetof(UBP_PlayerAIComponent_C, UberGraphFrame) == 0x0003C0, "Member 'UBP_PlayerAIComponent_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, MoveMode_0) == 0x0003C8, "Member 'UBP_PlayerAIComponent_C::MoveMode_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, OwnerPlayer) == 0x0003D0, "Member 'UBP_PlayerAIComponent_C::OwnerPlayer' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ControlPlayer) == 0x0003D8, "Member 'UBP_PlayerAIComponent_C::ControlPlayer' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bLeftPos_0) == 0x0003E0, "Member 'UBP_PlayerAIComponent_C::bLeftPos_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ControlPlayerDist_0) == 0x0003E4, "Member 'UBP_PlayerAIComponent_C::ControlPlayerDist_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, BattleTargetActor_0) == 0x0003F0, "Member 'UBP_PlayerAIComponent_C::BattleTargetActor_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, TargetSearchMode) == 0x0003F8, "Member 'UBP_PlayerAIComponent_C::TargetSearchMode' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, UpdateTargetTimer_0) == 0x0003FC, "Member 'UBP_PlayerAIComponent_C::UpdateTargetTimer_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bUpdateBattleTarget_0) == 0x000408, "Member 'UBP_PlayerAIComponent_C::bUpdateBattleTarget_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, LeftStick_0) == 0x00040C, "Member 'UBP_PlayerAIComponent_C::LeftStick_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bDodgeAble_0) == 0x000414, "Member 'UBP_PlayerAIComponent_C::bDodgeAble_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bEnableInputStick_0) == 0x000418, "Member 'UBP_PlayerAIComponent_C::bEnableInputStick_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, CurrentBattleThink_0) == 0x000468, "Member 'UBP_PlayerAIComponent_C::CurrentBattleThink_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_Free) == 0x000470, "Member 'UBP_PlayerAIComponent_C::ThinkTable_Free' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bAttackHit_0) == 0x000478, "Member 'UBP_PlayerAIComponent_C::bAttackHit_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, BattleTargetDist_0) == 0x00047C, "Member 'UBP_PlayerAIComponent_C::BattleTargetDist_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bBattleModeFlag_0) == 0x000488, "Member 'UBP_PlayerAIComponent_C::bBattleModeFlag_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, MOVE_AIM_CIRRCLE_SPEED_old) == 0x00048C, "Member 'UBP_PlayerAIComponent_C::MOVE_AIM_CIRRCLE_SPEED_old' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, RotateCircleAngle) == 0x000490, "Member 'UBP_PlayerAIComponent_C::RotateCircleAngle' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bCircleDirClockwise_0) == 0x000494, "Member 'UBP_PlayerAIComponent_C::bCircleDirClockwise_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, MoveCircleSpeed_0) == 0x000498, "Member 'UBP_PlayerAIComponent_C::MoveCircleSpeed_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, CurrentBattleThinkParam_0) == 0x00049C, "Member 'UBP_PlayerAIComponent_C::CurrentBattleThinkParam_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bDodgeAttack_0) == 0x00049D, "Member 'UBP_PlayerAIComponent_C::bDodgeAttack_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, DodgeIntervalTimer_0) == 0x0004A0, "Member 'UBP_PlayerAIComponent_C::DodgeIntervalTimer_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, JumpDestination_0) == 0x0004AC, "Member 'UBP_PlayerAIComponent_C::JumpDestination_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, OrderJumpNum_0) == 0x0004B8, "Member 'UBP_PlayerAIComponent_C::OrderJumpNum_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bForceUpdateTarget_0) == 0x0004BC, "Member 'UBP_PlayerAIComponent_C::bForceUpdateTarget_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, AttackCount_0) == 0x0004C0, "Member 'UBP_PlayerAIComponent_C::AttackCount_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, CONFUSION_FRIEND_PRIORITY_OFFSET_old) == 0x0004C4, "Member 'UBP_PlayerAIComponent_C::CONFUSION_FRIEND_PRIORITY_OFFSET_old' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkDistance_0) == 0x0004C8, "Member 'UBP_PlayerAIComponent_C::ThinkDistance_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bUseItemThink_0) == 0x0004CC, "Member 'UBP_PlayerAIComponent_C::bUseItemThink_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, UseItemID_0) == 0x0004CD, "Member 'UBP_PlayerAIComponent_C::UseItemID_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, StealthThinkTypeList) == 0x0004D0, "Member 'UBP_PlayerAIComponent_C::StealthThinkTypeList' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, StealthThinkRateList_0) == 0x0004E0, "Member 'UBP_PlayerAIComponent_C::StealthThinkRateList_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bEventMove_0) == 0x0004F0, "Member 'UBP_PlayerAIComponent_C::bEventMove_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, EventMovePosList_0) == 0x0004F8, "Member 'UBP_PlayerAIComponent_C::EventMovePosList_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, EventMoveRadiusList_0) == 0x000508, "Member 'UBP_PlayerAIComponent_C::EventMoveRadiusList_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, EventMoveWalkScale_0) == 0x000518, "Member 'UBP_PlayerAIComponent_C::EventMoveWalkScale_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, Order_0) == 0x00051C, "Member 'UBP_PlayerAIComponent_C::Order_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_BF) == 0x000520, "Member 'UBP_PlayerAIComponent_C::ThinkTable_BF' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_BFEnd) == 0x000528, "Member 'UBP_PlayerAIComponent_C::ThinkTable_BFEnd' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_Strong) == 0x000530, "Member 'UBP_PlayerAIComponent_C::ThinkTable_Strong' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_Caution) == 0x000538, "Member 'UBP_PlayerAIComponent_C::ThinkTable_Caution' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_Escape) == 0x000540, "Member 'UBP_PlayerAIComponent_C::ThinkTable_Escape' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, MOVE_CIRCLE_SPEED_FAR_old) == 0x000548, "Member 'UBP_PlayerAIComponent_C::MOVE_CIRCLE_SPEED_FAR_old' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bSelfRecoveryFlag_0) == 0x00054C, "Member 'UBP_PlayerAIComponent_C::bSelfRecoveryFlag_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bAssistItem_0) == 0x00054D, "Member 'UBP_PlayerAIComponent_C::bAssistItem_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, SelfRecoveryNum_0) == 0x000550, "Member 'UBP_PlayerAIComponent_C::SelfRecoveryNum_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ReserveThinkType_0) == 0x000554, "Member 'UBP_PlayerAIComponent_C::ReserveThinkType_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ReserveThinkParam_0) == 0x000555, "Member 'UBP_PlayerAIComponent_C::ReserveThinkParam_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bReserveNextThink_0) == 0x000556, "Member 'UBP_PlayerAIComponent_C::bReserveNextThink_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, NoAttackTime_0) == 0x000558, "Member 'UBP_PlayerAIComponent_C::NoAttackTime_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bOwnerENPC_0) == 0x00055C, "Member 'UBP_PlayerAIComponent_C::bOwnerENPC_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, CommonBranch) == 0x000560, "Member 'UBP_PlayerAIComponent_C::CommonBranch' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, EvaluateLocationTimerHandle_0) == 0x000568, "Member 'UBP_PlayerAIComponent_C::EvaluateLocationTimerHandle_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bDebugDrawLocationEvaluate_0) == 0x000570, "Member 'UBP_PlayerAIComponent_C::bDebugDrawLocationEvaluate_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bBeginEvaluateLocation_0) == 0x000571, "Member 'UBP_PlayerAIComponent_C::bBeginEvaluateLocation_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, CurrentGoalBaseLocation_0) == 0x000574, "Member 'UBP_PlayerAIComponent_C::CurrentGoalBaseLocation_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, BPMoveGoalActor) == 0x000580, "Member 'UBP_PlayerAIComponent_C::BPMoveGoalActor' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, CurrentGoalArmLength_0) == 0x000588, "Member 'UBP_PlayerAIComponent_C::CurrentGoalArmLength_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, CurrentGoalYaw_0) == 0x00058C, "Member 'UBP_PlayerAIComponent_C::CurrentGoalYaw_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bFirstEvaluate_0) == 0x000590, "Member 'UBP_PlayerAIComponent_C::bFirstEvaluate_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, PrevThinkLastActorForward_0) == 0x000594, "Member 'UBP_PlayerAIComponent_C::PrevThinkLastActorForward_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bCircleNear_0) == 0x0005A0, "Member 'UBP_PlayerAIComponent_C::bCircleNear_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, NearCircleMoveTimer_0) == 0x0005A4, "Member 'UBP_PlayerAIComponent_C::NearCircleMoveTimer_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, NearCircleMoveNearDist_0) == 0x0005B0, "Member 'UBP_PlayerAIComponent_C::NearCircleMoveNearDist_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, NearCircleMoveFarDist_0) == 0x0005B4, "Member 'UBP_PlayerAIComponent_C::NearCircleMoveFarDist_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, BattleDodgeDir_0) == 0x0005B8, "Member 'UBP_PlayerAIComponent_C::BattleDodgeDir_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, TargetEvaluateTable) == 0x0005C8, "Member 'UBP_PlayerAIComponent_C::TargetEvaluateTable' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, TargetEvaluateTableData) == 0x0005D0, "Member 'UBP_PlayerAIComponent_C::TargetEvaluateTableData' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bResetBehaviorTree_0) == 0x0005E0, "Member 'UBP_PlayerAIComponent_C::bResetBehaviorTree_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, InitialTargetLength_0) == 0x0005E4, "Member 'UBP_PlayerAIComponent_C::InitialTargetLength_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ClaimantNameEventMove_0) == 0x0005E8, "Member 'UBP_PlayerAIComponent_C::ClaimantNameEventMove_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, BattleTargetAngle_0) == 0x0005F0, "Member 'UBP_PlayerAIComponent_C::BattleTargetAngle_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bDodgeRangeAttack_0) == 0x0005F4, "Member 'UBP_PlayerAIComponent_C::bDodgeRangeAttack_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, DodgeRangeAttackDir_0) == 0x0005F8, "Member 'UBP_PlayerAIComponent_C::DodgeRangeAttackDir_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, JumpDir_0) == 0x000604, "Member 'UBP_PlayerAIComponent_C::JumpDir_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bMoveStickBack_0) == 0x000610, "Member 'UBP_PlayerAIComponent_C::bMoveStickBack_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, StoreCharacterHitPriority_0) == 0x000611, "Member 'UBP_PlayerAIComponent_C::StoreCharacterHitPriority_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bStoreCharacterHitPriority_0) == 0x000612, "Member 'UBP_PlayerAIComponent_C::bStoreCharacterHitPriority_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bEventMoveAfterWait_0) == 0x000613, "Member 'UBP_PlayerAIComponent_C::bEventMoveAfterWait_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, DodgeIntervalTime_0) == 0x000614, "Member 'UBP_PlayerAIComponent_C::DodgeIntervalTime_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bEventWait_0) == 0x000618, "Member 'UBP_PlayerAIComponent_C::bEventWait_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, OpenBrainField) == 0x000619, "Member 'UBP_PlayerAIComponent_C::OpenBrainField' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, CurrentThinkTableType_0) == 0x00061A, "Member 'UBP_PlayerAIComponent_C::CurrentThinkTableType_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bEnableInterruptAction) == 0x00061B, "Member 'UBP_PlayerAIComponent_C::bEnableInterruptAction' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_Drive) == 0x000620, "Member 'UBP_PlayerAIComponent_C::ThinkTable_Drive' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, SelfRecoveryDataCommon) == 0x000628, "Member 'UBP_PlayerAIComponent_C::SelfRecoveryDataCommon' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, SelfRecoveryDataWary) == 0x000638, "Member 'UBP_PlayerAIComponent_C::SelfRecoveryDataWary' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bFinishMetamorphosis_0) == 0x000648, "Member 'UBP_PlayerAIComponent_C::bFinishMetamorphosis_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkPhaseTransition_0) == 0x00064C, "Member 'UBP_PlayerAIComponent_C::ThinkPhaseTransition_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bDisableTargetChangeResetThink_0) == 0x000650, "Member 'UBP_PlayerAIComponent_C::bDisableTargetChangeResetThink_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_Unique00) == 0x000658, "Member 'UBP_PlayerAIComponent_C::ThinkTable_Unique00' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, SelfRecoveryDataLimit) == 0x000660, "Member 'UBP_PlayerAIComponent_C::SelfRecoveryDataLimit' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bInvalidKeepOut_0) == 0x000670, "Member 'UBP_PlayerAIComponent_C::bInvalidKeepOut_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_Unique01) == 0x000678, "Member 'UBP_PlayerAIComponent_C::ThinkTable_Unique01' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, ThinkTable_Unique02) == 0x000680, "Member 'UBP_PlayerAIComponent_C::ThinkTable_Unique02' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, PlayerAIParameterTable) == 0x000688, "Member 'UBP_PlayerAIComponent_C::PlayerAIParameterTable' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bBattleActionStartFlag_0) == 0x000690, "Member 'UBP_PlayerAIComponent_C::bBattleActionStartFlag_0' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bReserveBehaviorTreeRun) == 0x000691, "Member 'UBP_PlayerAIComponent_C::bReserveBehaviorTreeRun' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bRunBehaviorTree) == 0x000692, "Member 'UBP_PlayerAIComponent_C::bRunBehaviorTree' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bMetamorphosisCharacter) == 0x000693, "Member 'UBP_PlayerAIComponent_C::bMetamorphosisCharacter' has a wrong offset!");
static_assert(offsetof(UBP_PlayerAIComponent_C, bStartLastAttack) == 0x000694, "Member 'UBP_PlayerAIComponent_C::bStartLastAttack' has a wrong offset!");

}

