#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_LevelManager

#include "Basic.hpp"

#include "BattlePrototype_structs.hpp"
#include "BattlePrototype_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "S_LoadedLevelInfo_structs.hpp"
#include "Engine_structs.hpp"
#include "E_SceneType_structs.hpp"
#include "S_LevelManagerCommand_structs.hpp"
#include "S_AreaInfo_structs.hpp"
#include "E_LevelManagerStatus_structs.hpp"
#include "E_LevelLoadStatus_structs.hpp"
#include "E_LevelCommandStatus_structs.hpp"
#include "E_LevelManagerCommand_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_LevelManager.BP_LevelManager_C
// 0x02E8 (0x0538 - 0x0250)
class ABP_LevelManager_C final : public ALevelManager
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0250(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UBP_LoadCommandComponent_C*             LoadCommandComponent;                              // 0x0258(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_LevelCommandComponent_C*            LevelCommandComponent;                             // 0x0260(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0268(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	int32                                         MaxInfoAreaNum;                                    // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   CurrentAreaName;                                   // 0x0274(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_LevelManagerStatus                          LevelManagerStatus;                                // 0x027C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_CF6[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OldAreaName;                                       // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<class FName, struct FS_AreaInfo>         LoadedAreaInfos;                                   // 0x0288(0x0050)(Edit, BlueprintVisible)
	TArray<struct FS_LevelManagerCommand>         CommandQueue;                                      // 0x02D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	struct FS_LevelManagerCommand                 CurrentCommand;                                    // 0x02E8(0x0048)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<struct FPrimaryAssetType>              LoadedPacks;                                       // 0x0330(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             EventFinishWaitAreaVisibleDispatcher;              // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             EventFinishWaitAreaUnvisibleDispatcher;            // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<TSoftObjectPtr<class UObject>>         LoadedLevels;                                      // 0x0360(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<struct FS_LoadedLevelInfo>             LoadedLevelInfo;                                   // 0x0370(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<struct FS_LoadedLevelInfo>             OldLoadedLevelInfo;                                // 0x0380(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TMap<class FName, class FName>                LoadedCameraType;                                  // 0x0390(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	FMulticastInlineDelegateProperty_             EventFinishLoadAssetAsync;                         // 0x03E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMap<class FName, struct FRSStreamingSettings> StreamingSettingsMap;                              // 0x03F0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	class FName                                   CurrentStreamingSettingsName;                      // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bTextureStreaming;                                 // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_CF7[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FS_AreaInfo>         LocalAreaInfo;                                     // 0x0450(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	FMulticastInlineDelegateProperty_             OnStartCheckLevelVisible;                          // 0x04A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnEndCheckLevelVisible;                            // 0x04B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         DebugSyncUnloadIndex;                              // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_CF8[0x4];                                      // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FS_AreaInfo>         AreaSettingsCache;                                 // 0x04C8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          IsAreaSettingsCacheDirty;                          // 0x0518(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EPlayerCameraPreset                           CurrentCameraPreset;                               // 0x0519(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsNoAreaSelectVariationFunction;                   // 0x051A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_CF9[0x5];                                      // 0x051B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FS_LoadedLevelInfo>             StoreSubQuestNpcLevelList;                         // 0x0520(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class FName                                   CurrentSimulatorLevelInfosName;                    // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void EventFinishWaitAreaVisibleDispatcher__DelegateSignature(class FName AreaName);
	void EventFinishWaitAreaUnvisibleDispatcher__DelegateSignature(class FName AreaName);
	void EventFinishLoadAssetAsync__DelegateSignature(TSoftObjectPtr<class UObject> LoadedAsset);
	void OnStartCheckLevelVisible__DelegateSignature(TSoftObjectPtr<class UObject> Level);
	void OnEndCheckLevelVisible__DelegateSignature(TSoftObjectPtr<class UObject> Level);
	void ExecuteUbergraph_BP_LevelManager(int32 EntryPoint);
	void CopyCurrentSimulatorLevelInfosName();
	void DelayBeginPlay();
	void SyncUnloadStreamLevels();
	void ExecLevelCommand(const struct FS_LevelManagerCommand& Command);
	void ReceiveTick(float DeltaSeconds);
	void ReceiveBeginPlay();
	void EventFinishLoadLevelDispatcher_Event_0(TSoftObjectPtr<class UObject> LevelName, class FName AreaName);
	void EventFinishUnloadAreaDispatcher_Event_0(class FName AreaName);
	void EventFinishUnloadLevelDispatcher_Event_0(TSoftObjectPtr<class UObject> LevelName, class FName AreaName);
	void BindEventFinishLoadArea();
	void BindOnEndCheckLevelVisible();
	void OnEndCheckLevelVisible_Event(TSoftObjectPtr<class UObject> Level);
	void OnStartCheckLevelVisible_Event(TSoftObjectPtr<class UObject> Level);
	void BindOnStartCheckLevelVisible();
	void EventInitBind();
	void CallbackSetAreaVisibleFinishedAndSetPlayer(class FName AreaName);
	void BindSetPlayerStartAfterFinishAreaVisible(const class FString& PortalName);
	void EventFinishUnloadPackDispatcher_Event_0(const struct FPrimaryAssetType& Pack);
	void EventFinishLoadPackDispatcher_Event_0(const struct FPrimaryAssetType& Pack);
	void EventFinishLoadAreaDispatcher_Event_0(class FName AreaName);
	void BindEventFinishUnloadPack();
	void BindEventFinishLoadPack();
	void BindEventFinishUnloadLevel();
	void BindEventFinishUnloadArea();
	void BindEventFinishLoadLevel();
	void RequestLoadAreaImmediateByAreaName(class FName AreaName, bool SetVisbleAfterLoad, bool SkipEnemyLevels, bool SkipEventLevels);
	void SetCurrentArea(class FName AreaName, bool* Result);
	void CleanLoadedAreaInfos();
	void GetCurrentLevelCommand(struct FS_LevelManagerCommand* Command, bool* IsFound);
	void AddLevelCommand(E_LevelManagerCommand Command, class FName ArgName, class FName ArgName2, bool Flag, TSoftObjectPtr<class UObject> Asset, bool Flag2, int32* CommandNum);
	void StartLevelCommand();
	void FinishLevelCommand(bool IsError);
	void GetAreaInfoFromDB(class FName AreaName, bool* IsFound, struct FS_AreaInfo* AreaInfo);
	void SetAreaVisibleFlag(bool Visible, class FName AreaName);
	void RequestSetAreaVisible(class FName AreaName, bool Async, bool Visible);
	void SetLevelsVisibleFlag(bool Visible, TArray<TSoftObjectPtr<class UObject>>& Levels);
	void FullPathToLevelName(class FName FullPath, class FName* LevelName);
	void IsAreaInLoadedAreaInfosWithCondition(class FName AreaName, bool* IsLoaded, bool* IsExist, struct FS_AreaInfo* AreaInfo);
	void RequestUnloadAreaAsync(class FName AreaName);
	void SetAreaInfoStatus(class FName AreaName, E_LevelLoadStatus Status, bool* Error, E_LevelLoadStatus* OldStatus);
	void UpdateCurrentLevelCommandStatus(E_LevelCommandStatus Status);
	void DebugPrintArealInfoMap();
	void RemoveLoadedAreaInfoForce(class FName AreaName);
	void RemoveLoadedAreaInfo(class FName AreaName);
	void GetNotCurrentAreaName(TArray<class FName>* AreaNames);
	void IsLevelsUnloaded(TArray<TSoftObjectPtr<class UObject>>& Levels, bool CheckRaw, bool* Unloaded);
	void IsLevelsLoaded(TArray<TSoftObjectPtr<class UObject>>& Levels, bool CheckRaw, bool* IsLoaded);
	void AddOrUpdateLoadedAreaInfo(class FName Param_Name, const struct FS_AreaInfo& AreaInfo);
	void RemoveRedundantLevelCommand(class FName LevelName);
	void RequestSetAreaOnlyVisibleAsync(class FName AreaName, bool Async);
	void GetNotCurrentLoadedAreaInfos(class FName AreaName, TArray<struct FS_AreaInfo>* Infos);
	void RequestWaitLoadArea(class FName AreaName, bool Async);
	void RequestWaitUnloadArea(class FName AreaName, class FName NextAreaName, bool Async);
	void UpdateLoadedAreaInfoStatus();
	void RequestChangeArea(class FName AreaName);
	void _RequestUnloadUnusedArea();
	void _RequestUnloadAllArea();
	void IsAreaLevelsLoadedByAreaName(class FName AreaName, bool RawCheck, bool* IsLoaded, bool* IsError, struct FS_AreaInfo* Area_Info);
	void DebugPrintStatus();
	void DebugPrintCommandQueue();
	void IsLevelInLoadedAreaInfos(TSoftObjectPtr<class UObject> Level, bool* IsExist);
	void IsLevelInLoadedAreaInfosWithExclude(TSoftObjectPtr<class UObject> Level, TArray<class FName>& ExcludeAreaName, bool* IsExist);
	void RegisterLevelToLoaded(TSoftObjectPtr<class UObject> Level, class FName AreaName, bool* IsAlreadyExists);
	void UnregisterLevelToLoaded(TSoftObjectPtr<class UObject> Level, class FName AreaName, bool* IsError);
	void RegisterPackToLoaded(const struct FPrimaryAssetType& Param_Name, bool* IsAlreadyExists);
	void UnregisterPackToLoaded(const struct FPrimaryAssetType& LevelName, bool* IsError);
	void IsAreaLevelsLoadedByInfo(class FName AreaName, bool RawCheck, bool* IsLoaded);
	void IsAreaLevelsUnloadedWithoutOtherAreaUsing(class FName AreaName, bool* IsUnloaded, bool* Error);
	void IsLevelInOtherLoadedArea(TSoftObjectPtr<class UObject> Level, class FName ExcludeAreaName, bool* Found);
	void __RequestSetAreaVisibleAsync(class FName AreaName, bool IsVisible);
	void SetAllLevelsVisible(bool Visible);
	void _SetAreaOnlyVisible(class FName AreaName);
	void GetSceneSystemLevels(E_SceneType Scene, TArray<TSoftObjectPtr<class UObject>>* Levels);
	void GetAreaSystemLevelNames(class FName AreaName, TArray<TSoftObjectPtr<class UObject>>* LevelNames);
	void __IsPackInOtherLoadedArea(const struct FPrimaryAssetType& PAT, class FName ExcludeAreaName, bool* Found);
	void _RequestUnloadUnsedSystemLevelAsync(class FName AreaName, bool SetVisbleAfterLoad);
	void GetUnusedSystemLevelName(class FName WillUnloadAreaName, bool* Found, TSoftObjectPtr<class UObject>* UnusedSystemLevel);
	void GetSystemLevel(E_SceneType SceneType, TSoftObjectPtr<class UObject>* SystemLevel, bool* Found);
	void IsAreaVisible(class FName AreaName, bool* AllVisible);
	void GetAllLevelInArea(class FName AreaName, TArray<TSoftObjectPtr<class UObject>>* Levels, struct FS_AreaInfo* AreaInfo, bool* Error);
	void IsAreaUnvisible(class FName AreaName, bool* AllUnvisible);
	void RequestWaitAreaVisible(class FName AreaName);
	void RequestWaitAreaUnvisible(class FName AreaName);
	void DebugPrintCommandInfo(struct FS_LevelManagerCommand& Command);
	void _RequestCancelLoadAreaAsync(class FName AreaName, bool SetVisbleAfterLoad);
	void _RequestLoadAssetPackAsync(class FName AssetPackName);
	void RequestLoadAssetAsync(TSoftObjectPtr<class UObject> Asset);
	void GetAllLevelInAreaWithoutSystem(class FName AreaName, TArray<TSoftObjectPtr<class UObject>>* Levels, bool* Error);
	void GetSceneSystemLevelsByArea(class FName AreaName, TArray<TSoftObjectPtr<class UObject>>* Levels);
	void ResetPlayerTransform();
	void RequestSetCallbackPlayerStartAfterAreaVisible(const class FString& PortalName);
	void UpdateLoadedLevels();
	void IsLevelInLoadedLevelInfo(TSoftObjectPtr<class UObject> Level, struct FS_LoadedLevelInfo* LevelInfoRef, bool* Exist);
	void RemoveLevelFromLevelInfo(TSoftObjectPtr<class UObject> Level);
	void GetAllAreaInfoLevels(class FName AdditionalArea, class FName RemoveArea, TArray<TSoftObjectPtr<class UObject>>* Levels);
	void GetUnusedLevelWhenUnloadArea(class FName UnloadAreaName, class FName NextAreaName, TArray<TSoftObjectPtr<class UObject>>* ShouldUnloadLevels);
	void SetStatToLoadedLevel(TSoftObjectPtr<class UObject> Level, E_LevelLoadStatus Status);
	void StartPlayerWithPortalName(const class FString& PortalName, TArray<class APlayerStart*>& Portals);
	void StartPlayerAtActor(class AActor* Portal);
	void IsLevelVisibleInLoadedLevelInfo(TSoftObjectPtr<class UObject> Level, bool* Visible, bool* Error);
	void SetLevelVisibleFlag(bool Visible, TSoftObjectPtr<class UObject> Levels);
	void RequestSetVisibleLevelsAndWait(TArray<TSoftObjectPtr<class UObject>>& Levels, class FName AreaName, bool Visible);
	void IsAreaReadyForStart(class FName AreaName, bool* IsReady);
	void RequestWaitAreaPreloadVisible(class FName AreaName);
	void RequestSetAreaPreloadOnlyVisible(class FName AreaName, bool Async);
	void GetPreloadLevelInArea(class FName AreaName, TArray<TSoftObjectPtr<class UObject>>* Levels, struct FS_AreaInfo* AreaInfo, bool* Error);
	void _IsAreaPreloadVisible(class FName AreaName, bool* AllVisible);
	void RequestUnloadDynamicLevel();
	void RequestSetAllLevelUnvisible(bool Visible);
	void DebugFilterLevels(TArray<TSoftObjectPtr<class UObject>>& Levels, TArray<TSoftObjectPtr<class UObject>>* FilteredLevels);
	void DebugPrintLoadInfo();
	void AreaNameToID_Internal(class FName AreaName, int32* LocationId, int32* AreaId, int32* VariationID);
	void RequestUnloadAssetAsync(TSoftObjectPtr<class UObject> Asset);
	void RequestSetAreaPreloadVisible(class FName AreaName, bool Async);
	void SetStreamSettings(class FName RowName);
	void SetStreamSettingsInGame();
	void SetStreamSettingsInLoading();
	void InitStreamingSettings();
	void TweakStreamSettings(class FName Param_Name, const struct FRSStreamingSettings& Settings);
	void TweakStreamSettingsInLoading(const struct FRSStreamingSettings& Settings);
	void GetStreamSettings(class FName Param_Name, struct FRSStreamingSettings* Settings);
	void SetTextureStreaming(bool On);
	void MakeAreaInfo(class FName AreaName, struct FS_AreaInfo* AreaInfo);
	void GetLevelsFromBGAreaInfo(TArray<class FName>& BGAreaInfoNames, TArray<TSoftObjectPtr<class UObject>>* PreloadLevels, TArray<TSoftObjectPtr<class UObject>>* Levels, TArray<TSoftObjectPtr<class UObject>>* LbaAndPortalLevels);
	void GetLevelsFromEnemyAreaInfo(TArray<class FName>& InfoNames, TArray<TSoftObjectPtr<class UObject>>* Levels);
	void GetLevelsFromEventAreaInfo(TArray<class FName>& InfoNames, TArray<TSoftObjectPtr<class UObject>>* Levels);
	void GetLevelsFromNObjAreaInfo(TArray<class FName>& InfoNames, TArray<TSoftObjectPtr<class UObject>>* Levels);
	void GetLevelsFromNPCAreaInfo(TArray<class FName>& InfoNames, TArray<TSoftObjectPtr<class UObject>>* Levels);
	void GetAreaInfo(class FName AreaName, bool SkipEnemyLevel, bool SkipEventLevel, struct FS_AreaInfo* AreaInfo, bool* Found);
	void GetAreaInfoNames(TArray<class FName>* Names);
	void InitAreaInfo();
	void IsAreaLevelsLoaded(int32 LocationId, int32 AreaId, int32 VariationID, bool RawCheck, bool* IsLoaded, bool* IsError, struct FS_AreaInfo* Area_Info);
	void GetAreaInfoAfterTweak(class FName AreaName, bool SkipEnemyLevel, bool SkipEventLevel, struct FS_AreaInfo* AreaInfo, bool* Found);
	void TweakAreaSettings(const struct FS_AreaSettingsInfo& Settings, struct FS_AreaSettingsInfo* OutSettings, TArray<bool>* ConditionResults);
	void CheckTweakAllConditions(TArray<struct FS_AreaInfoTweakCondition>& Conditions, bool* AllOk);
	void CheckTweakCondition(struct FS_AreaInfoTweakCondition& Condition, bool* Result);
	void ExecAreaInfoTweaks(const struct FS_AreaSettingsInfo& Settings, TArray<struct FS_AreaInfoTweakExec>& TweakExecs, struct FS_AreaSettingsInfo* OutSettings);
	void ExecAreaInfoTweakAdd(const struct FS_AreaSettingsInfo& Settings, EAreaInfoType AreaInfoType, TArray<class FName>& InfoNames, struct FS_AreaSettingsInfo* OutSettings);
	void ExecAreaInfoTweakDelete(const struct FS_AreaSettingsInfo& Settings, EAreaInfoType AreaInfoType, TArray<class FName>& InfoNames, struct FS_AreaSettingsInfo* OutSettings);
	void ExecAreaInfoTweakReplace(const struct FS_AreaSettingsInfo& Settings, EAreaInfoType AreaInfoType, TArray<class FName>& InfoNames, E_SceneType SceneType, struct FS_AreaSettingsInfo* OutSettings);
	void RequestSetLevelVisible(bool Visible, TSoftObjectPtr<class UObject> Level);
	void RequestLoadAreaImmediateAsync(bool SetVisbleAfterLoad, int32 LocationId, int32 AreaId, int32 VariationID, bool SkipEnemyLevels, bool SkipEventLevels);
	void Request_Load_Area_Async(bool SetVisbleAfterLoad, int32 LocationId, int32 AreaId, bool SkipEnemyLevels, bool SkipEventLevels, int32* LoadLocationID, int32* LoadAreaID, int32* LoadVariationID);
	void RequestLoadAreaAsyncByShortAreaName(bool SetVisbleAfterLoad, class FName ShortAreaName, bool SkipEnemyLevels, int32* LoadLocationID, int32* LoadAreaID, int32* LoadVariationID);
	void MakeTweakedAreaInfo(const struct FS_AreaSettingsInfo& AreaSettings, bool SkipEnemyLevels, bool SkipEventLevels, struct FS_AreaInfo* AreaInfo);
	void GetLevelsFromArrangePointAreaInfo_0(TArray<class FName>& InfoNames, TArray<TSoftObjectPtr<class UObject>>* Levels);
	void GetAllLevelInLoadedAreaInfo(class FName AreaName, TArray<TSoftObjectPtr<class UObject>>* Levels, struct FS_AreaInfo* AreaInfo, bool* Error);
	void DebugPrint_Levels(TArray<TSoftObjectPtr<class UObject>>& Objs, const class FText& Header);
	void IsAreaInLoadedAreaInfos(class FName AreaName, bool* IsLoaded, bool* IsExist, struct FS_AreaInfo* AreaInfo);
	void IsExistAreaInfo(class FName AreaName, bool* Found);
	void LoadEventTriggerBoxAsset(class FName AreaName);
	void SetCurrentSceneType(E_SceneType SceneType, E_SceneType* OldSceneType);
	void GetCurrentSceneType(E_SceneType* SceneType);
	void ResetCheckVisibleLevelAll();
	void SetLevelInfoCheckVisible(const TSoftObjectPtr<class UObject>& Level, bool CheckVisible);
	void IsWaitingAnySetVisibility(bool* Waiting);
	void IsWaitingLoadOrVisible(bool* IsWaiting);
	void GetLocationNameFromAreaName(class FName AreaName, class FString* LocationString);
	void _UnloadAllAreas();
	void RequestUnloadAllLevel();
	void RequestWaitAnyLoadEnd();
	void UnloadAllLevels();
	void UnloadAreaAllLevels(class FName AreaName);
	void CheckExistQueueLoadCommand(bool* Exist);
	void CheckNeedLevelInLoadedLevels(class FName AreaName);
	void AppendArrayUnique(TArray<class FName>& DistNames, TArray<class FName>& AppendNames);
	void DebugPrintLoadedLevels();
	void GetCurrentCameraType(class FName* Camera_type, bool* Return);
	void DebugPrintAreaNames(TArray<class FName>& AreaNames, const class FText& DoText);
	void SetAreaInfoCacheDirty(bool Dirty);
	void RequestLoadLevelAsync(bool Visible, TSoftObjectPtr<class UObject> Level);
	void RequestUnloadLevelAsync(TSoftObjectPtr<class UObject> Level);
	void TweakStreamSettingsInGame(const struct FRSStreamingSettings& Settings);
	void GetLbAndPortalLevelInArea(class FName AreaName, TArray<TSoftObjectPtr<class UObject>>* Levels, struct FS_AreaInfo* AreaInfo, bool* Error);
	void IsLBPortalLevelInLoadedAreaInfos(TSoftObjectPtr<class UObject> Level, bool* IsExist);
	void IsAreaLBPortalLevelsLoadedByAreaName(class FName AreaName, bool RawCheck, bool* IsLoaded, bool* IsError, struct FS_AreaInfo* Area_Info);
	void IsAreaLBPortalLevelsLoadedByInfo(class FName AreaName, bool RawCheck, bool* IsLoaded);
	void IsAreaLBPortalLevelsLoaded(int32 LocationId, int32 AreaId, int32 VariationID, bool RawCheck, bool* IsLoaded, bool* IsError, struct FS_AreaInfo* Area_Info);
	void RequestLoadAreaLBPortalAsync(bool SetVisbleAfterLoad, int32 LocationId, int32 AreaId, bool SkipEnemyLevels, int32* LoadLocationID, int32* LoadAreaID, int32* LoadVariationID);
	void CheckUnloadLevels(class FName AreaName);
	void StartPlayerAtTransform(const struct FTransform& Transform);
	void RequestSetVisibleAndWaitAreaLBPortal(int32 LocationId, int32 AreaId, int32 VariationID);
	void IsAreaLBPortalLevelsVisible(int32 LocationId, int32 AreaId, int32 VariationID, bool RawCheck, bool* IsVisible, bool* IsError, struct FS_AreaInfo* Area_Info);
	void IsAreaLBPortalLevelsVisibleByAreaName(class FName AreaName, bool* AllVisible);
	void IsLevelsVisible(TArray<TSoftObjectPtr<class UObject>>& Levels, bool* AllVisible);
	void SetAreaNaviLevelVisible(bool Visible);
	void GetCurrentAreaCameraPreset(EPlayerCameraPreset* Camera_preset, bool* Return);
	void SetLastSpawnPlayerInfo(class FName PortalName, const struct FTransform& Transform);
	void RequestSetBgAreaVisible(class FName BgAreaName, bool Visible);
	bool GetAreaInfoFromNative(class FName AreName, TArray<class FName>& OutLevenName);
	void UnvisibleEventSubQuestNPCLevel();
	void RestoreVisibleEventSubQuestNPCLevel();
	bool IsNeedFrameWait();
	void RequestUnloadUnneedLevels(class FName UnloadAreaName, class FName NextAreaName);
	bool IsValidCurrentSimulatorLevelInfosName();
	void AreaNameToID(class FName AreaName, int32* LocationId, int32* AreaId, int32* VariationID);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_LevelManager_C">();
	}
	static class ABP_LevelManager_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_LevelManager_C>();
	}
};
static_assert(alignof(ABP_LevelManager_C) == 0x000008, "Wrong alignment on ABP_LevelManager_C");
static_assert(sizeof(ABP_LevelManager_C) == 0x000538, "Wrong size on ABP_LevelManager_C");
static_assert(offsetof(ABP_LevelManager_C, UberGraphFrame) == 0x000250, "Member 'ABP_LevelManager_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, LoadCommandComponent) == 0x000258, "Member 'ABP_LevelManager_C::LoadCommandComponent' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, LevelCommandComponent) == 0x000260, "Member 'ABP_LevelManager_C::LevelCommandComponent' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, DefaultSceneRoot) == 0x000268, "Member 'ABP_LevelManager_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, MaxInfoAreaNum) == 0x000270, "Member 'ABP_LevelManager_C::MaxInfoAreaNum' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, CurrentAreaName) == 0x000274, "Member 'ABP_LevelManager_C::CurrentAreaName' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, LevelManagerStatus) == 0x00027C, "Member 'ABP_LevelManager_C::LevelManagerStatus' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, OldAreaName) == 0x000280, "Member 'ABP_LevelManager_C::OldAreaName' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, LoadedAreaInfos) == 0x000288, "Member 'ABP_LevelManager_C::LoadedAreaInfos' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, CommandQueue) == 0x0002D8, "Member 'ABP_LevelManager_C::CommandQueue' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, CurrentCommand) == 0x0002E8, "Member 'ABP_LevelManager_C::CurrentCommand' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, LoadedPacks) == 0x000330, "Member 'ABP_LevelManager_C::LoadedPacks' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, EventFinishWaitAreaVisibleDispatcher) == 0x000340, "Member 'ABP_LevelManager_C::EventFinishWaitAreaVisibleDispatcher' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, EventFinishWaitAreaUnvisibleDispatcher) == 0x000350, "Member 'ABP_LevelManager_C::EventFinishWaitAreaUnvisibleDispatcher' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, LoadedLevels) == 0x000360, "Member 'ABP_LevelManager_C::LoadedLevels' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, LoadedLevelInfo) == 0x000370, "Member 'ABP_LevelManager_C::LoadedLevelInfo' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, OldLoadedLevelInfo) == 0x000380, "Member 'ABP_LevelManager_C::OldLoadedLevelInfo' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, LoadedCameraType) == 0x000390, "Member 'ABP_LevelManager_C::LoadedCameraType' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, EventFinishLoadAssetAsync) == 0x0003E0, "Member 'ABP_LevelManager_C::EventFinishLoadAssetAsync' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, StreamingSettingsMap) == 0x0003F0, "Member 'ABP_LevelManager_C::StreamingSettingsMap' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, CurrentStreamingSettingsName) == 0x000440, "Member 'ABP_LevelManager_C::CurrentStreamingSettingsName' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, bTextureStreaming) == 0x000448, "Member 'ABP_LevelManager_C::bTextureStreaming' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, LocalAreaInfo) == 0x000450, "Member 'ABP_LevelManager_C::LocalAreaInfo' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, OnStartCheckLevelVisible) == 0x0004A0, "Member 'ABP_LevelManager_C::OnStartCheckLevelVisible' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, OnEndCheckLevelVisible) == 0x0004B0, "Member 'ABP_LevelManager_C::OnEndCheckLevelVisible' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, DebugSyncUnloadIndex) == 0x0004C0, "Member 'ABP_LevelManager_C::DebugSyncUnloadIndex' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, AreaSettingsCache) == 0x0004C8, "Member 'ABP_LevelManager_C::AreaSettingsCache' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, IsAreaSettingsCacheDirty) == 0x000518, "Member 'ABP_LevelManager_C::IsAreaSettingsCacheDirty' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, CurrentCameraPreset) == 0x000519, "Member 'ABP_LevelManager_C::CurrentCameraPreset' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, IsNoAreaSelectVariationFunction) == 0x00051A, "Member 'ABP_LevelManager_C::IsNoAreaSelectVariationFunction' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, StoreSubQuestNpcLevelList) == 0x000520, "Member 'ABP_LevelManager_C::StoreSubQuestNpcLevelList' has a wrong offset!");
static_assert(offsetof(ABP_LevelManager_C, CurrentSimulatorLevelInfosName) == 0x000530, "Member 'ABP_LevelManager_C::CurrentSimulatorLevelInfosName' has a wrong offset!");

}

