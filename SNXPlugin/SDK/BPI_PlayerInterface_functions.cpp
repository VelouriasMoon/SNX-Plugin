#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_PlayerInterface

#include "Basic.hpp"

#include "BPI_PlayerInterface_classes.hpp"
#include "BPI_PlayerInterface_parameters.hpp"


namespace SDK
{

// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetSASCodeVisible
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetSASCodeVisible(bool bVisible, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetSASCodeVisible");

	Params::BPI_PlayerInterface_C_SetSASCodeVisible Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.EnableRigidBody
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   LerpTime                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::EnableRigidBody(bool bEnable, float LerpTime, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "EnableRigidBody");

	Params::BPI_PlayerInterface_C_EnableRigidBody Parms{};

	Parms.bEnable = bEnable;
	Parms.LerpTime = LerpTime;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetPlayerActionSAS
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetPlayerActionSAS(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetPlayerActionSAS");

	Params::BPI_PlayerInterface_C_SetPlayerActionSAS Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetPlayerBattle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bBattle                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetPlayerBattle(bool bBattle, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetPlayerBattle");

	Params::BPI_PlayerInterface_C_SetPlayerBattle Parms{};

	Parms.bBattle = bBattle;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetBrainCodeVisible
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDrive                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetBrainCodeVisible(bool bVisible, bool bDrive, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetBrainCodeVisible");

	Params::BPI_PlayerInterface_C_SetBrainCodeVisible Parms{};

	Parms.bVisible = bVisible;
	Parms.bDrive = bDrive;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetSASCodeParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Param                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetSASCodeParam(float Param, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetSASCodeParam");

	Params::BPI_PlayerInterface_C_SetSASCodeParam Parms{};

	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.StartSASCode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SASKind                               SasKind                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::StartSASCode(E_SASKind SasKind, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "StartSASCode");

	Params::BPI_PlayerInterface_C_StartSASCode Parms{};

	Parms.SasKind = SasKind;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetSASCodeActorList
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_CableBase_C*>          CodeList                                               (Parm, OutParm, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetSASCodeActorList(TArray<class ABP_CableBase_C*>* CodeList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetSASCodeActorList");

	Params::BPI_PlayerInterface_C_GetSASCodeActorList Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CodeList != nullptr)
		*CodeList = std::move(Parms.CodeList);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetBrainCodeActorList
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_CableBase_C*>          CodeList                                               (Parm, OutParm, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetBrainCodeActorList(TArray<class ABP_CableBase_C*>* CodeList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetBrainCodeActorList");

	Params::BPI_PlayerInterface_C_GetBrainCodeActorList Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CodeList != nullptr)
		*CodeList = std::move(Parms.CodeList);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetBrainFieldTimeRate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Rate                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetBrainFieldTimeRate(float* Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetBrainFieldTimeRate");

	Params::BPI_PlayerInterface_C_GetBrainFieldTimeRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Rate != nullptr)
		*Rate = Parms.Rate;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsOpenBrainField
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOpen                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsOpenBrainField(bool* bOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsOpenBrainField");

	Params::BPI_PlayerInterface_C_IsOpenBrainField Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bOpen != nullptr)
		*bOpen = Parms.bOpen;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.PlaySASCodeDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ERSCableGravityType                     Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::PlaySASCodeDirection(ERSCableGravityType Type, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "PlaySASCodeDirection");

	Params::BPI_PlayerInterface_C_PlaySASCodeDirection Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.StopSASCodeDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ERSCableGravityType                     Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::StopSASCodeDirection(ERSCableGravityType Type, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "StopSASCodeDirection");

	Params::BPI_PlayerInterface_C_StopSASCodeDirection Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.ResetSpecialEffects
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::ResetSpecialEffects(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "ResetSpecialEffects");

	Params::BPI_PlayerInterface_C_ResetSpecialEffects Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetPlayerActionAfterEvent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EParamAfterEventAction                  Param                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetPlayerActionAfterEvent(EParamAfterEventAction Param, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetPlayerActionAfterEvent");

	Params::BPI_PlayerInterface_C_SetPlayerActionAfterEvent Parms{};

	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetSAS_Kind
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SASButton                             Button                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_SASKind                               Kind                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetSAS_Kind(E_SASButton Button, E_SASKind* Kind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetSAS_Kind");

	Params::BPI_PlayerInterface_C_GetSAS_Kind Parms{};

	Parms.Button = Button;

	UObject::ProcessEvent(Func, &Parms);

	if (Kind != nullptr)
		*Kind = Parms.Kind;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.PlayerCameraReset
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InterpSec                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::PlayerCameraReset(float InterpSec, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "PlayerCameraReset");

	Params::BPI_PlayerInterface_C_PlayerCameraReset Parms{};

	Parms.InterpSec = InterpSec;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.ForceWarp_Interface
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       Transform                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// float                                   IdlingSeconds                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::ForceWarp_Interface(const struct FTransform& Transform, float IdlingSeconds, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "ForceWarp_Interface");

	Params::BPI_PlayerInterface_C_ForceWarp_Interface Parms{};

	Parms.Transform = std::move(Transform);
	Parms.IdlingSeconds = IdlingSeconds;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetPsychicObjectEnableRange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Is_Brain_Field_in                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Range                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::SetPsychicObjectEnableRange(bool Is_Brain_Field_in, float* Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetPsychicObjectEnableRange");

	Params::BPI_PlayerInterface_C_SetPsychicObjectEnableRange Parms{};

	Parms.Is_Brain_Field_in = Is_Brain_Field_in;

	UObject::ProcessEvent(Func, &Parms);

	if (Range != nullptr)
		*Range = Parms.Range;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetCanAnimOverrideSASColor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetCanAnimOverrideSASColor(bool Enable, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetCanAnimOverrideSASColor");

	Params::BPI_PlayerInterface_C_SetCanAnimOverrideSASColor Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetCanAnimOverrideSASColor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::GetCanAnimOverrideSASColor(bool* Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetCanAnimOverrideSASColor");

	Params::BPI_PlayerInterface_C_GetCanAnimOverrideSASColor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Enabled != nullptr)
		*Enabled = Parms.Enabled;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetStealth
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Flag_in                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetStealth(bool Flag_in)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetStealth");

	Params::BPI_PlayerInterface_C_SetStealth Parms{};

	Parms.Flag_in = Flag_in;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.AddPsychicFlyObj
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_PsychicObjectBasic_C*         FlyObj                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::AddPsychicFlyObj(class ABP_PsychicObjectBasic_C* FlyObj, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "AddPsychicFlyObj");

	Params::BPI_PlayerInterface_C_AddPsychicFlyObj Parms{};

	Parms.FlyObj = FlyObj;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetPsychicFlyObj
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   FlyObj                                                 (Parm, OutParm, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetPsychicFlyObj(TArray<class AActor*>* FlyObj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetPsychicFlyObj");

	Params::BPI_PlayerInterface_C_GetPsychicFlyObj Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FlyObj != nullptr)
		*FlyObj = std::move(Parms.FlyObj);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.AddHitPsychicFlyObj
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_PsychicObjectBasic_C*         HitFlyObj                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsAdd                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::AddHitPsychicFlyObj(class ABP_PsychicObjectBasic_C* HitFlyObj, bool* IsAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "AddHitPsychicFlyObj");

	Params::BPI_PlayerInterface_C_AddHitPsychicFlyObj Parms{};

	Parms.HitFlyObj = HitFlyObj;

	UObject::ProcessEvent(Func, &Parms);

	if (IsAdd != nullptr)
		*IsAdd = Parms.IsAdd;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsUseFog
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsFog                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsUseFog(bool* IsFog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsUseFog");

	Params::BPI_PlayerInterface_C_IsUseFog Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsFog != nullptr)
		*IsFog = Parms.IsFog;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnpcBarrier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsBarrier                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsEnpcBarrier(bool* IsBarrier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnpcBarrier");

	Params::BPI_PlayerInterface_C_IsEnpcBarrier Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsBarrier != nullptr)
		*IsBarrier = Parms.IsBarrier;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.CanBattleAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerAIBattleThinkType                ThinkType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanAction                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::CanBattleAction(EPlayerAIBattleThinkType ThinkType, bool* CanAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "CanBattleAction");

	Params::BPI_PlayerInterface_C_CanBattleAction Parms{};

	Parms.ThinkType = ThinkType;

	UObject::ProcessEvent(Func, &Parms);

	if (CanAction != nullptr)
		*CanAction = Parms.CanAction;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetENpcKind
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENpcKind                                ENpcKind                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetENpcKind(ENpcKind* ENpcKind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetENpcKind");

	Params::BPI_PlayerInterface_C_GetENpcKind Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ENpcKind != nullptr)
		*ENpcKind = Parms.ENpcKind;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsDodgeTargetRot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Param_IsDodgeTargetRot                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsDodgeTargetRot(bool* Param_IsDodgeTargetRot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsDodgeTargetRot");

	Params::BPI_PlayerInterface_C_IsDodgeTargetRot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_IsDodgeTargetRot != nullptr)
		*Param_IsDodgeTargetRot = Parms.Param_IsDodgeTargetRot;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetDodgeScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DodgeScale                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetDodgeScale(float* DodgeScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetDodgeScale");

	Params::BPI_PlayerInterface_C_GetDodgeScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DodgeScale != nullptr)
		*DodgeScale = Parms.DodgeScale;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsSpecialDown
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsSpDown                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   SpDownWince                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::IsSpecialDown(bool* IsSpDown, float* SpDownWince)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsSpecialDown");

	Params::BPI_PlayerInterface_C_IsSpecialDown Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsSpDown != nullptr)
		*IsSpDown = Parms.IsSpDown;

	if (SpDownWince != nullptr)
		*SpDownWince = Parms.SpDownWince;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetSpecialDownTimer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   SpDownTimer                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetSpecialDownTimer(float* SpDownTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetSpecialDownTimer");

	Params::BPI_PlayerInterface_C_GetSpecialDownTimer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SpDownTimer != nullptr)
		*SpDownTimer = Parms.SpDownTimer;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.ChangeENpcKind
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENpcKind                                ENpcKind                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::ChangeENpcKind(ENpcKind ENpcKind, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "ChangeENpcKind");

	Params::BPI_PlayerInterface_C_ChangeENpcKind Parms{};

	Parms.ENpcKind = ENpcKind;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetSkillCoreDropProbability
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Probability                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetSkillCoreDropProbability(float* Probability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetSkillCoreDropProbability");

	Params::BPI_PlayerInterface_C_GetSkillCoreDropProbability Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Probability != nullptr)
		*Probability = Parms.Probability;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.CanSpecialMoveTrigger
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanDo                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::CanSpecialMoveTrigger(bool* CanDo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "CanSpecialMoveTrigger");

	Params::BPI_PlayerInterface_C_CanSpecialMoveTrigger Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanDo != nullptr)
		*CanDo = Parms.CanDo;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.ReturnMetamorphosis
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class ARSBattlePlayer_C*                SpecifyPlayer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::ReturnMetamorphosis(const struct FVector& Location, const struct FRotator& Rotation, class ARSBattlePlayer_C* SpecifyPlayer, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "ReturnMetamorphosis");

	Params::BPI_PlayerInterface_C_ReturnMetamorphosis Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.SpecifyPlayer = SpecifyPlayer;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.OnAttackedEnemyDead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECharaDeadType                          DeadType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::OnAttackedEnemyDead(ECharaDeadType DeadType, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "OnAttackedEnemyDead");

	Params::BPI_PlayerInterface_C_OnAttackedEnemyDead Parms{};

	Parms.DeadType = DeadType;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.CanEnpcOpenBrainField
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanDo                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::CanEnpcOpenBrainField(bool* CanDo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "CanEnpcOpenBrainField");

	Params::BPI_PlayerInterface_C_CanEnpcOpenBrainField Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanDo != nullptr)
		*CanDo = Parms.CanDo;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.EnpcBarrierHitNotify
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHCHitResult                     Result                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// bool                                    Dammy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::EnpcBarrierHitNotify(const struct FHCHitResult& Result, bool* Dammy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "EnpcBarrierHitNotify");

	Params::BPI_PlayerInterface_C_EnpcBarrierHitNotify Parms{};

	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);

	if (Dammy != nullptr)
		*Dammy = Parms.Dammy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.CreateRedCode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::CreateRedCode(bool* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "CreateRedCode");

	Params::BPI_PlayerInterface_C_CreateRedCode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.DestroyRedCode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::DestroyRedCode(bool* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "DestroyRedCode");

	Params::BPI_PlayerInterface_C_DestroyRedCode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.CheckStickInputTurn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bTurn                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::CheckStickInputTurn(bool* bTurn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "CheckStickInputTurn");

	Params::BPI_PlayerInterface_C_CheckStickInputTurn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bTurn != nullptr)
		*bTurn = Parms.bTurn;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.OnAnimNotifyInputPsychic
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_PlayerInterface_C::OnAnimNotifyInputPsychic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "OnAnimNotifyInputPsychic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetEnableRigidBody
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::GetEnableRigidBody(bool* Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetEnableRigidBody");

	Params::BPI_PlayerInterface_C_GetEnableRigidBody Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Enable != nullptr)
		*Enable = Parms.Enable;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetPlayerInputRestriction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerInputRestrictionType             Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bRestriction                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetPlayerInputRestriction(EPlayerInputRestrictionType Type, bool bRestriction, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetPlayerInputRestriction");

	Params::BPI_PlayerInterface_C_SetPlayerInputRestriction Parms{};

	Parms.Type = Type;
	Parms.bRestriction = bRestriction;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsJumpAreaAble
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bAble                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsJumpAreaAble(bool* bAble)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsJumpAreaAble");

	Params::BPI_PlayerInterface_C_IsJumpAreaAble Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bAble != nullptr)
		*bAble = Parms.bAble;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnableInputPsychicCombo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsEnableInputPsychicCombo(bool* bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnableInputPsychicCombo");

	Params::BPI_PlayerInterface_C_IsEnableInputPsychicCombo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnable != nullptr)
		*bEnable = Parms.bEnable;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetPsychicEmissionInterface
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bON                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FName                             ClaimantName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::SetPsychicEmissionInterface(bool bON, class FName ClaimantName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetPsychicEmissionInterface");

	Params::BPI_PlayerInterface_C_SetPsychicEmissionInterface Parms{};

	Parms.bON = bON;
	Parms.ClaimantName = ClaimantName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsIntense
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIntense                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsIntense(bool* bIntense)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsIntense");

	Params::BPI_PlayerInterface_C_IsIntense Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bIntense != nullptr)
		*bIntense = Parms.bIntense;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnableSeeThrough
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsEnableSeeThrough(bool* bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnableSeeThrough");

	Params::BPI_PlayerInterface_C_IsEnableSeeThrough Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnable != nullptr)
		*bEnable = Parms.bEnable;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetTalkLookAtTurn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          LookAtLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetTalkLookAtTurn(const struct FVector& LookAtLocation, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetTalkLookAtTurn");

	Params::BPI_PlayerInterface_C_SetTalkLookAtTurn Parms{};

	Parms.LookAtLocation = std::move(LookAtLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.EndTalkLookAtTurn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::EndTalkLookAtTurn(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "EndTalkLookAtTurn");

	Params::BPI_PlayerInterface_C_EndTalkLookAtTurn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.EnableUseSeeThrough
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::EnableUseSeeThrough(bool* bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "EnableUseSeeThrough");

	Params::BPI_PlayerInterface_C_EnableUseSeeThrough Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnable != nullptr)
		*bEnable = Parms.bEnable;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.CheckTargetableCharacterENPC
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARSCharacterBase*                 Chara                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool IBPI_PlayerInterface_C::CheckTargetableCharacterENPC(class ARSCharacterBase* Chara)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "CheckTargetableCharacterENPC");

	Params::BPI_PlayerInterface_C_CheckTargetableCharacterENPC Parms{};

	Parms.Chara = Chara;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.RequestBrainFieldHelp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::RequestBrainFieldHelp(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "RequestBrainFieldHelp");

	Params::BPI_PlayerInterface_C_RequestBrainFieldHelp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetNpcBrainFieldDrive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDrive                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetNpcBrainFieldDrive(bool bDrive, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetNpcBrainFieldDrive");

	Params::BPI_PlayerInterface_C_SetNpcBrainFieldDrive Parms{};

	Parms.bDrive = bDrive;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.OnAnimNotify_EnpcSAS
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SASKind                               Kind                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::OnAnimNotify_EnpcSAS(E_SASKind Kind, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "OnAnimNotify_EnpcSAS");

	Params::BPI_PlayerInterface_C_OnAnimNotify_EnpcSAS Parms{};

	Parms.Kind = Kind;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.BeginEnpcSAS
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SASKind                               Kind                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::BeginEnpcSAS(E_SASKind Kind, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "BeginEnpcSAS");

	Params::BPI_PlayerInterface_C_BeginEnpcSAS Parms{};

	Parms.Kind = Kind;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.CheckAssassinAttack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAssassinAttackHit                      Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ARSBattleCharacter_C*             DamagedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bArmorBreak                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::CheckAssassinAttack(EAssassinAttackHit Type, class ARSBattleCharacter_C* DamagedActor, bool* bSuccess, bool* bArmorBreak)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "CheckAssassinAttack");

	Params::BPI_PlayerInterface_C_CheckAssassinAttack Parms{};

	Parms.Type = Type;
	Parms.DamagedActor = DamagedActor;

	UObject::ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	if (bArmorBreak != nullptr)
		*bArmorBreak = Parms.bArmorBreak;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.ResetCollisionOverlap
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::ResetCollisionOverlap(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "ResetCollisionOverlap");

	Params::BPI_PlayerInterface_C_ResetCollisionOverlap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.PlayBrainFieldBattleTalk
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::PlayBrainFieldBattleTalk(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "PlayBrainFieldBattleTalk");

	Params::BPI_PlayerInterface_C_PlayBrainFieldBattleTalk Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsDriveMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDrive                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsDriveMode(bool* bDrive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsDriveMode");

	Params::BPI_PlayerInterface_C_IsDriveMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDrive != nullptr)
		*bDrive = Parms.bDrive;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.EventInputRestrict
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRestrict                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::EventInputRestrict(bool bRestrict, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "EventInputRestrict");

	Params::BPI_PlayerInterface_C_EventInputRestrict Parms{};

	Parms.bRestrict = bRestrict;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.EventInputRestrictAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bRestrict                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::EventInputRestrictAction(bool bRestrict, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "EventInputRestrictAction");

	Params::BPI_PlayerInterface_C_EventInputRestrictAction Parms{};

	Parms.bRestrict = bRestrict;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SuspendPlayer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSuspend                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SuspendPlayer(bool* bSuspend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SuspendPlayer");

	Params::BPI_PlayerInterface_C_SuspendPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bSuspend != nullptr)
		*bSuspend = Parms.bSuspend;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.ResumePlayer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bResume                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::ResumePlayer(bool* bResume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "ResumePlayer");

	Params::BPI_PlayerInterface_C_ResumePlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bResume != nullptr)
		*bResume = Parms.bResume;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.FinishMetamorphosisLastAttack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::FinishMetamorphosisLastAttack(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "FinishMetamorphosisLastAttack");

	Params::BPI_PlayerInterface_C_FinishMetamorphosisLastAttack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnableCreateCopy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsEnableCreateCopy(bool* Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnableCreateCopy");

	Params::BPI_PlayerInterface_C_IsEnableCreateCopy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Enable != nullptr)
		*Enable = Parms.Enable;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.OnStartReactionChance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::OnStartReactionChance(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "OnStartReactionChance");

	Params::BPI_PlayerInterface_C_OnStartReactionChance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.OnStartEnpcDrive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::OnStartEnpcDrive(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "OnStartEnpcDrive");

	Params::BPI_PlayerInterface_C_OnStartEnpcDrive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetReactionChanceEndAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerAIBattleThinkType                EndAction                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetReactionChanceEndAction(EPlayerAIBattleThinkType* EndAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetReactionChanceEndAction");

	Params::BPI_PlayerInterface_C_GetReactionChanceEndAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EndAction != nullptr)
		*EndAction = Parms.EndAction;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SelectReactionChanceEndAction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<EPlayerAIBattleThinkType>        InEndAction                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// EPlayerAIBattleThinkType                OutEndAction                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::SelectReactionChanceEndAction(const TArray<EPlayerAIBattleThinkType>& InEndAction, EPlayerAIBattleThinkType* OutEndAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SelectReactionChanceEndAction");

	Params::BPI_PlayerInterface_C_SelectReactionChanceEndAction Parms{};

	Parms.InEndAction = std::move(InEndAction);

	UObject::ProcessEvent(Func, &Parms);

	if (OutEndAction != nullptr)
		*OutEndAction = Parms.OutEndAction;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetNpcWarpDither
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetNpcWarpDither(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetNpcWarpDither");

	Params::BPI_PlayerInterface_C_SetNpcWarpDither Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsExecNpcRevive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bExec                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsExecNpcRevive(bool* bExec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsExecNpcRevive");

	Params::BPI_PlayerInterface_C_IsExecNpcRevive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bExec != nullptr)
		*bExec = Parms.bExec;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsMainPlayer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bMainPlayer                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsMainPlayer(bool* bMainPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsMainPlayer");

	Params::BPI_PlayerInterface_C_IsMainPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bMainPlayer != nullptr)
		*bMainPlayer = Parms.bMainPlayer;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.NotifyKillEnemy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARSBattleCharacter_C*             KillActor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::NotifyKillEnemy(class ARSBattleCharacter_C* KillActor, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "NotifyKillEnemy");

	Params::BPI_PlayerInterface_C_NotifyKillEnemy Parms{};

	Parms.KillActor = KillActor;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.DisablePlayerFootIK
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDisable                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FName                             ClaimantName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::DisablePlayerFootIK(bool bDisable, class FName ClaimantName, float BlendTime, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "DisablePlayerFootIK");

	Params::BPI_PlayerInterface_C_DisablePlayerFootIK Parms{};

	Parms.bDisable = bDisable;
	Parms.ClaimantName = ClaimantName;
	Parms.BlendTime = BlendTime;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.ElevatorSetting
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bInElevator                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::ElevatorSetting(bool bInElevator, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "ElevatorSetting");

	Params::BPI_PlayerInterface_C_ElevatorSetting Parms{};

	Parms.bInElevator = bInElevator;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnableDrive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsEnableDrive(bool* Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnableDrive");

	Params::BPI_PlayerInterface_C_IsEnableDrive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Enable != nullptr)
		*Enable = Parms.Enable;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnableRegistSAS
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsEnableRegistSAS(bool* Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnableRegistSAS");

	Params::BPI_PlayerInterface_C_IsEnableRegistSAS Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Enable != nullptr)
		*Enable = Parms.Enable;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsActiveEnpcSasFire
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsActiveEnpcSasFire(bool* IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsActiveEnpcSasFire");

	Params::BPI_PlayerInterface_C_IsActiveEnpcSasFire Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsActive != nullptr)
		*IsActive = Parms.IsActive;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsActiveEnpcSasElectric
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsActiveEnpcSasElectric(bool* IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsActiveEnpcSasElectric");

	Params::BPI_PlayerInterface_C_IsActiveEnpcSasElectric Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsActive != nullptr)
		*IsActive = Parms.IsActive;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsActiveEnpcSasTeleport
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsActiveEnpcSasTeleport(bool* IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsActiveEnpcSasTeleport");

	Params::BPI_PlayerInterface_C_IsActiveEnpcSasTeleport Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsActive != nullptr)
		*IsActive = Parms.IsActive;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetDisableActionBoringIdle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDisable                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetDisableActionBoringIdle(bool bDisable, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetDisableActionBoringIdle");

	Params::BPI_PlayerInterface_C_SetDisableActionBoringIdle Parms{};

	Parms.bDisable = bDisable;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.UpdatePlayerActionAfterEvent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EParamAfterEventAction                  EventAction                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::UpdatePlayerActionAfterEvent(EParamAfterEventAction EventAction, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "UpdatePlayerActionAfterEvent");

	Params::BPI_PlayerInterface_C_UpdatePlayerActionAfterEvent Parms{};

	Parms.EventAction = EventAction;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.EnablePlaySpTrigger
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Return_                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::EnablePlaySpTrigger(bool bEnable, bool* Return_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "EnablePlaySpTrigger");

	Params::BPI_PlayerInterface_C_EnablePlaySpTrigger Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);

	if (Return_ != nullptr)
		*Return_ = Parms.Return_;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnablePlaySpTrigger
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_PlayerInterface_C::IsEnablePlaySpTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnablePlaySpTrigger");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetEnpcSasStealthStart
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetEnpcSasStealthStart(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetEnpcSasStealthStart");

	Params::BPI_PlayerInterface_C_SetEnpcSasStealthStart Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetEnpcSasStealthEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetEnpcSasStealthEnd(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetEnpcSasStealthEnd");

	Params::BPI_PlayerInterface_C_SetEnpcSasStealthEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.BattleSettingEm1500
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bBattle                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::BattleSettingEm1500(bool bBattle, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "BattleSettingEm1500");

	Params::BPI_PlayerInterface_C_BattleSettingEm1500 Parms{};

	Parms.bBattle = bBattle;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetAttackHitStop
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamagedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHCHitResult                     HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetAttackHitStop(class AActor* DamagedActor, const struct FHCHitResult& HitResult, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetAttackHitStop");

	Params::BPI_PlayerInterface_C_SetAttackHitStop Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.BeforeCutSceneEventManagerStart
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::BeforeCutSceneEventManagerStart(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "BeforeCutSceneEventManagerStart");

	Params::BPI_PlayerInterface_C_BeforeCutSceneEventManagerStart Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.CheckBattleStartTimer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::CheckBattleStartTimer(bool* Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "CheckBattleStartTimer");

	Params::BPI_PlayerInterface_C_CheckBattleStartTimer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Enable != nullptr)
		*Enable = Parms.Enable;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.StoreLockTargetInterface
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::StoreLockTargetInterface(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "StoreLockTargetInterface");

	Params::BPI_PlayerInterface_C_StoreLockTargetInterface Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.RestoreLockTargetInterface
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::RestoreLockTargetInterface(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "RestoreLockTargetInterface");

	Params::BPI_PlayerInterface_C_RestoreLockTargetInterface Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.ProcEndBrainCrash
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CrashTargetNum                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::ProcEndBrainCrash(int32 CrashTargetNum, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "ProcEndBrainCrash");

	Params::BPI_PlayerInterface_C_ProcEndBrainCrash Parms{};

	Parms.CrashTargetNum = CrashTargetNum;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.AddBattleBonusInterface
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EBattleBonusAddType                     Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::AddBattleBonusInterface(EBattleBonusAddType Type, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "AddBattleBonusInterface");

	Params::BPI_PlayerInterface_C_AddBattleBonusInterface Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnableDriveAttack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsEnableDriveAttack(bool* Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnableDriveAttack");

	Params::BPI_PlayerInterface_C_IsEnableDriveAttack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Enable != nullptr)
		*Enable = Parms.Enable;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetDriveAttacked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetDriveAttacked(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetDriveAttacked");

	Params::BPI_PlayerInterface_C_SetDriveAttacked Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetAttackCollisionDelayTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<float>                           AttackDelayTime                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetAttackCollisionDelayTime(const TArray<float>& AttackDelayTime, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetAttackCollisionDelayTime");

	Params::BPI_PlayerInterface_C_SetAttackCollisionDelayTime Parms{};

	Parms.AttackDelayTime = std::move(AttackDelayTime);

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.DebugNextBattleThinkLog
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFPlayerAIBattleThinkTransitionDataInTransitionData                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::DebugNextBattleThinkLog(const struct FFPlayerAIBattleThinkTransitionData& InTransitionData, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "DebugNextBattleThinkLog");

	Params::BPI_PlayerInterface_C_DebugNextBattleThinkLog Parms{};

	Parms.InTransitionData = std::move(InTransitionData);

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SASCancelEffectAndSEInterface
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEffect                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bSE                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SASCancelEffectAndSEInterface(bool bEffect, bool bSE, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SASCancelEffectAndSEInterface");

	Params::BPI_PlayerInterface_C_SASCancelEffectAndSEInterface Parms{};

	Parms.bEffect = bEffect;
	Parms.bSE = bSE;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsOverwriteAttackAutoAimSpeed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOverwrite                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Speed                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::IsOverwriteAttackAutoAimSpeed(bool* bOverwrite, float* Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsOverwriteAttackAutoAimSpeed");

	Params::BPI_PlayerInterface_C_IsOverwriteAttackAutoAimSpeed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bOverwrite != nullptr)
		*bOverwrite = Parms.bOverwrite;

	if (Speed != nullptr)
		*Speed = Parms.Speed;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetAllSasCodeList
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_CableBase_C*>          NormalCode                                             (Parm, OutParm, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetAllSasCodeList(TArray<class ABP_CableBase_C*>* NormalCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetAllSasCodeList");

	Params::BPI_PlayerInterface_C_GetAllSasCodeList Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NormalCode != nullptr)
		*NormalCode = std::move(Parms.NormalCode);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsNexusDriveSeeThroughBestJustDodge
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bBestJustDodge                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsNexusDriveSeeThroughBestJustDodge(bool* bBestJustDodge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsNexusDriveSeeThroughBestJustDodge");

	Params::BPI_PlayerInterface_C_IsNexusDriveSeeThroughBestJustDodge Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bBestJustDodge != nullptr)
		*bBestJustDodge = Parms.bBestJustDodge;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.SetPlayerPhysicsIdlingInterface
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   IdlingSeconds                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bRefreshSkin                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::SetPlayerPhysicsIdlingInterface(float IdlingSeconds, bool bRefreshSkin, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "SetPlayerPhysicsIdlingInterface");

	Params::BPI_PlayerInterface_C_SetPlayerPhysicsIdlingInterface Parms{};

	Parms.IdlingSeconds = IdlingSeconds;
	Parms.bRefreshSkin = bRefreshSkin;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetPlayerIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// int32                                   Param_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetPlayerIndex(int32* Param_Index) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetPlayerIndex");

	Params::BPI_PlayerInterface_C_GetPlayerIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_Index != nullptr)
		*Param_Index = Parms.Param_Index;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetPlayerWeaponList
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EGetPlayerWeaponType                    Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class ABP_WeaponBase_C*>         WeaponList                                             (Parm, OutParm, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetPlayerWeaponList(EGetPlayerWeaponType Type, TArray<class ABP_WeaponBase_C*>* WeaponList) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetPlayerWeaponList");

	Params::BPI_PlayerInterface_C_GetPlayerWeaponList Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (WeaponList != nullptr)
		*WeaponList = std::move(Parms.WeaponList);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnemyPlayer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bEnemyPlayer                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsEnemyPlayer(bool* bEnemyPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnemyPlayer");

	Params::BPI_PlayerInterface_C_IsEnemyPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnemyPlayer != nullptr)
		*bEnemyPlayer = Parms.bEnemyPlayer;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsForceWarpAble_Interface
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bWarpAble                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsForceWarpAble_Interface(bool* bWarpAble) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsForceWarpAble_Interface");

	Params::BPI_PlayerInterface_C_IsForceWarpAble_Interface Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bWarpAble != nullptr)
		*bWarpAble = Parms.bWarpAble;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetSkillParameter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EPlayerSkill                            Skill                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bLearned                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Parameter                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetSkillParameter(EPlayerSkill Skill, bool* bLearned, float* Parameter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetSkillParameter");

	Params::BPI_PlayerInterface_C_GetSkillParameter Parms{};

	Parms.Skill = Skill;

	UObject::ProcessEvent(Func, &Parms);

	if (bLearned != nullptr)
		*bLearned = Parms.bLearned;

	if (Parameter != nullptr)
		*Parameter = Parms.Parameter;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsPlayerInputRestriction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EPlayerInputRestrictionType             Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bRestriction                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsPlayerInputRestriction(EPlayerInputRestrictionType Type, bool* bRestriction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsPlayerInputRestriction");

	Params::BPI_PlayerInterface_C_IsPlayerInputRestriction Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (bRestriction != nullptr)
		*bRestriction = Parms.bRestriction;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetEnpcComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class UBP_ENpcComponent_C*              ReturnComp                                             (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetEnpcComp(class UBP_ENpcComponent_C** ReturnComp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetEnpcComp");

	Params::BPI_PlayerInterface_C_GetEnpcComp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ReturnComp != nullptr)
		*ReturnComp = Parms.ReturnComp;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsAnimationEndTalkTurn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bAnimation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsAnimationEndTalkTurn(bool* bAnimation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsAnimationEndTalkTurn");

	Params::BPI_PlayerInterface_C_IsAnimationEndTalkTurn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bAnimation != nullptr)
		*bAnimation = Parms.bAnimation;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetTalkLookAtLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bTalkLookAt                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::GetTalkLookAtLocation(bool* bTalkLookAt, struct FVector* Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetTalkLookAtLocation");

	Params::BPI_PlayerInterface_C_GetTalkLookAtLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bTalkLookAt != nullptr)
		*bTalkLookAt = Parms.bTalkLookAt;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsCameraControl
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bControl                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsCameraControl(bool* bControl) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsCameraControl");

	Params::BPI_PlayerInterface_C_IsCameraControl Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bControl != nullptr)
		*bControl = Parms.bControl;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsEnpcSASLinkAble
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// E_SASKind                               Kind                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bOK                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsEnpcSASLinkAble(E_SASKind Kind, bool* bOK) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsEnpcSASLinkAble");

	Params::BPI_PlayerInterface_C_IsEnpcSASLinkAble Parms{};

	Parms.Kind = Kind;

	UObject::ProcessEvent(Func, &Parms);

	if (bOK != nullptr)
		*bOK = Parms.bOK;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsDying
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bDying                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsDying(bool* bDying) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsDying");

	Params::BPI_PlayerInterface_C_IsDying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDying != nullptr)
		*bDying = Parms.bDying;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsAutoTakenItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bAuto                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsAutoTakenItem(bool* bAuto) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsAutoTakenItem");

	Params::BPI_PlayerInterface_C_IsAutoTakenItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bAuto != nullptr)
		*bAuto = Parms.bAuto;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.GetBrainCrashStartTransform
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::GetBrainCrashStartTransform(struct FTransform* Transform) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "GetBrainCrashStartTransform");

	Params::BPI_PlayerInterface_C_GetBrainCrashStartTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsExecTalkEvent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bTalk                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerInterface_C::IsExecTalkEvent(bool* bTalk) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsExecTalkEvent");

	Params::BPI_PlayerInterface_C_IsExecTalkEvent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bTalk != nullptr)
		*bTalk = Parms.bTalk;
}


// Function BPI_PlayerInterface.BPI_PlayerInterface_C.IsUsingItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bUsing                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EConsumeItemID                          ItemId                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerInterface_C::IsUsingItem(bool* bUsing, EConsumeItemID* ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerInterface_C", "IsUsingItem");

	Params::BPI_PlayerInterface_C_IsUsingItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bUsing != nullptr)
		*bUsing = Parms.bUsing;

	if (ItemId != nullptr)
		*ItemId = Parms.ItemId;
}

}

