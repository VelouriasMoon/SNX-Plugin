#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RSBattleEnemy

#include "Basic.hpp"

#include "UMG_structs.hpp"
#include "WeakObjectRecommendEnemy_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "BattlePrototype_structs.hpp"
#include "ST_emLostActionInfo_structs.hpp"
#include "Engine_structs.hpp"
#include "WeakObjectEntryEnemy_structs.hpp"
#include "BadStateParticleData_structs.hpp"
#include "Enum_EnemySpawnState_structs.hpp"
#include "AiParamEnemy_structs.hpp"
#include "Enum_EnemySound_structs.hpp"
#include "ST_emChangeAiTypeInfo_structs.hpp"
#include "EDeadFactor_structs.hpp"
#include "BadStateAddParticleData_structs.hpp"
#include "Enum_EnemyAiType_structs.hpp"
#include "Enum_EnemyBrainFieldProgress_structs.hpp"
#include "RSBattleCharacter_classes.hpp"
#include "DE_em_ChangeTimeDilation_structs.hpp"
#include "ECharaExecuteNotifyKind_structs.hpp"
#include "Enum_EnemyAvoidType_structs.hpp"
#include "Enum_EnemyRange_structs.hpp"
#include "Enum_em0300_structs.hpp"
#include "Enum_EnemyMotionParam_structs.hpp"
#include "BattleAIStateType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass RSBattleEnemy.RSBattleEnemy_C
// 0x1140 (0x2230 - 0x10F0)
#pragma pack(push, 0x1)
class alignas(0x10) ARSBattleEnemy_C : public ARSBattleCharacter_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_RSBattleEnemy_C;                    // 0x10F0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UEnemyScrollCheckComponent*             EnemyTargetLookCheck;                              // 0x10F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UEnemyPathAreaCheckComponent*           EnemyPathAreaCheck;                                // 0x1100(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UEnemyCalcGoalComponent*                EnemyCalcGoal;                                     // 0x1108(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UChangeWeakStateComponent_C*            ChangeWeakStateComponent;                          // 0x1110(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyGoalComponent_C*               BP_EnemyGoalComponent;                             // 0x1118(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyChangePlayRate_C*              BP_EnemyChangePlayRate;                            // 0x1120(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyChangeTimeDilationComponent_C* BP_EnemyChangeTimeDilationComponent;               // 0x1128(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UEnemyScriptComponent*                  EnemyScript;                                       // 0x1130(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyAroundWeakEffectComponent_C*   BP_EnemyAroundWeakEffectComponent;                 // 0x1138(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UEnemyLookCheckComponent*               EnemyLookCheck;                                    // 0x1140(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_Discover_Component_C*               BP_Discover_Component;                             // 0x1148(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyAddDamageShakeComponent_C*     BP_EnemyAddDamageShakeComponent;                   // 0x1150(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyDamageRagdollComponent_C*      BP_EnemyDamageRagdollComponent;                    // 0x1158(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyDamageMoveComponent_C*         BP_EnemyDamageMoveComponent;                       // 0x1160(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemySpawnComponent_C*              BP_EnemySpawnComponent;                            // 0x1168(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyDeadMoveComponent_C*           BP_EnemyDeadMoveComponent;                         // 0x1170(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyAvatarMaterial_C*              BP_EnemyAvatarMaterial;                            // 0x1178(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyAvatar_C*                      BP_EnemyAvatar;                                    // 0x1180(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UStealthWeakComponent_C*                StealthWeakComponent;                              // 0x1188(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USearchingComponent*                    Searching;                                         // 0x1190(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UEnemyDatatableAccessorComponent_C*     EnemyDatatableAccessorComponent;                   // 0x1198(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UEnemyAnimControllerComponent*          AnimCon;                                           // 0x11A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UAIAttackedInfoComponent_C*             AIAttackedInfoComponent;                           // 0x11A8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UVanishEnemyComponent_C*                VanishComponent;                                   // 0x11B0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class FName                                   BBKey_BattleAIState;                               // 0x11B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   EnemyStatusRowName;                                // 0x11C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SleepAIDistance;                                   // 0x11C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   DefaultStatusClaimantName;                         // 0x11CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   EnemyClaimantName;                                 // 0x11D4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   EnemyDeadClaimantName;                             // 0x11DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DeadEmissiveSec;                                   // 0x11E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DeadVanishSec;                                     // 0x11E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDeadStaging;                                      // 0x11EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D8D[0x3];                                     // 0x11ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeadStagingPastSec;                                // 0x11F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DeadVanishEffectSec;                               // 0x11F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DeadStagingTotalSec;                               // 0x11F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8D8E[0x4];                                     // 0x11FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          DeadFinishSE;                                      // 0x1200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CapsuleRad;                                        // 0x1208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SearchRange;                                       // 0x120C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SearchAngle;                                       // 0x1210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SensingArea;                                       // 0x1214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                InitPos;                                           // 0x1218(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsFirstAttack;                                     // 0x1224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsInitLayout;                                      // 0x1225(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	EnemyInitLayoutAnimKind                       InitLayout;                                        // 0x1226(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8D8F[0x1];                                     // 0x1227(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class ATargetPoint*                           TargetPos;                                         // 0x1228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TargetRange;                                       // 0x1230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsWander;                                          // 0x1234(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D90[0x3];                                     // 0x1235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetRangeCheck;                                  // 0x1238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBattleFinish;                                    // 0x123C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsNotSearchTableData;                              // 0x123D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D91[0x2];                                     // 0x123E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnableMoveArea;                                    // 0x1240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DistanceFromEnemyInitToPlayer;                     // 0x1244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SpeedScale;                                        // 0x1248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ShortDistance;                                     // 0x124C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBrainAccess;                                     // 0x1250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D92[0x7];                                     // 0x1251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDamagePartCollisionComponent*>  DamagePartComponents;                              // 0x1258(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	bool                                          IsBoss;                                            // 0x1268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D93[0x3];                                     // 0x1269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LongDistance;                                      // 0x126C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBrainSuccess;                                    // 0x1270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsMoveEnable;                                      // 0x1271(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsHitDamage;                                       // 0x1272(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D94[0x1];                                     // 0x1273(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DownTime;                                          // 0x1274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DownTimer;                                         // 0x1278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsLandCheck;                                       // 0x127C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsBlowOnce;                                        // 0x127D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bNoNavMove;                                        // 0x127E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D95[0x1];                                     // 0x127F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DamageRot;                                         // 0x1280(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsNotDamageAngle;                                  // 0x128C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D96[0x3];                                     // 0x128D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoNavMoveInterpSpeed;                              // 0x1290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsFreeCheck;                                       // 0x1294(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsCreateWeapon;                                    // 0x1295(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D97[0x2];                                     // 0x1296(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetDistance;                                    // 0x1298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MotionFootParam;                                   // 0x129C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsMotionFootParamUse;                              // 0x12A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D98[0x7];                                     // 0x12A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  MotionFootParamCheck;                              // 0x12A8(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<class FName>                           MotionFootParamName;                               // 0x12B8(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<struct FTransform>                     MotionFootParam_Trans;                             // 0x12C8(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<float>                                 MotionFootParam_Alpha;                             // 0x12D8(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	float                                         DeadTimer;                                         // 0x12E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBossDead;                                        // 0x12EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D99[0x3];                                     // 0x12ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 MotionFootParam_Timer;                             // 0x12F0(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	float                                         MotionFootParam_Time;                              // 0x1300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsRagdollEnable;                                   // 0x1304(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsRagdoll;                                         // 0x1305(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsRagdollDownEnable;                               // 0x1306(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsRagdollDown;                                     // 0x1307(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	class FName                                   RagdollDownBoneName;                               // 0x1308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RagdollDownBlend;                                  // 0x1310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RagdollDownBackToTime;                             // 0x1314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   RagdollBoneName;                                   // 0x1318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RagdollBlend;                                      // 0x1320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RagdollBackToTime;                                 // 0x1324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   RagdollPowerBoneName;                              // 0x1328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                RagdollPowerObj;                                   // 0x1330(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RagdollPowerObjS;                                  // 0x133C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RagdollPowerObjM;                                  // 0x1340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RagdollPowerObjL;                                  // 0x1344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RagdollPowerObjScale;                              // 0x1348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBerserk;                                         // 0x134C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D9A[0x3];                                     // 0x134D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlyUpTimer;                                        // 0x1350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         FlyUpTime;                                         // 0x1354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         FlyUpHeight;                                       // 0x1358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8D9B[0x4];                                     // 0x135C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FlyUpCurve;                                        // 0x1360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         FlyGroundHeight;                                   // 0x1368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8D9C[0x4];                                     // 0x136C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AiDataTable;                                       // 0x1370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBattleenemy;                                     // 0x1378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsFlyMove;                                         // 0x1379(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsJumpEnd;                                         // 0x137A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsDamageMotionEnd;                                 // 0x137B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsFoodedFlg;                                       // 0x137C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsMoveAnim;                                        // 0x137D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsBrainCrashDead;                                  // 0x137E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsWait;                                            // 0x137F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsHitCheck;                                        // 0x1380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D9D[0x3];                                     // 0x1381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WeakNo;                                            // 0x1384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsWeakEffect;                                      // 0x1388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D9E[0x3];                                     // 0x1389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeakMaterialEmissiveScale;                         // 0x138C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         WeakMaterialEmissiveTimer;                         // 0x1390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHitWeakMaterial;                                 // 0x1394(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          WeakMaterialRateMax;                               // 0x1395(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsMotionCancel;                                    // 0x1396(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8D9F[0x1];                                     // 0x1397(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           WeakMaterialEmissiveCurve;                         // 0x1398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MoveTimer;                                         // 0x13A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         MoveTime;                                          // 0x13A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsWeakObjectRecommend;                             // 0x13A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsWeakDamage;                                      // 0x13A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DA0[0x2];                                     // 0x13AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrainCrashEffectOffset;                            // 0x13AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FWeakObjectEntryEnemy>          WeakObjectEntry;                                   // 0x13B0(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	struct FWeakObjectRecommendEnemy              WeakPoint;                                         // 0x13C0(0x002C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   WeakName;                                          // 0x13EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DistanceFromEnemyToPlayer;                         // 0x13F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         WeakEffectNum;                                     // 0x13F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DA1[0x4];                                     // 0x13FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharactersParameterBasic              CharactersParameterBasicData;                      // 0x1400(0x0068)(Edit, BlueprintVisible, DisableEditOnInstance)
	float                                         OldWeakMaterialRate;                               // 0x1468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         OldWeakEffectRate;                                 // 0x146C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsWeakUiDamageHit;                                 // 0x1470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DA2[0x3];                                     // 0x1471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveDistance;                                      // 0x1474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsMoveWalk;                                        // 0x1478(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DA3[0x7];                                     // 0x1479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           BaseMontage;                                       // 0x1480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UAnimMontage*>                   BaseMontageOld;                                    // 0x1488(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	class UAnimMontage*                           BaseDamageMontage;                                 // 0x1498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsMontageDamageData;                               // 0x14A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DA4[0x3];                                     // 0x14A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ArmorNo;                                           // 0x14A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UDamagePartCollisionComponent*>  WeakComponent;                                     // 0x14A8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	bool                                          MoveFlyToFail;                                     // 0x14B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DA5[0x3];                                     // 0x14B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlyMoveTimer;                                      // 0x14BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<EObjectTypeQuery>                      EEnemyCollisionType;                               // 0x14C0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          IsBeginPlayEnd;                                    // 0x14D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DA6[0x3];                                     // 0x14D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StealthTimer;                                      // 0x14D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         StealthTime;                                       // 0x14D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsCheckGround;                                     // 0x14DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DA7[0x3];                                     // 0x14DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckGroundHeightTop;                              // 0x14E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CheckGroundHeightBottom;                           // 0x14E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        BrainCrashHitWeak;                                 // 0x14E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBattleStart;                                     // 0x14F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DA8[0x3];                                     // 0x14F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmorFlashTimer;                                   // 0x14F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ArmorFlashScale;                                   // 0x14F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   StealthRateName;                                   // 0x14FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   StealthVanishName;                                 // 0x1504(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   SeeThroughStealthRateName;                         // 0x150C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DA9[0x4];                                     // 0x1514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SeeThroughWeakSphereUse;                           // 0x1518(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	class FString                                 SeeThroughWeakSphereLocation;                      // 0x1528(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          IsDeadStartNotify;                                 // 0x1538(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DAA[0x3];                                     // 0x1539(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DamageDir;                                         // 0x153C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EEnemyStealthState                            StealthState;                                      // 0x1548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIsInvisibleHPGauge;                               // 0x1549(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsBranchAction;                                    // 0x154A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DAB[0x1];                                     // 0x154B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IgnoreAiMoveSeconds;                               // 0x154C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class FName>                           AvatarMaterialNames;                               // 0x1550(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class FName                                   AddBaseColor_OilName;                              // 0x1560(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         StealthStartHP;                                    // 0x1568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBT_ForceBreak;                                   // 0x156C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DAC[0x3];                                     // 0x156D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StealthRunAwayTarget;                              // 0x1570(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bCollisionHitWall;                                 // 0x157C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bUniqueAction;                                     // 0x157D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bDebugEnableEnsure_TableNotFound;                  // 0x157E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EEnemyFormType                                FormType;                                          // 0x157F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        CommonDeadEffect;                                  // 0x1580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        BrainCrashDeadEffect;                              // 0x1588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        AvatarDeadEffect;                                  // 0x1590(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UParticleSystem*                        BrainCrashAvatarDeadEffect;                        // 0x1598(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bNotVanish;                                        // 0x15A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsCoreDrop;                                        // 0x15A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CanDropData;                                       // 0x15A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DAD[0x5];                                     // 0x15A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         BrainCrashHitWeakEffectSoftRef;                    // 0x15A8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         CommonDeadEffectSoftRef;                           // 0x15D0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         BrainCrashDeadEffectSoftRef;                       // 0x15F8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         AvatarDeadEffectSoftRef;                           // 0x1620(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         BrainCrashAvatarDeadEffectSoftRef;                 // 0x1648(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          IsEventWait;                                       // 0x1670(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	bool                                          IsEventBerserk;                                    // 0x1671(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	bool                                          IsSpawn;                                           // 0x1672(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	uint8                                         Pad_8DAE[0x1];                                     // 0x1673(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnStartDistance;                                // 0x1674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EnemyActionAnimKind                           ActionSpawn;                                       // 0x1678(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DAF[0x7];                                     // 0x1679(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionEnabled>                     CollisionState;                                    // 0x1680(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          IsSpawnTarget;                                     // 0x1690(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	EnemyKind                                     SpawnEnemyKind;                                    // 0x1691(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsBeforeBrainAccess;                               // 0x1692(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DB0[0x1];                                     // 0x1693(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressBerserkProbability;                        // 0x1694(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsDelayDead;                                       // 0x1698(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DB1[0x3];                                     // 0x1699(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayDeadTime;                                     // 0x169C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FHCHitResult                           DeadBeforeHitResult;                               // 0x16A0(0x01C0)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	float                                         TargetAngle;                                       // 0x1860(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DB2[0x4];                                     // 0x1864(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ARSBattleCharacter_C*                   TargetCharacter;                                   // 0x1868(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHeightCheck;                                     // 0x1870(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn)
	uint8                                         Pad_8DB3[0x7];                                     // 0x1871(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  IsTickEnableComponentArray;                        // 0x1878(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         TickIntervalCounter;                               // 0x1888(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TickIntervalMax;                                   // 0x188C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TickIntervalDefault;                               // 0x1890(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DB4[0x4];                                     // 0x1894(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBadStateParticleData>          EnemyBadStateFlameParticleData;                    // 0x1898(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<class URSParticleSystemComponentBase*> EnemyBadStateFlameParticleHandles;                 // 0x18A8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	TArray<struct FBadStateParticleData>          EnemyBadStateElecParticleData;                     // 0x18B8(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<class URSParticleSystemComponentBase*> EnemyBadStateElecParticleHandles;                  // 0x18C8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	TArray<struct FBadStateParticleData>          EnemyBadStateOilParticleData;                      // 0x18D8(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<class URSParticleSystemComponentBase*> EnemyBadStateOilParticleHandles;                   // 0x18E8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	TArray<struct FBadStateParticleData>          EnemyBadStateFloodedParticleData;                  // 0x18F8(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<class URSParticleSystemComponentBase*> EnemyBadStateFloodedParticleHandles;               // 0x1908(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	EPlayerID                                     TargetID;                                          // 0x1918(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DB5[0x3];                                     // 0x1919(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetIndex;                                       // 0x191C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DamageRatio;                                       // 0x1920(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBendsDirection;                                  // 0x1924(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsOverWriteMotion;                                 // 0x1925(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsMotionReception;                                 // 0x1926(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DB6[0x1];                                     // 0x1927(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnemyAnimControllerComponent*          EnemyAnimConRef;                                   // 0x1928(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           BlendingOutMontage;                                // 0x1930(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           UseBlendOutMontage;                                // 0x1938(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsStealthInfinite;                                 // 0x1940(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DB7[0x3];                                     // 0x1941(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DownBonusScale;                                    // 0x1944(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HideWeak;                                          // 0x1948(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DB8[0x3];                                     // 0x1949(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickIntervalMaxSimple;                             // 0x194C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TickIntervalDefaultSimple;                         // 0x1950(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsSpawnNow;                                        // 0x1954(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DB9[0x3];                                     // 0x1955(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnWaitDelayTime;                                // 0x1958(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SpawnStartDelayTime;                               // 0x195C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SpawnUpdateTime;                                   // 0x1960(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	Enum_EnemySpawnState                          SpawnState;                                        // 0x1964(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DBA[0x3];                                     // 0x1965(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint8, struct FAiParamEnemy>             AiTableDataMap;                                    // 0x1968(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	float                                         DeadEnemyHitStopSeconds;                           // 0x19B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DeadEnemyHitStopRate;                              // 0x19BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPlayerHitStopType                            HitStop_Type;                                      // 0x19C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DBB[0x3];                                     // 0x19C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitStop_Seconds;                                   // 0x19C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         HitStop_Rate;                                      // 0x19C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HitStop_IsStart;                                   // 0x19CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DBC[0x3];                                     // 0x19CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitStop_StartDelayTime;                            // 0x19D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HitStop_IsTarget;                                  // 0x19D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          HitStop_AllThrow;                                  // 0x19D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DBD[0x2];                                     // 0x19D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageAngle;                                       // 0x19D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DBE[0x4];                                     // 0x19DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class USoundAtomCueSheet>> CueSheetRefs;                                      // 0x19E0(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	TArray<class USoundAtomCueSheet*>             CueSheetObjs;                                      // 0x19F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          IsReturn;                                          // 0x1A00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsReturnNow;                                       // 0x1A01(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DBF[0x2];                                     // 0x1A02(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnupdateTime;                                  // 0x1A04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	Enum_EnemySpawnState                          ReturnState;                                       // 0x1A08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DC0[0x3];                                     // 0x1A09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnCurrentWaitDelayTime;                         // 0x1A0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SpawnCurrentStartDelayTime;                        // 0x1A10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SpawnCurrentUpdateTime;                            // 0x1A14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ReturnCurrentUpdateTime;                           // 0x1A18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	Enum_EnemySound                               SoundType;                                         // 0x1A1C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsReverseBlowMotion;                               // 0x1A1D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DC1[0x2];                                     // 0x1A1E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ULevelSequence>          BrainCrashSequenceReference;                       // 0x1A20(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TSoftObjectPtr<class ULevelSequence>          BrainCrashSequenceReference2;                      // 0x1A48(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class ULevelSequence*                         BrainCrashSequenceInstance;                        // 0x1A70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsBlowTurnaround;                                  // 0x1A78(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsDownTurnaround;                                  // 0x1A79(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DC2[0x2];                                     // 0x1A7A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlyUpWaitTimer;                                    // 0x1A7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         FlyUpWaitTime;                                     // 0x1A80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EnemyActionAnimKind                           BerserkSignAction;                                 // 0x1A84(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsReleaseDelayDeath;                               // 0x1A85(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DC3[0x2];                                     // 0x1A86(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReleaseDelayDeathWait;                             // 0x1A88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bCrashChanceDown;                                  // 0x1A8C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          HitCrashDamage;                                    // 0x1A8D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsChangingCrashDamageMaterial;                     // 0x1A8E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DC4[0x1];                                     // 0x1A8F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           CrashDamageMaterialVectorCurve;                    // 0x1A90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CrashDamageMaterialTime;                           // 0x1A98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         PossibleBrainCrashRange;                           // 0x1A9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CrashDamageMaterialScale;                          // 0x1AA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsUniqueBadState;                                  // 0x1AA4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsDamageRotation;                                  // 0x1AA5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DC5[0x2];                                     // 0x1AA6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMoveScale;                                   // 0x1AA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                DamageLocation;                                    // 0x1AAC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FRotator                               CrashChanceBrainRotate;                            // 0x1AB8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	float                                         CrashDamageHighRate;                               // 0x1AC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsNewLaunch;                                       // 0x1AC8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DC6[0x7];                                     // 0x1AC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AnimMontage;                                       // 0x1AD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsEnableLaunch;                                    // 0x1AD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsRequestAddDamageMontage;                         // 0x1AD9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DC7[0x2];                                     // 0x1ADA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeakHitReactionSRate;                              // 0x1ADC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         WeakHitReactionLRate;                              // 0x1AE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         WeakHitDownRate;                                   // 0x1AE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIsDispHp;                                         // 0x1AE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DC8[0x3];                                     // 0x1AE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DispHpTimer;                                       // 0x1AEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CurrentDispHpTimer;                                // 0x1AF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         EnemyCameraShakeRangeL;                            // 0x1AF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         EnemyCameraShakeRangeM;                            // 0x1AF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         EnemyCameraShakeRangeS;                            // 0x1AFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class USoundAtomCue*                          ArmorBreakSE;                                      // 0x1B00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDebugReactionLFlash;                              // 0x1B08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bNotReflectContainer;                              // 0x1B09(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bCrashChanceFly;                                   // 0x1B0A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EHCSkillAttribute                             CurBadStateMaterial;                               // 0x1B0B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsWinceCounter;                                    // 0x1B0C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DC9[0x3];                                     // 0x1B0D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WinceCounter;                                      // 0x1B10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsPressDown;                                       // 0x1B14(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          EnablePressDown;                                   // 0x1B15(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsAcceptKnockBackCounter;                          // 0x1B16(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          EnableKnockBackCounter;                            // 0x1B17(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          EnableWinceCounter;                                // 0x1B18(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DCA[0x3];                                     // 0x1B19(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WinceCount;                                        // 0x1B1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsKnockBackCounter;                                // 0x1B20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DCB[0x7];                                     // 0x1B21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         BrainCrashSequenceInstance2;                       // 0x1B28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDiscoveredTarget;                                 // 0x1B30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DCC[0x3];                                     // 0x1B31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiscoverIconOffsetHeight;                          // 0x1B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableFitGround;                                  // 0x1B38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DCD[0x3];                                     // 0x1B39(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FitGroundSpeed;                                    // 0x1B3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         FitGroundAngleLimit;                               // 0x1B40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bChangingWeakDamageMaterial;                       // 0x1B44(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DCE[0x3];                                     // 0x1B45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeakDamageMaterialTime;                            // 0x1B48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         WeakDamageMaterialScale;                           // 0x1B4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   WeakMaterialSlotName;                              // 0x1B50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMaterialInstanceDynamic*               WeakMaterialInst;                                  // 0x1B58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCurveVector*                           WeakDamageMaterialVectorCurve;                     // 0x1B60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bBeforeUniqueObjState;                             // 0x1B68(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bUniqueObjState;                                   // 0x1B69(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DCF[0x2];                                     // 0x1B6A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AvoidInvalidLength;                                // 0x1B6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<EnemyAliveAnimKind>                    AvoidEnableActionKind;                             // 0x1B70(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<float>                                 AvoidProbabilityList;                              // 0x1B80(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bEnableAvoidObject;                                // 0x1B90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DD0[0x7];                                     // 0x1B91(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_co2000Base_C*                       BrainCoreReference;                                // 0x1B98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class ULevelSequence>          BossBrainCrashSequenceReference;                   // 0x1BA0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TSoftObjectPtr<class ULevelSequence>          BossBrainCrashSequenceReference2;                  // 0x1BC8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class ULevelSequence*                         BossBrainCrashSequenceInstance;                    // 0x1BF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ULevelSequence*                         BossBrainCrashSequenceInstance2;                   // 0x1BF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsLastBossBrainCrash;                              // 0x1C00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DD1[0x3];                                     // 0x1C01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCrashResistance;                                // 0x1C04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bPressDownLoop;                                    // 0x1C08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DD2[0x3];                                     // 0x1C09(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PressLoopTime;                                     // 0x1C0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TargetHeight;                                      // 0x1C10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         HeightFromEnemyToPlayer;                           // 0x1C14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         HeightFromEnemyInitToPlayer;                       // 0x1C18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableDiscoverIcon;                               // 0x1C1C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DD3[0x3];                                     // 0x1C1D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckCapsuleRadius;                                // 0x1C20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableRequestIK;                                  // 0x1C24(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DD4[0x3];                                     // 0x1C25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            WeakMaterialRateCurveData;                         // 0x1C28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EDeadFactor                                   MyDeadFactor;                                      // 0x1C30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DD5[0x7];                                     // 0x1C31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  bStartWeakAroundEffect;                            // 0x1C38(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bEnableLookAt;                                     // 0x1C48(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bUpdateBadStateMaterial;                           // 0x1C49(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DD6[0x2];                                     // 0x1C4A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BadStateMaterialCurveTime;                         // 0x1C4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bBrainCrashMiss;                                   // 0x1C50(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsChangeCharacterCollision;                        // 0x1C51(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DD7[0x6];                                     // 0x1C52(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MoveScaleCurveData;                                // 0x1C58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bReceivedNotifyLookAt;                             // 0x1C60(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bEnableWander;                                     // 0x1C61(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DD8[0x2];                                     // 0x1C62(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoreWeakEffect_CommonRate;                         // 0x1C64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CoreWeakEffect_AttachRate;                         // 0x1C68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LaunchDownTime;                                    // 0x1C6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsLaunchDown;                                      // 0x1C70(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DD9[0x7];                                     // 0x1C71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CurBadStateCurve;                                  // 0x1C78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCurveFloat*                            BadStateCurveFlame;                                // 0x1C80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCurveFloat*                            BadStateCurveElec;                                 // 0x1C88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class FName>                           DebugPrintSlotName;                                // 0x1C90(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash)
	TArray<uint8>                                 DebugIgnoreActions;                                // 0x1CA0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	int32                                         BadStateStartDamageMotion;                         // 0x1CB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableFitGroundTmp;                               // 0x1CB4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          EndFitGround;                                      // 0x1CB5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsStartHideArmor;                                  // 0x1CB6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bBrainFieldSealWeakParticle;                       // 0x1CB7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	class FName                                   BrainFieldClaimantName;                            // 0x1CB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDamageFloating;                                   // 0x1CC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DDA[0x7];                                     // 0x1CC1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 SaveBodyEmissiveValue;                             // 0x1CC8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          bExecLowProcess;                                   // 0x1CD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DDB[0x3];                                     // 0x1CD9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BrainInitPos;                                      // 0x1CDC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EnemyMoveAnimKind                             DownUpMoveAnimKind;                                // 0x1CE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DDC[0x3];                                     // 0x1CE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReactionChangeDilationTimer;                       // 0x1CEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   TopHeightSocketName;                               // 0x1CF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIdleMove;                                         // 0x1CF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DDD[0x7];                                     // 0x1CF9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URSParticleSystemComponentBase*         DeadEffectHandle;                                  // 0x1D00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDisableWeakAroundEffect;                          // 0x1D08(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bLaunchIgnorePriority;                             // 0x1D09(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EnemyDamageDownAnimKind                       SavedDamageDown;                                   // 0x1D0A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DDE[0x5];                                     // 0x1D0B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBadStateAddParticleData               EnemyBadStateAddFlameParticleData;                 // 0x1D10(0x0028)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FBadStateAddParticleData               EnemyBadStateAddElecParticleData;                  // 0x1D38(0x0028)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FBadStateAddParticleData               EnemyBadStateAddOilParticleData;                   // 0x1D60(0x0028)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FBadStateAddParticleData               EnemyBadStateAddFloodedParticleData;               // 0x1D88(0x0028)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         BadStateAddEffectOffset;                           // 0x1DB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TickIntervalSeconds;                               // 0x1DB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableEnemyGoal;                                  // 0x1DB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bAdjustCharaCapsule;                               // 0x1DB9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DDF[0x2];                                     // 0x1DBA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AdjustCharaCapsuleName;                            // 0x1DBC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                AdjustCharaCapsuleOffset;                          // 0x1DC4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AdjustCharaCapsuleInterpTime;                      // 0x1DD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CurrentAdjustCharaCapsuleInterpTime;               // 0x1DD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bAdjustInterpCharaCapsule;                         // 0x1DD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DE0[0x7];                                     // 0x1DD9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           WeakTargetSocketName;                              // 0x1DE0(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	class UParticleSystem*                        CrashChanceLoopEffect;                             // 0x1DF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class UParticleSystem>         CrashChanceLoopEffectSoftReference;                // 0x1DF8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         CrashChanceLoopEffectHandle;                       // 0x1E20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bNewDamageFloating;                                // 0x1E28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsLaunchTurnaround;                                // 0x1E29(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DE1[0x2];                                     // 0x1E2A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EyeSocketName;                                     // 0x1E2C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FEnemyFindChangeParam                  FindChangeParam;                                   // 0x1E34(0x0010)(Edit, BlueprintVisible, NoDestructor)
	EEnemyFindPlayerType                          LastDetectIcon;                                    // 0x1E44(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsSpecialDownFlyRot;                               // 0x1E45(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         ChangeCharaCollisionNo;                            // 0x1E46(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DE2[0x1];                                     // 0x1E47(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCapsuleComponent*>              CharaCollisionList;                                // 0x1E48(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	bool                                          bInvincible;                                       // 0x1E58(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DE3[0x3];                                     // 0x1E59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseMontageStartTime;                              // 0x1E5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          PreviousMaterialSwitchStealth;                     // 0x1E60(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DE4[0x7];                                     // 0x1E61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMaterialSwitchCache                   MaterialSwitchCache;                               // 0x1E68(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	EnemyMoveAnimKind                             SpawnMoveAnim;                                     // 0x1E78(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DE5[0x3];                                     // 0x1E79(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UniqueName;                                        // 0x1E7C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHiddenFirstDiscoverIcon;                         // 0x1E84(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsStartOnStealth;                                  // 0x1E85(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsIgnoreRestrictAttackOther;                       // 0x1E86(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsIgnoreAllowance;                                 // 0x1E87(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsNoCheckCaptureArea;                              // 0x1E88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsChangeSearchAngle;                               // 0x1E89(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DE6[0x2];                                     // 0x1E8A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeSearchAngle;                                 // 0x1E8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAlwaysChangeSearchAngle;                         // 0x1E90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsChangeSearchRange;                               // 0x1E91(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DE7[0x2];                                     // 0x1E92(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeSearchRange;                                 // 0x1E94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAlwaysChangeSearchRange;                         // 0x1E98(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsChangeSensingArea;                               // 0x1E99(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DE8[0x2];                                     // 0x1E9A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeSensingArea;                                 // 0x1E9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAlwaysSensingArea;                               // 0x1EA0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsChangeCaptureArea;                               // 0x1EA1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DE9[0x2];                                     // 0x1EA2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeCaptureArea;                                 // 0x1EA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAlwaysCaptureArea;                               // 0x1EA8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsChangeTerritoryArea;                             // 0x1EA9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DEA[0x2];                                     // 0x1EAA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeTerritoryArea;                               // 0x1EAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAlwaysTerritoryArea;                             // 0x1EB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsChangeRepopTime;                                 // 0x1EB1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DEB[0x2];                                     // 0x1EB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeRepopTime;                                   // 0x1EB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsChangeRepopRange;                                // 0x1EB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DEC[0x3];                                     // 0x1EB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeRepopRange;                                  // 0x1EBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsChangeRepopTimeTerritory;                        // 0x1EC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DED[0x3];                                     // 0x1EC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChangeRepopTimeTerritory;                          // 0x1EC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DamageStealthHalfTime;                             // 0x1EC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsStealthHalfNeedUpdate;                           // 0x1ECC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DEE[0x3];                                     // 0x1ECD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StealthHalfParam;                                  // 0x1ED0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsStealthHalfParamUp;                              // 0x1ED4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsNotAddedBattleManager;                           // 0x1ED5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsHitWeek;                                         // 0x1ED6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DEF[0x1];                                     // 0x1ED7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EHCSkillExtraType>                     SkillExtraType;                                    // 0x1ED8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class URSParticleSystemComponentBase*         DetectIconEffect;                                  // 0x1EE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FGameTimer                             DetectIconTimer;                                   // 0x1EF0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsDownSasFlagIgnoreDownTrigger;                    // 0x1EFC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsKnockbackSasFlagIgnoreKnockbackTrigger;          // 0x1EFD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsDownSasFlagIgnoreDownTriggerFlag;                // 0x1EFE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsKnockbackSasFlagIgnoreKnockbackTriggerFlag;      // 0x1EFF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bEnableWeak;                                       // 0x1F00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DF0[0x7];                                     // 0x1F01(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReserveMontage;                                    // 0x1F08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UBP_EnemyFixParam_C*                    EnemyFixParam;                                     // 0x1F10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsChangeSearchParam;                               // 0x1F18(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DF1[0x3];                                     // 0x1F19(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ET_StopID;                                         // 0x1F1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FGameTimer                             LostActionTimer;                                   // 0x1F20(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	float                                         EnableLostActionTime;                              // 0x1F2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDisableLostAction;                                // 0x1F30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DF2[0x3];                                     // 0x1F31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LostActionProbability;                             // 0x1F34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FST_emLostActionInfo>           LostActionInfoList;                                // 0x1F38(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash)
	float                                         ActivityAreaOutTimer;                              // 0x1F48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ActivityAreaOutDistance;                           // 0x1F4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                InitGroundPos;                                     // 0x1F50(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LostMoveTimeMin;                                   // 0x1F5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LostMoveTime_Max;                                  // 0x1F60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LostMoveRotationRate;                              // 0x1F64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bUseDefaultSpawnSearchParam;                       // 0x1F68(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DF3[0x7];                                     // 0x1F69(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ULevelSequence>          GeneralBrainCrashSequenceReference;                // 0x1F70(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class ULevelSequence*                         GeneralBrainCrashSequenceInstance;                 // 0x1F98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ARSLevelSequenceActor*                  GeneralBcSequencerActor;                           // 0x1FA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCurveFloat*                            NormalWeakMaterialRateCurveData;                   // 0x1FA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         NormalWeakMaterialScale;                           // 0x1FB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DF4[0x4];                                     // 0x1FB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            NormalWeakMaterialEmissiveCurve;                   // 0x1FB8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         NormalWeakMaterialEmissiveMax;                     // 0x1FC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         NormalWeakMaterialEmissiveMin;                     // 0x1FC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         NormalWeakMaterialRateMax;                         // 0x1FC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         NormalWeakMaterialRateMin;                         // 0x1FCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bStopWeakEmissive;                                 // 0x1FD0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bEnemyArmorBreak;                                  // 0x1FD1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bNoBrainCore;                                      // 0x1FD2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bHitReactionTrigger;                               // 0x1FD3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DF5[0x4];                                     // 0x1FD4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BadStateCurveFlameEnd;                             // 0x1FD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCurveFloat*                            BadStateCurveElecEnd;                              // 0x1FE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_EnemyManager_C*                     LEnemyManager;                                     // 0x1FE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	Enum_EnemyAiType                              CurrentAiType;                                     // 0x1FF0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DF6[0x7];                                     // 0x1FF1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<Enum_EnemyAiType, struct FST_emChangeAiTypeInfo> ChangeAiTypeInfoList;                              // 0x1FF8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	EMovementMode                                 SpawnMovementMode;                                 // 0x2048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DF7[0x3];                                     // 0x2049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalWeakMaterialEmissivePowerMin;                // 0x204C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         NormalWeakMaterialEmissivePowerMax;                // 0x2050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         WeakMaterialEmissivePowerMax;                      // 0x2054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         WeakMaterialPointRateMax;                          // 0x2058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EAssassinAttackHit                            AssassinAttackHitType;                             // 0x205C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsRepop;                                           // 0x205D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DF8[0x2];                                     // 0x205E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepopTime;                                         // 0x2060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RepopRange;                                        // 0x2064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         RepopProbability;                                  // 0x2068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAreaOut;                                         // 0x206C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DF9[0x3];                                     // 0x206D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             AreaOutTimer;                                      // 0x2070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	int32                                         AreaOutSequence;                                   // 0x207C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsStealthEndLaunch;                                // 0x2080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsStealthEndLaunchEdit;                            // 0x2081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          EnableDeadEffect;                                  // 0x2082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bNoDisplayDiscoverIcon;                            // 0x2083(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DFA[0x4];                                     // 0x2084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EnemyMoveAnimKind>                     GoHomeAminKind;                                    // 0x2088(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	class FName                                   RowNameAnimScaleHitStop;                           // 0x2098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsAnimScaleChangingHitStop;                        // 0x20A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsAnimScaleChangingHitStopSlow;                    // 0x20A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bDiscoveredOnce;                                   // 0x20A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bDiscoverClosed;                                   // 0x20A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsBrainCrashDamageDown;                            // 0x20A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsUseBrainCrashAfterMotion;                        // 0x20A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DFB[0x2];                                     // 0x20A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             PathAreaOutTimer;                                  // 0x20A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	EEnemyTickPriorityType                        TickProirity;                                      // 0x20B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8DFC[0x3];                                     // 0x20B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickSumRealSeconds;                                // 0x20B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TickRealSeconds;                                   // 0x20BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ExecTick;                                          // 0x20C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DFD[0x3];                                     // 0x20C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickSumActorSeconds;                               // 0x20C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TickActorSeconds;                                  // 0x20C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsOutOfBattlefield;                                // 0x20CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bDefeatedMainPlayer;                               // 0x20CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DFE[0x2];                                     // 0x20CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UroOffLength;                                      // 0x20D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          UpdateWeakMaterialEnable;                          // 0x20D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8DFF[0x3];                                     // 0x20D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         WeakSlotNameList;                                  // 0x20D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         OldWeakMaterialEmissiveTime;                       // 0x20E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          EnableUpdateSeeThrought;                           // 0x20EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          EndSetSpawnParam;                                  // 0x20ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          SimpleEnemy;                                       // 0x20EE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	Enum_EnemyBrainFieldProgress                  BrainFieldProgress;                                // 0x20EF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bUseWaitNoInterpolation;                           // 0x20F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E00[0x3];                                     // 0x20F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               InitRotationRate;                                  // 0x20F4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          DisableCheckAreaOut;                               // 0x2100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          StopUpdateEnemyTickEnable;                         // 0x2101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          StopUpdateAreaCheck;                               // 0x2102(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E01[0x1];                                     // 0x2103(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HitStop_Skillname;                                 // 0x2104(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HitStop_SlowOnce;                                  // 0x210C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E02[0x3];                                     // 0x210D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoAttackTargetChangeSecond;                        // 0x2110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          SetHideWeakEffect;                                 // 0x2114(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          SetVisibleWeakEffect;                              // 0x2115(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E03[0x2];                                     // 0x2116(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxEvDitherTime;                                   // 0x2118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CurrentEvDitherTime;                               // 0x211C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEvDitherDisp;                                     // 0x2120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E04[0x7];                                     // 0x2121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_TriggerEffectManager_C*             TrgEffMgr;                                         // 0x2128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         EnumBossBattleBegineAction;                        // 0x2130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHideCoreTimingOld;                               // 0x2131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsCrashChanceLoopStart;                            // 0x2132(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsDuringEventSpawnNow;                             // 0x2133(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E05[0x4];                                     // 0x2134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DeadMontage;                                       // 0x2138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           DownDeadMontage;                                   // 0x2140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         UniqueTickEnableRange;                             // 0x2148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AreaOutTime;                                       // 0x214C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsDeadMainTick;                                    // 0x2150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E06[0x3];                                     // 0x2151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitFloorTimer;                                     // 0x2154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnableTickMeshOnly;                               // 0x2158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E07[0x3];                                     // 0x2159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AreaOutOffsetRange;                                // 0x215C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AllowanceWaitSeconds;                              // 0x2160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsTickMove;                                        // 0x2164(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bAlreadyDroppedItem;                               // 0x2165(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bEnableDeadCleanup_DroppedItem;                    // 0x2166(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          IsEventDeath;                                      // 0x2167(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bUpDownWait;                                       // 0x2168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          NoChangeAnimRateCrashChanceAccelerate;             // 0x2169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E08[0x2];                                     // 0x216A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NowMinTickCount;                                   // 0x216C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UActorComponent*                        DebugEnemyBtlLog;                                  // 0x2170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         ActorLocationID;                                   // 0x2178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         ActorAreaID;                                       // 0x217C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsRepopping;                                       // 0x2180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsCheckSameFloor;                                  // 0x2181(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bPlayedPressKillMontage;                           // 0x2182(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E09[0x5];                                     // 0x2183(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_PsychicObjectBasic_C*               StateUniqueObject;                                 // 0x2188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FBattleSimulatorRareSpawnCondisionData RareSpawnCondisionData;                            // 0x2190(0x0038)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UDataTable*                             CrashVisionEffectTable;                            // 0x21C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<TSoftObjectPtr<class UParticleSystem>> CrashVisionHitEffectList;                          // 0x21D0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<TSoftObjectPtr<class UParticleSystem>> CrashVisionHitUniqueEffectList;                    // 0x21E0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	float                                         SpawnUpdateTimeOnlyBattleSimulator;                // 0x21F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          OutPutRareSpawnResultLog;                          // 0x21F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          CheckRareSpawnHpRate_0;                            // 0x21F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          IsRareSpawnCheckAtHpRate;                          // 0x21F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          PlayedBrainTalkBattleStartSimulator;               // 0x21F7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bAvatarCopyTags;                                   // 0x21F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_8E0A[0x3];                                     // 0x21F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             SimulatorStartMoveDelayTimer;                      // 0x21FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	struct FGameTimer                             EnableLostActionTimer;                             // 0x2208(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	EnemyActionAnimKind                           CurrentLostAction;                                 // 0x2214(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_8E0B[0x3];                                     // 0x2215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameTimer                             LostActionResetTimer;                              // 0x2218(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bLostActionResetTick;                              // 0x2224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)

public:
	void ExecuteUbergraph_RSBattleEnemy(int32 EntryPoint);
	void UnbindLostActionResetTick();
	void BindLostActionResetTick();
	void OnHitCrashVisionAttack();
	void OnDeadCrashVision();
	void UpdateOutRangeFade_Native(float ToTargetLenge, bool ForceDisp);
	void AddResetSecondRate();
	void UpdatePreviousElapsedTime(float ElapsedTime);
	void OnFinishSpawnWaitDelayTimer();
	void OnAbsorption();
	void OnGeneralEnemyBreak();
	void OnGeneralFloat();
	void OnSpawnStartCharaCondition();
	void OnDeadBrainCrash();
	void OnFellOutOfWorld();
	void SetEmPosDiscover(const struct FVector& DiscoverPos);
	void ReceiveDestroyed();
	void ReceiveMontageBlendingOut(class UAnimMontage* Montage, bool Interrupted);
	void ResetTargetHateEvent();
	void BndEvt__CapsuleComponent_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void EventPhysicsIdling(float IdlingSec, float IdleRestoreDelay);
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void BadStateEffectOn(EHCBadState bad);
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_1_BadStateOffDelegate__DelegateSignature(EHCBadState bad_state);
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_0_BadStateOnDelegate__DelegateSignature(EHCBadState bad_state, class AActor* Attacker);
	void BndEvt__DamageAccept_K2Node_ComponentBoundEvent_0_DamageHitDelegate__DelegateSignature(const struct FHCHitResult& HitResult, int32 Damage);
	void SetSuperArmor(bool bSuperArmor, class FName ClaimantName);
	void DamageAfter(TArray<struct FHCHitResult>& Result);
	void ReceiveBeginPlay();
	void ReceiveTick(float DeltaSeconds);
	void HideCore();
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_1_BrainCrashAccessOnDelegate__DelegateSignature();
	void BndEvt__CharactersParameter_K2Node_ComponentBoundEvent_0_BrainCrashAccessOffDelegate__DelegateSignature();
	void OnBrainCrashEnd(bool bBeginActor, class UAnimMontage* PlayerEndMontage);
	void OnBrainCrashDead();
	void OnBrainCrashDamage();
	void OnBrainCrashStart(bool bBeginActor);
	void One2_SetParameterDefaultRepopTimeTerritory();
	void One1_SetParameterDefaultRepopRange();
	void One0_SetParameterDefaultRepopTime();
	void Zero4_SetParameterDefaultTerritoryArea();
	void Zero3_SetParameterDefaultCaptureArea();
	void Zero2_SetParameterDefaultSensingArea();
	void Zero1_SetParameterDefaultSearchRange();
	void Zero0_SetParameterDefaultSearchAngle();
	void OnUnDiscovery();
	void OnDiscovery();
	void UpdateDeadStaging(float DeltaSeconds, bool* Dummy);
	void StartDeadStaging();
	void OnDeadCoreEnemy();
	void StartDamageAnimFunc(const struct FHCHitResult& HitResult, int32 DamageValue, bool IsDown, bool* Dummy);
	void BeginMoveBackward(bool* Result);
	void EndMoveBackward(bool* Result);
	void IsAbleMove(bool* IsAble);
	void GetHeadLocation(struct FVector* Location);
	void OnDamageActorHit(struct FHCHitResult& HitResult, bool* Dummy);
	void OnDead(bool* Dummy);
	void OnRevive(bool* Dummy);
	void SetBattling(bool bBattling, bool* Dummy);
	void On_Hit_Damage(TArray<struct FHCHitResult>& Result);
	void IsEnableMoveRange(bool* Return);
	void SetTargetPlayer();
	void UpdateLayoutStartUp();
	void SetParamEnemy();
	void IsDistanceAngleCheck(class AActor* Target, const struct FVector& TargetLocation, float Range, float Angle, const struct FRotator& Rot, bool NoHeight, const struct FVector& SelfLocation, bool SelfLocationOn, bool* Bool);
	void IsShortDistance(bool* Return);
	void IsMiddleDistance(bool* Return);
	void OnHitDamageCall(TArray<struct FHCHitResult>& Result, bool* Ret);
	void IsLongDistance(bool* Return);
	void DebugDamagePartHit(const struct FHCHitResult& Result, int32 Da_age);
	void MainTick(float DeltaSeconds, bool* Dummy);
	void DamageMotionEnd(float DeltaTime);
	void GetEnemySound(Enum_EnemySound* Return);
	struct FVector GetTargetCursorLocation();
	void GetBrainCrashDamageLocation(struct FVector* WorldLocation);
	void IsDamageDownWait(bool* Return);
	void DamageDownCheck(float Timer);
	void FlyDown(bool* IsEnd);
	void UpdateEnemyHp(bool BossOnly);
	void IsTargetBoss(bool* Ret);
	void NoNavMoveRotation(float Sec);
	void PlayAnimDamageMontage(class UAnimMontage* Montage);
	void RequestDamageMotion(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, bool IsSideDamage, class UPrimitiveComponent* Primitive, bool PsychicObjectCombo, const struct FHCSkillCommonInfo& Skill, class AActor* Attacker, class AActor* AttackObj, bool WasStartDamage);
	void SetAliveAnim(EnemyAliveAnimKind Alive);
	void Get_Param_Table_Resistance(EEnemyDamageType Damage, float* Resistance);
	void GetParamBasicAccumulation(EEnemyDamageType Damage, float* Accumulation);
	void SetDamageAnim(EnemyDamageAnimKind Alive, class UPrimitiveComponent* Primitive);
	void SetDamageDownAnim(EnemyDamageDownAnimKind Damage);
	void IsDamageAngle(const struct FVector& Location, float Angle, float RotZ, bool* Ret);
	float TimerDecrement(float Base, float Time);
	void UpdateTargetDistance();
	void BrainCrashDamage();
	void UpdateMotionFootParam(float Sec);
	void GetMotionFootParamCheck(TArray<bool>* MotionParam);
	void IsMotionFootParam(Enum_EnemyMotionParam MotionParam, bool* Ret);
	void UpdateMotionFootLock(float Sec);
	void UpdateDeadBoss(float Sec);
	void SetPhysics(class FName Param_Name, bool On, bool IncludeSelf);
	void AddRagdollPower(class FName Param_Name, const struct FVector& Power);
	void SetRagdollDamage(TArray<struct FHCHitResult>& Result);
	void SetRotationRate(float Rate, bool Reset);
	void ChangeRagdollBoneName();
	void CalcIntegerScale(TArray<int32>& Num, float Scale, TArray<int32>* Return);
	void CalcFloatScale(TArray<float>& Num, float Scale, TArray<float>* Return);
	void IsPsychicObjectCombo(const struct FHCHitResult& HCHitResult, bool* Return);
	void FlyUp(float Sec);
	void AddEnemyListManager();
	void GetAiDataTable(uint8 Enum, bool NoProblemNotFound, struct FAiParamEnemy* Param);
	void GetAiDataTableString(uint8 Enum, class FString* Param);
	void Set_Enemy_Target_Battle();
	void ResetEnemyTargetBattle();
	void OnAttackActorHit(const struct FHCHitResult& HitResult, bool* Dummy);
	void SetDamageElecDown(EHCBadState bad);
	void UpdateDamageAnim(bool* DamageEnd, bool* DamageDownEnd);
	void SetAnimRootMotionScale(float Scale);
	void UpdateFloodedAnimRootMotionScale();
	void IsFloodedAnimRootMotionScale(bool* Bool);
	void UpdateBrainCrashMotionCheck(float Timer);
	void OnBrainFieldStart(bool MoveBrainField, bool* Dummy);
	void OnBrainFieldEnd(bool MoveBrainField, bool* Dummy);
	void SetMoveRootMotion(bool On);
	void StopDamageMontage();
	void NotDamageMontage(bool* Return);
	void DamageMontage(TArray<struct FHCHitResult>& Result, bool* Damage_Enable);
	void WeakMaterialRate(float DeltaSec, bool* Ret);
	void WeakMaterialEmissiveRate(float Sec);
	void IsHitWeak(class UPrimitiveComponent* Primitive, struct FHCSkillCommonInfo& SkillInfo, bool* Return);
	void IsHitPart(class UPrimitiveComponent* Primitive, int32 No, bool* Return);
	void WeakMaterialHitDamage(TArray<struct FHCHitResult>& Result);
	void IsNotTarget(bool* Return);
	void IsEvent(bool* Return);
	void DeadCleanup();
	void UpdateMoveTimer(float Sec);
	void IsMoveCheck(bool* Return);
	void SetMoveRun(bool* Return);
	void SetMoveWalk(bool* Return);
	void GetAiTimer(uint8 Enum, float* AiTimer);
	void SetAiTimer(uint8 Enum, bool* Return);
	void UpdateWeakUIDisplay();
	void WeakDamageHitCheck(TArray<struct FHCHitResult>& Result);
	void WeakObjectRecommend();
	void AddWeakObjectRecommend(const struct FWeakObjectRecommendEnemy& Param);
	void RemoveWeakObjectRecommend(const struct FWeakObjectRecommendEnemy& Param);
	void DedugDrawWeakObjectRecommend();
	bool SetEventVisible(bool Visible);
	struct FVector GetBrainCrashEffectLocation();
	void WeakObjectUIIconUpdate(int32 Param_Index, bool Draw);
	void CalcTick();
	void SetMoveTo();
	void SetAttackWeakHit(class ARSBattlePlayer_C* Player, const struct FHCHitResult& Result);
	void SetHomeLocation();
	void SetTargetHate(class AActor* TargetActor);
	void GetTargetHate(TArray<class AActor*>* Target);
	void ResetTargetHate();
	void GetTargetLockHate(class AActor** Actor);
	void SubEnemyListManager();
	void WeakUiDamageHit();
	void SetMoveCheck(bool* Return);
	void IsMoveCheckDistance(bool* Return);
	void IsSuperArmor(bool* bSuperArmor);
	void IsDamageSuperArmor(bool* Return);
	void SetBaseMontage(class UAnimMontage* Param_BaseMontage);
	void GetBaseMontage(class UAnimMontage** Param_BaseMontage);
	bool IsMotionEnd();
	void DebugWeakHitArea();
	void SetWeakComponent();
	bool IsIgnoreHitCheck(class UPrimitiveComponent* PPrimitive, const struct FVector& HitPosition);
	void GetHitObjectType(TArray<EObjectTypeQuery>* ObjectType);
	float CalcFinalDamageByDefence(float Damage, class AActor* AttackActor);
	void OnStealth(bool IsDirectly, bool* Return);
	void UpdateStealth(float Sec);
	void IsStealthEnable(bool* Return);
	void OffStealth(bool* Return);
	void ChangeStealth(bool StealthSee, bool* Return);
	void IsRandomLocationCheckGround(bool* IsCheck);
	void SetRandomLocationCheckGround(bool IsCheck);
	void SetRandomLocationCheckGroundHeight(float Top, float Bottom);
	void OnEnemyAssetLoad(bool* Return);
	void LandCheck(bool* IsLand);
	void HitDamageMaterialArmor(TArray<struct FHCHitResult>& Result);
	void Update_Hit_Damage_Material_Armor(float Sec, float* Time);
	void SeeThroughWeakSphereUseOnOff(bool On);
	void WeakHitStop(TArray<struct FHCHitResult>& HitResult, bool IsMaterialChange);
	void GetCTTimer(uint8 EnemyEnum, float* LastTimer);
	void SetCTTimer(uint8 EnemyEnum, float Value);
	void GetActionTime(uint8 EnemyEnum, float* Time);
	void GetEnemySoundEnum(Enum_EnemySound* SoundEnum);
	void Stealth_End(bool* Return);
	void CounterAttack(EHCSkillAttackType AttackType, class AActor* Attacker, bool Param_IsHitWeek, bool* Dummy);
	void GetRandomRangeLocation(const struct FVector& SrcLocation, const struct FVector& TargetLocation, float RangeMin, float RangeMax, bool CheckWall, struct FVector* NewLocation, bool* IsSuccess);
	void SetInvisibleHPGauge(bool bInvisible);
	void DeadDropItem();
	void DeadAvatar();
	void GetStealthTargetActor(class AActor** TargetActor);
	void IsSeeThroughBreak(bool StealthSeeBreak, bool* IsSeeBreak);
	void DeadStart();
	void SetEnableDamageCollision(const class FString& CollisionName, ECollisionEnabled CollisionEnable);
	void ResetCollisionHitWall();
	void Dead_Effect(bool IsAvatar);
	void DebugDisplayAction(bool* Dummy);
	void DebugDisplayFront();
	void SetEnableDamageCollisions(TArray<class FString>& CollisionNames, ECollisionEnabled CollisionEnable);
	void ResetTargetHateEventCore();
	void InitSpawn();
	void SetSpawnCollisionState();
	void SetSpawnVisibility();
	void SetBrainCrashState();
	void UpdateDelayDead(float DeltaSeconds);
	void SetDelayDead(bool* Return);
	void InitializeActionTable();
	void IsSkipLowPriorityTick(float DeltaSeconds, bool IsSimple, bool* Skip);
	void DebugDisplayAiData();
	void DebugSetAiData(int32 AiEnum, float Probability);
	void DebugResetAiData();
	void BadStateEffectOnFlame(bool* bDummy);
	void BadStateEffectOffFlame(bool* bDummy);
	void Kick_Bad_State_Effect(TArray<struct FBadStateParticleData>& ParticleParams, bool bAttachLocationOnly, TArray<class URSParticleSystemComponentBase*>* NewParam);
	void StopBadStateEffect(TArray<class URSParticleSystemComponentBase*>& ParticleHandles);
	void KickBadStateEffectOne(struct FBadStateParticleData& ParticleParam, bool bAttachLocationOnly, TArray<class URSParticleSystemComponentBase*>* OutHandles);
	void BadStateEffectOnElec(bool* bDummy);
	void BadStateEffectOffElec(bool* bDummy);
	void BadStateEffectOnOil(bool* bDummy);
	void BadStateEffectOffOil(bool bNoMaterial, bool* bDummy);
	void BadStateEffectOnFlooded(bool* bDummy);
	void BadStateEffectOffFlooded(bool bNoMaterial, bool* bDummy);
	void RestoreHateData();
	void SetHateData(class ARSCharacterBase* TargetActor, int32 Param_Index);
	void IsContinuityDamageMotion(EnemyAliveAnimKind AliveAnimKind, bool* Dummy);
	void ReplaceHitResult(const struct FHCHitResult& HitResult, struct FHCHitResult* ReturnHitResult);
	void SetCanDropData(bool Param_CanDropData);
	void GetCanDropData(bool* Return);
	void SetupAnimController(bool* Dummy);
	void SetStealth(bool* Dummy);
	bool CalcAccumulationByDefence(float& RefWince, float& RefKnockback, float& RefDown, float& RefLaunch, float& RefFlame, float& RefElectric, float& RefFlooded, float& RefOil, float& RefConfusion, float& RefCrashScale, float& RefCrashCapCheckRate, class AActor* AttackActor);
	void UpdateSpawn(float DeltaSec);
	void SpawnWaitUpdate(float DeltaSec);
	void SpawnStartUpdate(float DeltaSec, bool* bEnd);
	void ReceivedNotifyAnimEnd(bool* Received);
	void SetDelayDeath(bool* Dummy);
	void UpdateHitStop(float DeltaSec);
	void LoadSound(bool* Dummy);
	void UnloadSound(bool* Dummy);
	void OnDestroy(bool* Dummy);
	void OnEnemyAssetUnload(bool* Dummy);
	void UpdateReturn(float DeltaSec);
	void ResetAction(bool* Dummy);
	void LoadSequence(bool* Dummy);
	void UnloadSequence(bool* Dummy);
	void StartFinishMove(bool* IsStart);
	void CheckDeadHitStop();
	void UpdateDelayDeath();
	void StartCrashDamageMaterial();
	void UpdateCrashDamageMaterial(float DeltaSec);
	void IsHitCrashDamage(class UPrimitiveComponent* Primitive, struct FHCSkillCommonInfo& SkillInfo, bool* Return);
	void IsUniqueDownCondition(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, class UPrimitiveComponent* Primitive, bool PsychicObjectCombo, const struct FHCSkillCommonInfo& Skill, class AActor* Attacker, bool* bDown);
	void GetLockOnTargetInterface(class AActor** TargetActor);
	void OnStartDamageDown(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, class UPrimitiveComponent* Primitive, const struct FHCSkillCommonInfo& Skill, class AActor* Attacker, bool* Dummy);
	void OnStartDamageSmall(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, class UPrimitiveComponent* Primitive, const struct FHCSkillCommonInfo& Skill, class AActor* Attacker, bool* Dummy);
	void OnStartDamageLarge(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, class UPrimitiveComponent* Primitive, const struct FHCSkillCommonInfo& Skill, class AActor* Attacker, bool* Dummy);
	void GetAiUniqueCondition(uint8 ConditionNo, bool* bResult);
	void BadStateOnHateAdd(EHCBadState BadState, class AActor* Attacker);
	void DebugDisplayHateData();
	void RequestLaunchMotion(const struct FHCSkillCommonInfo& Skill, bool* IsSuccess);
	void CheckReactionHitStop(class AActor* Attacker, EPlayerHitStopType Type, EHCHitStopCauseType CauseType, bool bIgnoreTarget, const struct FHCSkillCommonInfo& Skill);
	void RequestDownMotion(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, class UPrimitiveComponent* Primitive, bool PsychicObjectCombo, const struct FHCSkillCommonInfo& Skill, class AActor* Actor, class AActor* Obj, bool* IsSuccess);
	void IsUniqueKnockBackCondition(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, class UPrimitiveComponent* Primitive, bool PsychicObjectCombo, const struct FHCSkillCommonInfo& Skill, class AActor* Attacker, bool* bKnockBack);
	void RequestReactionLMotion(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, class UPrimitiveComponent* Primitive, bool PsychicObjectCombo, const struct FHCSkillCommonInfo& Skill, class AActor* Actor, bool* IsSuccess);
	void RequestBlowMotion(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, class UPrimitiveComponent* Primitive, bool PsychicObjectCombo, const struct FHCSkillCommonInfo& Skill, class AActor* Actor, bool* IsSuccess);
	void ForceDownMotion(class AActor* Attacker, EHCHitStopCauseType HitStopCauseType);
	void BeginAvatar(bool IsAvatar, bool* Dummy);
	void RequestDamageShake(bool* IsSuccess);
	void UpdateBossHpDisplay(float DeltaSec);
	void CreateEnemyWeapon(bool* Dummy);
	void OnArmorBreak(const struct FHCHitResult& HitResult, bool* Dammy);
	void StartReactionLFlash();
	void SelectShake(class UClass* ShakeClass, float Scale, const struct FVector& ShakeLocation, class UClass** ReturnClass, float* ReturnScale);
	void CreateBrainCore();
	void StartCrashChance(const struct FHCSkillCommonInfo& SkillInfo, bool* bStart);
	void BadStateOnMaterial(EHCSkillAttribute Attribute, bool* Dummy);
	void BadStateOffMaterial(EHCSkillAttribute Attr, bool* Dummy);
	void RequestPressDown(const struct FHCSkillCommonInfo& Skill, class AActor* Attacker, class AActor* Obj, bool* IsSuccess);
	void UpdatePressDown(float DeltaSec);
	void Request_Press_Kill(const struct FHCSkillCommonInfo& Skill, bool* IsSuccess);
	void CheckCounterAttack(const struct FHCSkillCommonInfo& Skill);
	void ResetCounterAttack();
	void CheckWinceCounter();
	void IsCounterSuperArmor(bool* SuperArmor);
	void IsSetWinceCounter(bool* Return);
	void IsUniqueReactionSmallCondition(const struct FRotator& Rot, const struct FVector& HitPosition, const struct FVector& HitDir, class UPrimitiveComponent* Primitive, bool PsychicObjectCombo, const struct FHCSkillCommonInfo& Skill, class AActor* Attacker, bool* bReactionSmall);
	void SetUniqueSeeWeak(bool On, bool* Dammy);
	void EnableFitGround(bool* Dummy);
	void DisableFitGround(bool* Dummy);
	void UpdateFitGround(float DeltaSeconds, bool* Dummy);
	void DebugDisplayMotionInfo(bool* Dummy);
	void StartWeakDamageMaterial();
	void UpdateWeakDamageMaterial(float DeltaSec);
	void GetAvoidAction(Enum_EnemyAvoidType AvoidEnum, uint8* AvoidAction);
	void CalcBrainCrashDamage(int32* Damage);
	void CheckLastBossBrainCrash();
	void LimitCrashAccumulation();
	void SetEnableDiscoverIcon(bool Enable, bool* Dummy);
	void GetCheckCapsuleRadius(float* Radius);
	void EnableIK();
	void DisableIK();
	void ProcFellOutOfWorld(bool* Dummy);
	void UpdateWeakAroundEffect();
	void LaunchDown(bool* IsEnd);
	void StartLookAt(bool* Dummy);
	void FinishLookAt(bool FinishRotZero, bool* Dummy);
	void RequestAddDamageL(const struct FHCSkillCommonInfo& Skill, bool* IsSuccess);
	void ResetAddBlend();
	void UpdateLookAt(float DeltaSeconds, bool* Dummy);
	void UpdateBadStateMaterial(float DeltaSeconds, bool* Dummy);
	void OnBrainCrashAccessOff(bool* Dummy);
	void OnBrainCrashAccessOn(bool* Dummy);
	void CallFuncDamageDownStart(bool* Dummy);
	int32 GetWeakNumber();
	void DoEventStart(bool* bDummy);
	void DoEventEnd(bool* bDummy);
	void DoStaticEventStart(bool* bDummy);
	void DoStaticEventEnd(bool* bDummy);
	void DoDynamicEventStart(bool* bDummy);
	void DoDynamicEventEnd(bool* bDummy);
	void CalcMoveScale(float CurrentTime, float MaxTime, float* MoveScale);
	void GetTargetAttacking(bool* bAttacking);
	void SwitchLookAt(bool bEnable, bool* Dummy);
	void DestroyEnemyWeapon(bool* Dummy);
	void DestroyBrainCore();
	void GetDebugAiTableKey(int32 AiEnum, bool* bSuccess, uint8* ReturnKey);
	void DebugDisplayUniqueConditionDescription(bool* Dummy);
	void DebugAddIgnoreAction(uint8 Action, bool* Dummy);
	void DebugResetIgnoreAction(bool* Dummy);
	void DebugRemoveIgnoreAction(uint8 Action, bool* Dummy);
	void PreTick(float DeltaSeconds, bool* Dummy);
	void PostTick(float DeltaSeconds, bool* Dummy);
	void EnableFitGroundTmp(bool* Dummy);
	void DisableFitGroundTmp(bool* Dummy);
	void OnArmorHit(const struct FHCHitResult& HitResult);
	void OnStartHideArmor(bool* Dummy);
	void StartDamageFloating(bool* Dummy);
	void EndDamageFloating(bool* Dummy);
	void DoBattleSequencerStart(bool bSetEnemyEvent, bool bDriveSequence, bool* bDummy);
	void DoBattleSequencerEnd(bool bSetEnemyEvent, bool bDriveSequence, bool* bDummy);
	void InitSaveBodyWeakValue(bool* Dummy);
	void SetWeakEmissiveOff(const class FString& WeakSlotName, bool* Dummy);
	void RestoreWeakEmissive(const class FString& WeakSlotName, bool* Dummy);
	void IsUniqueDisableAvoid(bool* bDisable);
	struct FVector GetCameraLookAtPos();
	void SetIdleMove(bool IsIdle);
	void GetCurrentActionTime(float* ActionTime);
	void StartChangeTimeDilation(bool bAddDamage);
	void UpdateUniqueObjState();
	void IsEnemyLandingCheck(bool* bHit);
	void StartChangePlayRate(bool bAddDamage);
	void SetBrainCrashReceive();
	bool SetHiddenCharacterAttachment(bool NewHidden);
	void DebugDrawSearchRange();
	void UpdateAdjustZCharaCapsule(float DeltaSec);
	void SetAdjustCharaCapsule(bool Enable);
	void KickCrashChanceLoopEffect();
	void StopCrashChanceLoopEffect();
	void UpdateScouting(float DeltaSeconds, bool* Dummy);
	bool SetActorAllTickEnabled(bool bEnabled);
	void UpdateDetectIcon(float DeltaSeconds, bool* Dummy);
	void EnableWeakCollision(bool bEnable, bool* Dummy);
	void AddCharaCollisionList(class UCapsuleComponent* Capsule, int32* ListNo);
	void UpdateChangeCharaCollision(bool* Dummy);
	void ResetCharaCollision();
	void DebugMainTick(float DeltaSec);
	void EnableInvincible(bool bEnable, bool* Dummy);
	void IsUniqueEnableMove(bool* bEnable);
	void GetSpeedScale(float* Param_SpeedScale);
	void IsNotDamageMotion(bool* Param_bNotDamageMotion);
	void EventDeath(bool WatchDeath, bool* Dummy);
	void SwitchMaterialStealth(bool SwitchStealth);
	void SetMaterialStealthParameter(float Rate);
	void SetMaterialStealthParameterFromTime(float Time);
	void CameraAttentionStartDelete(class UCurveFloat* ActorCurveIn, bool bChangeFov, float TargetFov, class UCurveFloat* FovCurveIn, bool* Dummy);
	void CameraAttentionEndDelete(class UCurveFloat* FovCurveOut, bool* Dummy);
	void Get_Search_Range(float* Range);
	void GetSearchAngle(float* Angle);
	void GetSensingArea(float* Area);
	void GetCaptureArea(float* Area);
	void GetMoveArea(float* Area);
	void SetDefault_SearchRange();
	void SetDefault_SearchAngle();
	void SetDefault_SensingArea();
	void SetDefault_CaptureArea();
	void SetDefault_TerritoryArea();
	void SetDefault_RepopTime();
	void SetDefault_RepopRange();
	void SetDefault_RepopTimeTerritory();
	void UpdateIsChangeParameter();
	void OnStealthHalf();
	void OffStealthHalf();
	void UpdateStealthHalf(float DeltaTime);
	void SetStealthHalfTime();
	void SetOverwriteParam();
	void BadStateIconOn(const struct FBadStateAddParticleData& Data, class UParticleSystemComponent** Handle);
	void AddBattleActor();
	void IsUniqueEffectiveSas(class AActor*& AttackActor, bool* IsEffectiveSas, float* WinceRate, float* KnockBackRate, float* DownRate, float* CrashRate);
	void GetAcceptanceRadius(float* AcceptanceRadius);
	void KickDetectIcon(EEnemyFindPlayerType FindType, bool* Dummy);
	void StopDetectIcon(bool* Dummy);
	void StartEnableWeak(bool* Dummy);
	void EndEnableWeak(bool* Dummy);
	void ReserveBaseMontage(class UAnimMontage* Param_BaseMontage);
	void UpdateBaseMontage();
	void IsPathAreaOut(bool* AreaOut);
	void PlayGeneralBrainCrashSequence();
	void OnStartAction(bool* Dummy);
	void IsEnableCharacterTick(bool* bEnable);
	void OnBrainFieldMoveInner(bool MoveBrainField, bool* Dummy);
	void UpdateFall();
	void OnPathAreaOut();
	void CallFuncDamageDownLoop(bool* Dummy);
	void IsNoMoveAnim(bool* bNoMoveAnim);
	void IsCreateBossCore(bool* bCreateBossCore);
	void RepopEntry();
	void RepopInit();
	void InsidePlayerCamera(const struct FVector& MyPos, bool* IsInside);
	void Start_Brain_Talk_Party_Bad_Status_Attribute(EHCSkillAttribute PartyBadStatusAttribute, bool* bSuccess);
	void PreAreaOutResetParam();
	void AreaOutResetParam();
	void ResetAllBadStatus();
	void ResetShell();
	void InitAreaOut();
	void UpdateAreaOut(float DeltaTime);
	void SetStealthEndLaunchFlag();
	void StealthEndLaunchLanding();
	bool CheckEmphasisCrashGauge(const struct FHCHitResult& HitResult);
	void GetReasonBattleEnd(EReasonBattleEnd* Reason);
	void StartBrainTalkEffectiveSas(E_SASKindNative SasKind);
	void SetNoDisplayDiscoverIcon(bool Enable, bool* Dummy);
	void CopyParamToAvatar(class ARSBattleEnemy_C* Original, bool* Dummy);
	void StartBrainTalkOnBadState(class AActor* Attacker, EHCBadState BadState);
	void DisplayEnemyHp(float DisplaySeconds, bool* Dummy);
	void SetAnimScaleHitStop(EnemyDamageAnimKind DamageAnimKind);
	void SetAnimScaleHitStopProduct();
	void SetAnimScaleHitStopSlow();
	void ReSetAnimScaleHitStop();
	void GetRowNameAnimScaleHitStop(EnemyDamageAnimKind DamageAnimKind, class FName* RowName);
	void SetBaseMontagePlayRate(float PlayRate);
	void CheckMapGimmickHitSlow(const struct FHCHitResult& HitResult);
	void IsDiscoveredOnce(bool* DiscoverdOnce);
	void CheckStealthCriticalHitSlow(const struct FHCHitResult& HitResult);
	void OnDamaging(const struct FHCHitResult& HitResult, float DamageValue, bool* Dummy);
	void InitUro();
	void UpdateUro();
	void PrioritizeTick(bool* Dummy);
	void CalcTickSeconds(float DeltaSeconds, bool* Dummy);
	void MainTickSometime(float DeltaSeconds, bool* Dummy);
	void InitCheckUpdateWeakMaterial();
	void InitUpdateSeeThrought();
	void CheckSimpleEnemy();
	void CallFuncDamageDownEnd(bool* Dummy);
	void SetUseWaitNoInterpolation(bool bUse, bool* bDummy);
	void RestoreInitRotationRate();
	void IsBossHpDisp(bool* IsDisp);
	void SpawnStartChangeCharaCondition();
	void IsEnableWeak(bool* Param_bEnableWeak);
	void SetStopWeakEmissive(bool IsStop);
	void IsStopWeakEmissive(bool* IsStop);
	void Is_Disable_Weak_Around_Effect(int32 Param_Index, bool* IsDisable);
	void SetDisableWeakAroundEffect(int32 Param_Index, bool IsDisable);
	void Set_Event_Wait(bool Param_IsEventWait);
	void SetBT_ForceBreak(bool Param_IsBT_ForceBreak);
	void SetWander(bool Param_IsWander);
	void SetBattleStart(bool Param_IsBattleStart);
	void SetSpawnState(Enum_EnemySpawnState Param_SpawnState);
	void SetEnableOutOfBattleField(bool SetEnable, int32 Param_GroupID, bool BossField);
	bool EventManagerEnd(bool RestoreEnableTick, bool RestoreVisibility);
	void GetBattleStart(bool* Param_IsBattleStart);
	void SetEnemyEnableOutOfBossBattlefield(bool SetEnable);
	void OnDamageArmorBreak(bool* bDummy);
	void SetFormType(EEnemyFormType Param_FormType);
	void SetArmorFlashControl(const struct FHCHitResult& Result, bool* Dummy);
	bool EventManagerStart(bool EnableTick, bool Visibility);
	void SetDeadMontage(bool bEnableConsiderFlag);
	void SetUpNativeParam();
	void LostSightInBattle();
	void IsHitAttackArmor(struct FHCHitResult& HitResult, bool* bHit);
	void SetNoCollisionAndStopAiFade(bool bNoColAndStopAi, bool* Dummy);
	void SetEnemyEnableOutOfNotBossBattlefield(bool SetEnable);
	void StartUpdateAreaOut();
	void FrameDamage(float Sec);
	void StartSpawn();
	void SetAreaOutActorLocation(const struct FVector& NewLocation, bool* Return);
	void CheckExecuteNotifyKind(class AActor* Param_Owner, ECharaExecuteNotifyKind ExecuteKind, bool* IsExecute);
	void GetET_StopWaitMontage(class UAnimMontage** WaitMontage);
	bool CheckAttractSelf(const struct FHCHitResult& HitResult);
	void SetAllowanceWaitSeconds();
	void AreaStart();
	void UniqueBossLostActionAbort(bool* IsUniqueAbort);
	bool IsPsychicFieldDamageRateToBoss();
	void DirectAttack(bool UseFixDamage, int32 FixDamage, class UDataTable* DataTable, class FName SkillName, class AActor* Attacker, class AActor* AttackerOwner, bool IgnoreInvalid, const struct FHCHitEffectInfo& Effect_Info, bool UseHitPosition, const struct FVector& HitPosition, bool NoDamageDisplay, bool bNotifyAttackActorHit);
	void SetBattlefieldFenceAppearRate(float FenceBattleRate);
	void OnHitDamage(const struct FHCHitResult& Result, bool* Return);
	void GetLocationAreaID(int32* LocationId, int32* AreaId);
	void SetGroupID(int32 NewGroupID);
	void CheckSpawnCondition(bool* IsSpawnOK);
	void Is_Enable_Spawn_by_Condition(bool* IsSpawnOK);
	bool SufferDamageAfterInterface(const struct FHCHitResult& HitResult, int32 Damage, int32 TakedDamage);
	void CheckCondisionByRareSpawn(EBattleSimulatorRareSpawnCondision Condision, float Value, bool* IsOK);
	void SetDeadBeforeHitResult(const struct FHCHitResult& HitResult);
	void GetDeadBeforeHitResult(struct FHCHitResult* HitResult);
	void SetDeadBeforeHitResultByDirectAttack(const struct FHCHitResult& HitResult);
	void OnStartCrashVisionEffect(bool bUniqueEffect);
	void CrashVisionDamage();
	void IsEnableSpawnByConditionEnemyHpRate(bool* IsSpawnOK);
	void RareSpawnResultLog(bool Success);
	void RareEnemySelfDestroy();
	void SetAvatarCopyTags(bool InAvatarCopyTags);
	void IsAvatarCopyTags(bool* AvatarCopyTags);
	void PlayBattleStartRevivalBossBT();
	void GetSpawnLocation(struct FVector* Location);
	void GetSpawnRotation(struct FRotator* Rotation);
	void OnSimulatorStartDirectionOpen();
	void OnSimulatorStartDirectionClose(float MoveDelaySec);
	void OnSimulatorStartDirectionCloseProduct();
	void UpdateSimulatorStart(float DeltaSec);
	void SetEnableLostActionTimer(float Time);
	void UpdateEnableLostActionTimer(float DeltaSec);
	void IsExistEnableLostActionTimer(bool* bExist);
	void TickLostActionReset(float DeltaSec);
	void StartLostActionResetTick(EnemyActionAnimKind LostAction, float Time);
	void EndLostActionResetTick();
	void IsLostActionResetTick(bool* bTick);
	void StartFallIfFlyingIF(bool* bDummy);
	void OnEndAnimDieIF(bool* bDummy);
	bool ResetAction_Native();
	bool UpdateFall_Native();
	void UpdateDamageAnim_Native(bool* DamageEnd, bool* DamageDownEnd);
	bool SwitchDispCore_Native(bool DisplayOn);
	bool StoreWeakState_Native();
	bool StopCrashChanceLoopEffect_Native();
	bool StartVanish_Native(float VanishSec, float StartVanish, float EndVanish);
	bool StartDamageFloating_Native();
	bool SetWeakEmissiveOff_Native(const class FString& WeakSlotName);
	bool SetUseWaitNoInterpolation_Native(bool Use);
	bool SetReserveAction_Native(uint8 Action, float Param00, float Param01);
	bool SetLanding_Native(bool bLanding);
	bool SetIsMoveAnim_Native(bool NewIsMoveAnim);
	bool SetIsLaunchDown_Native(bool NewIsLaunchDown);
	bool SetIsLandCheck_Native(bool NewIsLandCheck);
	bool SetIsBrainAccess_Native(bool NewIsBrainAccess);
	bool SetIdleMove_Native(bool IsIdle);
	bool SetHp_Native(int32 HP);
	bool SetDownTimer_Native(float NewTime);
	bool SetDamageCollisionDisable_Native(const class FName& ClaimantName);
	bool SafeDestroy_Native(class AActor* Actor);
	bool RestoreWeakState_Native();
	bool RestoreWeakEmissive_Native(const class FString& WeakSlotName);
	bool ResetStateReceivedExecuteAi_Native();
	bool ResetCore_Native(class AActor* Enemy, bool RemoveCore);
	void ReceivedNotifyAnimEnd_Native(bool* Received);
	bool OutputLogCrashChanceEnd_Native();
	bool LeaveBrainCrashAccess_Native(class ARSCharacterBase* Character);
	void LaunchDown_Native(bool* IsEnd);
	bool KickCrashChanceLoopEffect_Native();
	bool IsMotionEnd_Native();
	void IsIgnoreLandingCheck_Native(bool* bIgnoreLandingCheck);
	void IsEnemyLandingCheck_Native(bool* bHit);
	void IsBrainCrashMiss_Native(bool* IsMiss);
	class USearchingComponent* GetSearchingComponent_Native();
	void GetLostData_Native(float* Param_LostMoveTimeMin, float* LostMoveTimeMax, float* Param_LostMoveRotationRate, float* Param_SpeedScale, bool* IsNoMoveAnim);
	void GetHitObjectType_Native(TArray<EObjectTypeQuery>* ObjectType);
	bool GetFall_Native();
	bool GetFailedFall_Native();
	void GetCurrentActionTime_Native(float* ActionTime);
	void FlyDown_Native(bool* IsEnd);
	bool EntryBrainCrashAccess_Native(class ARSCharacterBase* Character);
	bool EndDamageFloating_Native();
	bool EnableFitGroundTmp_Native();
	bool EnableAllWeak_Native(bool bEnable);
	bool DropFlyingEnemy_Native(class AActor* Enemy);
	bool DisableFitGroundTmp_Native();
	bool DeadStart_Native();
	bool DamageMotionEnd_Native(float DeltaTime);
	bool DamageFloatEnd_Native();
	bool CheckSASHologramAttack_Native(ESASHologramAttackTiming Timing, class ARSCharacterBase* RequestCharacter);
	bool CheckNpcDrive_Native(ENpcDriveCheckType CheckType, class AActor* EnemyActor);
	bool CameraAttentionEnd_Native(class UCurveFloat* FovCurveOut);
	bool CallFuncDamageDownStart_Native();
	bool CallFuncDamageDownLoop_Native();
	bool CallFuncDamageDownEnd_Native();
	bool CallDead_Native();
	bool BrainCrashLock_Native();
	bool IsPossibleTargetAttack_CallFromCPP(class AActor* Actor);
	bool IsEnemyStateAttack_CallFromCPP();
	bool OnEndCrashChance_Native();
	bool UpdateMoveMaxSpeed();
	bool EnemyUpdateEvDitherNative(float DeltaSec);
	bool EnemyStartEvDitherNative(bool bDisp, float DitherTime);
	bool EnemyEndEvDitherNative(bool bDisp);
	bool IsFlyEnemyCheck_Native();
	bool IsEnemyDamageDown_CallFromCPP();
	bool StartReactionDilation_CallFromCPP(uint8 ReactionKind, bool bAddDamage);
	bool IsCheckLookScrollTick(const struct FVector& Start, const struct FVector& End);
	bool SetTickEnableMeshOnly(bool bMeshOnly);
	bool IsCheckSameCompareGroundLoaction();
	bool SetEnemyConsiderDownDead(bool bEnable);
	EEnemyTribe GetEnemyTribe();
	bool OnCrashVisionDead();
	bool OnNotifyPlayerDead();
	void GetEnemyInterfaceSound(Enum_EnemySound* Enum);
	void BeginEnemyAttack(EnemyAttackAnimKind Attack, bool* Bool);
	void IsEnemyDamageDown(bool* Bool);
	void IsEnemyDamageWince(bool* Bool);
	void IsEnemyMove(EnemyMoveAnimKind Move, bool* Bool);
	void BeginEnemyMove(EnemyMoveAnimKind Move, bool* Bool);
	void IsEnemyAttack(EnemyAttackAnimKind Attack, bool* Bool);
	void IsEnemyAction(EnemyActionAnimKind Action, bool* Bool);
	void BeginEnemyAction(EnemyActionAnimKind Action, bool* Bool);
	void IsEnemyDamageBlow(bool* Bool);
	void IsEnemyDamageknockBack(bool* Bool);
	void IsEnemyDamageLaunch(bool* Bool);
	void IsEnemyStateAction(bool* Return);
	void IsEnemyStateDamage(bool* Return);
	void IsEnemyStateAttack(bool* Return);
	void IsEnemyStateMove(bool* Return);
	void IsEnemyStateDamageDown(bool* Return);
	void IsEnemyBossActive(bool* Return);
	void SetEnemyBrainCrashPerformance(bool* Return);
	void ResetEnemyTarget(bool* NewParam);
	void SetEnemyTarget(bool* NewParam);
	void SetEnemyDamageReaction(bool* NewParam);
	void SetEnemyBrainFieldEnd(bool MoveBrainField, bool* NewParam);
	void SetEnemyBrainFieldStart(bool MoveBrainField, bool* NewParam);
	void GetEnemyGroundTransform(const struct FTransform& Transform, struct FTransform* Return);
	void ResetEnemyWait(bool* NewParam);
	void SetEnemyWait(bool* NewParam);
	void OnSwitchVisibleBrainFieldLevel(bool Visible, bool* Unused);
	void SetEnemyBrainCrashParam(float BrainCrashTimer, float BrainCrashMissScale, bool* Return);
	void SetEnemyStealthSeeEnable(bool On, bool ShadowChange, bool* Return);
	void IsEnableEnemyMoveRange(bool* bReturn);
	void PlayerActionForEnemyReaction(BattlePrototype::EPsychicObjectAttackType PsychicObjectType, const struct FVector& PsychicObjLocation, bool* Dummy);
	void EnemyDataDrop(const struct FVector& Param_SpawnLocation, const struct FVector& SpawnDir, bool* IsDrop);
	void SetEnemySpawn(bool Spawn, bool* Return);
	void SpawnStart(bool* Return);
	void IsHideWeak(bool* Param_IsHideWeak);
	void ReturnStart(bool* Return);
	void IsAttacking(bool* IsAttack);
	void GetTargetKind(ERSPartyPlayerKind* TargetKind);
	void GetBrainCore(class ABP_co2000Base_C** CoreObject);
	void IsEnemyStateFloating(bool* IsFloating);
	void CalcCameraShake(class UClass* InputShakeClass, float InputScale, const struct FVector& ShakeLocation, class UClass** OutputShakeClass, float* OutputScale);
	void SetEnemyPressDownEnd(bool* Dammy);
	void EndUniqueObjState(bool* Dummy);
	void StartUniqueObjState(class ABP_PsychicObjectBasic_C* AttackObject, bool* Dummy);
	void CheckUniqueObjState(const struct FHCHitResult& HitResult, bool* Dummy);
	void IsUniqueObjState(bool* Param_ReturnState);
	void SwitchDispCore(bool DisplayOn, bool* Dummy);
	void OnStartCrashChance(bool* bStart);
	void OnEndCrashChance(bool* bEnd);
	void IsPossibleTargetAttack(class AActor* Attacker, bool* bPossible);
	void IsDisableLostAction(bool* bDisable);
	void GetCoreCollision(class UDamagePartCollisionComponent** CoreCollision);
	void OnSpawnMoveStart(bool* Dummy);
	void OnEnemyBrainFieldResetAction(bool bMoveBrainField, bool* bReset);
	void OnEnemyBrainFieldFinishWeapon(bool bMoveBrainField, bool* Dummy);
	void OnEnemyBrainFieldResetStatus(bool bMoveBrainField, bool* Dummy);
	void SetEnemyBrainFieldMoveInner(bool MoveBrainField, bool* Dummy);
	void SetEnemyBrainFieldMoveNormal(bool MoveBrainField, bool* Dummy);
	void OnEnemyBrainFieldCutChange(bool* Dummy);
	void ChangeAiType(Enum_EnemyAiType Param_ChangeAiType, bool* bFailed);
	void CheckChangeAiTypeForHpRate(bool* Failed);
	void IsChangeAiTypeAction(Enum_EnemyAiType InAiType, bool* bPossible);
	void Em1200_ChangePhaseParamSetting(bool* Dummy);
	void Em1210_AddPSychicFlyObj(class ABP_PsychicObjectBasic_C* FlyObj, bool* Dummy);
	void StartReactionDilation(uint8 ReactionKind, bool AddDamage, bool* Return);
	void IsEnemyDiscoveredOnceInterface(bool* bDiscoverd);
	void Em0700_EnableInvalidDamage(bool* bEnable);
	void Em1400_StartDither(float TotalDuration, bool* Return);
	void Em1400_EndDither(bool* Return);
	void Em1400_UpdateDither(EEasingFunc EasingFunc, float DeltaSec, bool* Return);
	void Em1400_SetSpawnTransform(const struct FTransform& SpawnTransform, bool* Return);
	void Em1400_GetSpawnTransform(struct FTransform* SpawTransform);
	void IsBrainFieldEnemyAlive(bool* bEnemyAlive);
	void IsSwitchAttackCollisionInfo(bool* IsSwitch);
	void SetEnemyUpDownWait(bool DownWait, bool* Dummy);
	void IsEnemyUpDownWait(bool* Param_bUpDownWait);
	void StartCriticalHitSlow(const struct FHCHitResult& InHitResult, bool* Return);
	void Em1130_EnableWeak(bool bEnable, bool* Return);
	void GetEnemySpawnConditionCheck(bool* IsSpawnOK);
	void StartEnemyCrashVisionHitEffect(bool* NewParam);
	void StartEnemyCrashVisionHitUniqueEffect(bool* NewParam);
	void BindingCrashVisionEnemy(bool* NewParam);
	void Em8300_DeadBattleSimulator(bool* Dummy);
	void IsEnemyRepop(bool* Repop);
	void GetEmPosDiscover(struct FVector* DiscoverPos);
	bool IsNeedResetStateMachine(float ElapsedTime, float ResetSecond);
	bool GetAndUpdateContinuousSameDamageReaction();

	void GetIsBattleMode(bool* IsBattleMode) const;
	void IsBattling(bool* bBatting) const;
	bool IsTargetEnemy() const;
	void IsArmor(class UPrimitiveComponent* Prim, bool* Return) const;
	struct FVector GetDamagePartDir(class UDamagePartCollisionComponent* DamagePart) const;
	void GetEnemyEnumLength(int32* Length) const;
	void IsHitWall(const struct FVector& Src, const struct FVector& Dst, bool* IsHit) const;
	void IsRangeArea(const struct FVector& HomePos, const struct FVector& CurPos, float Range, bool* InRange) const;
	void GetRandomRangeLocationCore(const struct FVector& SrcLocation, const struct FVector& TargetLocation, float RangeMin, float RangeMax, bool CheckWall, class ANavigationData* NaviData, struct FVector* NewLocation, bool* IsSuccess) const;
	void GetInvisibleHPGauge(bool* IsInvisible) const;
	void GetTargetRangeType(Enum_EnemyRange* RangeType) const;
	void GetRangeActions(Enum_EnemyRange RangeType, TArray<uint8>* Actions) const;
	void GetWeakTargetPoint(const struct FVector& AttackerPos, struct FVector* Point) const;
	void GetTopTargetPoint(struct FVector* Point) const;
	void GetTargetCursorPoint(struct FVector* Point) const;
	void IsStateStealth(bool* Return) const;
	void Is_Brain_Crash_Dead_State(bool* Param_IsBrainCrashDead) const;
	void GetWeakUIPoint(int32 Param_Index, struct FVector* Point) const;
	void IsCollisionHitWall(bool* bHit) const;
	void IsCollisionHitChara(bool* bHit) const;
	void IsCollisionHitAny(bool* bHit) const;
	void GetMoveActions(TArray<uint8>* Actions) const;
	void GetRangeDistance(Enum_EnemyRange RangeType, float* Distance) const;
	void IsNotVanish(bool* NotVanish) const;
	void IsHitWallCapsule(const struct FVector& CheckLocation, bool* IsHit) const;
	void InMoveArea(const struct FVector& CheckLocation, float AreaScale, bool* InArea) const;
	bool IsTargetable() const;
	void GetEnemyBaseLocation(struct FVector* baseLocation) const;
	bool IsIgnoreVisionFog() const;
	void GetBodyMeshArray(TArray<class USkeletalMeshComponent*>* MeshArray) const;
	void IsSimpleEnemy(bool* IsSimple) const;
	float GetBrainCrashRange() const;
	void CalcRangeType(float CheckDistance, Enum_EnemyRange* RangeType) const;
	void GetMainPlayerRangeType(Enum_EnemyRange* RangeType) const;
	void IsIdleResetMoveMode(bool* bReset) const;
	void IsInvisibleHPGauge(bool* bInvisible) const;
	bool IsBerserkCharacter() const;
	ESpecialDamageTableType GetSpecialDamageTableType() const;
	void GetCrashChanceCursorPoint(struct FVector* Point) const;
	void GetHpGaugePoint(struct FVector* Point) const;
	bool IsBrainCrashAccess() const;
	bool IsBrainCrashSuccess() const;
	void DebugMakeMotionInfoText(class FText* InfoText) const;
	void IsSpawnWait(bool* bSpawnWait) const;
	void UpdateEnableIK(bool* Dummy) const;
	void IsSuspendIKCondition(bool* bEnable) const;
	void IsBrainCrashMiss(bool* IsMiss) const;
	void IsHitFromMainPlayer(class AActor* Attacker, bool* Return) const;
	void CanTakeBrainField(bool* CanTake) const;
	void IsHitWeak_ChangeDefaultEffect(bool* ChangeDefault) const;
	void DebugGetUniqueConditionText(TArray<class FText>* Text) const;
	void IsCurrentTarget(bool* bTarget) const;
	void DebugIsEnableUniqueCondition(int32 ConditionNo, bool* EnableCondition) const;
	void DebugFindIgnoreAction(uint8 Action, bool* Find) const;
	void IsEnableSlashEffect(struct FHCHitResult& HitResult, bool* bEnable) const;
	void IsIdleMove(bool* IsIdle) const;
	void GetWeakTargetTransform(const struct FVector& AttackerPos, struct FTransform* WeakTransform) const;
	void DebugDisplayAiBasic(bool* Dummy) const;
	struct FVector GetEyePosition() const;
	struct FEnemyFindChangeParam GetEnemyFindChangeParam() const;
	void GetBadStateIconParam(EHCBadState BadType, struct FBadStateAddParticleData* ParamData) const;
	void GetBadStateIconCameraOffset(float* Value) const;
	void IsInvincible(bool* Param_bInvincible) const;
	void GetDownTime(float* Time) const;
	bool IsInvisibleMiniMap() const;
	void IsReceiveSasEffectAttack(bool CheckAccelerator, bool ChackTelepo, bool CheckStealth, bool CheckStealthSee, bool CheckMetal, class AActor* AttackActor, bool* ReceivedSas) const;
	EAssassinAttackHit GetAssasinAttackHitType() const;
	void BadStateEffectDispSwitch(bool bInDisp, bool* bSuccess) const;
	void GetWeakTargetSocketName(TArray<class FName>* SocketName) const;
	void GetTickIntervalSeconds(EEnemyTickPriorityType PriorityType, float* DefaultSeconds, float* MaxSeconds) const;
	void IsExecSometimeTick(bool* bExec) const;
	void GetBrainFieldProgress(Enum_EnemyBrainFieldProgress* Progress) const;
	void IsUseWaitNoInterpolation(bool* bUse) const;
	void GetInitRotationRate(struct FRotator* Rotation) const;
	void GetCurrentActionRotationScaleRate(float* Scale) const;
	void GetArmorPartsList(TArray<int32>* Armor) const;
	void GetBrainCrashSequenceEm8300(bool IsUnique, class ULevelSequence** Sequence) const;
	void InBrainFieldProgress(bool* InBrainField) const;
	bool IsNotAbleBrainCrashTarget() const;
	void IsPlayerOutOfBattleFieldFence(bool* Return) const;
	void IsUseBattleFieldFence(bool* Return) const;
	void IsNotApplyPhotoModeMeshProfile(bool* bNotApply) const;
	bool IsDebugInvincible() const;
	struct FVector GetDamageHitDirectionIF() const;
	class AActor* GetCurrentTarget() const;
	bool IsReflectContainer() const;
	bool IsExecLowProcess() const;
	struct FVector GetTopHeightLocation() const;
	class UEnemyAiComponentBase* GetEnemyAiComponent() const;
	class UEnemyScriptComponent* GetEnemyScriptComponent() const;
	bool IsUpdateEnemyTickEnable() const;
	bool IsUpdateEnemySpawn() const;
	bool IsTickDisableCondition() const;
	bool IsEnemySpawn_Interface() const;
	bool IsEnemyFalling_Interface() const;
	bool IsCheckHeightChangeTick() const;
	bool IsDisableUroAction_Interface() const;
	bool IsCheckLookTargetTick(const struct FVector& Start, const struct FVector& End) const;
	class UEnemyAnimControllerComponent* GetEnemyAnimControllerComponent() const;
	bool IsPressDown_Native() const;
	bool IsLaunchDown_Native() const;
	bool IsDamageMotionEnd_Native() const;
	bool IsBrainSuccess_Native() const;
	class AActor* GetTargetCharacter_Native() const;
	bool GetPressDownLoop_Native() const;
	bool GetNewDamageFloating_Native() const;
	void GetLostActionInfoList_Native(TArray<struct FEmLostActionInfo>* LostActionInfo) const;
	bool GetIsLandCheck() const;
	bool GetIsJumpEnd() const;
	class UHateTargetComponent* GetHateTarget_Native() const;
	EnemyMoveAnimKind GetDownUpMoveAnimKind_Native() const;
	float GetDownTimer_Native() const;
	bool GetDebugEnemyDownInfinity_Native() const;
	class UCapsuleComponent* GetCapsuleComponent_Native() const;
	bool IsWeakUiDamageHit_CallFromCPP() const;
	bool IsNotFindPlayer_CallFromCPP() const;
	bool IsUniqueAroundEffectPause() const;
	float GetUniqueTickEnableRange() const;
	bool IsBossEnemy_CallFromCPP() const;
	bool IsSpawned() const;
	bool IsDisableDownMotionInterface() const;
	bool IsSuspendFollowAttackInterface() const;
	bool IsInvincible_Native() const;
	bool IsEnemyConsiderDownDead() const;
	void IsEnemyActive(bool* Return) const;
	void IsBossEnemy(bool* bBoss) const;
	void GetDistanceToPlayer(float* Distance) const;
	void GetTargetDistance(float* Distance) const;
	void GetEnemySpawn(bool* Return) const;
	void GetHeightCheckFlag(bool* NewParam) const;
	void IsFlyEnemyCheck(bool* NewParam) const;
	void GetBrainCrashSequence(bool IsUnique, class ULevelSequence** Sequence) const;
	void GetMoveToTargetAnim(EnemyMoveAnimKind* MoveAnim) const;
	void GetMainPlayerDistance(float* Distance) const;
	void IsRealThings(bool* bReal) const;
	void IsEnemySpawnNow(bool* SpawnNow) const;
	void IsNotFindPlayer(bool* bNotFind) const;
	void IsEnemyTickDisableCondition(bool* bDisableCondition) const;
	void Em8310_IsMaskMan(bool* bMaskMan) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"RSBattleEnemy_C">();
	}
	static class ARSBattleEnemy_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARSBattleEnemy_C>();
	}
};
#pragma pack(pop)
static_assert(alignof(ARSBattleEnemy_C) == 0x000010, "Wrong alignment on ARSBattleEnemy_C");
static_assert(sizeof(ARSBattleEnemy_C) == 0x002230, "Wrong size on ARSBattleEnemy_C");
static_assert(offsetof(ARSBattleEnemy_C, UberGraphFrame_RSBattleEnemy_C) == 0x0010F0, "Member 'ARSBattleEnemy_C::UberGraphFrame_RSBattleEnemy_C' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyTargetLookCheck) == 0x0010F8, "Member 'ARSBattleEnemy_C::EnemyTargetLookCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyPathAreaCheck) == 0x001100, "Member 'ARSBattleEnemy_C::EnemyPathAreaCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyCalcGoal) == 0x001108, "Member 'ARSBattleEnemy_C::EnemyCalcGoal' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeWeakStateComponent) == 0x001110, "Member 'ARSBattleEnemy_C::ChangeWeakStateComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyGoalComponent) == 0x001118, "Member 'ARSBattleEnemy_C::BP_EnemyGoalComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyChangePlayRate) == 0x001120, "Member 'ARSBattleEnemy_C::BP_EnemyChangePlayRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyChangeTimeDilationComponent) == 0x001128, "Member 'ARSBattleEnemy_C::BP_EnemyChangeTimeDilationComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyScript) == 0x001130, "Member 'ARSBattleEnemy_C::EnemyScript' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyAroundWeakEffectComponent) == 0x001138, "Member 'ARSBattleEnemy_C::BP_EnemyAroundWeakEffectComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyLookCheck) == 0x001140, "Member 'ARSBattleEnemy_C::EnemyLookCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_Discover_Component) == 0x001148, "Member 'ARSBattleEnemy_C::BP_Discover_Component' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyAddDamageShakeComponent) == 0x001150, "Member 'ARSBattleEnemy_C::BP_EnemyAddDamageShakeComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyDamageRagdollComponent) == 0x001158, "Member 'ARSBattleEnemy_C::BP_EnemyDamageRagdollComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyDamageMoveComponent) == 0x001160, "Member 'ARSBattleEnemy_C::BP_EnemyDamageMoveComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemySpawnComponent) == 0x001168, "Member 'ARSBattleEnemy_C::BP_EnemySpawnComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyDeadMoveComponent) == 0x001170, "Member 'ARSBattleEnemy_C::BP_EnemyDeadMoveComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyAvatarMaterial) == 0x001178, "Member 'ARSBattleEnemy_C::BP_EnemyAvatarMaterial' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BP_EnemyAvatar) == 0x001180, "Member 'ARSBattleEnemy_C::BP_EnemyAvatar' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StealthWeakComponent) == 0x001188, "Member 'ARSBattleEnemy_C::StealthWeakComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, Searching) == 0x001190, "Member 'ARSBattleEnemy_C::Searching' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyDatatableAccessorComponent) == 0x001198, "Member 'ARSBattleEnemy_C::EnemyDatatableAccessorComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AnimCon) == 0x0011A0, "Member 'ARSBattleEnemy_C::AnimCon' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AIAttackedInfoComponent) == 0x0011A8, "Member 'ARSBattleEnemy_C::AIAttackedInfoComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, VanishComponent) == 0x0011B0, "Member 'ARSBattleEnemy_C::VanishComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BBKey_BattleAIState) == 0x0011B8, "Member 'ARSBattleEnemy_C::BBKey_BattleAIState' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyStatusRowName) == 0x0011C0, "Member 'ARSBattleEnemy_C::EnemyStatusRowName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SleepAIDistance) == 0x0011C8, "Member 'ARSBattleEnemy_C::SleepAIDistance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DefaultStatusClaimantName) == 0x0011CC, "Member 'ARSBattleEnemy_C::DefaultStatusClaimantName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyClaimantName) == 0x0011D4, "Member 'ARSBattleEnemy_C::EnemyClaimantName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyDeadClaimantName) == 0x0011DC, "Member 'ARSBattleEnemy_C::EnemyDeadClaimantName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadEmissiveSec) == 0x0011E4, "Member 'ARSBattleEnemy_C::DeadEmissiveSec' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadVanishSec) == 0x0011E8, "Member 'ARSBattleEnemy_C::DeadVanishSec' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDeadStaging) == 0x0011EC, "Member 'ARSBattleEnemy_C::bDeadStaging' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadStagingPastSec) == 0x0011F0, "Member 'ARSBattleEnemy_C::DeadStagingPastSec' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadVanishEffectSec) == 0x0011F4, "Member 'ARSBattleEnemy_C::DeadVanishEffectSec' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadStagingTotalSec) == 0x0011F8, "Member 'ARSBattleEnemy_C::DeadStagingTotalSec' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadFinishSE) == 0x001200, "Member 'ARSBattleEnemy_C::DeadFinishSE' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CapsuleRad) == 0x001208, "Member 'ARSBattleEnemy_C::CapsuleRad' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SearchRange) == 0x00120C, "Member 'ARSBattleEnemy_C::SearchRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SearchAngle) == 0x001210, "Member 'ARSBattleEnemy_C::SearchAngle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SensingArea) == 0x001214, "Member 'ARSBattleEnemy_C::SensingArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, InitPos) == 0x001218, "Member 'ARSBattleEnemy_C::InitPos' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsFirstAttack) == 0x001224, "Member 'ARSBattleEnemy_C::IsFirstAttack' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsInitLayout) == 0x001225, "Member 'ARSBattleEnemy_C::IsInitLayout' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, InitLayout) == 0x001226, "Member 'ARSBattleEnemy_C::InitLayout' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TargetPos) == 0x001228, "Member 'ARSBattleEnemy_C::TargetPos' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TargetRange) == 0x001230, "Member 'ARSBattleEnemy_C::TargetRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsWander) == 0x001234, "Member 'ARSBattleEnemy_C::IsWander' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TargetRangeCheck) == 0x001238, "Member 'ARSBattleEnemy_C::TargetRangeCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBattleFinish) == 0x00123C, "Member 'ARSBattleEnemy_C::IsBattleFinish' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsNotSearchTableData) == 0x00123D, "Member 'ARSBattleEnemy_C::IsNotSearchTableData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnableMoveArea) == 0x001240, "Member 'ARSBattleEnemy_C::EnableMoveArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DistanceFromEnemyInitToPlayer) == 0x001244, "Member 'ARSBattleEnemy_C::DistanceFromEnemyInitToPlayer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpeedScale) == 0x001248, "Member 'ARSBattleEnemy_C::SpeedScale' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ShortDistance) == 0x00124C, "Member 'ARSBattleEnemy_C::ShortDistance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBrainAccess) == 0x001250, "Member 'ARSBattleEnemy_C::IsBrainAccess' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DamagePartComponents) == 0x001258, "Member 'ARSBattleEnemy_C::DamagePartComponents' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBoss) == 0x001268, "Member 'ARSBattleEnemy_C::IsBoss' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LongDistance) == 0x00126C, "Member 'ARSBattleEnemy_C::LongDistance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBrainSuccess) == 0x001270, "Member 'ARSBattleEnemy_C::IsBrainSuccess' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsMoveEnable) == 0x001271, "Member 'ARSBattleEnemy_C::IsMoveEnable' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsHitDamage) == 0x001272, "Member 'ARSBattleEnemy_C::IsHitDamage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DownTime) == 0x001274, "Member 'ARSBattleEnemy_C::DownTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DownTimer) == 0x001278, "Member 'ARSBattleEnemy_C::DownTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsLandCheck) == 0x00127C, "Member 'ARSBattleEnemy_C::IsLandCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBlowOnce) == 0x00127D, "Member 'ARSBattleEnemy_C::IsBlowOnce' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bNoNavMove) == 0x00127E, "Member 'ARSBattleEnemy_C::bNoNavMove' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DamageRot) == 0x001280, "Member 'ARSBattleEnemy_C::DamageRot' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsNotDamageAngle) == 0x00128C, "Member 'ARSBattleEnemy_C::IsNotDamageAngle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NoNavMoveInterpSpeed) == 0x001290, "Member 'ARSBattleEnemy_C::NoNavMoveInterpSpeed' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsFreeCheck) == 0x001294, "Member 'ARSBattleEnemy_C::IsFreeCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsCreateWeapon) == 0x001295, "Member 'ARSBattleEnemy_C::IsCreateWeapon' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TargetDistance) == 0x001298, "Member 'ARSBattleEnemy_C::TargetDistance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MotionFootParam) == 0x00129C, "Member 'ARSBattleEnemy_C::MotionFootParam' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsMotionFootParamUse) == 0x0012A0, "Member 'ARSBattleEnemy_C::IsMotionFootParamUse' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MotionFootParamCheck) == 0x0012A8, "Member 'ARSBattleEnemy_C::MotionFootParamCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MotionFootParamName) == 0x0012B8, "Member 'ARSBattleEnemy_C::MotionFootParamName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MotionFootParam_Trans) == 0x0012C8, "Member 'ARSBattleEnemy_C::MotionFootParam_Trans' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MotionFootParam_Alpha) == 0x0012D8, "Member 'ARSBattleEnemy_C::MotionFootParam_Alpha' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadTimer) == 0x0012E8, "Member 'ARSBattleEnemy_C::DeadTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBossDead) == 0x0012EC, "Member 'ARSBattleEnemy_C::IsBossDead' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MotionFootParam_Timer) == 0x0012F0, "Member 'ARSBattleEnemy_C::MotionFootParam_Timer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MotionFootParam_Time) == 0x001300, "Member 'ARSBattleEnemy_C::MotionFootParam_Time' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsRagdollEnable) == 0x001304, "Member 'ARSBattleEnemy_C::IsRagdollEnable' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsRagdoll) == 0x001305, "Member 'ARSBattleEnemy_C::IsRagdoll' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsRagdollDownEnable) == 0x001306, "Member 'ARSBattleEnemy_C::IsRagdollDownEnable' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsRagdollDown) == 0x001307, "Member 'ARSBattleEnemy_C::IsRagdollDown' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollDownBoneName) == 0x001308, "Member 'ARSBattleEnemy_C::RagdollDownBoneName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollDownBlend) == 0x001310, "Member 'ARSBattleEnemy_C::RagdollDownBlend' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollDownBackToTime) == 0x001314, "Member 'ARSBattleEnemy_C::RagdollDownBackToTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollBoneName) == 0x001318, "Member 'ARSBattleEnemy_C::RagdollBoneName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollBlend) == 0x001320, "Member 'ARSBattleEnemy_C::RagdollBlend' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollBackToTime) == 0x001324, "Member 'ARSBattleEnemy_C::RagdollBackToTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollPowerBoneName) == 0x001328, "Member 'ARSBattleEnemy_C::RagdollPowerBoneName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollPowerObj) == 0x001330, "Member 'ARSBattleEnemy_C::RagdollPowerObj' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollPowerObjS) == 0x00133C, "Member 'ARSBattleEnemy_C::RagdollPowerObjS' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollPowerObjM) == 0x001340, "Member 'ARSBattleEnemy_C::RagdollPowerObjM' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollPowerObjL) == 0x001344, "Member 'ARSBattleEnemy_C::RagdollPowerObjL' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RagdollPowerObjScale) == 0x001348, "Member 'ARSBattleEnemy_C::RagdollPowerObjScale' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBerserk) == 0x00134C, "Member 'ARSBattleEnemy_C::IsBerserk' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FlyUpTimer) == 0x001350, "Member 'ARSBattleEnemy_C::FlyUpTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FlyUpTime) == 0x001354, "Member 'ARSBattleEnemy_C::FlyUpTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FlyUpHeight) == 0x001358, "Member 'ARSBattleEnemy_C::FlyUpHeight' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FlyUpCurve) == 0x001360, "Member 'ARSBattleEnemy_C::FlyUpCurve' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FlyGroundHeight) == 0x001368, "Member 'ARSBattleEnemy_C::FlyGroundHeight' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AiDataTable) == 0x001370, "Member 'ARSBattleEnemy_C::AiDataTable' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBattleenemy) == 0x001378, "Member 'ARSBattleEnemy_C::IsBattleenemy' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsFlyMove) == 0x001379, "Member 'ARSBattleEnemy_C::IsFlyMove' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsJumpEnd) == 0x00137A, "Member 'ARSBattleEnemy_C::IsJumpEnd' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsDamageMotionEnd) == 0x00137B, "Member 'ARSBattleEnemy_C::IsDamageMotionEnd' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsFoodedFlg) == 0x00137C, "Member 'ARSBattleEnemy_C::IsFoodedFlg' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsMoveAnim) == 0x00137D, "Member 'ARSBattleEnemy_C::IsMoveAnim' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBrainCrashDead) == 0x00137E, "Member 'ARSBattleEnemy_C::IsBrainCrashDead' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsWait) == 0x00137F, "Member 'ARSBattleEnemy_C::IsWait' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsHitCheck) == 0x001380, "Member 'ARSBattleEnemy_C::IsHitCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakNo) == 0x001384, "Member 'ARSBattleEnemy_C::WeakNo' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsWeakEffect) == 0x001388, "Member 'ARSBattleEnemy_C::IsWeakEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakMaterialEmissiveScale) == 0x00138C, "Member 'ARSBattleEnemy_C::WeakMaterialEmissiveScale' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakMaterialEmissiveTimer) == 0x001390, "Member 'ARSBattleEnemy_C::WeakMaterialEmissiveTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsHitWeakMaterial) == 0x001394, "Member 'ARSBattleEnemy_C::IsHitWeakMaterial' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakMaterialRateMax) == 0x001395, "Member 'ARSBattleEnemy_C::WeakMaterialRateMax' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsMotionCancel) == 0x001396, "Member 'ARSBattleEnemy_C::IsMotionCancel' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakMaterialEmissiveCurve) == 0x001398, "Member 'ARSBattleEnemy_C::WeakMaterialEmissiveCurve' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MoveTimer) == 0x0013A0, "Member 'ARSBattleEnemy_C::MoveTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MoveTime) == 0x0013A4, "Member 'ARSBattleEnemy_C::MoveTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsWeakObjectRecommend) == 0x0013A8, "Member 'ARSBattleEnemy_C::IsWeakObjectRecommend' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsWeakDamage) == 0x0013A9, "Member 'ARSBattleEnemy_C::IsWeakDamage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashEffectOffset) == 0x0013AC, "Member 'ARSBattleEnemy_C::BrainCrashEffectOffset' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakObjectEntry) == 0x0013B0, "Member 'ARSBattleEnemy_C::WeakObjectEntry' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakPoint) == 0x0013C0, "Member 'ARSBattleEnemy_C::WeakPoint' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakName) == 0x0013EC, "Member 'ARSBattleEnemy_C::WeakName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DistanceFromEnemyToPlayer) == 0x0013F4, "Member 'ARSBattleEnemy_C::DistanceFromEnemyToPlayer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakEffectNum) == 0x0013F8, "Member 'ARSBattleEnemy_C::WeakEffectNum' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CharactersParameterBasicData) == 0x001400, "Member 'ARSBattleEnemy_C::CharactersParameterBasicData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, OldWeakMaterialRate) == 0x001468, "Member 'ARSBattleEnemy_C::OldWeakMaterialRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, OldWeakEffectRate) == 0x00146C, "Member 'ARSBattleEnemy_C::OldWeakEffectRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsWeakUiDamageHit) == 0x001470, "Member 'ARSBattleEnemy_C::IsWeakUiDamageHit' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MoveDistance) == 0x001474, "Member 'ARSBattleEnemy_C::MoveDistance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsMoveWalk) == 0x001478, "Member 'ARSBattleEnemy_C::IsMoveWalk' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BaseMontage) == 0x001480, "Member 'ARSBattleEnemy_C::BaseMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BaseMontageOld) == 0x001488, "Member 'ARSBattleEnemy_C::BaseMontageOld' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BaseDamageMontage) == 0x001498, "Member 'ARSBattleEnemy_C::BaseDamageMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsMontageDamageData) == 0x0014A0, "Member 'ARSBattleEnemy_C::IsMontageDamageData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ArmorNo) == 0x0014A4, "Member 'ARSBattleEnemy_C::ArmorNo' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakComponent) == 0x0014A8, "Member 'ARSBattleEnemy_C::WeakComponent' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MoveFlyToFail) == 0x0014B8, "Member 'ARSBattleEnemy_C::MoveFlyToFail' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FlyMoveTimer) == 0x0014BC, "Member 'ARSBattleEnemy_C::FlyMoveTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EEnemyCollisionType) == 0x0014C0, "Member 'ARSBattleEnemy_C::EEnemyCollisionType' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBeginPlayEnd) == 0x0014D0, "Member 'ARSBattleEnemy_C::IsBeginPlayEnd' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StealthTimer) == 0x0014D4, "Member 'ARSBattleEnemy_C::StealthTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StealthTime) == 0x0014D8, "Member 'ARSBattleEnemy_C::StealthTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsCheckGround) == 0x0014DC, "Member 'ARSBattleEnemy_C::IsCheckGround' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CheckGroundHeightTop) == 0x0014E0, "Member 'ARSBattleEnemy_C::CheckGroundHeightTop' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CheckGroundHeightBottom) == 0x0014E4, "Member 'ARSBattleEnemy_C::CheckGroundHeightBottom' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashHitWeak) == 0x0014E8, "Member 'ARSBattleEnemy_C::BrainCrashHitWeak' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBattleStart) == 0x0014F0, "Member 'ARSBattleEnemy_C::IsBattleStart' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ArmorFlashTimer) == 0x0014F4, "Member 'ARSBattleEnemy_C::ArmorFlashTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ArmorFlashScale) == 0x0014F8, "Member 'ARSBattleEnemy_C::ArmorFlashScale' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StealthRateName) == 0x0014FC, "Member 'ARSBattleEnemy_C::StealthRateName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StealthVanishName) == 0x001504, "Member 'ARSBattleEnemy_C::StealthVanishName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SeeThroughStealthRateName) == 0x00150C, "Member 'ARSBattleEnemy_C::SeeThroughStealthRateName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SeeThroughWeakSphereUse) == 0x001518, "Member 'ARSBattleEnemy_C::SeeThroughWeakSphereUse' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SeeThroughWeakSphereLocation) == 0x001528, "Member 'ARSBattleEnemy_C::SeeThroughWeakSphereLocation' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsDeadStartNotify) == 0x001538, "Member 'ARSBattleEnemy_C::IsDeadStartNotify' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DamageDir) == 0x00153C, "Member 'ARSBattleEnemy_C::DamageDir' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StealthState) == 0x001548, "Member 'ARSBattleEnemy_C::StealthState' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bIsInvisibleHPGauge) == 0x001549, "Member 'ARSBattleEnemy_C::bIsInvisibleHPGauge' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBranchAction) == 0x00154A, "Member 'ARSBattleEnemy_C::IsBranchAction' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IgnoreAiMoveSeconds) == 0x00154C, "Member 'ARSBattleEnemy_C::IgnoreAiMoveSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AvatarMaterialNames) == 0x001550, "Member 'ARSBattleEnemy_C::AvatarMaterialNames' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AddBaseColor_OilName) == 0x001560, "Member 'ARSBattleEnemy_C::AddBaseColor_OilName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StealthStartHP) == 0x001568, "Member 'ARSBattleEnemy_C::StealthStartHP' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBT_ForceBreak) == 0x00156C, "Member 'ARSBattleEnemy_C::IsBT_ForceBreak' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StealthRunAwayTarget) == 0x001570, "Member 'ARSBattleEnemy_C::StealthRunAwayTarget' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bCollisionHitWall) == 0x00157C, "Member 'ARSBattleEnemy_C::bCollisionHitWall' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bUniqueAction) == 0x00157D, "Member 'ARSBattleEnemy_C::bUniqueAction' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDebugEnableEnsure_TableNotFound) == 0x00157E, "Member 'ARSBattleEnemy_C::bDebugEnableEnsure_TableNotFound' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FormType) == 0x00157F, "Member 'ARSBattleEnemy_C::FormType' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CommonDeadEffect) == 0x001580, "Member 'ARSBattleEnemy_C::CommonDeadEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashDeadEffect) == 0x001588, "Member 'ARSBattleEnemy_C::BrainCrashDeadEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AvatarDeadEffect) == 0x001590, "Member 'ARSBattleEnemy_C::AvatarDeadEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashAvatarDeadEffect) == 0x001598, "Member 'ARSBattleEnemy_C::BrainCrashAvatarDeadEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bNotVanish) == 0x0015A0, "Member 'ARSBattleEnemy_C::bNotVanish' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsCoreDrop) == 0x0015A1, "Member 'ARSBattleEnemy_C::IsCoreDrop' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CanDropData) == 0x0015A2, "Member 'ARSBattleEnemy_C::CanDropData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashHitWeakEffectSoftRef) == 0x0015A8, "Member 'ARSBattleEnemy_C::BrainCrashHitWeakEffectSoftRef' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CommonDeadEffectSoftRef) == 0x0015D0, "Member 'ARSBattleEnemy_C::CommonDeadEffectSoftRef' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashDeadEffectSoftRef) == 0x0015F8, "Member 'ARSBattleEnemy_C::BrainCrashDeadEffectSoftRef' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AvatarDeadEffectSoftRef) == 0x001620, "Member 'ARSBattleEnemy_C::AvatarDeadEffectSoftRef' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashAvatarDeadEffectSoftRef) == 0x001648, "Member 'ARSBattleEnemy_C::BrainCrashAvatarDeadEffectSoftRef' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsEventWait) == 0x001670, "Member 'ARSBattleEnemy_C::IsEventWait' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsEventBerserk) == 0x001671, "Member 'ARSBattleEnemy_C::IsEventBerserk' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsSpawn) == 0x001672, "Member 'ARSBattleEnemy_C::IsSpawn' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnStartDistance) == 0x001674, "Member 'ARSBattleEnemy_C::SpawnStartDistance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ActionSpawn) == 0x001678, "Member 'ARSBattleEnemy_C::ActionSpawn' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CollisionState) == 0x001680, "Member 'ARSBattleEnemy_C::CollisionState' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsSpawnTarget) == 0x001690, "Member 'ARSBattleEnemy_C::IsSpawnTarget' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnEnemyKind) == 0x001691, "Member 'ARSBattleEnemy_C::SpawnEnemyKind' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBeforeBrainAccess) == 0x001692, "Member 'ARSBattleEnemy_C::IsBeforeBrainAccess' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ProgressBerserkProbability) == 0x001694, "Member 'ARSBattleEnemy_C::ProgressBerserkProbability' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsDelayDead) == 0x001698, "Member 'ARSBattleEnemy_C::IsDelayDead' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DelayDeadTime) == 0x00169C, "Member 'ARSBattleEnemy_C::DelayDeadTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadBeforeHitResult) == 0x0016A0, "Member 'ARSBattleEnemy_C::DeadBeforeHitResult' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TargetAngle) == 0x001860, "Member 'ARSBattleEnemy_C::TargetAngle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TargetCharacter) == 0x001868, "Member 'ARSBattleEnemy_C::TargetCharacter' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsHeightCheck) == 0x001870, "Member 'ARSBattleEnemy_C::IsHeightCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsTickEnableComponentArray) == 0x001878, "Member 'ARSBattleEnemy_C::IsTickEnableComponentArray' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickIntervalCounter) == 0x001888, "Member 'ARSBattleEnemy_C::TickIntervalCounter' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickIntervalMax) == 0x00188C, "Member 'ARSBattleEnemy_C::TickIntervalMax' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickIntervalDefault) == 0x001890, "Member 'ARSBattleEnemy_C::TickIntervalDefault' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateFlameParticleData) == 0x001898, "Member 'ARSBattleEnemy_C::EnemyBadStateFlameParticleData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateFlameParticleHandles) == 0x0018A8, "Member 'ARSBattleEnemy_C::EnemyBadStateFlameParticleHandles' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateElecParticleData) == 0x0018B8, "Member 'ARSBattleEnemy_C::EnemyBadStateElecParticleData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateElecParticleHandles) == 0x0018C8, "Member 'ARSBattleEnemy_C::EnemyBadStateElecParticleHandles' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateOilParticleData) == 0x0018D8, "Member 'ARSBattleEnemy_C::EnemyBadStateOilParticleData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateOilParticleHandles) == 0x0018E8, "Member 'ARSBattleEnemy_C::EnemyBadStateOilParticleHandles' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateFloodedParticleData) == 0x0018F8, "Member 'ARSBattleEnemy_C::EnemyBadStateFloodedParticleData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateFloodedParticleHandles) == 0x001908, "Member 'ARSBattleEnemy_C::EnemyBadStateFloodedParticleHandles' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TargetID) == 0x001918, "Member 'ARSBattleEnemy_C::TargetID' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TargetIndex) == 0x00191C, "Member 'ARSBattleEnemy_C::TargetIndex' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DamageRatio) == 0x001920, "Member 'ARSBattleEnemy_C::DamageRatio' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBendsDirection) == 0x001924, "Member 'ARSBattleEnemy_C::IsBendsDirection' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsOverWriteMotion) == 0x001925, "Member 'ARSBattleEnemy_C::IsOverWriteMotion' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsMotionReception) == 0x001926, "Member 'ARSBattleEnemy_C::IsMotionReception' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyAnimConRef) == 0x001928, "Member 'ARSBattleEnemy_C::EnemyAnimConRef' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BlendingOutMontage) == 0x001930, "Member 'ARSBattleEnemy_C::BlendingOutMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, UseBlendOutMontage) == 0x001938, "Member 'ARSBattleEnemy_C::UseBlendOutMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsStealthInfinite) == 0x001940, "Member 'ARSBattleEnemy_C::IsStealthInfinite' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DownBonusScale) == 0x001944, "Member 'ARSBattleEnemy_C::DownBonusScale' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HideWeak) == 0x001948, "Member 'ARSBattleEnemy_C::HideWeak' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickIntervalMaxSimple) == 0x00194C, "Member 'ARSBattleEnemy_C::TickIntervalMaxSimple' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickIntervalDefaultSimple) == 0x001950, "Member 'ARSBattleEnemy_C::TickIntervalDefaultSimple' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsSpawnNow) == 0x001954, "Member 'ARSBattleEnemy_C::IsSpawnNow' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnWaitDelayTime) == 0x001958, "Member 'ARSBattleEnemy_C::SpawnWaitDelayTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnStartDelayTime) == 0x00195C, "Member 'ARSBattleEnemy_C::SpawnStartDelayTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnUpdateTime) == 0x001960, "Member 'ARSBattleEnemy_C::SpawnUpdateTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnState) == 0x001964, "Member 'ARSBattleEnemy_C::SpawnState' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AiTableDataMap) == 0x001968, "Member 'ARSBattleEnemy_C::AiTableDataMap' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadEnemyHitStopSeconds) == 0x0019B8, "Member 'ARSBattleEnemy_C::DeadEnemyHitStopSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadEnemyHitStopRate) == 0x0019BC, "Member 'ARSBattleEnemy_C::DeadEnemyHitStopRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitStop_Type) == 0x0019C0, "Member 'ARSBattleEnemy_C::HitStop_Type' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitStop_Seconds) == 0x0019C4, "Member 'ARSBattleEnemy_C::HitStop_Seconds' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitStop_Rate) == 0x0019C8, "Member 'ARSBattleEnemy_C::HitStop_Rate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitStop_IsStart) == 0x0019CC, "Member 'ARSBattleEnemy_C::HitStop_IsStart' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitStop_StartDelayTime) == 0x0019D0, "Member 'ARSBattleEnemy_C::HitStop_StartDelayTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitStop_IsTarget) == 0x0019D4, "Member 'ARSBattleEnemy_C::HitStop_IsTarget' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitStop_AllThrow) == 0x0019D5, "Member 'ARSBattleEnemy_C::HitStop_AllThrow' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DamageAngle) == 0x0019D8, "Member 'ARSBattleEnemy_C::DamageAngle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CueSheetRefs) == 0x0019E0, "Member 'ARSBattleEnemy_C::CueSheetRefs' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CueSheetObjs) == 0x0019F0, "Member 'ARSBattleEnemy_C::CueSheetObjs' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsReturn) == 0x001A00, "Member 'ARSBattleEnemy_C::IsReturn' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsReturnNow) == 0x001A01, "Member 'ARSBattleEnemy_C::IsReturnNow' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ReturnupdateTime) == 0x001A04, "Member 'ARSBattleEnemy_C::ReturnupdateTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ReturnState) == 0x001A08, "Member 'ARSBattleEnemy_C::ReturnState' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnCurrentWaitDelayTime) == 0x001A0C, "Member 'ARSBattleEnemy_C::SpawnCurrentWaitDelayTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnCurrentStartDelayTime) == 0x001A10, "Member 'ARSBattleEnemy_C::SpawnCurrentStartDelayTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnCurrentUpdateTime) == 0x001A14, "Member 'ARSBattleEnemy_C::SpawnCurrentUpdateTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ReturnCurrentUpdateTime) == 0x001A18, "Member 'ARSBattleEnemy_C::ReturnCurrentUpdateTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SoundType) == 0x001A1C, "Member 'ARSBattleEnemy_C::SoundType' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsReverseBlowMotion) == 0x001A1D, "Member 'ARSBattleEnemy_C::IsReverseBlowMotion' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashSequenceReference) == 0x001A20, "Member 'ARSBattleEnemy_C::BrainCrashSequenceReference' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashSequenceReference2) == 0x001A48, "Member 'ARSBattleEnemy_C::BrainCrashSequenceReference2' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashSequenceInstance) == 0x001A70, "Member 'ARSBattleEnemy_C::BrainCrashSequenceInstance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBlowTurnaround) == 0x001A78, "Member 'ARSBattleEnemy_C::IsBlowTurnaround' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsDownTurnaround) == 0x001A79, "Member 'ARSBattleEnemy_C::IsDownTurnaround' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FlyUpWaitTimer) == 0x001A7C, "Member 'ARSBattleEnemy_C::FlyUpWaitTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FlyUpWaitTime) == 0x001A80, "Member 'ARSBattleEnemy_C::FlyUpWaitTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BerserkSignAction) == 0x001A84, "Member 'ARSBattleEnemy_C::BerserkSignAction' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsReleaseDelayDeath) == 0x001A85, "Member 'ARSBattleEnemy_C::IsReleaseDelayDeath' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ReleaseDelayDeathWait) == 0x001A88, "Member 'ARSBattleEnemy_C::ReleaseDelayDeathWait' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bCrashChanceDown) == 0x001A8C, "Member 'ARSBattleEnemy_C::bCrashChanceDown' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitCrashDamage) == 0x001A8D, "Member 'ARSBattleEnemy_C::HitCrashDamage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangingCrashDamageMaterial) == 0x001A8E, "Member 'ARSBattleEnemy_C::IsChangingCrashDamageMaterial' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashDamageMaterialVectorCurve) == 0x001A90, "Member 'ARSBattleEnemy_C::CrashDamageMaterialVectorCurve' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashDamageMaterialTime) == 0x001A98, "Member 'ARSBattleEnemy_C::CrashDamageMaterialTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, PossibleBrainCrashRange) == 0x001A9C, "Member 'ARSBattleEnemy_C::PossibleBrainCrashRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashDamageMaterialScale) == 0x001AA0, "Member 'ARSBattleEnemy_C::CrashDamageMaterialScale' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsUniqueBadState) == 0x001AA4, "Member 'ARSBattleEnemy_C::IsUniqueBadState' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsDamageRotation) == 0x001AA5, "Member 'ARSBattleEnemy_C::IsDamageRotation' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DamageMoveScale) == 0x001AA8, "Member 'ARSBattleEnemy_C::DamageMoveScale' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DamageLocation) == 0x001AAC, "Member 'ARSBattleEnemy_C::DamageLocation' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashChanceBrainRotate) == 0x001AB8, "Member 'ARSBattleEnemy_C::CrashChanceBrainRotate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashDamageHighRate) == 0x001AC4, "Member 'ARSBattleEnemy_C::CrashDamageHighRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsNewLaunch) == 0x001AC8, "Member 'ARSBattleEnemy_C::IsNewLaunch' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AnimMontage) == 0x001AD0, "Member 'ARSBattleEnemy_C::AnimMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsEnableLaunch) == 0x001AD8, "Member 'ARSBattleEnemy_C::IsEnableLaunch' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsRequestAddDamageMontage) == 0x001AD9, "Member 'ARSBattleEnemy_C::IsRequestAddDamageMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakHitReactionSRate) == 0x001ADC, "Member 'ARSBattleEnemy_C::WeakHitReactionSRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakHitReactionLRate) == 0x001AE0, "Member 'ARSBattleEnemy_C::WeakHitReactionLRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakHitDownRate) == 0x001AE4, "Member 'ARSBattleEnemy_C::WeakHitDownRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bIsDispHp) == 0x001AE8, "Member 'ARSBattleEnemy_C::bIsDispHp' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DispHpTimer) == 0x001AEC, "Member 'ARSBattleEnemy_C::DispHpTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CurrentDispHpTimer) == 0x001AF0, "Member 'ARSBattleEnemy_C::CurrentDispHpTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyCameraShakeRangeL) == 0x001AF4, "Member 'ARSBattleEnemy_C::EnemyCameraShakeRangeL' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyCameraShakeRangeM) == 0x001AF8, "Member 'ARSBattleEnemy_C::EnemyCameraShakeRangeM' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyCameraShakeRangeS) == 0x001AFC, "Member 'ARSBattleEnemy_C::EnemyCameraShakeRangeS' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ArmorBreakSE) == 0x001B00, "Member 'ARSBattleEnemy_C::ArmorBreakSE' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDebugReactionLFlash) == 0x001B08, "Member 'ARSBattleEnemy_C::bDebugReactionLFlash' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bNotReflectContainer) == 0x001B09, "Member 'ARSBattleEnemy_C::bNotReflectContainer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bCrashChanceFly) == 0x001B0A, "Member 'ARSBattleEnemy_C::bCrashChanceFly' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CurBadStateMaterial) == 0x001B0B, "Member 'ARSBattleEnemy_C::CurBadStateMaterial' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsWinceCounter) == 0x001B0C, "Member 'ARSBattleEnemy_C::IsWinceCounter' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WinceCounter) == 0x001B10, "Member 'ARSBattleEnemy_C::WinceCounter' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsPressDown) == 0x001B14, "Member 'ARSBattleEnemy_C::IsPressDown' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnablePressDown) == 0x001B15, "Member 'ARSBattleEnemy_C::EnablePressDown' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsAcceptKnockBackCounter) == 0x001B16, "Member 'ARSBattleEnemy_C::IsAcceptKnockBackCounter' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnableKnockBackCounter) == 0x001B17, "Member 'ARSBattleEnemy_C::EnableKnockBackCounter' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnableWinceCounter) == 0x001B18, "Member 'ARSBattleEnemy_C::EnableWinceCounter' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WinceCount) == 0x001B1C, "Member 'ARSBattleEnemy_C::WinceCount' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsKnockBackCounter) == 0x001B20, "Member 'ARSBattleEnemy_C::IsKnockBackCounter' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCrashSequenceInstance2) == 0x001B28, "Member 'ARSBattleEnemy_C::BrainCrashSequenceInstance2' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDiscoveredTarget) == 0x001B30, "Member 'ARSBattleEnemy_C::bDiscoveredTarget' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DiscoverIconOffsetHeight) == 0x001B34, "Member 'ARSBattleEnemy_C::DiscoverIconOffsetHeight' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableFitGround) == 0x001B38, "Member 'ARSBattleEnemy_C::bEnableFitGround' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FitGroundSpeed) == 0x001B3C, "Member 'ARSBattleEnemy_C::FitGroundSpeed' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FitGroundAngleLimit) == 0x001B40, "Member 'ARSBattleEnemy_C::FitGroundAngleLimit' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bChangingWeakDamageMaterial) == 0x001B44, "Member 'ARSBattleEnemy_C::bChangingWeakDamageMaterial' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakDamageMaterialTime) == 0x001B48, "Member 'ARSBattleEnemy_C::WeakDamageMaterialTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakDamageMaterialScale) == 0x001B4C, "Member 'ARSBattleEnemy_C::WeakDamageMaterialScale' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakMaterialSlotName) == 0x001B50, "Member 'ARSBattleEnemy_C::WeakMaterialSlotName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakMaterialInst) == 0x001B58, "Member 'ARSBattleEnemy_C::WeakMaterialInst' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakDamageMaterialVectorCurve) == 0x001B60, "Member 'ARSBattleEnemy_C::WeakDamageMaterialVectorCurve' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bBeforeUniqueObjState) == 0x001B68, "Member 'ARSBattleEnemy_C::bBeforeUniqueObjState' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bUniqueObjState) == 0x001B69, "Member 'ARSBattleEnemy_C::bUniqueObjState' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AvoidInvalidLength) == 0x001B6C, "Member 'ARSBattleEnemy_C::AvoidInvalidLength' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AvoidEnableActionKind) == 0x001B70, "Member 'ARSBattleEnemy_C::AvoidEnableActionKind' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AvoidProbabilityList) == 0x001B80, "Member 'ARSBattleEnemy_C::AvoidProbabilityList' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableAvoidObject) == 0x001B90, "Member 'ARSBattleEnemy_C::bEnableAvoidObject' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainCoreReference) == 0x001B98, "Member 'ARSBattleEnemy_C::BrainCoreReference' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BossBrainCrashSequenceReference) == 0x001BA0, "Member 'ARSBattleEnemy_C::BossBrainCrashSequenceReference' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BossBrainCrashSequenceReference2) == 0x001BC8, "Member 'ARSBattleEnemy_C::BossBrainCrashSequenceReference2' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BossBrainCrashSequenceInstance) == 0x001BF0, "Member 'ARSBattleEnemy_C::BossBrainCrashSequenceInstance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BossBrainCrashSequenceInstance2) == 0x001BF8, "Member 'ARSBattleEnemy_C::BossBrainCrashSequenceInstance2' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsLastBossBrainCrash) == 0x001C00, "Member 'ARSBattleEnemy_C::IsLastBossBrainCrash' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MaxCrashResistance) == 0x001C04, "Member 'ARSBattleEnemy_C::MaxCrashResistance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bPressDownLoop) == 0x001C08, "Member 'ARSBattleEnemy_C::bPressDownLoop' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, PressLoopTime) == 0x001C0C, "Member 'ARSBattleEnemy_C::PressLoopTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TargetHeight) == 0x001C10, "Member 'ARSBattleEnemy_C::TargetHeight' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HeightFromEnemyToPlayer) == 0x001C14, "Member 'ARSBattleEnemy_C::HeightFromEnemyToPlayer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HeightFromEnemyInitToPlayer) == 0x001C18, "Member 'ARSBattleEnemy_C::HeightFromEnemyInitToPlayer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableDiscoverIcon) == 0x001C1C, "Member 'ARSBattleEnemy_C::bEnableDiscoverIcon' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CheckCapsuleRadius) == 0x001C20, "Member 'ARSBattleEnemy_C::CheckCapsuleRadius' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableRequestIK) == 0x001C24, "Member 'ARSBattleEnemy_C::bEnableRequestIK' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakMaterialRateCurveData) == 0x001C28, "Member 'ARSBattleEnemy_C::WeakMaterialRateCurveData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MyDeadFactor) == 0x001C30, "Member 'ARSBattleEnemy_C::MyDeadFactor' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bStartWeakAroundEffect) == 0x001C38, "Member 'ARSBattleEnemy_C::bStartWeakAroundEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableLookAt) == 0x001C48, "Member 'ARSBattleEnemy_C::bEnableLookAt' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bUpdateBadStateMaterial) == 0x001C49, "Member 'ARSBattleEnemy_C::bUpdateBadStateMaterial' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BadStateMaterialCurveTime) == 0x001C4C, "Member 'ARSBattleEnemy_C::BadStateMaterialCurveTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bBrainCrashMiss) == 0x001C50, "Member 'ARSBattleEnemy_C::bBrainCrashMiss' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeCharacterCollision) == 0x001C51, "Member 'ARSBattleEnemy_C::IsChangeCharacterCollision' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MoveScaleCurveData) == 0x001C58, "Member 'ARSBattleEnemy_C::MoveScaleCurveData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bReceivedNotifyLookAt) == 0x001C60, "Member 'ARSBattleEnemy_C::bReceivedNotifyLookAt' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableWander) == 0x001C61, "Member 'ARSBattleEnemy_C::bEnableWander' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CoreWeakEffect_CommonRate) == 0x001C64, "Member 'ARSBattleEnemy_C::CoreWeakEffect_CommonRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CoreWeakEffect_AttachRate) == 0x001C68, "Member 'ARSBattleEnemy_C::CoreWeakEffect_AttachRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LaunchDownTime) == 0x001C6C, "Member 'ARSBattleEnemy_C::LaunchDownTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsLaunchDown) == 0x001C70, "Member 'ARSBattleEnemy_C::IsLaunchDown' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CurBadStateCurve) == 0x001C78, "Member 'ARSBattleEnemy_C::CurBadStateCurve' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BadStateCurveFlame) == 0x001C80, "Member 'ARSBattleEnemy_C::BadStateCurveFlame' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BadStateCurveElec) == 0x001C88, "Member 'ARSBattleEnemy_C::BadStateCurveElec' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DebugPrintSlotName) == 0x001C90, "Member 'ARSBattleEnemy_C::DebugPrintSlotName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DebugIgnoreActions) == 0x001CA0, "Member 'ARSBattleEnemy_C::DebugIgnoreActions' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BadStateStartDamageMotion) == 0x001CB0, "Member 'ARSBattleEnemy_C::BadStateStartDamageMotion' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableFitGroundTmp) == 0x001CB4, "Member 'ARSBattleEnemy_C::bEnableFitGroundTmp' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EndFitGround) == 0x001CB5, "Member 'ARSBattleEnemy_C::EndFitGround' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsStartHideArmor) == 0x001CB6, "Member 'ARSBattleEnemy_C::IsStartHideArmor' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bBrainFieldSealWeakParticle) == 0x001CB7, "Member 'ARSBattleEnemy_C::bBrainFieldSealWeakParticle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainFieldClaimantName) == 0x001CB8, "Member 'ARSBattleEnemy_C::BrainFieldClaimantName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDamageFloating) == 0x001CC0, "Member 'ARSBattleEnemy_C::bDamageFloating' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SaveBodyEmissiveValue) == 0x001CC8, "Member 'ARSBattleEnemy_C::SaveBodyEmissiveValue' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bExecLowProcess) == 0x001CD8, "Member 'ARSBattleEnemy_C::bExecLowProcess' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainInitPos) == 0x001CDC, "Member 'ARSBattleEnemy_C::BrainInitPos' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DownUpMoveAnimKind) == 0x001CE8, "Member 'ARSBattleEnemy_C::DownUpMoveAnimKind' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ReactionChangeDilationTimer) == 0x001CEC, "Member 'ARSBattleEnemy_C::ReactionChangeDilationTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TopHeightSocketName) == 0x001CF0, "Member 'ARSBattleEnemy_C::TopHeightSocketName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bIdleMove) == 0x001CF8, "Member 'ARSBattleEnemy_C::bIdleMove' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadEffectHandle) == 0x001D00, "Member 'ARSBattleEnemy_C::DeadEffectHandle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDisableWeakAroundEffect) == 0x001D08, "Member 'ARSBattleEnemy_C::bDisableWeakAroundEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bLaunchIgnorePriority) == 0x001D09, "Member 'ARSBattleEnemy_C::bLaunchIgnorePriority' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SavedDamageDown) == 0x001D0A, "Member 'ARSBattleEnemy_C::SavedDamageDown' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateAddFlameParticleData) == 0x001D10, "Member 'ARSBattleEnemy_C::EnemyBadStateAddFlameParticleData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateAddElecParticleData) == 0x001D38, "Member 'ARSBattleEnemy_C::EnemyBadStateAddElecParticleData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateAddOilParticleData) == 0x001D60, "Member 'ARSBattleEnemy_C::EnemyBadStateAddOilParticleData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyBadStateAddFloodedParticleData) == 0x001D88, "Member 'ARSBattleEnemy_C::EnemyBadStateAddFloodedParticleData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BadStateAddEffectOffset) == 0x001DB0, "Member 'ARSBattleEnemy_C::BadStateAddEffectOffset' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickIntervalSeconds) == 0x001DB4, "Member 'ARSBattleEnemy_C::TickIntervalSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableEnemyGoal) == 0x001DB8, "Member 'ARSBattleEnemy_C::bEnableEnemyGoal' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bAdjustCharaCapsule) == 0x001DB9, "Member 'ARSBattleEnemy_C::bAdjustCharaCapsule' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AdjustCharaCapsuleName) == 0x001DBC, "Member 'ARSBattleEnemy_C::AdjustCharaCapsuleName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AdjustCharaCapsuleOffset) == 0x001DC4, "Member 'ARSBattleEnemy_C::AdjustCharaCapsuleOffset' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AdjustCharaCapsuleInterpTime) == 0x001DD0, "Member 'ARSBattleEnemy_C::AdjustCharaCapsuleInterpTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CurrentAdjustCharaCapsuleInterpTime) == 0x001DD4, "Member 'ARSBattleEnemy_C::CurrentAdjustCharaCapsuleInterpTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bAdjustInterpCharaCapsule) == 0x001DD8, "Member 'ARSBattleEnemy_C::bAdjustInterpCharaCapsule' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakTargetSocketName) == 0x001DE0, "Member 'ARSBattleEnemy_C::WeakTargetSocketName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashChanceLoopEffect) == 0x001DF0, "Member 'ARSBattleEnemy_C::CrashChanceLoopEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashChanceLoopEffectSoftReference) == 0x001DF8, "Member 'ARSBattleEnemy_C::CrashChanceLoopEffectSoftReference' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashChanceLoopEffectHandle) == 0x001E20, "Member 'ARSBattleEnemy_C::CrashChanceLoopEffectHandle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bNewDamageFloating) == 0x001E28, "Member 'ARSBattleEnemy_C::bNewDamageFloating' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsLaunchTurnaround) == 0x001E29, "Member 'ARSBattleEnemy_C::IsLaunchTurnaround' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EyeSocketName) == 0x001E2C, "Member 'ARSBattleEnemy_C::EyeSocketName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, FindChangeParam) == 0x001E34, "Member 'ARSBattleEnemy_C::FindChangeParam' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LastDetectIcon) == 0x001E44, "Member 'ARSBattleEnemy_C::LastDetectIcon' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsSpecialDownFlyRot) == 0x001E45, "Member 'ARSBattleEnemy_C::IsSpecialDownFlyRot' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeCharaCollisionNo) == 0x001E46, "Member 'ARSBattleEnemy_C::ChangeCharaCollisionNo' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CharaCollisionList) == 0x001E48, "Member 'ARSBattleEnemy_C::CharaCollisionList' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bInvincible) == 0x001E58, "Member 'ARSBattleEnemy_C::bInvincible' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BaseMontageStartTime) == 0x001E5C, "Member 'ARSBattleEnemy_C::BaseMontageStartTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, PreviousMaterialSwitchStealth) == 0x001E60, "Member 'ARSBattleEnemy_C::PreviousMaterialSwitchStealth' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MaterialSwitchCache) == 0x001E68, "Member 'ARSBattleEnemy_C::MaterialSwitchCache' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnMoveAnim) == 0x001E78, "Member 'ARSBattleEnemy_C::SpawnMoveAnim' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, UniqueName) == 0x001E7C, "Member 'ARSBattleEnemy_C::UniqueName' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsHiddenFirstDiscoverIcon) == 0x001E84, "Member 'ARSBattleEnemy_C::IsHiddenFirstDiscoverIcon' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsStartOnStealth) == 0x001E85, "Member 'ARSBattleEnemy_C::IsStartOnStealth' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsIgnoreRestrictAttackOther) == 0x001E86, "Member 'ARSBattleEnemy_C::IsIgnoreRestrictAttackOther' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsIgnoreAllowance) == 0x001E87, "Member 'ARSBattleEnemy_C::IsIgnoreAllowance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsNoCheckCaptureArea) == 0x001E88, "Member 'ARSBattleEnemy_C::IsNoCheckCaptureArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeSearchAngle) == 0x001E89, "Member 'ARSBattleEnemy_C::IsChangeSearchAngle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeSearchAngle) == 0x001E8C, "Member 'ARSBattleEnemy_C::ChangeSearchAngle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsAlwaysChangeSearchAngle) == 0x001E90, "Member 'ARSBattleEnemy_C::IsAlwaysChangeSearchAngle' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeSearchRange) == 0x001E91, "Member 'ARSBattleEnemy_C::IsChangeSearchRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeSearchRange) == 0x001E94, "Member 'ARSBattleEnemy_C::ChangeSearchRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsAlwaysChangeSearchRange) == 0x001E98, "Member 'ARSBattleEnemy_C::IsAlwaysChangeSearchRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeSensingArea) == 0x001E99, "Member 'ARSBattleEnemy_C::IsChangeSensingArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeSensingArea) == 0x001E9C, "Member 'ARSBattleEnemy_C::ChangeSensingArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsAlwaysSensingArea) == 0x001EA0, "Member 'ARSBattleEnemy_C::IsAlwaysSensingArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeCaptureArea) == 0x001EA1, "Member 'ARSBattleEnemy_C::IsChangeCaptureArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeCaptureArea) == 0x001EA4, "Member 'ARSBattleEnemy_C::ChangeCaptureArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsAlwaysCaptureArea) == 0x001EA8, "Member 'ARSBattleEnemy_C::IsAlwaysCaptureArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeTerritoryArea) == 0x001EA9, "Member 'ARSBattleEnemy_C::IsChangeTerritoryArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeTerritoryArea) == 0x001EAC, "Member 'ARSBattleEnemy_C::ChangeTerritoryArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsAlwaysTerritoryArea) == 0x001EB0, "Member 'ARSBattleEnemy_C::IsAlwaysTerritoryArea' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeRepopTime) == 0x001EB1, "Member 'ARSBattleEnemy_C::IsChangeRepopTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeRepopTime) == 0x001EB4, "Member 'ARSBattleEnemy_C::ChangeRepopTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeRepopRange) == 0x001EB8, "Member 'ARSBattleEnemy_C::IsChangeRepopRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeRepopRange) == 0x001EBC, "Member 'ARSBattleEnemy_C::ChangeRepopRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeRepopTimeTerritory) == 0x001EC0, "Member 'ARSBattleEnemy_C::IsChangeRepopTimeTerritory' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeRepopTimeTerritory) == 0x001EC4, "Member 'ARSBattleEnemy_C::ChangeRepopTimeTerritory' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DamageStealthHalfTime) == 0x001EC8, "Member 'ARSBattleEnemy_C::DamageStealthHalfTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsStealthHalfNeedUpdate) == 0x001ECC, "Member 'ARSBattleEnemy_C::IsStealthHalfNeedUpdate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StealthHalfParam) == 0x001ED0, "Member 'ARSBattleEnemy_C::StealthHalfParam' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsStealthHalfParamUp) == 0x001ED4, "Member 'ARSBattleEnemy_C::IsStealthHalfParamUp' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsNotAddedBattleManager) == 0x001ED5, "Member 'ARSBattleEnemy_C::IsNotAddedBattleManager' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsHitWeek) == 0x001ED6, "Member 'ARSBattleEnemy_C::IsHitWeek' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SkillExtraType) == 0x001ED8, "Member 'ARSBattleEnemy_C::SkillExtraType' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DetectIconEffect) == 0x001EE8, "Member 'ARSBattleEnemy_C::DetectIconEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DetectIconTimer) == 0x001EF0, "Member 'ARSBattleEnemy_C::DetectIconTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsDownSasFlagIgnoreDownTrigger) == 0x001EFC, "Member 'ARSBattleEnemy_C::IsDownSasFlagIgnoreDownTrigger' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsKnockbackSasFlagIgnoreKnockbackTrigger) == 0x001EFD, "Member 'ARSBattleEnemy_C::IsKnockbackSasFlagIgnoreKnockbackTrigger' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsDownSasFlagIgnoreDownTriggerFlag) == 0x001EFE, "Member 'ARSBattleEnemy_C::IsDownSasFlagIgnoreDownTriggerFlag' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsKnockbackSasFlagIgnoreKnockbackTriggerFlag) == 0x001EFF, "Member 'ARSBattleEnemy_C::IsKnockbackSasFlagIgnoreKnockbackTriggerFlag' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableWeak) == 0x001F00, "Member 'ARSBattleEnemy_C::bEnableWeak' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ReserveMontage) == 0x001F08, "Member 'ARSBattleEnemy_C::ReserveMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnemyFixParam) == 0x001F10, "Member 'ARSBattleEnemy_C::EnemyFixParam' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsChangeSearchParam) == 0x001F18, "Member 'ARSBattleEnemy_C::IsChangeSearchParam' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ET_StopID) == 0x001F1C, "Member 'ARSBattleEnemy_C::ET_StopID' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LostActionTimer) == 0x001F20, "Member 'ARSBattleEnemy_C::LostActionTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnableLostActionTime) == 0x001F2C, "Member 'ARSBattleEnemy_C::EnableLostActionTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDisableLostAction) == 0x001F30, "Member 'ARSBattleEnemy_C::bDisableLostAction' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LostActionProbability) == 0x001F34, "Member 'ARSBattleEnemy_C::LostActionProbability' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LostActionInfoList) == 0x001F38, "Member 'ARSBattleEnemy_C::LostActionInfoList' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ActivityAreaOutTimer) == 0x001F48, "Member 'ARSBattleEnemy_C::ActivityAreaOutTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ActivityAreaOutDistance) == 0x001F4C, "Member 'ARSBattleEnemy_C::ActivityAreaOutDistance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, InitGroundPos) == 0x001F50, "Member 'ARSBattleEnemy_C::InitGroundPos' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LostMoveTimeMin) == 0x001F5C, "Member 'ARSBattleEnemy_C::LostMoveTimeMin' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LostMoveTime_Max) == 0x001F60, "Member 'ARSBattleEnemy_C::LostMoveTime_Max' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LostMoveRotationRate) == 0x001F64, "Member 'ARSBattleEnemy_C::LostMoveRotationRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bUseDefaultSpawnSearchParam) == 0x001F68, "Member 'ARSBattleEnemy_C::bUseDefaultSpawnSearchParam' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, GeneralBrainCrashSequenceReference) == 0x001F70, "Member 'ARSBattleEnemy_C::GeneralBrainCrashSequenceReference' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, GeneralBrainCrashSequenceInstance) == 0x001F98, "Member 'ARSBattleEnemy_C::GeneralBrainCrashSequenceInstance' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, GeneralBcSequencerActor) == 0x001FA0, "Member 'ARSBattleEnemy_C::GeneralBcSequencerActor' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NormalWeakMaterialRateCurveData) == 0x001FA8, "Member 'ARSBattleEnemy_C::NormalWeakMaterialRateCurveData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NormalWeakMaterialScale) == 0x001FB0, "Member 'ARSBattleEnemy_C::NormalWeakMaterialScale' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NormalWeakMaterialEmissiveCurve) == 0x001FB8, "Member 'ARSBattleEnemy_C::NormalWeakMaterialEmissiveCurve' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NormalWeakMaterialEmissiveMax) == 0x001FC0, "Member 'ARSBattleEnemy_C::NormalWeakMaterialEmissiveMax' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NormalWeakMaterialEmissiveMin) == 0x001FC4, "Member 'ARSBattleEnemy_C::NormalWeakMaterialEmissiveMin' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NormalWeakMaterialRateMax) == 0x001FC8, "Member 'ARSBattleEnemy_C::NormalWeakMaterialRateMax' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NormalWeakMaterialRateMin) == 0x001FCC, "Member 'ARSBattleEnemy_C::NormalWeakMaterialRateMin' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bStopWeakEmissive) == 0x001FD0, "Member 'ARSBattleEnemy_C::bStopWeakEmissive' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnemyArmorBreak) == 0x001FD1, "Member 'ARSBattleEnemy_C::bEnemyArmorBreak' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bNoBrainCore) == 0x001FD2, "Member 'ARSBattleEnemy_C::bNoBrainCore' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bHitReactionTrigger) == 0x001FD3, "Member 'ARSBattleEnemy_C::bHitReactionTrigger' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BadStateCurveFlameEnd) == 0x001FD8, "Member 'ARSBattleEnemy_C::BadStateCurveFlameEnd' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BadStateCurveElecEnd) == 0x001FE0, "Member 'ARSBattleEnemy_C::BadStateCurveElecEnd' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LEnemyManager) == 0x001FE8, "Member 'ARSBattleEnemy_C::LEnemyManager' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CurrentAiType) == 0x001FF0, "Member 'ARSBattleEnemy_C::CurrentAiType' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ChangeAiTypeInfoList) == 0x001FF8, "Member 'ARSBattleEnemy_C::ChangeAiTypeInfoList' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnMovementMode) == 0x002048, "Member 'ARSBattleEnemy_C::SpawnMovementMode' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NormalWeakMaterialEmissivePowerMin) == 0x00204C, "Member 'ARSBattleEnemy_C::NormalWeakMaterialEmissivePowerMin' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NormalWeakMaterialEmissivePowerMax) == 0x002050, "Member 'ARSBattleEnemy_C::NormalWeakMaterialEmissivePowerMax' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakMaterialEmissivePowerMax) == 0x002054, "Member 'ARSBattleEnemy_C::WeakMaterialEmissivePowerMax' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakMaterialPointRateMax) == 0x002058, "Member 'ARSBattleEnemy_C::WeakMaterialPointRateMax' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AssassinAttackHitType) == 0x00205C, "Member 'ARSBattleEnemy_C::AssassinAttackHitType' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsRepop) == 0x00205D, "Member 'ARSBattleEnemy_C::IsRepop' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RepopTime) == 0x002060, "Member 'ARSBattleEnemy_C::RepopTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RepopRange) == 0x002064, "Member 'ARSBattleEnemy_C::RepopRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RepopProbability) == 0x002068, "Member 'ARSBattleEnemy_C::RepopProbability' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsAreaOut) == 0x00206C, "Member 'ARSBattleEnemy_C::IsAreaOut' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AreaOutTimer) == 0x002070, "Member 'ARSBattleEnemy_C::AreaOutTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AreaOutSequence) == 0x00207C, "Member 'ARSBattleEnemy_C::AreaOutSequence' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsStealthEndLaunch) == 0x002080, "Member 'ARSBattleEnemy_C::IsStealthEndLaunch' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsStealthEndLaunchEdit) == 0x002081, "Member 'ARSBattleEnemy_C::IsStealthEndLaunchEdit' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnableDeadEffect) == 0x002082, "Member 'ARSBattleEnemy_C::EnableDeadEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bNoDisplayDiscoverIcon) == 0x002083, "Member 'ARSBattleEnemy_C::bNoDisplayDiscoverIcon' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, GoHomeAminKind) == 0x002088, "Member 'ARSBattleEnemy_C::GoHomeAminKind' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RowNameAnimScaleHitStop) == 0x002098, "Member 'ARSBattleEnemy_C::RowNameAnimScaleHitStop' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsAnimScaleChangingHitStop) == 0x0020A0, "Member 'ARSBattleEnemy_C::IsAnimScaleChangingHitStop' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsAnimScaleChangingHitStopSlow) == 0x0020A1, "Member 'ARSBattleEnemy_C::IsAnimScaleChangingHitStopSlow' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDiscoveredOnce) == 0x0020A2, "Member 'ARSBattleEnemy_C::bDiscoveredOnce' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDiscoverClosed) == 0x0020A3, "Member 'ARSBattleEnemy_C::bDiscoverClosed' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsBrainCrashDamageDown) == 0x0020A4, "Member 'ARSBattleEnemy_C::IsBrainCrashDamageDown' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsUseBrainCrashAfterMotion) == 0x0020A5, "Member 'ARSBattleEnemy_C::IsUseBrainCrashAfterMotion' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, PathAreaOutTimer) == 0x0020A8, "Member 'ARSBattleEnemy_C::PathAreaOutTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickProirity) == 0x0020B4, "Member 'ARSBattleEnemy_C::TickProirity' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickSumRealSeconds) == 0x0020B8, "Member 'ARSBattleEnemy_C::TickSumRealSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickRealSeconds) == 0x0020BC, "Member 'ARSBattleEnemy_C::TickRealSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ExecTick) == 0x0020C0, "Member 'ARSBattleEnemy_C::ExecTick' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickSumActorSeconds) == 0x0020C4, "Member 'ARSBattleEnemy_C::TickSumActorSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TickActorSeconds) == 0x0020C8, "Member 'ARSBattleEnemy_C::TickActorSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsOutOfBattlefield) == 0x0020CC, "Member 'ARSBattleEnemy_C::IsOutOfBattlefield' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bDefeatedMainPlayer) == 0x0020CD, "Member 'ARSBattleEnemy_C::bDefeatedMainPlayer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, UroOffLength) == 0x0020D0, "Member 'ARSBattleEnemy_C::UroOffLength' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, UpdateWeakMaterialEnable) == 0x0020D4, "Member 'ARSBattleEnemy_C::UpdateWeakMaterialEnable' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, WeakSlotNameList) == 0x0020D8, "Member 'ARSBattleEnemy_C::WeakSlotNameList' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, OldWeakMaterialEmissiveTime) == 0x0020E8, "Member 'ARSBattleEnemy_C::OldWeakMaterialEmissiveTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnableUpdateSeeThrought) == 0x0020EC, "Member 'ARSBattleEnemy_C::EnableUpdateSeeThrought' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EndSetSpawnParam) == 0x0020ED, "Member 'ARSBattleEnemy_C::EndSetSpawnParam' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SimpleEnemy) == 0x0020EE, "Member 'ARSBattleEnemy_C::SimpleEnemy' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, BrainFieldProgress) == 0x0020EF, "Member 'ARSBattleEnemy_C::BrainFieldProgress' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bUseWaitNoInterpolation) == 0x0020F0, "Member 'ARSBattleEnemy_C::bUseWaitNoInterpolation' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, InitRotationRate) == 0x0020F4, "Member 'ARSBattleEnemy_C::InitRotationRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DisableCheckAreaOut) == 0x002100, "Member 'ARSBattleEnemy_C::DisableCheckAreaOut' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StopUpdateEnemyTickEnable) == 0x002101, "Member 'ARSBattleEnemy_C::StopUpdateEnemyTickEnable' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StopUpdateAreaCheck) == 0x002102, "Member 'ARSBattleEnemy_C::StopUpdateAreaCheck' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitStop_Skillname) == 0x002104, "Member 'ARSBattleEnemy_C::HitStop_Skillname' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitStop_SlowOnce) == 0x00210C, "Member 'ARSBattleEnemy_C::HitStop_SlowOnce' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NoAttackTargetChangeSecond) == 0x002110, "Member 'ARSBattleEnemy_C::NoAttackTargetChangeSecond' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SetHideWeakEffect) == 0x002114, "Member 'ARSBattleEnemy_C::SetHideWeakEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SetVisibleWeakEffect) == 0x002115, "Member 'ARSBattleEnemy_C::SetVisibleWeakEffect' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, MaxEvDitherTime) == 0x002118, "Member 'ARSBattleEnemy_C::MaxEvDitherTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CurrentEvDitherTime) == 0x00211C, "Member 'ARSBattleEnemy_C::CurrentEvDitherTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEvDitherDisp) == 0x002120, "Member 'ARSBattleEnemy_C::bEvDitherDisp' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, TrgEffMgr) == 0x002128, "Member 'ARSBattleEnemy_C::TrgEffMgr' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnumBossBattleBegineAction) == 0x002130, "Member 'ARSBattleEnemy_C::EnumBossBattleBegineAction' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsHideCoreTimingOld) == 0x002131, "Member 'ARSBattleEnemy_C::IsHideCoreTimingOld' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsCrashChanceLoopStart) == 0x002132, "Member 'ARSBattleEnemy_C::IsCrashChanceLoopStart' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsDuringEventSpawnNow) == 0x002133, "Member 'ARSBattleEnemy_C::IsDuringEventSpawnNow' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DeadMontage) == 0x002138, "Member 'ARSBattleEnemy_C::DeadMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DownDeadMontage) == 0x002140, "Member 'ARSBattleEnemy_C::DownDeadMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, UniqueTickEnableRange) == 0x002148, "Member 'ARSBattleEnemy_C::UniqueTickEnableRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AreaOutTime) == 0x00214C, "Member 'ARSBattleEnemy_C::AreaOutTime' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsDeadMainTick) == 0x002150, "Member 'ARSBattleEnemy_C::IsDeadMainTick' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, HitFloorTimer) == 0x002154, "Member 'ARSBattleEnemy_C::HitFloorTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableTickMeshOnly) == 0x002158, "Member 'ARSBattleEnemy_C::bEnableTickMeshOnly' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AreaOutOffsetRange) == 0x00215C, "Member 'ARSBattleEnemy_C::AreaOutOffsetRange' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, AllowanceWaitSeconds) == 0x002160, "Member 'ARSBattleEnemy_C::AllowanceWaitSeconds' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsTickMove) == 0x002164, "Member 'ARSBattleEnemy_C::IsTickMove' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bAlreadyDroppedItem) == 0x002165, "Member 'ARSBattleEnemy_C::bAlreadyDroppedItem' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bEnableDeadCleanup_DroppedItem) == 0x002166, "Member 'ARSBattleEnemy_C::bEnableDeadCleanup_DroppedItem' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsEventDeath) == 0x002167, "Member 'ARSBattleEnemy_C::IsEventDeath' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bUpDownWait) == 0x002168, "Member 'ARSBattleEnemy_C::bUpDownWait' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NoChangeAnimRateCrashChanceAccelerate) == 0x002169, "Member 'ARSBattleEnemy_C::NoChangeAnimRateCrashChanceAccelerate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, NowMinTickCount) == 0x00216C, "Member 'ARSBattleEnemy_C::NowMinTickCount' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, DebugEnemyBtlLog) == 0x002170, "Member 'ARSBattleEnemy_C::DebugEnemyBtlLog' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ActorLocationID) == 0x002178, "Member 'ARSBattleEnemy_C::ActorLocationID' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, ActorAreaID) == 0x00217C, "Member 'ARSBattleEnemy_C::ActorAreaID' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsRepopping) == 0x002180, "Member 'ARSBattleEnemy_C::IsRepopping' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsCheckSameFloor) == 0x002181, "Member 'ARSBattleEnemy_C::IsCheckSameFloor' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bPlayedPressKillMontage) == 0x002182, "Member 'ARSBattleEnemy_C::bPlayedPressKillMontage' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, StateUniqueObject) == 0x002188, "Member 'ARSBattleEnemy_C::StateUniqueObject' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, RareSpawnCondisionData) == 0x002190, "Member 'ARSBattleEnemy_C::RareSpawnCondisionData' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashVisionEffectTable) == 0x0021C8, "Member 'ARSBattleEnemy_C::CrashVisionEffectTable' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashVisionHitEffectList) == 0x0021D0, "Member 'ARSBattleEnemy_C::CrashVisionHitEffectList' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CrashVisionHitUniqueEffectList) == 0x0021E0, "Member 'ARSBattleEnemy_C::CrashVisionHitUniqueEffectList' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SpawnUpdateTimeOnlyBattleSimulator) == 0x0021F0, "Member 'ARSBattleEnemy_C::SpawnUpdateTimeOnlyBattleSimulator' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, OutPutRareSpawnResultLog) == 0x0021F4, "Member 'ARSBattleEnemy_C::OutPutRareSpawnResultLog' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CheckRareSpawnHpRate_0) == 0x0021F5, "Member 'ARSBattleEnemy_C::CheckRareSpawnHpRate_0' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, IsRareSpawnCheckAtHpRate) == 0x0021F6, "Member 'ARSBattleEnemy_C::IsRareSpawnCheckAtHpRate' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, PlayedBrainTalkBattleStartSimulator) == 0x0021F7, "Member 'ARSBattleEnemy_C::PlayedBrainTalkBattleStartSimulator' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bAvatarCopyTags) == 0x0021F8, "Member 'ARSBattleEnemy_C::bAvatarCopyTags' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, SimulatorStartMoveDelayTimer) == 0x0021FC, "Member 'ARSBattleEnemy_C::SimulatorStartMoveDelayTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, EnableLostActionTimer) == 0x002208, "Member 'ARSBattleEnemy_C::EnableLostActionTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, CurrentLostAction) == 0x002214, "Member 'ARSBattleEnemy_C::CurrentLostAction' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, LostActionResetTimer) == 0x002218, "Member 'ARSBattleEnemy_C::LostActionResetTimer' has a wrong offset!");
static_assert(offsetof(ARSBattleEnemy_C, bLostActionResetTick) == 0x002224, "Member 'ARSBattleEnemy_C::bLostActionResetTick' has a wrong offset!");

}

