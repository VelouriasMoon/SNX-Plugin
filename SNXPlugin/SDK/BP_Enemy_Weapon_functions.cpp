#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Enemy_Weapon

#include "Basic.hpp"

#include "BP_Enemy_Weapon_classes.hpp"
#include "BP_Enemy_Weapon_parameters.hpp"


namespace SDK
{

// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.ExecuteUbergraph_BP_Enemy_Weapon
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::ExecuteUbergraph_BP_Enemy_Weapon(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "ExecuteUbergraph_BP_Enemy_Weapon");

	Params::BP_Enemy_Weapon_C_ExecuteUbergraph_BP_Enemy_Weapon Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.EndCurveTargetMove_FromNative
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Sec                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::EndCurveTargetMove_FromNative(float Sec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "EndCurveTargetMove_FromNative");

	Params::BP_Enemy_Weapon_C_EndCurveTargetMove_FromNative Parms{};

	Parms.Sec = Sec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.BndEvt__PhysicsCollision_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Enemy_Weapon_C::BndEvt__PhysicsCollision_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "BndEvt__PhysicsCollision_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_Enemy_Weapon_C_BndEvt__PhysicsCollision_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.BndEvt__PhysicsCollision_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          NormalImpulse                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Enemy_Weapon_C::BndEvt__PhysicsCollision_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "BndEvt__PhysicsCollision_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature");

	Params::BP_Enemy_Weapon_C_BndEvt__PhysicsCollision_K2Node_ComponentBoundEvent_0_ComponentHitSignature__DelegateSignature Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "ReceiveEndPlay");

	Params::BP_Enemy_Weapon_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.BndEvt__BaseHitCheckReceiver_K2Node_ComponentBoundEvent_2_HitResultDelegate__DelegateSignature
// (BlueprintEvent)
// Parameters:
// struct FHCHitResult                     Result                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)

void ABP_Enemy_Weapon_C::BndEvt__BaseHitCheckReceiver_K2Node_ComponentBoundEvent_2_HitResultDelegate__DelegateSignature(const struct FHCHitResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "BndEvt__BaseHitCheckReceiver_K2Node_ComponentBoundEvent_2_HitResultDelegate__DelegateSignature");

	Params::BP_Enemy_Weapon_C_BndEvt__BaseHitCheckReceiver_K2Node_ComponentBoundEvent_2_HitResultDelegate__DelegateSignature Parms{};

	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.BndEvt__BaseHitCheckReceiver_K2Node_ComponentBoundEvent_1_HitResultDelegate__DelegateSignature
// (BlueprintEvent)
// Parameters:
// struct FHCHitResult                     Result                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)

void ABP_Enemy_Weapon_C::BndEvt__BaseHitCheckReceiver_K2Node_ComponentBoundEvent_1_HitResultDelegate__DelegateSignature(const struct FHCHitResult& Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "BndEvt__BaseHitCheckReceiver_K2Node_ComponentBoundEvent_1_HitResultDelegate__DelegateSignature");

	Params::BP_Enemy_Weapon_C_BndEvt__BaseHitCheckReceiver_K2Node_ComponentBoundEvent_1_HitResultDelegate__DelegateSignature Parms{};

	Parms.Result = std::move(Result);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "ReceiveTick");

	Params::BP_Enemy_Weapon_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Enemy_Weapon_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.CreateAttackCollosion
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDataTable*                       DataTable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             SkillName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Param_Owner                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Timer                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::CreateAttackCollosion(class UDataTable* DataTable, class FName SkillName, class AActor* Param_Owner, float Timer, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "CreateAttackCollosion");

	Params::BP_Enemy_Weapon_C_CreateAttackCollosion Parms{};

	Parms.DataTable = DataTable;
	Parms.SkillName = SkillName;
	Parms.Param_Owner = Param_Owner;
	Parms.Timer = Timer;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateCurveTargetMove
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Sec                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::UpdateCurveTargetMove(float Sec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateCurveTargetMove");

	Params::BP_Enemy_Weapon_C_UpdateCurveTargetMove Parms{};

	Parms.Sec = Sec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.GetTargetDistance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float ABP_Enemy_Weapon_C::GetTargetDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "GetTargetDistance");

	Params::BP_Enemy_Weapon_C_GetTargetDistance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.SetCurveTargetMoveInit
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::SetCurveTargetMoveInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "SetCurveTargetMoveInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.SetTargetMoveEffectRotation
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::SetTargetMoveEffectRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "SetTargetMoveEffectRotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.HitCurveMoveTarget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::HitCurveMoveTarget(const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "HitCurveMoveTarget");

	Params::BP_Enemy_Weapon_C_HitCurveMoveTarget Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.HitAfterCurveMoveTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::HitAfterCurveMoveTarget(const struct FVector& HitLocation, const struct FVector& HitNormal, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "HitAfterCurveMoveTarget");

	Params::BP_Enemy_Weapon_C_HitAfterCurveMoveTarget Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.AttackCollisionEnd
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsVisible                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::AttackCollisionEnd(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "AttackCollisionEnd");

	Params::BP_Enemy_Weapon_C_AttackCollisionEnd Parms{};

	Parms.IsVisible = IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.EndCurveTargetMove
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Sec                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::EndCurveTargetMove(float Sec, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "EndCurveTargetMove");

	Params::BP_Enemy_Weapon_C_EndCurveTargetMove Parms{};

	Parms.Sec = Sec;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.GetHitObjectType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<EObjectTypeQuery>                ObjectType                                             (Parm, OutParm, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::GetHitObjectType(TArray<EObjectTypeQuery>* ObjectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "GetHitObjectType");

	Params::BP_Enemy_Weapon_C_GetHitObjectType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ObjectType != nullptr)
		*ObjectType = std::move(Parms.ObjectType);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitCommonMove
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InitPos                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          MoveDir                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MoveSpeed                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoTargetMove                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::InitCommonMove(const struct FVector& InitPos, const struct FVector& MoveDir, float MoveSpeed, bool NoTargetMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitCommonMove");

	Params::BP_Enemy_Weapon_C_InitCommonMove Parms{};

	Parms.InitPos = std::move(InitPos);
	Parms.MoveDir = std::move(MoveDir);
	Parms.MoveSpeed = MoveSpeed;
	Parms.NoTargetMove = NoTargetMove;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateCommonMove
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::UpdateCommonMove(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateCommonMove");

	Params::BP_Enemy_Weapon_C_UpdateCommonMove Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.IsHitLineCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          EndLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Param_IsAnyHit                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Enemy_Weapon_C::IsHitLineCheck(const struct FVector& StartLocation, const struct FVector& EndLocation, bool* Param_IsAnyHit, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "IsHitLineCheck");

	Params::BP_Enemy_Weapon_C_IsHitLineCheck Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (Param_IsAnyHit != nullptr)
		*Param_IsAnyHit = Parms.Param_IsAnyHit;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.OnHitAttack
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHCHitResult                     HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::OnHitAttack(const struct FHCHitResult& HitResult, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "OnHitAttack");

	Params::BP_Enemy_Weapon_C_OnHitAttack Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.OnHitDamage
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHCHitResult                     HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::OnHitDamage(const struct FHCHitResult& HitResult, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "OnHitDamage");

	Params::BP_Enemy_Weapon_C_OnHitDamage Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateProjectileMove
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::UpdateProjectileMove(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateProjectileMove");

	Params::BP_Enemy_Weapon_C_UpdateProjectileMove Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.OnHitObject
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::OnHitObject(const struct FHitResult& HitResult, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "OnHitObject");

	Params::BP_Enemy_Weapon_C_OnHitObject Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.WeaponUpdate
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::WeaponUpdate(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "WeaponUpdate");

	Params::BP_Enemy_Weapon_C_WeaponUpdate Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateGravityMiove
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::UpdateGravityMiove(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateGravityMiove");

	Params::BP_Enemy_Weapon_C_UpdateGravityMiove Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.GravityHitProcess
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsHitPlayer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::GravityHitProcess(bool IsHitPlayer, const struct FVector& HitLocation, const struct FVector& HitNormal, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "GravityHitProcess");

	Params::BP_Enemy_Weapon_C_GravityHitProcess Parms{};

	Parms.IsHitPlayer = IsHitPlayer;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.Bullet Recycle
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::Bullet_Recycle(const struct FVector& Location, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "Bullet Recycle");

	Params::BP_Enemy_Weapon_C_Bullet_Recycle Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitProjectileMove
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Src                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Dst                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Dir                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Speed                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxAngle                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   GravityScale                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::InitProjectileMove(const struct FVector& Src, const struct FVector& Dst, const struct FVector& Dir, float Speed, float Angle, float MaxAngle, float GravityScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitProjectileMove");

	Params::BP_Enemy_Weapon_C_InitProjectileMove Parms{};

	Parms.Src = std::move(Src);
	Parms.Dst = std::move(Dst);
	Parms.Dir = std::move(Dir);
	Parms.Speed = Speed;
	Parms.Angle = Angle;
	Parms.MaxAngle = MaxAngle;
	Parms.GravityScale = GravityScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitInterceptMove_Old
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARSBattleCharacter_C*             Attacker                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ARSBattleCharacter_C*             Param_Target                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::InitInterceptMove_Old(class ARSBattleCharacter_C* Attacker, class ARSBattleCharacter_C* Param_Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitInterceptMove_Old");

	Params::BP_Enemy_Weapon_C_InitInterceptMove_Old Parms{};

	Parms.Attacker = Attacker;
	Parms.Param_Target = Param_Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.GetAttackCollisionPrimitive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Primitive                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::GetAttackCollisionPrimitive(class UPrimitiveComponent** Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "GetAttackCollisionPrimitive");

	Params::BP_Enemy_Weapon_C_GetAttackCollisionPrimitive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Primitive != nullptr)
		*Primitive = Parms.Primitive;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateTimer
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::UpdateTimer(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateTimer");

	Params::BP_Enemy_Weapon_C_UpdateTimer Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.ProjectileHitProcess
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsHitPlayer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::ProjectileHitProcess(bool IsHitPlayer, const struct FVector& HitLocation, const struct FVector& HitNormal, bool* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "ProjectileHitProcess");

	Params::BP_Enemy_Weapon_C_ProjectileHitProcess Parms{};

	Parms.IsHitPlayer = IsHitPlayer;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.EndHoming
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::EndHoming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "EndHoming");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateCustomMove
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::UpdateCustomMove(float DeltaTime, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateCustomMove");

	Params::BP_Enemy_Weapon_C_UpdateCustomMove Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitCustomMove
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::InitCustomMove(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitCustomMove");

	Params::BP_Enemy_Weapon_C_InitCustomMove Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.CorrectBulletDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          FireLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Param_TargetLocation                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          FireForwardVector                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AbsoluteAngleZ                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxAngleZ                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Speed                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OutDirection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::CorrectBulletDirection(const struct FVector& FireLocation, const struct FVector& Param_TargetLocation, const struct FVector& FireForwardVector, float AbsoluteAngleZ, float MaxAngleZ, float Speed, struct FVector* OutDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "CorrectBulletDirection");

	Params::BP_Enemy_Weapon_C_CorrectBulletDirection Parms{};

	Parms.FireLocation = std::move(FireLocation);
	Parms.Param_TargetLocation = std::move(Param_TargetLocation);
	Parms.FireForwardVector = std::move(FireForwardVector);
	Parms.AbsoluteAngleZ = AbsoluteAngleZ;
	Parms.MaxAngleZ = MaxAngleZ;
	Parms.Speed = Speed;

	UObject::ProcessEvent(Func, &Parms);

	if (OutDirection != nullptr)
		*OutDirection = std::move(Parms.OutDirection);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitHomingProjectileMove
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Param_TargetLocation                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ForwardVec                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Speed                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxAngle                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   GravityScale                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   HomingStartDis                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   HomingMagunitude                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ARSBattleCharacter_C*             TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::InitHomingProjectileMove(const struct FVector& StartLocation, const struct FVector& Param_TargetLocation, const struct FVector& ForwardVec, float Speed, float Angle, float MaxAngle, float GravityScale, float HomingStartDis, float HomingMagunitude, class ARSBattleCharacter_C* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitHomingProjectileMove");

	Params::BP_Enemy_Weapon_C_InitHomingProjectileMove Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.Param_TargetLocation = std::move(Param_TargetLocation);
	Parms.ForwardVec = std::move(ForwardVec);
	Parms.Speed = Speed;
	Parms.Angle = Angle;
	Parms.MaxAngle = MaxAngle;
	Parms.GravityScale = GravityScale;
	Parms.HomingStartDis = HomingStartDis;
	Parms.HomingMagunitude = HomingMagunitude;
	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateHomingMove
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::UpdateHomingMove(float DeltaSeconds, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateHomingMove");

	Params::BP_Enemy_Weapon_C_UpdateHomingMove Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitHomingMove
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReadyStart                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReadyEnd                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::InitHomingMove(const struct FVector& ReadyStart, const struct FVector& ReadyEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitHomingMove");

	Params::BP_Enemy_Weapon_C_InitHomingMove Parms{};

	Parms.ReadyStart = std::move(ReadyStart);
	Parms.ReadyEnd = std::move(ReadyEnd);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.StartVanishEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::StartVanishEffect(const struct FVector& HitLocation, const struct FVector& HitNormal, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "StartVanishEffect");

	Params::BP_Enemy_Weapon_C_StartVanishEffect Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.SetWeaponActivate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::SetWeaponActivate(bool bActive, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "SetWeaponActivate");

	Params::BP_Enemy_Weapon_C_SetWeaponActivate Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitVariable
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::InitVariable(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitVariable");

	Params::BP_Enemy_Weapon_C_InitVariable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitWeapon
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::InitWeapon(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitWeapon");

	Params::BP_Enemy_Weapon_C_InitWeapon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.FinishWeapon
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::FinishWeapon(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "FinishWeapon");

	Params::BP_Enemy_Weapon_C_FinishWeapon Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.SetWeaponVisibility
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bVisible                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::SetWeaponVisibility(bool bVisible, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "SetWeaponVisibility");

	Params::BP_Enemy_Weapon_C_SetWeaponVisibility Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.IsHitFloor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_Enemy_Weapon_C::IsHitFloor(const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "IsHitFloor");

	Params::BP_Enemy_Weapon_C_IsHitFloor Parms{};

	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitProjectileMoveSimple
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Velocity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   GravityScale                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::InitProjectileMoveSimple(const struct FVector& Location, const struct FVector& Velocity, float GravityScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitProjectileMoveSimple");

	Params::BP_Enemy_Weapon_C_InitProjectileMoveSimple Parms{};

	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.GravityScale = GravityScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.PlayHitSound
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsWall                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::PlayHitSound(const struct FVector& Location, bool IsWall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "PlayHitSound");

	Params::BP_Enemy_Weapon_C_PlayHitSound Parms{};

	Parms.Location = std::move(Location);
	Parms.IsWall = IsWall;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.NoticeSelfDestruct
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::NoticeSelfDestruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "NoticeSelfDestruct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitCommonMoveWithGravity
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InitPos                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          MoveDir                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MoveSpeed                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Param_Gravity                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NoTargetMove                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::InitCommonMoveWithGravity(const struct FVector& InitPos, const struct FVector& MoveDir, float MoveSpeed, float Param_Gravity, bool NoTargetMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitCommonMoveWithGravity");

	Params::BP_Enemy_Weapon_C_InitCommonMoveWithGravity Parms{};

	Parms.InitPos = std::move(InitPos);
	Parms.MoveDir = std::move(MoveDir);
	Parms.MoveSpeed = MoveSpeed;
	Parms.Param_Gravity = Param_Gravity;
	Parms.NoTargetMove = NoTargetMove;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.IsHomingCutDistance
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Param_TargetLocation                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsCut                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::IsHomingCutDistance(const struct FVector& Param_TargetLocation, bool* IsCut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "IsHomingCutDistance");

	Params::BP_Enemy_Weapon_C_IsHomingCutDistance Parms{};

	Parms.Param_TargetLocation = std::move(Param_TargetLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (IsCut != nullptr)
		*IsCut = Parms.IsCut;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.StopHomingSe
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::StopHomingSe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "StopHomingSe");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateInterceptReserve
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::UpdateInterceptReserve(float DeltaSeconds, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateInterceptReserve");

	Params::BP_Enemy_Weapon_C_UpdateInterceptReserve Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.CheckHomingEnd
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::CheckHomingEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "CheckHomingEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.EndCustomMove
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bForce                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::EndCustomMove(bool bForce, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "EndCustomMove");

	Params::BP_Enemy_Weapon_C_EndCustomMove Parms{};

	Parms.bForce = bForce;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.CancelAllEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::CancelAllEffect(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "CancelAllEffect");

	Params::BP_Enemy_Weapon_C_CancelAllEffect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.OnHitProjectileWall
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsWall                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsFloor                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::OnHitProjectileWall(bool IsWall, bool IsFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "OnHitProjectileWall");

	Params::BP_Enemy_Weapon_C_OnHitProjectileWall Parms{};

	Parms.IsWall = IsWall;
	Parms.IsFloor = IsFloor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateInterceptMove
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::UpdateInterceptMove(float DeltaSeconds, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateInterceptMove");

	Params::BP_Enemy_Weapon_C_UpdateInterceptMove Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitInterceptMove
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARSBattleCharacter_C*             Attacker                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ARSBattleCharacter_C*             Param_Target                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::InitInterceptMove(class ARSBattleCharacter_C* Attacker, class ARSBattleCharacter_C* Param_Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitInterceptMove");

	Params::BP_Enemy_Weapon_C_InitInterceptMove Parms{};

	Parms.Attacker = Attacker;
	Parms.Param_Target = Param_Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InitializePhysicsCollision
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::InitializePhysicsCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InitializePhysicsCollision");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.StartPhysicsCollision
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::StartPhysicsCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "StartPhysicsCollision");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.HitPhysicsCollision
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::HitPhysicsCollision(const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "HitPhysicsCollision");

	Params::BP_Enemy_Weapon_C_HitPhysicsCollision Parms{};

	Parms.HitLocation = std::move(HitLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.IsHitPhysicsCollision
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    bHit                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::IsHitPhysicsCollision(bool* bHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "IsHitPhysicsCollision");

	Params::BP_Enemy_Weapon_C_IsHitPhysicsCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bHit != nullptr)
		*bHit = Parms.bHit;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdatePhysicsCollision
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSec                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::UpdatePhysicsCollision(float DeltaSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdatePhysicsCollision");

	Params::BP_Enemy_Weapon_C_UpdatePhysicsCollision Parms{};

	Parms.DeltaSec = DeltaSec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.EndPhysicsCollision
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::EndPhysicsCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "EndPhysicsCollision");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.IsHitLineCheckForObjects
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          StartLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          EndLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// TArray<class AActor*>                   ActorsToIgnore                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// bool                                    Param_IsAnyHit                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_Enemy_Weapon_C::IsHitLineCheckForObjects(const struct FVector& StartLocation, const struct FVector& EndLocation, TArray<EObjectTypeQuery>& ObjectTypes, TArray<class AActor*>& ActorsToIgnore, bool* Param_IsAnyHit, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "IsHitLineCheckForObjects");

	Params::BP_Enemy_Weapon_C_IsHitLineCheckForObjects Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	UObject::ProcessEvent(Func, &Parms);

	ObjectTypes = std::move(Parms.ObjectTypes);
	ActorsToIgnore = std::move(Parms.ActorsToIgnore);

	if (Param_IsAnyHit != nullptr)
		*Param_IsAnyHit = Parms.Param_IsAnyHit;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.AddIgnoreJustDodge
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Enemy_Weapon_C::AddIgnoreJustDodge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "AddIgnoreJustDodge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.Set Ignore Just Dodge Seconds
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DelaySeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::Set_Ignore_Just_Dodge_Seconds(float DelaySeconds, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "Set Ignore Just Dodge Seconds");

	Params::BP_Enemy_Weapon_C_Set_Ignore_Just_Dodge_Seconds Parms{};

	Parms.DelaySeconds = DelaySeconds;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.GetAttackOwnerTargetCharaNative
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class AActor* ABP_Enemy_Weapon_C::GetAttackOwnerTargetCharaNative()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "GetAttackOwnerTargetCharaNative");

	Params::BP_Enemy_Weapon_C_GetAttackOwnerTargetCharaNative Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.ProjectileHitProcess_FromNative
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsHitPlayer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_Enemy_Weapon_C::ProjectileHitProcess_FromNative(bool IsHitPlayer, const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "ProjectileHitProcess_FromNative");

	Params::BP_Enemy_Weapon_C_ProjectileHitProcess_FromNative Parms{};

	Parms.IsHitPlayer = IsHitPlayer;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.GetHitCheckComponent_FromNative
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UHitCheckComponent*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UHitCheckComponent* ABP_Enemy_Weapon_C::GetHitCheckComponent_FromNative()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "GetHitCheckComponent_FromNative");

	Params::BP_Enemy_Weapon_C_GetHitCheckComponent_FromNative Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.HitAfterCurveMoveTarget_FromNative
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_Enemy_Weapon_C::HitAfterCurveMoveTarget_FromNative(const struct FVector& HitLocation, const struct FVector& HitNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "HitAfterCurveMoveTarget_FromNative");

	Params::BP_Enemy_Weapon_C_HitAfterCurveMoveTarget_FromNative Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.IsIntercept
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsInterceptReserve                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::IsIntercept(bool* IsInterceptReserve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "IsIntercept");

	Params::BP_Enemy_Weapon_C_IsIntercept Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsInterceptReserve != nullptr)
		*IsInterceptReserve = Parms.IsInterceptReserve;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.UpdateEmitterInstance
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class URSParticleSystemComponentBase*   NewEmitterInstance                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::UpdateEmitterInstance(class URSParticleSystemComponentBase* NewEmitterInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "UpdateEmitterInstance");

	Params::BP_Enemy_Weapon_C_UpdateEmitterInstance Parms{};

	Parms.NewEmitterInstance = NewEmitterInstance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InterceptAttack
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ARSBattleCharacter_C*             Intercepter                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ARSBattleCharacter_C*             NewTarget                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::InterceptAttack(class ARSBattleCharacter_C* Intercepter, class ARSBattleCharacter_C* NewTarget, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InterceptAttack");

	Params::BP_Enemy_Weapon_C_InterceptAttack Parms{};

	Parms.Intercepter = Intercepter;
	Parms.NewTarget = NewTarget;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InterceptReserve
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::InterceptReserve(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InterceptReserve");

	Params::BP_Enemy_Weapon_C_InterceptReserve Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.InterceptCancel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::InterceptCancel(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "InterceptCancel");

	Params::BP_Enemy_Weapon_C_InterceptCancel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.IsInterceptFail
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bFail                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::IsInterceptFail(bool* bFail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "IsInterceptFail");

	Params::BP_Enemy_Weapon_C_IsInterceptFail Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bFail != nullptr)
		*bFail = Parms.bFail;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.GetLocationForHitDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnemyWeapon                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Enemy_Weapon_C::GetLocationForHitDirection(bool* IsEnemyWeapon, struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "GetLocationForHitDirection");

	Params::BP_Enemy_Weapon_C_GetLocationForHitDirection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsEnemyWeapon != nullptr)
		*IsEnemyWeapon = Parms.IsEnemyWeapon;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.IsOverTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    IsOver                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::IsOverTarget(bool* IsOver) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "IsOverTarget");

	Params::BP_Enemy_Weapon_C_IsOverTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsOver != nullptr)
		*IsOver = Parms.IsOver;
}


// Function BP_Enemy_Weapon.BP_Enemy_Weapon_C.IsWeaponActive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bActive                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_Enemy_Weapon_C::IsWeaponActive(bool* bActive) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Enemy_Weapon_C", "IsWeaponActive");

	Params::BP_Enemy_Weapon_C_IsWeaponActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bActive != nullptr)
		*bActive = Parms.bActive;
}

}

