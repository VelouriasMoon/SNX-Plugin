#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_PlayerAIInterface

#include "Basic.hpp"

#include "BPI_PlayerAIInterface_classes.hpp"
#include "BPI_PlayerAIInterface_parameters.hpp"


namespace SDK
{

// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.SetMoveMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerAIMoveMode                       Mode                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::SetMoveMode(EPlayerAIMoveMode Mode, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "SetMoveMode");

	Params::BPI_PlayerAIInterface_C_SetMoveMode Parms{};

	Parms.Mode = Mode;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.InputAI_Attack
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bPressed                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::InputAI_Attack(bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "InputAI_Attack");

	Params::BPI_PlayerAIInterface_C_InputAI_Attack Parms{};

	Parms.bPressed = bPressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.InputAI_LeftStick
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   X                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Y                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerAIInterface_C::InputAI_LeftStick(float X, float Y)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "InputAI_LeftStick");

	Params::BPI_PlayerAIInterface_C_InputAI_LeftStick Parms{};

	Parms.X = X;
	Parms.Y = Y;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.InputAI_Dodge
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bPressed                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::InputAI_Dodge(bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "InputAI_Dodge");

	Params::BPI_PlayerAIInterface_C_InputAI_Dodge Parms{};

	Parms.bPressed = bPressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.SetEnableInputStick
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::SetEnableInputStick(bool bEnable, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "SetEnableInputStick");

	Params::BPI_PlayerAIInterface_C_SetEnableInputStick Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.NextBattleThink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::NextBattleThink(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "NextBattleThink");

	Params::BPI_PlayerAIInterface_C_NextBattleThink Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.ResetBattleThink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::ResetBattleThink(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "ResetBattleThink");

	Params::BPI_PlayerAIInterface_C_ResetBattleThink Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.InputAI_Jump
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bPressed                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::InputAI_Jump(bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "InputAI_Jump");

	Params::BPI_PlayerAIInterface_C_InputAI_Jump Parms{};

	Parms.bPressed = bPressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.OnChangeBattleThink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerAIBattleThinkType                NextThinkType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EPlayerAIBattleThinkType                PrevThinkType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::OnChangeBattleThink(EPlayerAIBattleThinkType NextThinkType, EPlayerAIBattleThinkType PrevThinkType, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "OnChangeBattleThink");

	Params::BPI_PlayerAIInterface_C_OnChangeBattleThink Parms{};

	Parms.NextThinkType = NextThinkType;
	Parms.PrevThinkType = PrevThinkType;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.SetAIMoveStick
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bMoveStick                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::SetAIMoveStick(bool bMoveStick, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "SetAIMoveStick");

	Params::BPI_PlayerAIInterface_C_SetAIMoveStick Parms{};

	Parms.bMoveStick = bMoveStick;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.AimStartAI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::AimStartAI(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "AimStartAI");

	Params::BPI_PlayerAIInterface_C_AimStartAI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.AimEndAI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::AimEndAI(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "AimEndAI");

	Params::BPI_PlayerAIInterface_C_AimEndAI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsUseItemThink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsUseItemThink(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsUseItemThink");

	Params::BPI_PlayerAIInterface_C_IsUseItemThink Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.InputAI_UseItem
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bPressed                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::InputAI_UseItem(bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "InputAI_UseItem");

	Params::BPI_PlayerAIInterface_C_InputAI_UseItem Parms{};

	Parms.bPressed = bPressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsInputAI_UseItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bON                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsInputAI_UseItem(bool* bON)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsInputAI_UseItem");

	Params::BPI_PlayerAIInterface_C_IsInputAI_UseItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bON != nullptr)
		*bON = Parms.bON;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.SetEventMove
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  Pos_list_in                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// TArray<float>                           Radius_list_in                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// bool                                    Walk                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bAfterWait                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   MaxMoveTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::SetEventMove(TArray<struct FVector>& Pos_list_in, TArray<float>& Radius_list_in, bool Walk, bool bAfterWait, float MaxMoveTime, bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "SetEventMove");

	Params::BPI_PlayerAIInterface_C_SetEventMove Parms{};

	Parms.Pos_list_in = std::move(Pos_list_in);
	Parms.Radius_list_in = std::move(Radius_list_in);
	Parms.Walk = Walk;
	Parms.bAfterWait = bAfterWait;
	Parms.MaxMoveTime = MaxMoveTime;

	UObject::ProcessEvent(Func, &Parms);

	Pos_list_in = std::move(Parms.Pos_list_in);
	Radius_list_in = std::move(Parms.Radius_list_in);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.GetEventMovePosActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerAIInterface_C::GetEventMovePosActor(class AActor** Actor, float* Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "GetEventMovePosActor");

	Params::BPI_PlayerAIInterface_C_GetEventMovePosActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Actor != nullptr)
		*Actor = Parms.Actor;

	if (Radius != nullptr)
		*Radius = Parms.Radius;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.CheckEventMovePos
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Goal                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::CheckEventMovePos(bool* Goal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "CheckEventMovePos");

	Params::BPI_PlayerAIInterface_C_CheckEventMovePos Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Goal != nullptr)
		*Goal = Parms.Goal;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsSelfRecovery
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsSelfRecovery(bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsSelfRecovery");

	Params::BPI_PlayerAIInterface_C_IsSelfRecovery Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.NotifyResetBehaviorTree
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Dummy                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::NotifyResetBehaviorTree(bool* Dummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "NotifyResetBehaviorTree");

	Params::BPI_PlayerAIInterface_C_NotifyResetBehaviorTree Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dummy != nullptr)
		*Dummy = Parms.Dummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.SearchAIPsychicObject
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bFiound                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::SearchAIPsychicObject(bool* bFiound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "SearchAIPsychicObject");

	Params::BPI_PlayerAIInterface_C_SearchAIPsychicObject Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bFiound != nullptr)
		*bFiound = Parms.bFiound;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.CheckAIPsychicObject
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bCapture                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bAttack                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bOK                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::CheckAIPsychicObject(bool bCapture, bool bAttack, bool* bOK)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "CheckAIPsychicObject");

	Params::BPI_PlayerAIInterface_C_CheckAIPsychicObject Parms{};

	Parms.bCapture = bCapture;
	Parms.bAttack = bAttack;

	UObject::ProcessEvent(Func, &Parms);

	if (bOK != nullptr)
		*bOK = Parms.bOK;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.InputAI_Psychic
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bPressed                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::InputAI_Psychic(bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "InputAI_Psychic");

	Params::BPI_PlayerAIInterface_C_InputAI_Psychic Parms{};

	Parms.bPressed = bPressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsInputAI_Psychic
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bON                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsInputAI_Psychic(bool* bON)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsInputAI_Psychic");

	Params::BPI_PlayerAIInterface_C_IsInputAI_Psychic Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bON != nullptr)
		*bON = Parms.bON;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsPsychicAble
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsPsychicAble(bool* bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsPsychicAble");

	Params::BPI_PlayerAIInterface_C_IsPsychicAble Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnable != nullptr)
		*bEnable = Parms.bEnable;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.SetMoveStickBack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bBack                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::SetMoveStickBack(bool bBack, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "SetMoveStickBack");

	Params::BPI_PlayerAIInterface_C_SetMoveStickBack Parms{};

	Parms.bBack = bBack;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.SetEventWait
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::SetEventWait(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "SetEventWait");

	Params::BPI_PlayerAIInterface_C_SetEventWait Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.EndEventWait
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::EndEventWait(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "EndEventWait");

	Params::BPI_PlayerAIInterface_C_EndEventWait Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsUniqueConditionTransition
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   UniqueNo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsUniqueConditionTransition(int32 UniqueNo, bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsUniqueConditionTransition");

	Params::BPI_PlayerAIInterface_C_IsUniqueConditionTransition Parms{};

	Parms.UniqueNo = UniqueNo;

	UObject::ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.RestartBattleAI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::RestartBattleAI(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "RestartBattleAI");

	Params::BPI_PlayerAIInterface_C_RestartBattleAI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsBattleActionStartAI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bStart                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsBattleActionStartAI(bool* bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsBattleActionStartAI");

	Params::BPI_PlayerAIInterface_C_IsBattleActionStartAI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bStart != nullptr)
		*bStart = Parms.bStart;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsTargetCanBeAttacked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanDo                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsTargetCanBeAttacked(bool* CanDo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsTargetCanBeAttacked");

	Params::BPI_PlayerAIInterface_C_IsTargetCanBeAttacked Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanDo != nullptr)
		*CanDo = Parms.CanDo;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.CancelUseItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::CancelUseItem(bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "CancelUseItem");

	Params::BPI_PlayerAIInterface_C_CancelUseItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.BehaviorTreeTaskExit_Attack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerAIBattleThinkTypeCPP             ExitThinkType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDummy                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::BehaviorTreeTaskExit_Attack(EPlayerAIBattleThinkTypeCPP ExitThinkType, bool* bDummy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "BehaviorTreeTaskExit_Attack");

	Params::BPI_PlayerAIInterface_C_BehaviorTreeTaskExit_Attack Parms{};

	Parms.ExitThinkType = ExitThinkType;

	UObject::ProcessEvent(Func, &Parms);

	if (bDummy != nullptr)
		*bDummy = Parms.bDummy;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.GetCurrentBattleThinkInterface
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPlayerAIBattleThinkTypeCPP             ThinkType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerAIInterface_C::GetCurrentBattleThinkInterface(EPlayerAIBattleThinkTypeCPP* ThinkType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "GetCurrentBattleThinkInterface");

	Params::BPI_PlayerAIInterface_C_GetCurrentBattleThinkInterface Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ThinkType != nullptr)
		*ThinkType = Parms.ThinkType;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.GetControlPlayerDist
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FVector                          Dist                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerAIInterface_C::GetControlPlayerDist(struct FVector* Dist) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "GetControlPlayerDist");

	Params::BPI_PlayerAIInterface_C_GetControlPlayerDist Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Dist != nullptr)
		*Dist = std::move(Parms.Dist);
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsMoveAble
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bEnable                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsMoveAble(bool* bEnable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsMoveAble");

	Params::BPI_PlayerAIInterface_C_IsMoveAble Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnable != nullptr)
		*bEnable = Parms.bEnable;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.GetMovePosActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class AActor*                           MovePosActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerAIInterface_C::GetMovePosActor(class AActor** MovePosActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "GetMovePosActor");

	Params::BPI_PlayerAIInterface_C_GetMovePosActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MovePosActor != nullptr)
		*MovePosActor = Parms.MovePosActor;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsAttackAble
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bEnable                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsAttackAble(bool* bEnable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsAttackAble");

	Params::BPI_PlayerAIInterface_C_IsAttackAble Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnable != nullptr)
		*bEnable = Parms.bEnable;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsActionStatusAI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EPlayerActionStatus                     ActionStatus                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsActionStatusAI(EPlayerActionStatus ActionStatus, bool* bResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsActionStatusAI");

	Params::BPI_PlayerAIInterface_C_IsActionStatusAI Parms{};

	Parms.ActionStatus = ActionStatus;

	UObject::ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsPlayerStatusAI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EPlayerCommonStatus                     PlayerStatus                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsPlayerStatusAI(EPlayerCommonStatus PlayerStatus, bool* bResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsPlayerStatusAI");

	Params::BPI_PlayerAIInterface_C_IsPlayerStatusAI Parms{};

	Parms.PlayerStatus = PlayerStatus;

	UObject::ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsInputAI_Attack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bON                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsInputAI_Attack(bool* bON) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsInputAI_Attack");

	Params::BPI_PlayerAIInterface_C_IsInputAI_Attack Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bON != nullptr)
		*bON = Parms.bON;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsInputAI_Dodge
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bON                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsInputAI_Dodge(bool* bON) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsInputAI_Dodge");

	Params::BPI_PlayerAIInterface_C_IsInputAI_Dodge Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bON != nullptr)
		*bON = Parms.bON;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsDodgeAble
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bEnable                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsDodgeAble(bool* bEnable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsDodgeAble");

	Params::BPI_PlayerAIInterface_C_IsDodgeAble Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnable != nullptr)
		*bEnable = Parms.bEnable;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsAIMoveMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EPlayerAIMoveMode                       Mode                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsAIMoveMode(EPlayerAIMoveMode Mode, bool* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsAIMoveMode");

	Params::BPI_PlayerAIInterface_C_IsAIMoveMode Parms{};

	Parms.Mode = Mode;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsBattleThink
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EPlayerAIBattleThinkType                Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsBattleThink(EPlayerAIBattleThinkType Type, bool* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsBattleThink");

	Params::BPI_PlayerAIInterface_C_IsBattleThink Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsBattleThinkParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EPlayerAIBattleThinkParam               Param                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsBattleThinkParam(EPlayerAIBattleThinkParam Param, bool* bResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsBattleThinkParam");

	Params::BPI_PlayerAIInterface_C_IsBattleThinkParam Parms{};

	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.GetBattleTargetActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerAIInterface_C::GetBattleTargetActor(class AActor** TargetActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "GetBattleTargetActor");

	Params::BPI_PlayerAIInterface_C_GetBattleTargetActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TargetActor != nullptr)
		*TargetActor = Parms.TargetActor;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsInputAI_Jump
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bON                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsInputAI_Jump(bool* bON) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsInputAI_Jump");

	Params::BPI_PlayerAIInterface_C_IsInputAI_Jump Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bON != nullptr)
		*bON = Parms.bON;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsJumpAble
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bEnable                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsJumpAble(bool* bEnable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsJumpAble");

	Params::BPI_PlayerAIInterface_C_IsJumpAble Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnable != nullptr)
		*bEnable = Parms.bEnable;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.GetAttackCountAI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// int32                                   Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerAIInterface_C::GetAttackCountAI(int32* Count) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "GetAttackCountAI");

	Params::BPI_PlayerAIInterface_C_GetAttackCountAI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.OverwriteAttackInputKindAI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EPlayerAIBattleThinkType                ThinkType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ERSAttackInputKind                      InputKind                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ERSAttackInputKind                      Kind                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerAIInterface_C::OverwriteAttackInputKindAI(EPlayerAIBattleThinkType ThinkType, ERSAttackInputKind InputKind, ERSAttackInputKind* Kind) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "OverwriteAttackInputKindAI");

	Params::BPI_PlayerAIInterface_C_OverwriteAttackInputKindAI Parms{};

	Parms.ThinkType = ThinkType;
	Parms.InputKind = InputKind;

	UObject::ProcessEvent(Func, &Parms);

	if (Kind != nullptr)
		*Kind = Parms.Kind;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsEventMove
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsEventMove(bool* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsEventMove");

	Params::BPI_PlayerAIInterface_C_IsEventMove Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsEventMoveEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsEventMoveEnd(bool* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsEventMoveEnd");

	Params::BPI_PlayerAIInterface_C_IsEventMoveEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsResetBehaviorTree
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bReset                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsResetBehaviorTree(bool* bReset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsResetBehaviorTree");

	Params::BPI_PlayerAIInterface_C_IsResetBehaviorTree Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bReset != nullptr)
		*bReset = Parms.bReset;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.IsEventWait
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    bWait                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IBPI_PlayerAIInterface_C::IsEventWait(bool* bWait) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "IsEventWait");

	Params::BPI_PlayerAIInterface_C_IsEventWait Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bWait != nullptr)
		*bWait = Parms.bWait;
}


// Function BPI_PlayerAIInterface.BPI_PlayerAIInterface_C.GetUseItemID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// EConsumeItemID                          ItemId                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_PlayerAIInterface_C::GetUseItemID(EConsumeItemID* ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPI_PlayerAIInterface_C", "GetUseItemID");

	Params::BPI_PlayerAIInterface_C_GetUseItemID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemId != nullptr)
		*ItemId = Parms.ItemId;
}

}

